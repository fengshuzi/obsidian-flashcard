var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
    throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) =>
    key in obj
        ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
        : (obj[key] = value);
var __commonJS = (cb, mod) =>
    function __require() {
        return (
            mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
            mod.exports
        );
    };
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
    if ((from2 && typeof from2 === "object") || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))
            if (!__hasOwnProp.call(to2, key) && key !== except)
                __defProp(to2, key, {
                    get: () => from2[key],
                    enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable,
                });
    }
    return to2;
};
var __toESM = (mod, isNodeMode, target) => (
    (target = mod != null ? __create(__getProtoOf(mod)) : {}),
    __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule
            ? __defProp(target, "default", { value: mod, enumerable: true })
            : target,
        mod,
    )
);
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) =>
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (
    __accessCheck(obj, member, "read from private field"),
    getter ? getter.call(obj) : member.get(obj)
);
var __privateAdd = (obj, member, value) =>
    member.has(obj)
        ? __typeError("Cannot add the same private member more than once")
        : member instanceof WeakSet
          ? member.add(obj)
          : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (
    __accessCheck(obj, member, "write to private field"),
    setter ? setter.call(obj, value) : member.set(obj, value),
    value
);
var __privateMethod = (obj, member, method) => (
    __accessCheck(obj, member, "access private method"),
    method
);

// node_modules/moment/moment.js
var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module2) {
        (function (global, factory) {
            typeof exports === "object" && typeof module2 !== "undefined"
                ? (module2.exports = factory())
                : typeof define === "function" && define.amd
                  ? define(factory)
                  : (global.moment = factory());
        })(exports, function () {
            "use strict";
            var hookCallback;
            function hooks() {
                return hookCallback.apply(null, arguments);
            }
            function setHookCallback(callback2) {
                hookCallback = callback2;
            }
            function isArray2(input) {
                return (
                    input instanceof Array ||
                    Object.prototype.toString.call(input) === "[object Array]"
                );
            }
            function isObject2(input) {
                return input != null && Object.prototype.toString.call(input) === "[object Object]";
            }
            function hasOwnProp(a2, b2) {
                return Object.prototype.hasOwnProperty.call(a2, b2);
            }
            function isObjectEmpty(obj) {
                if (Object.getOwnPropertyNames) {
                    return Object.getOwnPropertyNames(obj).length === 0;
                } else {
                    var k;
                    for (k in obj) {
                        if (hasOwnProp(obj, k)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            function isUndefined(input) {
                return input === void 0;
            }
            function isNumber2(input) {
                return (
                    typeof input === "number" ||
                    Object.prototype.toString.call(input) === "[object Number]"
                );
            }
            function isDate(input) {
                return (
                    input instanceof Date ||
                    Object.prototype.toString.call(input) === "[object Date]"
                );
            }
            function map3(arr, fn2) {
                var res = [],
                    i2,
                    arrLen = arr.length;
                for (i2 = 0; i2 < arrLen; ++i2) {
                    res.push(fn2(arr[i2], i2));
                }
                return res;
            }
            function extend(a2, b2) {
                for (var i2 in b2) {
                    if (hasOwnProp(b2, i2)) {
                        a2[i2] = b2[i2];
                    }
                }
                if (hasOwnProp(b2, "toString")) {
                    a2.toString = b2.toString;
                }
                if (hasOwnProp(b2, "valueOf")) {
                    a2.valueOf = b2.valueOf;
                }
                return a2;
            }
            function createUTC(input, format2, locale3, strict) {
                return createLocalOrUTC(input, format2, locale3, strict, true).utc();
            }
            function defaultParsingFlags() {
                return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidEra: null,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    era: null,
                    meridiem: null,
                    rfc2822: false,
                    weekdayMismatch: false,
                };
            }
            function getParsingFlags(m2) {
                if (m2._pf == null) {
                    m2._pf = defaultParsingFlags();
                }
                return m2._pf;
            }
            var some;
            if (Array.prototype.some) {
                some = Array.prototype.some;
            } else {
                some = function (fun) {
                    var t3 = Object(this),
                        len = t3.length >>> 0,
                        i2;
                    for (i2 = 0; i2 < len; i2++) {
                        if (i2 in t3 && fun.call(this, t3[i2], i2, t3)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            function isValid(m2) {
                var flags = null,
                    parsedParts = false,
                    isNowValid = m2._d && !isNaN(m2._d.getTime());
                if (isNowValid) {
                    flags = getParsingFlags(m2);
                    parsedParts = some.call(flags.parsedDateParts, function (i2) {
                        return i2 != null;
                    });
                    isNowValid =
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));
                    if (m2._strict) {
                        isNowValid =
                            isNowValid &&
                            flags.charsLeftOver === 0 &&
                            flags.unusedTokens.length === 0 &&
                            flags.bigHour === void 0;
                    }
                }
                if (Object.isFrozen == null || !Object.isFrozen(m2)) {
                    m2._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
                return m2._isValid;
            }
            function createInvalid(flags) {
                var m2 = createUTC(NaN);
                if (flags != null) {
                    extend(getParsingFlags(m2), flags);
                } else {
                    getParsingFlags(m2).userInvalidated = true;
                }
                return m2;
            }
            var momentProperties = (hooks.momentProperties = []),
                updateInProgress = false;
            function copyConfig(to3, from3) {
                var i2,
                    prop,
                    val,
                    momentPropertiesLen = momentProperties.length;
                if (!isUndefined(from3._isAMomentObject)) {
                    to3._isAMomentObject = from3._isAMomentObject;
                }
                if (!isUndefined(from3._i)) {
                    to3._i = from3._i;
                }
                if (!isUndefined(from3._f)) {
                    to3._f = from3._f;
                }
                if (!isUndefined(from3._l)) {
                    to3._l = from3._l;
                }
                if (!isUndefined(from3._strict)) {
                    to3._strict = from3._strict;
                }
                if (!isUndefined(from3._tzm)) {
                    to3._tzm = from3._tzm;
                }
                if (!isUndefined(from3._isUTC)) {
                    to3._isUTC = from3._isUTC;
                }
                if (!isUndefined(from3._offset)) {
                    to3._offset = from3._offset;
                }
                if (!isUndefined(from3._pf)) {
                    to3._pf = getParsingFlags(from3);
                }
                if (!isUndefined(from3._locale)) {
                    to3._locale = from3._locale;
                }
                if (momentPropertiesLen > 0) {
                    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
                        prop = momentProperties[i2];
                        val = from3[prop];
                        if (!isUndefined(val)) {
                            to3[prop] = val;
                        }
                    }
                }
                return to3;
            }
            function Moment3(config) {
                copyConfig(this, config);
                this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                if (!this.isValid()) {
                    this._d = /* @__PURE__ */ new Date(NaN);
                }
                if (updateInProgress === false) {
                    updateInProgress = true;
                    hooks.updateOffset(this);
                    updateInProgress = false;
                }
            }
            function isMoment(obj) {
                return obj instanceof Moment3 || (obj != null && obj._isAMomentObject != null);
            }
            function warn(msg) {
                if (
                    hooks.suppressDeprecationWarnings === false &&
                    typeof console !== "undefined" &&
                    console.warn
                ) {
                    console.warn("Deprecation warning: " + msg);
                }
            }
            function deprecate(msg, fn2) {
                var firstTime = true;
                return extend(function () {
                    if (hooks.deprecationHandler != null) {
                        hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                        var args = [],
                            arg,
                            i2,
                            key,
                            argLen = arguments.length;
                        for (i2 = 0; i2 < argLen; i2++) {
                            arg = "";
                            if (typeof arguments[i2] === "object") {
                                arg += "\n[" + i2 + "] ";
                                for (key in arguments[0]) {
                                    if (hasOwnProp(arguments[0], key)) {
                                        arg += key + ": " + arguments[0][key] + ", ";
                                    }
                                }
                                arg = arg.slice(0, -2);
                            } else {
                                arg = arguments[i2];
                            }
                            args.push(arg);
                        }
                        warn(
                            msg +
                                "\nArguments: " +
                                Array.prototype.slice.call(args).join("") +
                                "\n" +
                                new Error().stack,
                        );
                        firstTime = false;
                    }
                    return fn2.apply(this, arguments);
                }, fn2);
            }
            var deprecations = {};
            function deprecateSimple(name, msg) {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(name, msg);
                }
                if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                }
            }
            hooks.suppressDeprecationWarnings = false;
            hooks.deprecationHandler = null;
            function isFunction2(input) {
                return (
                    (typeof Function !== "undefined" && input instanceof Function) ||
                    Object.prototype.toString.call(input) === "[object Function]"
                );
            }
            function set2(config) {
                var prop, i2;
                for (i2 in config) {
                    if (hasOwnProp(config, i2)) {
                        prop = config[i2];
                        if (isFunction2(prop)) {
                            this[i2] = prop;
                        } else {
                            this["_" + i2] = prop;
                        }
                    }
                }
                this._config = config;
                this._dayOfMonthOrdinalParseLenient = new RegExp(
                    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                        "|" +
                        /\d{1,2}/.source,
                );
            }
            function mergeConfigs(parentConfig, childConfig) {
                var res = extend({}, parentConfig),
                    prop;
                for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                        if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
                            res[prop] = {};
                            extend(res[prop], parentConfig[prop]);
                            extend(res[prop], childConfig[prop]);
                        } else if (childConfig[prop] != null) {
                            res[prop] = childConfig[prop];
                        } else {
                            delete res[prop];
                        }
                    }
                }
                for (prop in parentConfig) {
                    if (
                        hasOwnProp(parentConfig, prop) &&
                        !hasOwnProp(childConfig, prop) &&
                        isObject2(parentConfig[prop])
                    ) {
                        res[prop] = extend({}, res[prop]);
                    }
                }
                return res;
            }
            function Locale(config) {
                if (config != null) {
                    this.set(config);
                }
            }
            var keys;
            if (Object.keys) {
                keys = Object.keys;
            } else {
                keys = function (obj) {
                    var i2,
                        res = [];
                    for (i2 in obj) {
                        if (hasOwnProp(obj, i2)) {
                            res.push(i2);
                        }
                    }
                    return res;
                };
            }
            var defaultCalendar = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L",
            };
            function calendar(key, mom, now3) {
                var output = this._calendar[key] || this._calendar["sameElse"];
                return isFunction2(output) ? output.call(mom, now3) : output;
            }
            function zeroFill(number, targetLength, forceSign) {
                var absNumber = "" + Math.abs(number),
                    zerosToFill = targetLength - absNumber.length,
                    sign3 = number >= 0;
                return (
                    (sign3 ? (forceSign ? "+" : "") : "-") +
                    Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                    absNumber
                );
            }
            var formattingTokens =
                    /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
                formatFunctions = {},
                formatTokenFunctions = {};
            function addFormatToken(token2, padded, ordinal2, callback2) {
                var func = callback2;
                if (typeof callback2 === "string") {
                    func = function () {
                        return this[callback2]();
                    };
                }
                if (token2) {
                    formatTokenFunctions[token2] = func;
                }
                if (padded) {
                    formatTokenFunctions[padded[0]] = function () {
                        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                }
                if (ordinal2) {
                    formatTokenFunctions[ordinal2] = function () {
                        return this.localeData().ordinal(func.apply(this, arguments), token2);
                    };
                }
            }
            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, "");
                }
                return input.replace(/\\/g, "");
            }
            function makeFormatFunction(format2) {
                var array = format2.match(formattingTokens),
                    i2,
                    length;
                for (i2 = 0, length = array.length; i2 < length; i2++) {
                    if (formatTokenFunctions[array[i2]]) {
                        array[i2] = formatTokenFunctions[array[i2]];
                    } else {
                        array[i2] = removeFormattingTokens(array[i2]);
                    }
                }
                return function (mom) {
                    var output = "",
                        i3;
                    for (i3 = 0; i3 < length; i3++) {
                        output += isFunction2(array[i3]) ? array[i3].call(mom, format2) : array[i3];
                    }
                    return output;
                };
            }
            function formatMoment(m2, format2) {
                if (!m2.isValid()) {
                    return m2.localeData().invalidDate();
                }
                format2 = expandFormat(format2, m2.localeData());
                formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
                return formatFunctions[format2](m2);
            }
            function expandFormat(format2, locale3) {
                var i2 = 5;
                function replaceLongDateFormatTokens(input) {
                    return locale3.longDateFormat(input) || input;
                }
                localFormattingTokens.lastIndex = 0;
                while (i2 >= 0 && localFormattingTokens.test(format2)) {
                    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i2 -= 1;
                }
                return format2;
            }
            var defaultLongDateFormat = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A",
            };
            function longDateFormat(key) {
                var format2 = this._longDateFormat[key],
                    formatUpper = this._longDateFormat[key.toUpperCase()];
                if (format2 || !formatUpper) {
                    return format2;
                }
                this._longDateFormat[key] = formatUpper
                    .match(formattingTokens)
                    .map(function (tok) {
                        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
                            return tok.slice(1);
                        }
                        return tok;
                    })
                    .join("");
                return this._longDateFormat[key];
            }
            var defaultInvalidDate = "Invalid date";
            function invalidDate() {
                return this._invalidDate;
            }
            var defaultOrdinal = "%d",
                defaultDayOfMonthOrdinalParse = /\d{1,2}/;
            function ordinal(number) {
                return this._ordinal.replace("%d", number);
            }
            var defaultRelativeTime = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                w: "a week",
                ww: "%d weeks",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years",
            };
            function relativeTime(number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return isFunction2(output)
                    ? output(number, withoutSuffix, string, isFuture)
                    : output.replace(/%d/i, number);
            }
            function pastFuture(diff2, output) {
                var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
                return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
            }
            var aliases = {
                D: "date",
                dates: "date",
                date: "date",
                d: "day",
                days: "day",
                day: "day",
                e: "weekday",
                weekdays: "weekday",
                weekday: "weekday",
                E: "isoWeekday",
                isoweekdays: "isoWeekday",
                isoweekday: "isoWeekday",
                DDD: "dayOfYear",
                dayofyears: "dayOfYear",
                dayofyear: "dayOfYear",
                h: "hour",
                hours: "hour",
                hour: "hour",
                ms: "millisecond",
                milliseconds: "millisecond",
                millisecond: "millisecond",
                m: "minute",
                minutes: "minute",
                minute: "minute",
                M: "month",
                months: "month",
                month: "month",
                Q: "quarter",
                quarters: "quarter",
                quarter: "quarter",
                s: "second",
                seconds: "second",
                second: "second",
                gg: "weekYear",
                weekyears: "weekYear",
                weekyear: "weekYear",
                GG: "isoWeekYear",
                isoweekyears: "isoWeekYear",
                isoweekyear: "isoWeekYear",
                w: "week",
                weeks: "week",
                week: "week",
                W: "isoWeek",
                isoweeks: "isoWeek",
                isoweek: "isoWeek",
                y: "year",
                years: "year",
                year: "year",
            };
            function normalizeUnits(units) {
                return typeof units === "string"
                    ? aliases[units] || aliases[units.toLowerCase()]
                    : void 0;
            }
            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {},
                    normalizedProp,
                    prop;
                for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop];
                        }
                    }
                }
                return normalizedInput;
            }
            var priorities = {
                date: 9,
                day: 11,
                weekday: 11,
                isoWeekday: 11,
                dayOfYear: 4,
                hour: 13,
                millisecond: 16,
                minute: 14,
                month: 8,
                quarter: 7,
                second: 15,
                weekYear: 1,
                isoWeekYear: 1,
                week: 5,
                isoWeek: 5,
                year: 1,
            };
            function getPrioritizedUnits(unitsObj) {
                var units = [],
                    u2;
                for (u2 in unitsObj) {
                    if (hasOwnProp(unitsObj, u2)) {
                        units.push({ unit: u2, priority: priorities[u2] });
                    }
                }
                units.sort(function (a2, b2) {
                    return a2.priority - b2.priority;
                });
                return units;
            }
            var match1 = /\d/,
                match2 = /\d\d/,
                match3 = /\d{3}/,
                match4 = /\d{4}/,
                match6 = /[+-]?\d{6}/,
                match1to2 = /\d\d?/,
                match3to4 = /\d\d\d\d?/,
                match5to6 = /\d\d\d\d\d\d?/,
                match1to3 = /\d{1,3}/,
                match1to4 = /\d{1,4}/,
                match1to6 = /[+-]?\d{1,6}/,
                matchUnsigned = /\d+/,
                matchSigned = /[+-]?\d+/,
                matchOffset = /Z|[+-]\d\d:?\d\d/gi,
                matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
                matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
                matchWord =
                    /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
                match1to2NoLeadingZero = /^[1-9]\d?/,
                match1to2HasZero = /^([1-9]\d|\d)/,
                regexes;
            regexes = {};
            function addRegexToken(token2, regex, strictRegex) {
                regexes[token2] = isFunction2(regex)
                    ? regex
                    : function (isStrict, localeData2) {
                          return isStrict && strictRegex ? strictRegex : regex;
                      };
            }
            function getParseRegexForToken(token2, config) {
                if (!hasOwnProp(regexes, token2)) {
                    return new RegExp(unescapeFormat(token2));
                }
                return regexes[token2](config._strict, config._locale);
            }
            function unescapeFormat(s2) {
                return regexEscape(
                    s2
                        .replace("\\", "")
                        .replace(
                            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                            function (matched, p1, p2, p3, p4) {
                                return p1 || p2 || p3 || p4;
                            },
                        ),
                );
            }
            function regexEscape(s2) {
                return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
            }
            function absFloor(number) {
                if (number < 0) {
                    return Math.ceil(number) || 0;
                } else {
                    return Math.floor(number);
                }
            }
            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion,
                    value = 0;
                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                }
                return value;
            }
            var tokens = {};
            function addParseToken(token2, callback2) {
                var i2,
                    func = callback2,
                    tokenLen;
                if (typeof token2 === "string") {
                    token2 = [token2];
                }
                if (isNumber2(callback2)) {
                    func = function (input, array) {
                        array[callback2] = toInt(input);
                    };
                }
                tokenLen = token2.length;
                for (i2 = 0; i2 < tokenLen; i2++) {
                    tokens[token2[i2]] = func;
                }
            }
            function addWeekParseToken(token2, callback2) {
                addParseToken(token2, function (input, array, config, token3) {
                    config._w = config._w || {};
                    callback2(input, config._w, config, token3);
                });
            }
            function addTimeToArrayFromToken(token2, input, config) {
                if (input != null && hasOwnProp(tokens, token2)) {
                    tokens[token2](input, config._a, config, token2);
                }
            }
            function isLeapYear(year) {
                return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
            }
            var YEAR = 0,
                MONTH = 1,
                DATE = 2,
                HOUR = 3,
                MINUTE = 4,
                SECOND = 5,
                MILLISECOND = 6,
                WEEK = 7,
                WEEKDAY = 8;
            addFormatToken("Y", 0, 0, function () {
                var y2 = this.year();
                return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
            });
            addFormatToken(0, ["YY", 2], 0, function () {
                return this.year() % 100;
            });
            addFormatToken(0, ["YYYY", 4], 0, "year");
            addFormatToken(0, ["YYYYY", 5], 0, "year");
            addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
            addRegexToken("Y", matchSigned);
            addRegexToken("YY", match1to2, match2);
            addRegexToken("YYYY", match1to4, match4);
            addRegexToken("YYYYY", match1to6, match6);
            addRegexToken("YYYYYY", match1to6, match6);
            addParseToken(["YYYYY", "YYYYYY"], YEAR);
            addParseToken("YYYY", function (input, array) {
                array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
            });
            addParseToken("YY", function (input, array) {
                array[YEAR] = hooks.parseTwoDigitYear(input);
            });
            addParseToken("Y", function (input, array) {
                array[YEAR] = parseInt(input, 10);
            });
            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }
            hooks.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
            };
            var getSetYear = makeGetSet("FullYear", true);
            function getIsLeapYear() {
                return isLeapYear(this.year());
            }
            function makeGetSet(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        set$1(this, unit, value);
                        hooks.updateOffset(this, keepTime);
                        return this;
                    } else {
                        return get(this, unit);
                    }
                };
            }
            function get(mom, unit) {
                if (!mom.isValid()) {
                    return NaN;
                }
                var d2 = mom._d,
                    isUTC = mom._isUTC;
                switch (unit) {
                    case "Milliseconds":
                        return isUTC ? d2.getUTCMilliseconds() : d2.getMilliseconds();
                    case "Seconds":
                        return isUTC ? d2.getUTCSeconds() : d2.getSeconds();
                    case "Minutes":
                        return isUTC ? d2.getUTCMinutes() : d2.getMinutes();
                    case "Hours":
                        return isUTC ? d2.getUTCHours() : d2.getHours();
                    case "Date":
                        return isUTC ? d2.getUTCDate() : d2.getDate();
                    case "Day":
                        return isUTC ? d2.getUTCDay() : d2.getDay();
                    case "Month":
                        return isUTC ? d2.getUTCMonth() : d2.getMonth();
                    case "FullYear":
                        return isUTC ? d2.getUTCFullYear() : d2.getFullYear();
                    default:
                        return NaN;
                }
            }
            function set$1(mom, unit, value) {
                var d2, isUTC, year, month, date;
                if (!mom.isValid() || isNaN(value)) {
                    return;
                }
                d2 = mom._d;
                isUTC = mom._isUTC;
                switch (unit) {
                    case "Milliseconds":
                        return void (isUTC
                            ? d2.setUTCMilliseconds(value)
                            : d2.setMilliseconds(value));
                    case "Seconds":
                        return void (isUTC ? d2.setUTCSeconds(value) : d2.setSeconds(value));
                    case "Minutes":
                        return void (isUTC ? d2.setUTCMinutes(value) : d2.setMinutes(value));
                    case "Hours":
                        return void (isUTC ? d2.setUTCHours(value) : d2.setHours(value));
                    case "Date":
                        return void (isUTC ? d2.setUTCDate(value) : d2.setDate(value));
                    // case 'Day': // Not real
                    //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
                    // case 'Month': // Not used because we need to pass two variables
                    //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
                    case "FullYear":
                        break;
                    // See below ...
                    default:
                        return;
                }
                year = value;
                month = mom.month();
                date = mom.date();
                date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
                void (isUTC
                    ? d2.setUTCFullYear(year, month, date)
                    : d2.setFullYear(year, month, date));
            }
            function stringGet(units) {
                units = normalizeUnits(units);
                if (isFunction2(this[units])) {
                    return this[units]();
                }
                return this;
            }
            function stringSet(units, value) {
                if (typeof units === "object") {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units),
                        i2,
                        prioritizedLen = prioritized.length;
                    for (i2 = 0; i2 < prioritizedLen; i2++) {
                        this[prioritized[i2].unit](units[prioritized[i2].unit]);
                    }
                } else {
                    units = normalizeUnits(units);
                    if (isFunction2(this[units])) {
                        return this[units](value);
                    }
                }
                return this;
            }
            function mod(n2, x2) {
                return ((n2 % x2) + x2) % x2;
            }
            var indexOf;
            if (Array.prototype.indexOf) {
                indexOf = Array.prototype.indexOf;
            } else {
                indexOf = function (o2) {
                    var i2;
                    for (i2 = 0; i2 < this.length; ++i2) {
                        if (this[i2] === o2) {
                            return i2;
                        }
                    }
                    return -1;
                };
            }
            function daysInMonth(year, month) {
                if (isNaN(year) || isNaN(month)) {
                    return NaN;
                }
                var modMonth = mod(month, 12);
                year += (month - modMonth) / 12;
                return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : 31 - ((modMonth % 7) % 2);
            }
            addFormatToken("M", ["MM", 2], "Mo", function () {
                return this.month() + 1;
            });
            addFormatToken("MMM", 0, 0, function (format2) {
                return this.localeData().monthsShort(this, format2);
            });
            addFormatToken("MMMM", 0, 0, function (format2) {
                return this.localeData().months(this, format2);
            });
            addRegexToken("M", match1to2, match1to2NoLeadingZero);
            addRegexToken("MM", match1to2, match2);
            addRegexToken("MMM", function (isStrict, locale3) {
                return locale3.monthsShortRegex(isStrict);
            });
            addRegexToken("MMMM", function (isStrict, locale3) {
                return locale3.monthsRegex(isStrict);
            });
            addParseToken(["M", "MM"], function (input, array) {
                array[MONTH] = toInt(input) - 1;
            });
            addParseToken(["MMM", "MMMM"], function (input, array, config, token2) {
                var month = config._locale.monthsParse(input, token2, config._strict);
                if (month != null) {
                    array[MONTH] = month;
                } else {
                    getParsingFlags(config).invalidMonth = input;
                }
            });
            var defaultLocaleMonths =
                    "January_February_March_April_May_June_July_August_September_October_November_December".split(
                        "_",
                    ),
                defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
                    "_",
                ),
                MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                defaultMonthsShortRegex = matchWord,
                defaultMonthsRegex = matchWord;
            function localeMonths(m2, format2) {
                if (!m2) {
                    return isArray2(this._months) ? this._months : this._months["standalone"];
                }
                return isArray2(this._months)
                    ? this._months[m2.month()]
                    : this._months[
                          (this._months.isFormat || MONTHS_IN_FORMAT).test(format2)
                              ? "format"
                              : "standalone"
                      ][m2.month()];
            }
            function localeMonthsShort(m2, format2) {
                if (!m2) {
                    return isArray2(this._monthsShort)
                        ? this._monthsShort
                        : this._monthsShort["standalone"];
                }
                return isArray2(this._monthsShort)
                    ? this._monthsShort[m2.month()]
                    : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][
                          m2.month()
                      ];
            }
            function handleStrictParse(monthName, format2, strict) {
                var i2,
                    ii,
                    mom,
                    llc = monthName.toLocaleLowerCase();
                if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i2 = 0; i2 < 12; ++i2) {
                        mom = createUTC([2e3, i2]);
                        this._shortMonthsParse[i2] = this.monthsShort(mom, "").toLocaleLowerCase();
                        this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
                    }
                }
                if (strict) {
                    if (format2 === "MMM") {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format2 === "MMM") {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }
            function localeMonthsParse(monthName, format2, strict) {
                var i2, mom, regex;
                if (this._monthsParseExact) {
                    return handleStrictParse.call(this, monthName, format2, strict);
                }
                if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                }
                for (i2 = 0; i2 < 12; i2++) {
                    mom = createUTC([2e3, i2]);
                    if (strict && !this._longMonthsParse[i2]) {
                        this._longMonthsParse[i2] = new RegExp(
                            "^" + this.months(mom, "").replace(".", "") + "$",
                            "i",
                        );
                        this._shortMonthsParse[i2] = new RegExp(
                            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                            "i",
                        );
                    }
                    if (!strict && !this._monthsParse[i2]) {
                        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                        this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
                        return i2;
                    } else if (
                        strict &&
                        format2 === "MMM" &&
                        this._shortMonthsParse[i2].test(monthName)
                    ) {
                        return i2;
                    } else if (!strict && this._monthsParse[i2].test(monthName)) {
                        return i2;
                    }
                }
            }
            function setMonth(mom, value) {
                if (!mom.isValid()) {
                    return mom;
                }
                if (typeof value === "string") {
                    if (/^\d+$/.test(value)) {
                        value = toInt(value);
                    } else {
                        value = mom.localeData().monthsParse(value);
                        if (!isNumber2(value)) {
                            return mom;
                        }
                    }
                }
                var month = value,
                    date = mom.date();
                date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
                void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
                return mom;
            }
            function getSetMonth(value) {
                if (value != null) {
                    setMonth(this, value);
                    hooks.updateOffset(this, true);
                    return this;
                } else {
                    return get(this, "Month");
                }
            }
            function getDaysInMonth() {
                return daysInMonth(this.year(), this.month());
            }
            function monthsShortRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsShortStrictRegex;
                    } else {
                        return this._monthsShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, "_monthsShortRegex")) {
                        this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict
                        ? this._monthsShortStrictRegex
                        : this._monthsShortRegex;
                }
            }
            function monthsRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsStrictRegex;
                    } else {
                        return this._monthsRegex;
                    }
                } else {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                        this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict
                        ? this._monthsStrictRegex
                        : this._monthsRegex;
                }
            }
            function computeMonthsParse() {
                function cmpLenRev(a2, b2) {
                    return b2.length - a2.length;
                }
                var shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i2,
                    mom,
                    shortP,
                    longP;
                for (i2 = 0; i2 < 12; i2++) {
                    mom = createUTC([2e3, i2]);
                    shortP = regexEscape(this.monthsShort(mom, ""));
                    longP = regexEscape(this.months(mom, ""));
                    shortPieces.push(shortP);
                    longPieces.push(longP);
                    mixedPieces.push(longP);
                    mixedPieces.push(shortP);
                }
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                this._monthsShortRegex = this._monthsRegex;
                this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
            }
            function createDate(y2, m2, d2, h6, M2, s2, ms) {
                var date;
                if (y2 < 100 && y2 >= 0) {
                    date = new Date(y2 + 400, m2, d2, h6, M2, s2, ms);
                    if (isFinite(date.getFullYear())) {
                        date.setFullYear(y2);
                    }
                } else {
                    date = new Date(y2, m2, d2, h6, M2, s2, ms);
                }
                return date;
            }
            function createUTCDate(y2) {
                var date, args;
                if (y2 < 100 && y2 >= 0) {
                    args = Array.prototype.slice.call(arguments);
                    args[0] = y2 + 400;
                    date = new Date(Date.UTC.apply(null, args));
                    if (isFinite(date.getUTCFullYear())) {
                        date.setUTCFullYear(y2);
                    }
                } else {
                    date = new Date(Date.UTC.apply(null, arguments));
                }
                return date;
            }
            function firstWeekOffset(year, dow, doy) {
                var fwd = 7 + dow - doy,
                    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
                return -fwdlw + fwd - 1;
            }
            function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                var localWeekday = (7 + weekday - dow) % 7,
                    weekOffset = firstWeekOffset(year, dow, doy),
                    dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                    resYear,
                    resDayOfYear;
                if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                }
                return {
                    year: resYear,
                    dayOfYear: resDayOfYear,
                };
            }
            function weekOfYear(mom, dow, doy) {
                var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                    resWeek,
                    resYear;
                if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                } else {
                    resYear = mom.year();
                    resWeek = week;
                }
                return {
                    week: resWeek,
                    year: resYear,
                };
            }
            function weeksInYear(year, dow, doy) {
                var weekOffset = firstWeekOffset(year, dow, doy),
                    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
            }
            addFormatToken("w", ["ww", 2], "wo", "week");
            addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
            addRegexToken("w", match1to2, match1to2NoLeadingZero);
            addRegexToken("ww", match1to2, match2);
            addRegexToken("W", match1to2, match1to2NoLeadingZero);
            addRegexToken("WW", match1to2, match2);
            addWeekParseToken(["w", "ww", "W", "WW"], function (input, week, config, token2) {
                week[token2.substr(0, 1)] = toInt(input);
            });
            function localeWeek(mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week;
            }
            var defaultLocaleWeek = {
                dow: 0,
                // Sunday is the first day of the week.
                doy: 6,
                // The week that contains Jan 6th is the first week of the year.
            };
            function localeFirstDayOfWeek() {
                return this._week.dow;
            }
            function localeFirstDayOfYear() {
                return this._week.doy;
            }
            function getSetWeek(input) {
                var week = this.localeData().week(this);
                return input == null ? week : this.add((input - week) * 7, "d");
            }
            function getSetISOWeek(input) {
                var week = weekOfYear(this, 1, 4).week;
                return input == null ? week : this.add((input - week) * 7, "d");
            }
            addFormatToken("d", 0, "do", "day");
            addFormatToken("dd", 0, 0, function (format2) {
                return this.localeData().weekdaysMin(this, format2);
            });
            addFormatToken("ddd", 0, 0, function (format2) {
                return this.localeData().weekdaysShort(this, format2);
            });
            addFormatToken("dddd", 0, 0, function (format2) {
                return this.localeData().weekdays(this, format2);
            });
            addFormatToken("e", 0, 0, "weekday");
            addFormatToken("E", 0, 0, "isoWeekday");
            addRegexToken("d", match1to2);
            addRegexToken("e", match1to2);
            addRegexToken("E", match1to2);
            addRegexToken("dd", function (isStrict, locale3) {
                return locale3.weekdaysMinRegex(isStrict);
            });
            addRegexToken("ddd", function (isStrict, locale3) {
                return locale3.weekdaysShortRegex(isStrict);
            });
            addRegexToken("dddd", function (isStrict, locale3) {
                return locale3.weekdaysRegex(isStrict);
            });
            addWeekParseToken(["dd", "ddd", "dddd"], function (input, week, config, token2) {
                var weekday = config._locale.weekdaysParse(input, token2, config._strict);
                if (weekday != null) {
                    week.d = weekday;
                } else {
                    getParsingFlags(config).invalidWeekday = input;
                }
            });
            addWeekParseToken(["d", "e", "E"], function (input, week, config, token2) {
                week[token2] = toInt(input);
            });
            function parseWeekday(input, locale3) {
                if (typeof input !== "string") {
                    return input;
                }
                if (!isNaN(input)) {
                    return parseInt(input, 10);
                }
                input = locale3.weekdaysParse(input);
                if (typeof input === "number") {
                    return input;
                }
                return null;
            }
            function parseIsoWeekday(input, locale3) {
                if (typeof input === "string") {
                    return locale3.weekdaysParse(input) % 7 || 7;
                }
                return isNaN(input) ? null : input;
            }
            function shiftWeekdays(ws, n2) {
                return ws.slice(n2, 7).concat(ws.slice(0, n2));
            }
            var defaultLocaleWeekdays =
                    "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                defaultWeekdaysRegex = matchWord,
                defaultWeekdaysShortRegex = matchWord,
                defaultWeekdaysMinRegex = matchWord;
            function localeWeekdays(m2, format2) {
                var weekdays = isArray2(this._weekdays)
                    ? this._weekdays
                    : this._weekdays[
                          m2 && m2 !== true && this._weekdays.isFormat.test(format2)
                              ? "format"
                              : "standalone"
                      ];
                return m2 === true
                    ? shiftWeekdays(weekdays, this._week.dow)
                    : m2
                      ? weekdays[m2.day()]
                      : weekdays;
            }
            function localeWeekdaysShort(m2) {
                return m2 === true
                    ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                    : m2
                      ? this._weekdaysShort[m2.day()]
                      : this._weekdaysShort;
            }
            function localeWeekdaysMin(m2) {
                return m2 === true
                    ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                    : m2
                      ? this._weekdaysMin[m2.day()]
                      : this._weekdaysMin;
            }
            function handleStrictParse$1(weekdayName, format2, strict) {
                var i2,
                    ii,
                    mom,
                    llc = weekdayName.toLocaleLowerCase();
                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];
                    for (i2 = 0; i2 < 7; ++i2) {
                        mom = createUTC([2e3, 1]).day(i2);
                        this._minWeekdaysParse[i2] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                        this._shortWeekdaysParse[i2] = this.weekdaysShort(
                            mom,
                            "",
                        ).toLocaleLowerCase();
                        this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
                    }
                }
                if (strict) {
                    if (format2 === "dddd") {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format2 === "dddd") {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }
            function localeWeekdaysParse(weekdayName, format2, strict) {
                var i2, mom, regex;
                if (this._weekdaysParseExact) {
                    return handleStrictParse$1.call(this, weekdayName, format2, strict);
                }
                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                }
                for (i2 = 0; i2 < 7; i2++) {
                    mom = createUTC([2e3, 1]).day(i2);
                    if (strict && !this._fullWeekdaysParse[i2]) {
                        this._fullWeekdaysParse[i2] = new RegExp(
                            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                            "i",
                        );
                        this._shortWeekdaysParse[i2] = new RegExp(
                            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                            "i",
                        );
                        this._minWeekdaysParse[i2] = new RegExp(
                            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                            "i",
                        );
                    }
                    if (!this._weekdaysParse[i2]) {
                        regex =
                            "^" +
                            this.weekdays(mom, "") +
                            "|^" +
                            this.weekdaysShort(mom, "") +
                            "|^" +
                            this.weekdaysMin(mom, "");
                        this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (
                        strict &&
                        format2 === "dddd" &&
                        this._fullWeekdaysParse[i2].test(weekdayName)
                    ) {
                        return i2;
                    } else if (
                        strict &&
                        format2 === "ddd" &&
                        this._shortWeekdaysParse[i2].test(weekdayName)
                    ) {
                        return i2;
                    } else if (
                        strict &&
                        format2 === "dd" &&
                        this._minWeekdaysParse[i2].test(weekdayName)
                    ) {
                        return i2;
                    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
                        return i2;
                    }
                }
            }
            function getSetDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var day = get(this, "Day");
                if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, "d");
                } else {
                    return day;
                }
            }
            function getSetLocaleDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return input == null ? weekday : this.add(input - weekday, "d");
            }
            function getSetISODayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                } else {
                    return this.day() || 7;
                }
            }
            function weekdaysRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysStrictRegex;
                    } else {
                        return this._weekdaysRegex;
                    }
                } else {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                        this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict
                        ? this._weekdaysStrictRegex
                        : this._weekdaysRegex;
                }
            }
            function weekdaysShortRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysShortStrictRegex;
                    } else {
                        return this._weekdaysShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict
                        ? this._weekdaysShortStrictRegex
                        : this._weekdaysShortRegex;
                }
            }
            function weekdaysMinRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysMinStrictRegex;
                    } else {
                        return this._weekdaysMinRegex;
                    }
                } else {
                    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict
                        ? this._weekdaysMinStrictRegex
                        : this._weekdaysMinRegex;
                }
            }
            function computeWeekdaysParse() {
                function cmpLenRev(a2, b2) {
                    return b2.length - a2.length;
                }
                var minPieces = [],
                    shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i2,
                    mom,
                    minp,
                    shortp,
                    longp;
                for (i2 = 0; i2 < 7; i2++) {
                    mom = createUTC([2e3, 1]).day(i2);
                    minp = regexEscape(this.weekdaysMin(mom, ""));
                    shortp = regexEscape(this.weekdaysShort(mom, ""));
                    longp = regexEscape(this.weekdays(mom, ""));
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                }
                minPieces.sort(cmpLenRev);
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                this._weekdaysShortRegex = this._weekdaysRegex;
                this._weekdaysMinRegex = this._weekdaysRegex;
                this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                this._weekdaysShortStrictRegex = new RegExp(
                    "^(" + shortPieces.join("|") + ")",
                    "i",
                );
                this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
            }
            function hFormat() {
                return this.hours() % 12 || 12;
            }
            function kFormat() {
                return this.hours() || 24;
            }
            addFormatToken("H", ["HH", 2], 0, "hour");
            addFormatToken("h", ["hh", 2], 0, hFormat);
            addFormatToken("k", ["kk", 2], 0, kFormat);
            addFormatToken("hmm", 0, 0, function () {
                return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
            });
            addFormatToken("hmmss", 0, 0, function () {
                return (
                    "" +
                    hFormat.apply(this) +
                    zeroFill(this.minutes(), 2) +
                    zeroFill(this.seconds(), 2)
                );
            });
            addFormatToken("Hmm", 0, 0, function () {
                return "" + this.hours() + zeroFill(this.minutes(), 2);
            });
            addFormatToken("Hmmss", 0, 0, function () {
                return (
                    "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
                );
            });
            function meridiem(token2, lowercase) {
                addFormatToken(token2, 0, 0, function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                });
            }
            meridiem("a", true);
            meridiem("A", false);
            function matchMeridiem(isStrict, locale3) {
                return locale3._meridiemParse;
            }
            addRegexToken("a", matchMeridiem);
            addRegexToken("A", matchMeridiem);
            addRegexToken("H", match1to2, match1to2HasZero);
            addRegexToken("h", match1to2, match1to2NoLeadingZero);
            addRegexToken("k", match1to2, match1to2NoLeadingZero);
            addRegexToken("HH", match1to2, match2);
            addRegexToken("hh", match1to2, match2);
            addRegexToken("kk", match1to2, match2);
            addRegexToken("hmm", match3to4);
            addRegexToken("hmmss", match5to6);
            addRegexToken("Hmm", match3to4);
            addRegexToken("Hmmss", match5to6);
            addParseToken(["H", "HH"], HOUR);
            addParseToken(["k", "kk"], function (input, array, config) {
                var kInput = toInt(input);
                array[HOUR] = kInput === 24 ? 0 : kInput;
            });
            addParseToken(["a", "A"], function (input, array, config) {
                config._isPm = config._locale.isPM(input);
                config._meridiem = input;
            });
            addParseToken(["h", "hh"], function (input, array, config) {
                array[HOUR] = toInt(input);
                getParsingFlags(config).bigHour = true;
            });
            addParseToken("hmm", function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken("hmmss", function (input, array, config) {
                var pos1 = input.length - 4,
                    pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken("Hmm", function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
            });
            addParseToken("Hmmss", function (input, array, config) {
                var pos1 = input.length - 4,
                    pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
            });
            function localeIsPM(input) {
                return (input + "").toLowerCase().charAt(0) === "p";
            }
            var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
                getSetHour = makeGetSet("Hours", true);
            function localeMeridiem(hours2, minutes2, isLower) {
                if (hours2 > 11) {
                    return isLower ? "pm" : "PM";
                } else {
                    return isLower ? "am" : "AM";
                }
            }
            var baseConfig = {
                calendar: defaultCalendar,
                longDateFormat: defaultLongDateFormat,
                invalidDate: defaultInvalidDate,
                ordinal: defaultOrdinal,
                dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                relativeTime: defaultRelativeTime,
                months: defaultLocaleMonths,
                monthsShort: defaultLocaleMonthsShort,
                week: defaultLocaleWeek,
                weekdays: defaultLocaleWeekdays,
                weekdaysMin: defaultLocaleWeekdaysMin,
                weekdaysShort: defaultLocaleWeekdaysShort,
                meridiemParse: defaultLocaleMeridiemParse,
            };
            var locales = {},
                localeFamilies = {},
                globalLocale;
            function commonPrefix(arr1, arr2) {
                var i2,
                    minl = Math.min(arr1.length, arr2.length);
                for (i2 = 0; i2 < minl; i2 += 1) {
                    if (arr1[i2] !== arr2[i2]) {
                        return i2;
                    }
                }
                return minl;
            }
            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace("_", "-") : key;
            }
            function chooseLocale(names2) {
                var i2 = 0,
                    j2,
                    next,
                    locale3,
                    split;
                while (i2 < names2.length) {
                    split = normalizeLocale(names2[i2]).split("-");
                    j2 = split.length;
                    next = normalizeLocale(names2[i2 + 1]);
                    next = next ? next.split("-") : null;
                    while (j2 > 0) {
                        locale3 = loadLocale(split.slice(0, j2).join("-"));
                        if (locale3) {
                            return locale3;
                        }
                        if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
                            break;
                        }
                        j2--;
                    }
                    i2++;
                }
                return globalLocale;
            }
            function isLocaleNameSane(name) {
                return !!(name && name.match("^[^/\\\\]*$"));
            }
            function loadLocale(name) {
                var oldLocale = null,
                    aliasedRequire;
                if (
                    locales[name] === void 0 &&
                    typeof module2 !== "undefined" &&
                    module2 &&
                    module2.exports &&
                    isLocaleNameSane(name)
                ) {
                    try {
                        oldLocale = globalLocale._abbr;
                        aliasedRequire = require;
                        aliasedRequire("./locale/" + name);
                        getSetGlobalLocale(oldLocale);
                    } catch (e2) {
                        locales[name] = null;
                    }
                }
                return locales[name];
            }
            function getSetGlobalLocale(key, values) {
                var data;
                if (key) {
                    if (isUndefined(values)) {
                        data = getLocale(key);
                    } else {
                        data = defineLocale(key, values);
                    }
                    if (data) {
                        globalLocale = data;
                    } else {
                        if (typeof console !== "undefined" && console.warn) {
                            console.warn(
                                "Locale " + key + " not found. Did you forget to load it?",
                            );
                        }
                    }
                }
                return globalLocale._abbr;
            }
            function defineLocale(name, config) {
                if (config !== null) {
                    var locale3,
                        parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                        deprecateSimple(
                            "defineLocaleOverride",
                            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.",
                        );
                        parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                        if (locales[config.parentLocale] != null) {
                            parentConfig = locales[config.parentLocale]._config;
                        } else {
                            locale3 = loadLocale(config.parentLocale);
                            if (locale3 != null) {
                                parentConfig = locale3._config;
                            } else {
                                if (!localeFamilies[config.parentLocale]) {
                                    localeFamilies[config.parentLocale] = [];
                                }
                                localeFamilies[config.parentLocale].push({
                                    name,
                                    config,
                                });
                                return null;
                            }
                        }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));
                    if (localeFamilies[name]) {
                        localeFamilies[name].forEach(function (x2) {
                            defineLocale(x2.name, x2.config);
                        });
                    }
                    getSetGlobalLocale(name);
                    return locales[name];
                } else {
                    delete locales[name];
                    return null;
                }
            }
            function updateLocale(name, config) {
                if (config != null) {
                    var locale3,
                        tmpLocale,
                        parentConfig = baseConfig;
                    if (locales[name] != null && locales[name].parentLocale != null) {
                        locales[name].set(mergeConfigs(locales[name]._config, config));
                    } else {
                        tmpLocale = loadLocale(name);
                        if (tmpLocale != null) {
                            parentConfig = tmpLocale._config;
                        }
                        config = mergeConfigs(parentConfig, config);
                        if (tmpLocale == null) {
                            config.abbr = name;
                        }
                        locale3 = new Locale(config);
                        locale3.parentLocale = locales[name];
                        locales[name] = locale3;
                    }
                    getSetGlobalLocale(name);
                } else {
                    if (locales[name] != null) {
                        if (locales[name].parentLocale != null) {
                            locales[name] = locales[name].parentLocale;
                            if (name === getSetGlobalLocale()) {
                                getSetGlobalLocale(name);
                            }
                        } else if (locales[name] != null) {
                            delete locales[name];
                        }
                    }
                }
                return locales[name];
            }
            function getLocale(key) {
                var locale3;
                if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                }
                if (!key) {
                    return globalLocale;
                }
                if (!isArray2(key)) {
                    locale3 = loadLocale(key);
                    if (locale3) {
                        return locale3;
                    }
                    key = [key];
                }
                return chooseLocale(key);
            }
            function listLocales() {
                return keys(locales);
            }
            function checkOverflow(m2) {
                var overflow,
                    a2 = m2._a;
                if (a2 && getParsingFlags(m2).overflow === -2) {
                    overflow =
                        a2[MONTH] < 0 || a2[MONTH] > 11
                            ? MONTH
                            : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH])
                              ? DATE
                              : a2[HOUR] < 0 ||
                                  a2[HOUR] > 24 ||
                                  (a2[HOUR] === 24 &&
                                      (a2[MINUTE] !== 0 ||
                                          a2[SECOND] !== 0 ||
                                          a2[MILLISECOND] !== 0))
                                ? HOUR
                                : a2[MINUTE] < 0 || a2[MINUTE] > 59
                                  ? MINUTE
                                  : a2[SECOND] < 0 || a2[SECOND] > 59
                                    ? SECOND
                                    : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999
                                      ? MILLISECOND
                                      : -1;
                    if (
                        getParsingFlags(m2)._overflowDayOfYear &&
                        (overflow < YEAR || overflow > DATE)
                    ) {
                        overflow = DATE;
                    }
                    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
                        overflow = WEEK;
                    }
                    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
                        overflow = WEEKDAY;
                    }
                    getParsingFlags(m2).overflow = overflow;
                }
                return m2;
            }
            var extendedIsoRegex =
                    /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                basicIsoRegex =
                    /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
                isoDates = [
                    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
                    ["YYYY-DDD", /\d{4}-\d{3}/],
                    ["YYYY-MM", /\d{4}-\d\d/, false],
                    ["YYYYYYMMDD", /[+-]\d{10}/],
                    ["YYYYMMDD", /\d{8}/],
                    ["GGGG[W]WWE", /\d{4}W\d{3}/],
                    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
                    ["YYYYDDD", /\d{7}/],
                    ["YYYYMM", /\d{6}/, false],
                    ["YYYY", /\d{4}/, false],
                ],
                isoTimes = [
                    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                    ["HH:mm", /\d\d:\d\d/],
                    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                    ["HHmmss", /\d\d\d\d\d\d/],
                    ["HHmm", /\d\d\d\d/],
                    ["HH", /\d\d/],
                ],
                aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
                rfc2822 =
                    /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                obsOffsets = {
                    UT: 0,
                    GMT: 0,
                    EDT: -4 * 60,
                    EST: -5 * 60,
                    CDT: -5 * 60,
                    CST: -6 * 60,
                    MDT: -6 * 60,
                    MST: -7 * 60,
                    PDT: -7 * 60,
                    PST: -8 * 60,
                };
            function configFromISO(config) {
                var i2,
                    l2,
                    string = config._i,
                    match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                    allowTime,
                    dateFormat,
                    timeFormat,
                    tzFormat,
                    isoDatesLen = isoDates.length,
                    isoTimesLen = isoTimes.length;
                if (match5) {
                    getParsingFlags(config).iso = true;
                    for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
                        if (isoDates[i2][1].exec(match5[1])) {
                            dateFormat = isoDates[i2][0];
                            allowTime = isoDates[i2][2] !== false;
                            break;
                        }
                    }
                    if (dateFormat == null) {
                        config._isValid = false;
                        return;
                    }
                    if (match5[3]) {
                        for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
                            if (isoTimes[i2][1].exec(match5[3])) {
                                timeFormat = (match5[2] || " ") + isoTimes[i2][0];
                                break;
                            }
                        }
                        if (timeFormat == null) {
                            config._isValid = false;
                            return;
                        }
                    }
                    if (!allowTime && timeFormat != null) {
                        config._isValid = false;
                        return;
                    }
                    if (match5[4]) {
                        if (tzRegex.exec(match5[4])) {
                            tzFormat = "Z";
                        } else {
                            config._isValid = false;
                            return;
                        }
                    }
                    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
                    configFromStringAndFormat(config);
                } else {
                    config._isValid = false;
                }
            }
            function extractFromRFC2822Strings(
                yearStr,
                monthStr,
                dayStr,
                hourStr,
                minuteStr,
                secondStr,
            ) {
                var result = [
                    untruncateYear(yearStr),
                    defaultLocaleMonthsShort.indexOf(monthStr),
                    parseInt(dayStr, 10),
                    parseInt(hourStr, 10),
                    parseInt(minuteStr, 10),
                ];
                if (secondStr) {
                    result.push(parseInt(secondStr, 10));
                }
                return result;
            }
            function untruncateYear(yearStr) {
                var year = parseInt(yearStr, 10);
                if (year <= 49) {
                    return 2e3 + year;
                } else if (year <= 999) {
                    return 1900 + year;
                }
                return year;
            }
            function preprocessRFC2822(s2) {
                return s2
                    .replace(/\([^()]*\)|[\n\t]/g, " ")
                    .replace(/(\s\s+)/g, " ")
                    .replace(/^\s\s*/, "")
                    .replace(/\s\s*$/, "");
            }
            function checkWeekday(weekdayStr, parsedInput, config) {
                if (weekdayStr) {
                    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                        weekdayActual = new Date(
                            parsedInput[0],
                            parsedInput[1],
                            parsedInput[2],
                        ).getDay();
                    if (weekdayProvided !== weekdayActual) {
                        getParsingFlags(config).weekdayMismatch = true;
                        config._isValid = false;
                        return false;
                    }
                }
                return true;
            }
            function calculateOffset(obsOffset, militaryOffset, numOffset) {
                if (obsOffset) {
                    return obsOffsets[obsOffset];
                } else if (militaryOffset) {
                    return 0;
                } else {
                    var hm = parseInt(numOffset, 10),
                        m2 = hm % 100,
                        h6 = (hm - m2) / 100;
                    return h6 * 60 + m2;
                }
            }
            function configFromRFC2822(config) {
                var match5 = rfc2822.exec(preprocessRFC2822(config._i)),
                    parsedArray;
                if (match5) {
                    parsedArray = extractFromRFC2822Strings(
                        match5[4],
                        match5[3],
                        match5[2],
                        match5[5],
                        match5[6],
                        match5[7],
                    );
                    if (!checkWeekday(match5[1], parsedArray, config)) {
                        return;
                    }
                    config._a = parsedArray;
                    config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
                    config._d = createUTCDate.apply(null, config._a);
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    getParsingFlags(config).rfc2822 = true;
                } else {
                    config._isValid = false;
                }
            }
            function configFromString(config) {
                var matched = aspNetJsonRegex.exec(config._i);
                if (matched !== null) {
                    config._d = /* @__PURE__ */ new Date(+matched[1]);
                    return;
                }
                configFromISO(config);
                if (config._isValid === false) {
                    delete config._isValid;
                } else {
                    return;
                }
                configFromRFC2822(config);
                if (config._isValid === false) {
                    delete config._isValid;
                } else {
                    return;
                }
                if (config._strict) {
                    config._isValid = false;
                } else {
                    hooks.createFromInputFallback(config);
                }
            }
            hooks.createFromInputFallback = deprecate(
                "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
                function (config) {
                    config._d = /* @__PURE__ */ new Date(
                        config._i + (config._useUTC ? " UTC" : ""),
                    );
                },
            );
            function defaults3(a2, b2, c2) {
                if (a2 != null) {
                    return a2;
                }
                if (b2 != null) {
                    return b2;
                }
                return c2;
            }
            function currentDateArray(config) {
                var nowValue = new Date(hooks.now());
                if (config._useUTC) {
                    return [
                        nowValue.getUTCFullYear(),
                        nowValue.getUTCMonth(),
                        nowValue.getUTCDate(),
                    ];
                }
                return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
            }
            function configFromArray(config) {
                var i2,
                    date,
                    input = [],
                    currentDate,
                    expectedWeekday,
                    yearToUse;
                if (config._d) {
                    return;
                }
                currentDate = currentDateArray(config);
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                }
                if (config._dayOfYear != null) {
                    yearToUse = defaults3(config._a[YEAR], currentDate[YEAR]);
                    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                        getParsingFlags(config)._overflowDayOfYear = true;
                    }
                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                }
                for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
                    config._a[i2] = input[i2] = currentDate[i2];
                }
                for (; i2 < 7; i2++) {
                    config._a[i2] = input[i2] =
                        config._a[i2] == null ? (i2 === 2 ? 1 : 0) : config._a[i2];
                }
                if (
                    config._a[HOUR] === 24 &&
                    config._a[MINUTE] === 0 &&
                    config._a[SECOND] === 0 &&
                    config._a[MILLISECOND] === 0
                ) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                }
                config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
                if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                }
                if (config._nextDay) {
                    config._a[HOUR] = 24;
                }
                if (
                    config._w &&
                    typeof config._w.d !== "undefined" &&
                    config._w.d !== expectedWeekday
                ) {
                    getParsingFlags(config).weekdayMismatch = true;
                }
            }
            function dayOfYearFromWeekInfo(config) {
                var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
                w2 = config._w;
                if (w2.GG != null || w2.W != null || w2.E != null) {
                    dow = 1;
                    doy = 4;
                    weekYear = defaults3(
                        w2.GG,
                        config._a[YEAR],
                        weekOfYear(createLocal(), 1, 4).year,
                    );
                    week = defaults3(w2.W, 1);
                    weekday = defaults3(w2.E, 1);
                    if (weekday < 1 || weekday > 7) {
                        weekdayOverflow = true;
                    }
                } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;
                    curWeek = weekOfYear(createLocal(), dow, doy);
                    weekYear = defaults3(w2.gg, config._a[YEAR], curWeek.year);
                    week = defaults3(w2.w, curWeek.week);
                    if (w2.d != null) {
                        weekday = w2.d;
                        if (weekday < 0 || weekday > 6) {
                            weekdayOverflow = true;
                        }
                    } else if (w2.e != null) {
                        weekday = w2.e + dow;
                        if (w2.e < 0 || w2.e > 6) {
                            weekdayOverflow = true;
                        }
                    } else {
                        weekday = dow;
                    }
                }
                if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }
            }
            hooks.ISO_8601 = function () {};
            hooks.RFC_2822 = function () {};
            function configFromStringAndFormat(config) {
                if (config._f === hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                }
                if (config._f === hooks.RFC_2822) {
                    configFromRFC2822(config);
                    return;
                }
                config._a = [];
                getParsingFlags(config).empty = true;
                var string = "" + config._i,
                    i2,
                    parsedInput,
                    tokens2,
                    token2,
                    skipped,
                    stringLength = string.length,
                    totalParsedInputLength = 0,
                    era,
                    tokenLen;
                tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                tokenLen = tokens2.length;
                for (i2 = 0; i2 < tokenLen; i2++) {
                    token2 = tokens2[i2];
                    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            getParsingFlags(config).unusedInput.push(skipped);
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length;
                    }
                    if (formatTokenFunctions[token2]) {
                        if (parsedInput) {
                            getParsingFlags(config).empty = false;
                        } else {
                            getParsingFlags(config).unusedTokens.push(token2);
                        }
                        addTimeToArrayFromToken(token2, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                        getParsingFlags(config).unusedTokens.push(token2);
                    }
                }
                getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                }
                if (
                    config._a[HOUR] <= 12 &&
                    getParsingFlags(config).bigHour === true &&
                    config._a[HOUR] > 0
                ) {
                    getParsingFlags(config).bigHour = void 0;
                }
                getParsingFlags(config).parsedDateParts = config._a.slice(0);
                getParsingFlags(config).meridiem = config._meridiem;
                config._a[HOUR] = meridiemFixWrap(
                    config._locale,
                    config._a[HOUR],
                    config._meridiem,
                );
                era = getParsingFlags(config).era;
                if (era !== null) {
                    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
                }
                configFromArray(config);
                checkOverflow(config);
            }
            function meridiemFixWrap(locale3, hour, meridiem2) {
                var isPm;
                if (meridiem2 == null) {
                    return hour;
                }
                if (locale3.meridiemHour != null) {
                    return locale3.meridiemHour(hour, meridiem2);
                } else if (locale3.isPM != null) {
                    isPm = locale3.isPM(meridiem2);
                    if (isPm && hour < 12) {
                        hour += 12;
                    }
                    if (!isPm && hour === 12) {
                        hour = 0;
                    }
                    return hour;
                } else {
                    return hour;
                }
            }
            function configFromStringAndArray(config) {
                var tempConfig,
                    bestMoment,
                    scoreToBeat,
                    i2,
                    currentScore,
                    validFormatFound,
                    bestFormatIsValid = false,
                    configfLen = config._f.length;
                if (configfLen === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = /* @__PURE__ */ new Date(NaN);
                    return;
                }
                for (i2 = 0; i2 < configfLen; i2++) {
                    currentScore = 0;
                    validFormatFound = false;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                        tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i2];
                    configFromStringAndFormat(tempConfig);
                    if (isValid(tempConfig)) {
                        validFormatFound = true;
                    }
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
                    getParsingFlags(tempConfig).score = currentScore;
                    if (!bestFormatIsValid) {
                        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                            if (validFormatFound) {
                                bestFormatIsValid = true;
                            }
                        }
                    } else {
                        if (currentScore < scoreToBeat) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                        }
                    }
                }
                extend(config, bestMoment || tempConfig);
            }
            function configFromObject(config) {
                if (config._d) {
                    return;
                }
                var i2 = normalizeObjectUnits(config._i),
                    dayOrDate = i2.day === void 0 ? i2.date : i2.day;
                config._a = map3(
                    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
                    function (obj) {
                        return obj && parseInt(obj, 10);
                    },
                );
                configFromArray(config);
            }
            function createFromConfig(config) {
                var res = new Moment3(checkOverflow(prepareConfig(config)));
                if (res._nextDay) {
                    res.add(1, "d");
                    res._nextDay = void 0;
                }
                return res;
            }
            function prepareConfig(config) {
                var input = config._i,
                    format2 = config._f;
                config._locale = config._locale || getLocale(config._l);
                if (input === null || (format2 === void 0 && input === "")) {
                    return createInvalid({ nullInput: true });
                }
                if (typeof input === "string") {
                    config._i = input = config._locale.preparse(input);
                }
                if (isMoment(input)) {
                    return new Moment3(checkOverflow(input));
                } else if (isDate(input)) {
                    config._d = input;
                } else if (isArray2(format2)) {
                    configFromStringAndArray(config);
                } else if (format2) {
                    configFromStringAndFormat(config);
                } else {
                    configFromInput(config);
                }
                if (!isValid(config)) {
                    config._d = null;
                }
                return config;
            }
            function configFromInput(config) {
                var input = config._i;
                if (isUndefined(input)) {
                    config._d = new Date(hooks.now());
                } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                } else if (typeof input === "string") {
                    configFromString(config);
                } else if (isArray2(input)) {
                    config._a = map3(input.slice(0), function (obj) {
                        return parseInt(obj, 10);
                    });
                    configFromArray(config);
                } else if (isObject2(input)) {
                    configFromObject(config);
                } else if (isNumber2(input)) {
                    config._d = new Date(input);
                } else {
                    hooks.createFromInputFallback(config);
                }
            }
            function createLocalOrUTC(input, format2, locale3, strict, isUTC) {
                var c2 = {};
                if (format2 === true || format2 === false) {
                    strict = format2;
                    format2 = void 0;
                }
                if (locale3 === true || locale3 === false) {
                    strict = locale3;
                    locale3 = void 0;
                }
                if (
                    (isObject2(input) && isObjectEmpty(input)) ||
                    (isArray2(input) && input.length === 0)
                ) {
                    input = void 0;
                }
                c2._isAMomentObject = true;
                c2._useUTC = c2._isUTC = isUTC;
                c2._l = locale3;
                c2._i = input;
                c2._f = format2;
                c2._strict = strict;
                return createFromConfig(c2);
            }
            function createLocal(input, format2, locale3, strict) {
                return createLocalOrUTC(input, format2, locale3, strict, false);
            }
            var prototypeMin = deprecate(
                    "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other < this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    },
                ),
                prototypeMax = deprecate(
                    "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other > this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    },
                );
            function pickBy(fn2, moments) {
                var res, i2;
                if (moments.length === 1 && isArray2(moments[0])) {
                    moments = moments[0];
                }
                if (!moments.length) {
                    return createLocal();
                }
                res = moments[0];
                for (i2 = 1; i2 < moments.length; ++i2) {
                    if (!moments[i2].isValid() || moments[i2][fn2](res)) {
                        res = moments[i2];
                    }
                }
                return res;
            }
            function min() {
                var args = [].slice.call(arguments, 0);
                return pickBy("isBefore", args);
            }
            function max() {
                var args = [].slice.call(arguments, 0);
                return pickBy("isAfter", args);
            }
            var now2 = function () {
                return Date.now ? Date.now() : +(/* @__PURE__ */ new Date());
            };
            var ordering = [
                "year",
                "quarter",
                "month",
                "week",
                "day",
                "hour",
                "minute",
                "second",
                "millisecond",
            ];
            function isDurationValid(m2) {
                var key,
                    unitHasDecimal = false,
                    i2,
                    orderLen = ordering.length;
                for (key in m2) {
                    if (
                        hasOwnProp(m2, key) &&
                        !(
                            indexOf.call(ordering, key) !== -1 &&
                            (m2[key] == null || !isNaN(m2[key]))
                        )
                    ) {
                        return false;
                    }
                }
                for (i2 = 0; i2 < orderLen; ++i2) {
                    if (m2[ordering[i2]]) {
                        if (unitHasDecimal) {
                            return false;
                        }
                        if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
                            unitHasDecimal = true;
                        }
                    }
                }
                return true;
            }
            function isValid$1() {
                return this._isValid;
            }
            function createInvalid$1() {
                return createDuration(NaN);
            }
            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                    years2 = normalizedInput.year || 0,
                    quarters = normalizedInput.quarter || 0,
                    months2 = normalizedInput.month || 0,
                    weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0,
                    days2 = normalizedInput.day || 0,
                    hours2 = normalizedInput.hour || 0,
                    minutes2 = normalizedInput.minute || 0,
                    seconds2 = normalizedInput.second || 0,
                    milliseconds2 = normalizedInput.millisecond || 0;
                this._isValid = isDurationValid(normalizedInput);
                this._milliseconds =
                    +milliseconds2 +
                    seconds2 * 1e3 + // 1000
                    minutes2 * 6e4 + // 1000 * 60
                    hours2 * 1e3 * 60 * 60;
                this._days = +days2 + weeks2 * 7;
                this._months = +months2 + quarters * 3 + years2 * 12;
                this._data = {};
                this._locale = getLocale();
                this._bubble();
            }
            function isDuration(obj) {
                return obj instanceof Duration;
            }
            function absRound(number) {
                if (number < 0) {
                    return Math.round(-1 * number) * -1;
                } else {
                    return Math.round(number);
                }
            }
            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0,
                    i2;
                for (i2 = 0; i2 < len; i2++) {
                    if (
                        (dontConvert && array1[i2] !== array2[i2]) ||
                        (!dontConvert && toInt(array1[i2]) !== toInt(array2[i2]))
                    ) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }
            function offset(token2, separator) {
                addFormatToken(token2, 0, 0, function () {
                    var offset2 = this.utcOffset(),
                        sign3 = "+";
                    if (offset2 < 0) {
                        offset2 = -offset2;
                        sign3 = "-";
                    }
                    return (
                        sign3 +
                        zeroFill(~~(offset2 / 60), 2) +
                        separator +
                        zeroFill(~~offset2 % 60, 2)
                    );
                });
            }
            offset("Z", ":");
            offset("ZZ", "");
            addRegexToken("Z", matchShortOffset);
            addRegexToken("ZZ", matchShortOffset);
            addParseToken(["Z", "ZZ"], function (input, array, config) {
                config._useUTC = true;
                config._tzm = offsetFromString(matchShortOffset, input);
            });
            var chunkOffset = /([\+\-]|\d\d)/gi;
            function offsetFromString(matcher, string) {
                var matches = (string || "").match(matcher),
                    chunk,
                    parts,
                    minutes2;
                if (matches === null) {
                    return null;
                }
                chunk = matches[matches.length - 1] || [];
                parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
                minutes2 = +(parts[1] * 60) + toInt(parts[2]);
                return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
            }
            function cloneWithOffset(input, model) {
                var res, diff2;
                if (model._isUTC) {
                    res = model.clone();
                    diff2 =
                        (isMoment(input) || isDate(input)
                            ? input.valueOf()
                            : createLocal(input).valueOf()) - res.valueOf();
                    res._d.setTime(res._d.valueOf() + diff2);
                    hooks.updateOffset(res, false);
                    return res;
                } else {
                    return createLocal(input).local();
                }
            }
            function getDateOffset(m2) {
                return -Math.round(m2._d.getTimezoneOffset());
            }
            hooks.updateOffset = function () {};
            function getSetOffset(input, keepLocalTime, keepMinutes) {
                var offset2 = this._offset || 0,
                    localAdjust;
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                if (input != null) {
                    if (typeof input === "string") {
                        input = offsetFromString(matchShortOffset, input);
                        if (input === null) {
                            return this;
                        }
                    } else if (Math.abs(input) < 16 && !keepMinutes) {
                        input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                        localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                        this.add(localAdjust, "m");
                    }
                    if (offset2 !== input) {
                        if (!keepLocalTime || this._changeInProgress) {
                            addSubtract(this, createDuration(input - offset2, "m"), 1, false);
                        } else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            hooks.updateOffset(this, true);
                            this._changeInProgress = null;
                        }
                    }
                    return this;
                } else {
                    return this._isUTC ? offset2 : getDateOffset(this);
                }
            }
            function getSetZone(input, keepLocalTime) {
                if (input != null) {
                    if (typeof input !== "string") {
                        input = -input;
                    }
                    this.utcOffset(input, keepLocalTime);
                    return this;
                } else {
                    return -this.utcOffset();
                }
            }
            function setOffsetToUTC(keepLocalTime) {
                return this.utcOffset(0, keepLocalTime);
            }
            function setOffsetToLocal(keepLocalTime) {
                if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;
                    if (keepLocalTime) {
                        this.subtract(getDateOffset(this), "m");
                    }
                }
                return this;
            }
            function setOffsetToParsedOffset() {
                if (this._tzm != null) {
                    this.utcOffset(this._tzm, false, true);
                } else if (typeof this._i === "string") {
                    var tZone = offsetFromString(matchOffset, this._i);
                    if (tZone != null) {
                        this.utcOffset(tZone);
                    } else {
                        this.utcOffset(0, true);
                    }
                }
                return this;
            }
            function hasAlignedHourOffset(input) {
                if (!this.isValid()) {
                    return false;
                }
                input = input ? createLocal(input).utcOffset() : 0;
                return (this.utcOffset() - input) % 60 === 0;
            }
            function isDaylightSavingTime() {
                return (
                    this.utcOffset() > this.clone().month(0).utcOffset() ||
                    this.utcOffset() > this.clone().month(5).utcOffset()
                );
            }
            function isDaylightSavingTimeShifted() {
                if (!isUndefined(this._isDSTShifted)) {
                    return this._isDSTShifted;
                }
                var c2 = {},
                    other;
                copyConfig(c2, this);
                c2 = prepareConfig(c2);
                if (c2._a) {
                    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
                    this._isDSTShifted =
                        this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
                } else {
                    this._isDSTShifted = false;
                }
                return this._isDSTShifted;
            }
            function isLocal() {
                return this.isValid() ? !this._isUTC : false;
            }
            function isUtcOffset() {
                return this.isValid() ? this._isUTC : false;
            }
            function isUtc() {
                return this.isValid() ? this._isUTC && this._offset === 0 : false;
            }
            var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                isoRegex =
                    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
            function createDuration(input, key) {
                var duration = input,
                    match5 = null,
                    sign3,
                    ret,
                    diffRes;
                if (isDuration(input)) {
                    duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months,
                    };
                } else if (isNumber2(input) || !isNaN(+input)) {
                    duration = {};
                    if (key) {
                        duration[key] = +input;
                    } else {
                        duration.milliseconds = +input;
                    }
                } else if ((match5 = aspNetRegex.exec(input))) {
                    sign3 = match5[1] === "-" ? -1 : 1;
                    duration = {
                        y: 0,
                        d: toInt(match5[DATE]) * sign3,
                        h: toInt(match5[HOUR]) * sign3,
                        m: toInt(match5[MINUTE]) * sign3,
                        s: toInt(match5[SECOND]) * sign3,
                        ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign3,
                        // the millisecond decimal point is included in the match
                    };
                } else if ((match5 = isoRegex.exec(input))) {
                    sign3 = match5[1] === "-" ? -1 : 1;
                    duration = {
                        y: parseIso(match5[2], sign3),
                        M: parseIso(match5[3], sign3),
                        w: parseIso(match5[4], sign3),
                        d: parseIso(match5[5], sign3),
                        h: parseIso(match5[6], sign3),
                        m: parseIso(match5[7], sign3),
                        s: parseIso(match5[8], sign3),
                    };
                } else if (duration == null) {
                    duration = {};
                } else if (
                    typeof duration === "object" &&
                    ("from" in duration || "to" in duration)
                ) {
                    diffRes = momentsDifference(
                        createLocal(duration.from),
                        createLocal(duration.to),
                    );
                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                }
                ret = new Duration(duration);
                if (isDuration(input) && hasOwnProp(input, "_locale")) {
                    ret._locale = input._locale;
                }
                if (isDuration(input) && hasOwnProp(input, "_isValid")) {
                    ret._isValid = input._isValid;
                }
                return ret;
            }
            createDuration.fn = Duration.prototype;
            createDuration.invalid = createInvalid$1;
            function parseIso(inp, sign3) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign3;
            }
            function positiveMomentsDifference(base, other) {
                var res = {};
                res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                if (base.clone().add(res.months, "M").isAfter(other)) {
                    --res.months;
                }
                res.milliseconds = +other - +base.clone().add(res.months, "M");
                return res;
            }
            function momentsDifference(base, other) {
                var res;
                if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                }
                other = cloneWithOffset(other, base);
                if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                }
                return res;
            }
            function createAdder(direction, name) {
                return function (val, period) {
                    var dur, tmp;
                    if (period !== null && !isNaN(+period)) {
                        deprecateSimple(
                            name,
                            "moment()." +
                                name +
                                "(period, number) is deprecated. Please use moment()." +
                                name +
                                "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.",
                        );
                        tmp = val;
                        val = period;
                        period = tmp;
                    }
                    dur = createDuration(val, period);
                    addSubtract(this, dur, direction);
                    return this;
                };
            }
            function addSubtract(mom, duration, isAdding, updateOffset) {
                var milliseconds2 = duration._milliseconds,
                    days2 = absRound(duration._days),
                    months2 = absRound(duration._months);
                if (!mom.isValid()) {
                    return;
                }
                updateOffset = updateOffset == null ? true : updateOffset;
                if (months2) {
                    setMonth(mom, get(mom, "Month") + months2 * isAdding);
                }
                if (days2) {
                    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
                }
                if (milliseconds2) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
                }
                if (updateOffset) {
                    hooks.updateOffset(mom, days2 || months2);
                }
            }
            var add = createAdder(1, "add"),
                subtract = createAdder(-1, "subtract");
            function isString(input) {
                return typeof input === "string" || input instanceof String;
            }
            function isMomentInput(input) {
                return (
                    isMoment(input) ||
                    isDate(input) ||
                    isString(input) ||
                    isNumber2(input) ||
                    isNumberOrStringArray(input) ||
                    isMomentInputObject(input) ||
                    input === null ||
                    input === void 0
                );
            }
            function isMomentInputObject(input) {
                var objectTest = isObject2(input) && !isObjectEmpty(input),
                    propertyTest = false,
                    properties = [
                        "years",
                        "year",
                        "y",
                        "months",
                        "month",
                        "M",
                        "days",
                        "day",
                        "d",
                        "dates",
                        "date",
                        "D",
                        "hours",
                        "hour",
                        "h",
                        "minutes",
                        "minute",
                        "m",
                        "seconds",
                        "second",
                        "s",
                        "milliseconds",
                        "millisecond",
                        "ms",
                    ],
                    i2,
                    property,
                    propertyLen = properties.length;
                for (i2 = 0; i2 < propertyLen; i2 += 1) {
                    property = properties[i2];
                    propertyTest = propertyTest || hasOwnProp(input, property);
                }
                return objectTest && propertyTest;
            }
            function isNumberOrStringArray(input) {
                var arrayTest = isArray2(input),
                    dataTypeTest = false;
                if (arrayTest) {
                    dataTypeTest =
                        input.filter(function (item) {
                            return !isNumber2(item) && isString(input);
                        }).length === 0;
                }
                return arrayTest && dataTypeTest;
            }
            function isCalendarSpec(input) {
                var objectTest = isObject2(input) && !isObjectEmpty(input),
                    propertyTest = false,
                    properties = [
                        "sameDay",
                        "nextDay",
                        "lastDay",
                        "nextWeek",
                        "lastWeek",
                        "sameElse",
                    ],
                    i2,
                    property;
                for (i2 = 0; i2 < properties.length; i2 += 1) {
                    property = properties[i2];
                    propertyTest = propertyTest || hasOwnProp(input, property);
                }
                return objectTest && propertyTest;
            }
            function getCalendarFormat(myMoment, now3) {
                var diff2 = myMoment.diff(now3, "days", true);
                return diff2 < -6
                    ? "sameElse"
                    : diff2 < -1
                      ? "lastWeek"
                      : diff2 < 0
                        ? "lastDay"
                        : diff2 < 1
                          ? "sameDay"
                          : diff2 < 2
                            ? "nextDay"
                            : diff2 < 7
                              ? "nextWeek"
                              : "sameElse";
            }
            function calendar$1(time, formats) {
                if (arguments.length === 1) {
                    if (!arguments[0]) {
                        time = void 0;
                        formats = void 0;
                    } else if (isMomentInput(arguments[0])) {
                        time = arguments[0];
                        formats = void 0;
                    } else if (isCalendarSpec(arguments[0])) {
                        formats = arguments[0];
                        time = void 0;
                    }
                }
                var now3 = time || createLocal(),
                    sod = cloneWithOffset(now3, this).startOf("day"),
                    format2 = hooks.calendarFormat(this, sod) || "sameElse",
                    output =
                        formats &&
                        (isFunction2(formats[format2])
                            ? formats[format2].call(this, now3)
                            : formats[format2]);
                return this.format(
                    output || this.localeData().calendar(format2, this, createLocal(now3)),
                );
            }
            function clone3() {
                return new Moment3(this);
            }
            function isAfter(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units) || "millisecond";
                if (units === "millisecond") {
                    return this.valueOf() > localInput.valueOf();
                } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                }
            }
            function isBefore(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units) || "millisecond";
                if (units === "millisecond") {
                    return this.valueOf() < localInput.valueOf();
                } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                }
            }
            function isBetween(from3, to3, units, inclusivity) {
                var localFrom = isMoment(from3) ? from3 : createLocal(from3),
                    localTo = isMoment(to3) ? to3 : createLocal(to3);
                if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                    return false;
                }
                inclusivity = inclusivity || "()";
                return (
                    (inclusivity[0] === "("
                        ? this.isAfter(localFrom, units)
                        : !this.isBefore(localFrom, units)) &&
                    (inclusivity[1] === ")"
                        ? this.isBefore(localTo, units)
                        : !this.isAfter(localTo, units))
                );
            }
            function isSame(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input),
                    inputMs;
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units) || "millisecond";
                if (units === "millisecond") {
                    return this.valueOf() === localInput.valueOf();
                } else {
                    inputMs = localInput.valueOf();
                    return (
                        this.clone().startOf(units).valueOf() <= inputMs &&
                        inputMs <= this.clone().endOf(units).valueOf()
                    );
                }
            }
            function isSameOrAfter(input, units) {
                return this.isSame(input, units) || this.isAfter(input, units);
            }
            function isSameOrBefore(input, units) {
                return this.isSame(input, units) || this.isBefore(input, units);
            }
            function diff(input, units, asFloat) {
                var that, zoneDelta, output;
                if (!this.isValid()) {
                    return NaN;
                }
                that = cloneWithOffset(input, this);
                if (!that.isValid()) {
                    return NaN;
                }
                zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
                units = normalizeUnits(units);
                switch (units) {
                    case "year":
                        output = monthDiff(this, that) / 12;
                        break;
                    case "month":
                        output = monthDiff(this, that);
                        break;
                    case "quarter":
                        output = monthDiff(this, that) / 3;
                        break;
                    case "second":
                        output = (this - that) / 1e3;
                        break;
                    // 1000
                    case "minute":
                        output = (this - that) / 6e4;
                        break;
                    // 1000 * 60
                    case "hour":
                        output = (this - that) / 36e5;
                        break;
                    // 1000 * 60 * 60
                    case "day":
                        output = (this - that - zoneDelta) / 864e5;
                        break;
                    // 1000 * 60 * 60 * 24, negate dst
                    case "week":
                        output = (this - that - zoneDelta) / 6048e5;
                        break;
                    // 1000 * 60 * 60 * 24 * 7, negate dst
                    default:
                        output = this - that;
                }
                return asFloat ? output : absFloor(output);
            }
            function monthDiff(a2, b2) {
                if (a2.date() < b2.date()) {
                    return -monthDiff(b2, a2);
                }
                var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()),
                    anchor = a2.clone().add(wholeMonthDiff, "months"),
                    anchor2,
                    adjust;
                if (b2 - anchor < 0) {
                    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
                    adjust = (b2 - anchor) / (anchor - anchor2);
                } else {
                    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
                    adjust = (b2 - anchor) / (anchor2 - anchor);
                }
                return -(wholeMonthDiff + adjust) || 0;
            }
            hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
            hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
            function toString() {
                return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
            }
            function toISOString(keepOffset) {
                if (!this.isValid()) {
                    return null;
                }
                var utc = keepOffset !== true,
                    m2 = utc ? this.clone().utc() : this;
                if (m2.year() < 0 || m2.year() > 9999) {
                    return formatMoment(
                        m2,
                        utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ",
                    );
                }
                if (isFunction2(Date.prototype.toISOString)) {
                    if (utc) {
                        return this.toDate().toISOString();
                    } else {
                        return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3)
                            .toISOString()
                            .replace("Z", formatMoment(m2, "Z"));
                    }
                }
                return formatMoment(
                    m2,
                    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ",
                );
            }
            function inspect() {
                if (!this.isValid()) {
                    return "moment.invalid(/* " + this._i + " */)";
                }
                var func = "moment",
                    zone = "",
                    prefix,
                    year,
                    datetime,
                    suffix;
                if (!this.isLocal()) {
                    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
                    zone = "Z";
                }
                prefix = "[" + func + '("]';
                year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
                datetime = "-MM-DD[T]HH:mm:ss.SSS";
                suffix = zone + '[")]';
                return this.format(prefix + year + datetime + suffix);
            }
            function format(inputString) {
                if (!inputString) {
                    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                }
                var output = formatMoment(this, inputString);
                return this.localeData().postformat(output);
            }
            function from2(time, withoutSuffix) {
                if (
                    this.isValid() &&
                    ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
                ) {
                    return createDuration({ to: this, from: time })
                        .locale(this.locale())
                        .humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }
            function fromNow(withoutSuffix) {
                return this.from(createLocal(), withoutSuffix);
            }
            function to2(time, withoutSuffix) {
                if (
                    this.isValid() &&
                    ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
                ) {
                    return createDuration({ from: this, to: time })
                        .locale(this.locale())
                        .humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }
            function toNow(withoutSuffix) {
                return this.to(createLocal(), withoutSuffix);
            }
            function locale2(key) {
                var newLocaleData;
                if (key === void 0) {
                    return this._locale._abbr;
                } else {
                    newLocaleData = getLocale(key);
                    if (newLocaleData != null) {
                        this._locale = newLocaleData;
                    }
                    return this;
                }
            }
            var lang = deprecate(
                "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
                function (key) {
                    if (key === void 0) {
                        return this.localeData();
                    } else {
                        return this.locale(key);
                    }
                },
            );
            function localeData() {
                return this._locale;
            }
            var MS_PER_SECOND = 1e3,
                MS_PER_MINUTE = 60 * MS_PER_SECOND,
                MS_PER_HOUR = 60 * MS_PER_MINUTE,
                MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
            function mod$1(dividend, divisor) {
                return ((dividend % divisor) + divisor) % divisor;
            }
            function localStartOfDate(y2, m2, d2) {
                if (y2 < 100 && y2 >= 0) {
                    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
                } else {
                    return new Date(y2, m2, d2).valueOf();
                }
            }
            function utcStartOfDate(y2, m2, d2) {
                if (y2 < 100 && y2 >= 0) {
                    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
                } else {
                    return Date.UTC(y2, m2, d2);
                }
            }
            function startOf(units) {
                var time, startOfDate;
                units = normalizeUnits(units);
                if (units === void 0 || units === "millisecond" || !this.isValid()) {
                    return this;
                }
                startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                switch (units) {
                    case "year":
                        time = startOfDate(this.year(), 0, 1);
                        break;
                    case "quarter":
                        time = startOfDate(this.year(), this.month() - (this.month() % 3), 1);
                        break;
                    case "month":
                        time = startOfDate(this.year(), this.month(), 1);
                        break;
                    case "week":
                        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                        break;
                    case "isoWeek":
                        time = startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1),
                        );
                        break;
                    case "day":
                    case "date":
                        time = startOfDate(this.year(), this.month(), this.date());
                        break;
                    case "hour":
                        time = this._d.valueOf();
                        time -= mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR,
                        );
                        break;
                    case "minute":
                        time = this._d.valueOf();
                        time -= mod$1(time, MS_PER_MINUTE);
                        break;
                    case "second":
                        time = this._d.valueOf();
                        time -= mod$1(time, MS_PER_SECOND);
                        break;
                }
                this._d.setTime(time);
                hooks.updateOffset(this, true);
                return this;
            }
            function endOf(units) {
                var time, startOfDate;
                units = normalizeUnits(units);
                if (units === void 0 || units === "millisecond" || !this.isValid()) {
                    return this;
                }
                startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                switch (units) {
                    case "year":
                        time = startOfDate(this.year() + 1, 0, 1) - 1;
                        break;
                    case "quarter":
                        time =
                            startOfDate(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1;
                        break;
                    case "month":
                        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                        break;
                    case "week":
                        time =
                            startOfDate(
                                this.year(),
                                this.month(),
                                this.date() - this.weekday() + 7,
                            ) - 1;
                        break;
                    case "isoWeek":
                        time =
                            startOfDate(
                                this.year(),
                                this.month(),
                                this.date() - (this.isoWeekday() - 1) + 7,
                            ) - 1;
                        break;
                    case "day":
                    case "date":
                        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                        break;
                    case "hour":
                        time = this._d.valueOf();
                        time +=
                            MS_PER_HOUR -
                            mod$1(
                                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                                MS_PER_HOUR,
                            ) -
                            1;
                        break;
                    case "minute":
                        time = this._d.valueOf();
                        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                        break;
                    case "second":
                        time = this._d.valueOf();
                        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                        break;
                }
                this._d.setTime(time);
                hooks.updateOffset(this, true);
                return this;
            }
            function valueOf() {
                return this._d.valueOf() - (this._offset || 0) * 6e4;
            }
            function unix() {
                return Math.floor(this.valueOf() / 1e3);
            }
            function toDate() {
                return new Date(this.valueOf());
            }
            function toArray() {
                var m2 = this;
                return [
                    m2.year(),
                    m2.month(),
                    m2.date(),
                    m2.hour(),
                    m2.minute(),
                    m2.second(),
                    m2.millisecond(),
                ];
            }
            function toObject() {
                var m2 = this;
                return {
                    years: m2.year(),
                    months: m2.month(),
                    date: m2.date(),
                    hours: m2.hours(),
                    minutes: m2.minutes(),
                    seconds: m2.seconds(),
                    milliseconds: m2.milliseconds(),
                };
            }
            function toJSON() {
                return this.isValid() ? this.toISOString() : null;
            }
            function isValid$2() {
                return isValid(this);
            }
            function parsingFlags() {
                return extend({}, getParsingFlags(this));
            }
            function invalidAt() {
                return getParsingFlags(this).overflow;
            }
            function creationData() {
                return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict,
                };
            }
            addFormatToken("N", 0, 0, "eraAbbr");
            addFormatToken("NN", 0, 0, "eraAbbr");
            addFormatToken("NNN", 0, 0, "eraAbbr");
            addFormatToken("NNNN", 0, 0, "eraName");
            addFormatToken("NNNNN", 0, 0, "eraNarrow");
            addFormatToken("y", ["y", 1], "yo", "eraYear");
            addFormatToken("y", ["yy", 2], 0, "eraYear");
            addFormatToken("y", ["yyy", 3], 0, "eraYear");
            addFormatToken("y", ["yyyy", 4], 0, "eraYear");
            addRegexToken("N", matchEraAbbr);
            addRegexToken("NN", matchEraAbbr);
            addRegexToken("NNN", matchEraAbbr);
            addRegexToken("NNNN", matchEraName);
            addRegexToken("NNNNN", matchEraNarrow);
            addParseToken(
                ["N", "NN", "NNN", "NNNN", "NNNNN"],
                function (input, array, config, token2) {
                    var era = config._locale.erasParse(input, token2, config._strict);
                    if (era) {
                        getParsingFlags(config).era = era;
                    } else {
                        getParsingFlags(config).invalidEra = input;
                    }
                },
            );
            addRegexToken("y", matchUnsigned);
            addRegexToken("yy", matchUnsigned);
            addRegexToken("yyy", matchUnsigned);
            addRegexToken("yyyy", matchUnsigned);
            addRegexToken("yo", matchEraYearOrdinal);
            addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
            addParseToken(["yo"], function (input, array, config, token2) {
                var match5;
                if (config._locale._eraYearOrdinalRegex) {
                    match5 = input.match(config._locale._eraYearOrdinalRegex);
                }
                if (config._locale.eraYearOrdinalParse) {
                    array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
                } else {
                    array[YEAR] = parseInt(input, 10);
                }
            });
            function localeEras(m2, format2) {
                var i2,
                    l2,
                    date,
                    eras = this._eras || getLocale("en")._eras;
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    switch (typeof eras[i2].since) {
                        case "string":
                            date = hooks(eras[i2].since).startOf("day");
                            eras[i2].since = date.valueOf();
                            break;
                    }
                    switch (typeof eras[i2].until) {
                        case "undefined":
                            eras[i2].until = Infinity;
                            break;
                        case "string":
                            date = hooks(eras[i2].until).startOf("day").valueOf();
                            eras[i2].until = date.valueOf();
                            break;
                    }
                }
                return eras;
            }
            function localeErasParse(eraName, format2, strict) {
                var i2,
                    l2,
                    eras = this.eras(),
                    name,
                    abbr,
                    narrow;
                eraName = eraName.toUpperCase();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    name = eras[i2].name.toUpperCase();
                    abbr = eras[i2].abbr.toUpperCase();
                    narrow = eras[i2].narrow.toUpperCase();
                    if (strict) {
                        switch (format2) {
                            case "N":
                            case "NN":
                            case "NNN":
                                if (abbr === eraName) {
                                    return eras[i2];
                                }
                                break;
                            case "NNNN":
                                if (name === eraName) {
                                    return eras[i2];
                                }
                                break;
                            case "NNNNN":
                                if (narrow === eraName) {
                                    return eras[i2];
                                }
                                break;
                        }
                    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                        return eras[i2];
                    }
                }
            }
            function localeErasConvertYear(era, year) {
                var dir = era.since <= era.until ? 1 : -1;
                if (year === void 0) {
                    return hooks(era.since).year();
                } else {
                    return hooks(era.since).year() + (year - era.offset) * dir;
                }
            }
            function getEraName() {
                var i2,
                    l2,
                    val,
                    eras = this.localeData().eras();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    val = this.clone().startOf("day").valueOf();
                    if (eras[i2].since <= val && val <= eras[i2].until) {
                        return eras[i2].name;
                    }
                    if (eras[i2].until <= val && val <= eras[i2].since) {
                        return eras[i2].name;
                    }
                }
                return "";
            }
            function getEraNarrow() {
                var i2,
                    l2,
                    val,
                    eras = this.localeData().eras();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    val = this.clone().startOf("day").valueOf();
                    if (eras[i2].since <= val && val <= eras[i2].until) {
                        return eras[i2].narrow;
                    }
                    if (eras[i2].until <= val && val <= eras[i2].since) {
                        return eras[i2].narrow;
                    }
                }
                return "";
            }
            function getEraAbbr() {
                var i2,
                    l2,
                    val,
                    eras = this.localeData().eras();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    val = this.clone().startOf("day").valueOf();
                    if (eras[i2].since <= val && val <= eras[i2].until) {
                        return eras[i2].abbr;
                    }
                    if (eras[i2].until <= val && val <= eras[i2].since) {
                        return eras[i2].abbr;
                    }
                }
                return "";
            }
            function getEraYear() {
                var i2,
                    l2,
                    dir,
                    val,
                    eras = this.localeData().eras();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
                    val = this.clone().startOf("day").valueOf();
                    if (
                        (eras[i2].since <= val && val <= eras[i2].until) ||
                        (eras[i2].until <= val && val <= eras[i2].since)
                    ) {
                        return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
                    }
                }
                return this.year();
            }
            function erasNameRegex(isStrict) {
                if (!hasOwnProp(this, "_erasNameRegex")) {
                    computeErasParse.call(this);
                }
                return isStrict ? this._erasNameRegex : this._erasRegex;
            }
            function erasAbbrRegex(isStrict) {
                if (!hasOwnProp(this, "_erasAbbrRegex")) {
                    computeErasParse.call(this);
                }
                return isStrict ? this._erasAbbrRegex : this._erasRegex;
            }
            function erasNarrowRegex(isStrict) {
                if (!hasOwnProp(this, "_erasNarrowRegex")) {
                    computeErasParse.call(this);
                }
                return isStrict ? this._erasNarrowRegex : this._erasRegex;
            }
            function matchEraAbbr(isStrict, locale3) {
                return locale3.erasAbbrRegex(isStrict);
            }
            function matchEraName(isStrict, locale3) {
                return locale3.erasNameRegex(isStrict);
            }
            function matchEraNarrow(isStrict, locale3) {
                return locale3.erasNarrowRegex(isStrict);
            }
            function matchEraYearOrdinal(isStrict, locale3) {
                return locale3._eraYearOrdinalRegex || matchUnsigned;
            }
            function computeErasParse() {
                var abbrPieces = [],
                    namePieces = [],
                    narrowPieces = [],
                    mixedPieces = [],
                    i2,
                    l2,
                    erasName,
                    erasAbbr,
                    erasNarrow,
                    eras = this.eras();
                for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
                    erasName = regexEscape(eras[i2].name);
                    erasAbbr = regexEscape(eras[i2].abbr);
                    erasNarrow = regexEscape(eras[i2].narrow);
                    namePieces.push(erasName);
                    abbrPieces.push(erasAbbr);
                    narrowPieces.push(erasNarrow);
                    mixedPieces.push(erasName);
                    mixedPieces.push(erasAbbr);
                    mixedPieces.push(erasNarrow);
                }
                this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
                this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
                this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
            }
            addFormatToken(0, ["gg", 2], 0, function () {
                return this.weekYear() % 100;
            });
            addFormatToken(0, ["GG", 2], 0, function () {
                return this.isoWeekYear() % 100;
            });
            function addWeekYearFormatToken(token2, getter) {
                addFormatToken(0, [token2, token2.length], 0, getter);
            }
            addWeekYearFormatToken("gggg", "weekYear");
            addWeekYearFormatToken("ggggg", "weekYear");
            addWeekYearFormatToken("GGGG", "isoWeekYear");
            addWeekYearFormatToken("GGGGG", "isoWeekYear");
            addRegexToken("G", matchSigned);
            addRegexToken("g", matchSigned);
            addRegexToken("GG", match1to2, match2);
            addRegexToken("gg", match1to2, match2);
            addRegexToken("GGGG", match1to4, match4);
            addRegexToken("gggg", match1to4, match4);
            addRegexToken("GGGGG", match1to6, match6);
            addRegexToken("ggggg", match1to6, match6);
            addWeekParseToken(
                ["gggg", "ggggg", "GGGG", "GGGGG"],
                function (input, week, config, token2) {
                    week[token2.substr(0, 2)] = toInt(input);
                },
            );
            addWeekParseToken(["gg", "GG"], function (input, week, config, token2) {
                week[token2] = hooks.parseTwoDigitYear(input);
            });
            function getSetWeekYear(input) {
                return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.week(),
                    this.weekday() + this.localeData()._week.dow,
                    this.localeData()._week.dow,
                    this.localeData()._week.doy,
                );
            }
            function getSetISOWeekYear(input) {
                return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.isoWeek(),
                    this.isoWeekday(),
                    1,
                    4,
                );
            }
            function getISOWeeksInYear() {
                return weeksInYear(this.year(), 1, 4);
            }
            function getISOWeeksInISOWeekYear() {
                return weeksInYear(this.isoWeekYear(), 1, 4);
            }
            function getWeeksInYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
            }
            function getWeeksInWeekYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
            }
            function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                var weeksTarget;
                if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                        week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                }
            }
            function setWeekAll(weekYear, week, weekday, dow, doy) {
                var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                this.year(date.getUTCFullYear());
                this.month(date.getUTCMonth());
                this.date(date.getUTCDate());
                return this;
            }
            addFormatToken("Q", 0, "Qo", "quarter");
            addRegexToken("Q", match1);
            addParseToken("Q", function (input, array) {
                array[MONTH] = (toInt(input) - 1) * 3;
            });
            function getSetQuarter(input) {
                return input == null
                    ? Math.ceil((this.month() + 1) / 3)
                    : this.month((input - 1) * 3 + (this.month() % 3));
            }
            addFormatToken("D", ["DD", 2], "Do", "date");
            addRegexToken("D", match1to2, match1to2NoLeadingZero);
            addRegexToken("DD", match1to2, match2);
            addRegexToken("Do", function (isStrict, locale3) {
                return isStrict
                    ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse
                    : locale3._dayOfMonthOrdinalParseLenient;
            });
            addParseToken(["D", "DD"], DATE);
            addParseToken("Do", function (input, array) {
                array[DATE] = toInt(input.match(match1to2)[0]);
            });
            var getSetDayOfMonth = makeGetSet("Date", true);
            addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
            addRegexToken("DDD", match1to3);
            addRegexToken("DDDD", match3);
            addParseToken(["DDD", "DDDD"], function (input, array, config) {
                config._dayOfYear = toInt(input);
            });
            function getSetDayOfYear(input) {
                var dayOfYear =
                    Math.round(
                        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5,
                    ) + 1;
                return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
            }
            addFormatToken("m", ["mm", 2], 0, "minute");
            addRegexToken("m", match1to2, match1to2HasZero);
            addRegexToken("mm", match1to2, match2);
            addParseToken(["m", "mm"], MINUTE);
            var getSetMinute = makeGetSet("Minutes", false);
            addFormatToken("s", ["ss", 2], 0, "second");
            addRegexToken("s", match1to2, match1to2HasZero);
            addRegexToken("ss", match1to2, match2);
            addParseToken(["s", "ss"], SECOND);
            var getSetSecond = makeGetSet("Seconds", false);
            addFormatToken("S", 0, 0, function () {
                return ~~(this.millisecond() / 100);
            });
            addFormatToken(0, ["SS", 2], 0, function () {
                return ~~(this.millisecond() / 10);
            });
            addFormatToken(0, ["SSS", 3], 0, "millisecond");
            addFormatToken(0, ["SSSS", 4], 0, function () {
                return this.millisecond() * 10;
            });
            addFormatToken(0, ["SSSSS", 5], 0, function () {
                return this.millisecond() * 100;
            });
            addFormatToken(0, ["SSSSSS", 6], 0, function () {
                return this.millisecond() * 1e3;
            });
            addFormatToken(0, ["SSSSSSS", 7], 0, function () {
                return this.millisecond() * 1e4;
            });
            addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
                return this.millisecond() * 1e5;
            });
            addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
                return this.millisecond() * 1e6;
            });
            addRegexToken("S", match1to3, match1);
            addRegexToken("SS", match1to3, match2);
            addRegexToken("SSS", match1to3, match3);
            var token, getSetMillisecond;
            for (token = "SSSS"; token.length <= 9; token += "S") {
                addRegexToken(token, matchUnsigned);
            }
            function parseMs(input, array) {
                array[MILLISECOND] = toInt(("0." + input) * 1e3);
            }
            for (token = "S"; token.length <= 9; token += "S") {
                addParseToken(token, parseMs);
            }
            getSetMillisecond = makeGetSet("Milliseconds", false);
            addFormatToken("z", 0, 0, "zoneAbbr");
            addFormatToken("zz", 0, 0, "zoneName");
            function getZoneAbbr() {
                return this._isUTC ? "UTC" : "";
            }
            function getZoneName() {
                return this._isUTC ? "Coordinated Universal Time" : "";
            }
            var proto = Moment3.prototype;
            proto.add = add;
            proto.calendar = calendar$1;
            proto.clone = clone3;
            proto.diff = diff;
            proto.endOf = endOf;
            proto.format = format;
            proto.from = from2;
            proto.fromNow = fromNow;
            proto.to = to2;
            proto.toNow = toNow;
            proto.get = stringGet;
            proto.invalidAt = invalidAt;
            proto.isAfter = isAfter;
            proto.isBefore = isBefore;
            proto.isBetween = isBetween;
            proto.isSame = isSame;
            proto.isSameOrAfter = isSameOrAfter;
            proto.isSameOrBefore = isSameOrBefore;
            proto.isValid = isValid$2;
            proto.lang = lang;
            proto.locale = locale2;
            proto.localeData = localeData;
            proto.max = prototypeMax;
            proto.min = prototypeMin;
            proto.parsingFlags = parsingFlags;
            proto.set = stringSet;
            proto.startOf = startOf;
            proto.subtract = subtract;
            proto.toArray = toArray;
            proto.toObject = toObject;
            proto.toDate = toDate;
            proto.toISOString = toISOString;
            proto.inspect = inspect;
            if (typeof Symbol !== "undefined" && Symbol.for != null) {
                proto[Symbol.for("nodejs.util.inspect.custom")] = function () {
                    return "Moment<" + this.format() + ">";
                };
            }
            proto.toJSON = toJSON;
            proto.toString = toString;
            proto.unix = unix;
            proto.valueOf = valueOf;
            proto.creationData = creationData;
            proto.eraName = getEraName;
            proto.eraNarrow = getEraNarrow;
            proto.eraAbbr = getEraAbbr;
            proto.eraYear = getEraYear;
            proto.year = getSetYear;
            proto.isLeapYear = getIsLeapYear;
            proto.weekYear = getSetWeekYear;
            proto.isoWeekYear = getSetISOWeekYear;
            proto.quarter = proto.quarters = getSetQuarter;
            proto.month = getSetMonth;
            proto.daysInMonth = getDaysInMonth;
            proto.week = proto.weeks = getSetWeek;
            proto.isoWeek = proto.isoWeeks = getSetISOWeek;
            proto.weeksInYear = getWeeksInYear;
            proto.weeksInWeekYear = getWeeksInWeekYear;
            proto.isoWeeksInYear = getISOWeeksInYear;
            proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
            proto.date = getSetDayOfMonth;
            proto.day = proto.days = getSetDayOfWeek;
            proto.weekday = getSetLocaleDayOfWeek;
            proto.isoWeekday = getSetISODayOfWeek;
            proto.dayOfYear = getSetDayOfYear;
            proto.hour = proto.hours = getSetHour;
            proto.minute = proto.minutes = getSetMinute;
            proto.second = proto.seconds = getSetSecond;
            proto.millisecond = proto.milliseconds = getSetMillisecond;
            proto.utcOffset = getSetOffset;
            proto.utc = setOffsetToUTC;
            proto.local = setOffsetToLocal;
            proto.parseZone = setOffsetToParsedOffset;
            proto.hasAlignedHourOffset = hasAlignedHourOffset;
            proto.isDST = isDaylightSavingTime;
            proto.isLocal = isLocal;
            proto.isUtcOffset = isUtcOffset;
            proto.isUtc = isUtc;
            proto.isUTC = isUtc;
            proto.zoneAbbr = getZoneAbbr;
            proto.zoneName = getZoneName;
            proto.dates = deprecate(
                "dates accessor is deprecated. Use date instead.",
                getSetDayOfMonth,
            );
            proto.months = deprecate(
                "months accessor is deprecated. Use month instead",
                getSetMonth,
            );
            proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
            proto.zone = deprecate(
                "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
                getSetZone,
            );
            proto.isDSTShifted = deprecate(
                "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
                isDaylightSavingTimeShifted,
            );
            function createUnix(input) {
                return createLocal(input * 1e3);
            }
            function createInZone() {
                return createLocal.apply(null, arguments).parseZone();
            }
            function preParsePostFormat(string) {
                return string;
            }
            var proto$1 = Locale.prototype;
            proto$1.calendar = calendar;
            proto$1.longDateFormat = longDateFormat;
            proto$1.invalidDate = invalidDate;
            proto$1.ordinal = ordinal;
            proto$1.preparse = preParsePostFormat;
            proto$1.postformat = preParsePostFormat;
            proto$1.relativeTime = relativeTime;
            proto$1.pastFuture = pastFuture;
            proto$1.set = set2;
            proto$1.eras = localeEras;
            proto$1.erasParse = localeErasParse;
            proto$1.erasConvertYear = localeErasConvertYear;
            proto$1.erasAbbrRegex = erasAbbrRegex;
            proto$1.erasNameRegex = erasNameRegex;
            proto$1.erasNarrowRegex = erasNarrowRegex;
            proto$1.months = localeMonths;
            proto$1.monthsShort = localeMonthsShort;
            proto$1.monthsParse = localeMonthsParse;
            proto$1.monthsRegex = monthsRegex;
            proto$1.monthsShortRegex = monthsShortRegex;
            proto$1.week = localeWeek;
            proto$1.firstDayOfYear = localeFirstDayOfYear;
            proto$1.firstDayOfWeek = localeFirstDayOfWeek;
            proto$1.weekdays = localeWeekdays;
            proto$1.weekdaysMin = localeWeekdaysMin;
            proto$1.weekdaysShort = localeWeekdaysShort;
            proto$1.weekdaysParse = localeWeekdaysParse;
            proto$1.weekdaysRegex = weekdaysRegex;
            proto$1.weekdaysShortRegex = weekdaysShortRegex;
            proto$1.weekdaysMinRegex = weekdaysMinRegex;
            proto$1.isPM = localeIsPM;
            proto$1.meridiem = localeMeridiem;
            function get$1(format2, index, field, setter) {
                var locale3 = getLocale(),
                    utc = createUTC().set(setter, index);
                return locale3[field](utc, format2);
            }
            function listMonthsImpl(format2, index, field) {
                if (isNumber2(format2)) {
                    index = format2;
                    format2 = void 0;
                }
                format2 = format2 || "";
                if (index != null) {
                    return get$1(format2, index, field, "month");
                }
                var i2,
                    out = [];
                for (i2 = 0; i2 < 12; i2++) {
                    out[i2] = get$1(format2, i2, field, "month");
                }
                return out;
            }
            function listWeekdaysImpl(localeSorted, format2, index, field) {
                if (typeof localeSorted === "boolean") {
                    if (isNumber2(format2)) {
                        index = format2;
                        format2 = void 0;
                    }
                    format2 = format2 || "";
                } else {
                    format2 = localeSorted;
                    index = format2;
                    localeSorted = false;
                    if (isNumber2(format2)) {
                        index = format2;
                        format2 = void 0;
                    }
                    format2 = format2 || "";
                }
                var locale3 = getLocale(),
                    shift = localeSorted ? locale3._week.dow : 0,
                    i2,
                    out = [];
                if (index != null) {
                    return get$1(format2, (index + shift) % 7, field, "day");
                }
                for (i2 = 0; i2 < 7; i2++) {
                    out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
                }
                return out;
            }
            function listMonths(format2, index) {
                return listMonthsImpl(format2, index, "months");
            }
            function listMonthsShort(format2, index) {
                return listMonthsImpl(format2, index, "monthsShort");
            }
            function listWeekdays(localeSorted, format2, index) {
                return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
            }
            function listWeekdaysShort(localeSorted, format2, index) {
                return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
            }
            function listWeekdaysMin(localeSorted, format2, index) {
                return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
            }
            getSetGlobalLocale("en", {
                eras: [
                    {
                        since: "0001-01-01",
                        until: Infinity,
                        offset: 1,
                        name: "Anno Domini",
                        narrow: "AD",
                        abbr: "AD",
                    },
                    {
                        since: "0000-12-31",
                        until: -Infinity,
                        offset: 1,
                        name: "Before Christ",
                        narrow: "BC",
                        abbr: "BC",
                    },
                ],
                dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (number) {
                    var b2 = number % 10,
                        output =
                            toInt((number % 100) / 10) === 1
                                ? "th"
                                : b2 === 1
                                  ? "st"
                                  : b2 === 2
                                    ? "nd"
                                    : b2 === 3
                                      ? "rd"
                                      : "th";
                    return number + output;
                },
            });
            hooks.lang = deprecate(
                "moment.lang is deprecated. Use moment.locale instead.",
                getSetGlobalLocale,
            );
            hooks.langData = deprecate(
                "moment.langData is deprecated. Use moment.localeData instead.",
                getLocale,
            );
            var mathAbs = Math.abs;
            function abs() {
                var data = this._data;
                this._milliseconds = mathAbs(this._milliseconds);
                this._days = mathAbs(this._days);
                this._months = mathAbs(this._months);
                data.milliseconds = mathAbs(data.milliseconds);
                data.seconds = mathAbs(data.seconds);
                data.minutes = mathAbs(data.minutes);
                data.hours = mathAbs(data.hours);
                data.months = mathAbs(data.months);
                data.years = mathAbs(data.years);
                return this;
            }
            function addSubtract$1(duration, input, value, direction) {
                var other = createDuration(input, value);
                duration._milliseconds += direction * other._milliseconds;
                duration._days += direction * other._days;
                duration._months += direction * other._months;
                return duration._bubble();
            }
            function add$1(input, value) {
                return addSubtract$1(this, input, value, 1);
            }
            function subtract$1(input, value) {
                return addSubtract$1(this, input, value, -1);
            }
            function absCeil(number) {
                if (number < 0) {
                    return Math.floor(number);
                } else {
                    return Math.ceil(number);
                }
            }
            function bubble() {
                var milliseconds2 = this._milliseconds,
                    days2 = this._days,
                    months2 = this._months,
                    data = this._data,
                    seconds2,
                    minutes2,
                    hours2,
                    years2,
                    monthsFromDays;
                if (
                    !(
                        (milliseconds2 >= 0 && days2 >= 0 && months2 >= 0) ||
                        (milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)
                    )
                ) {
                    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
                    days2 = 0;
                    months2 = 0;
                }
                data.milliseconds = milliseconds2 % 1e3;
                seconds2 = absFloor(milliseconds2 / 1e3);
                data.seconds = seconds2 % 60;
                minutes2 = absFloor(seconds2 / 60);
                data.minutes = minutes2 % 60;
                hours2 = absFloor(minutes2 / 60);
                data.hours = hours2 % 24;
                days2 += absFloor(hours2 / 24);
                monthsFromDays = absFloor(daysToMonths(days2));
                months2 += monthsFromDays;
                days2 -= absCeil(monthsToDays(monthsFromDays));
                years2 = absFloor(months2 / 12);
                months2 %= 12;
                data.days = days2;
                data.months = months2;
                data.years = years2;
                return this;
            }
            function daysToMonths(days2) {
                return (days2 * 4800) / 146097;
            }
            function monthsToDays(months2) {
                return (months2 * 146097) / 4800;
            }
            function as(units) {
                if (!this.isValid()) {
                    return NaN;
                }
                var days2,
                    months2,
                    milliseconds2 = this._milliseconds;
                units = normalizeUnits(units);
                if (units === "month" || units === "quarter" || units === "year") {
                    days2 = this._days + milliseconds2 / 864e5;
                    months2 = this._months + daysToMonths(days2);
                    switch (units) {
                        case "month":
                            return months2;
                        case "quarter":
                            return months2 / 3;
                        case "year":
                            return months2 / 12;
                    }
                } else {
                    days2 = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                        case "week":
                            return days2 / 7 + milliseconds2 / 6048e5;
                        case "day":
                            return days2 + milliseconds2 / 864e5;
                        case "hour":
                            return days2 * 24 + milliseconds2 / 36e5;
                        case "minute":
                            return days2 * 1440 + milliseconds2 / 6e4;
                        case "second":
                            return days2 * 86400 + milliseconds2 / 1e3;
                        // Math.floor prevents floating point math errors here
                        case "millisecond":
                            return Math.floor(days2 * 864e5) + milliseconds2;
                        default:
                            throw new Error("Unknown unit " + units);
                    }
                }
            }
            function makeAs(alias) {
                return function () {
                    return this.as(alias);
                };
            }
            var asMilliseconds = makeAs("ms"),
                asSeconds = makeAs("s"),
                asMinutes = makeAs("m"),
                asHours = makeAs("h"),
                asDays = makeAs("d"),
                asWeeks = makeAs("w"),
                asMonths = makeAs("M"),
                asQuarters = makeAs("Q"),
                asYears = makeAs("y"),
                valueOf$1 = asMilliseconds;
            function clone$1() {
                return createDuration(this);
            }
            function get$2(units) {
                units = normalizeUnits(units);
                return this.isValid() ? this[units + "s"]() : NaN;
            }
            function makeGetter(name) {
                return function () {
                    return this.isValid() ? this._data[name] : NaN;
                };
            }
            var milliseconds = makeGetter("milliseconds"),
                seconds = makeGetter("seconds"),
                minutes = makeGetter("minutes"),
                hours = makeGetter("hours"),
                days = makeGetter("days"),
                months = makeGetter("months"),
                years = makeGetter("years");
            function weeks() {
                return absFloor(this.days() / 7);
            }
            var round2 = Math.round,
                thresholds = {
                    ss: 44,
                    // a few seconds to seconds
                    s: 45,
                    // seconds to minute
                    m: 45,
                    // minutes to hour
                    h: 22,
                    // hours to day
                    d: 26,
                    // days to month/week
                    w: null,
                    // weeks to month
                    M: 11,
                    // months to year
                };
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale3) {
                return locale3.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }
            function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale3) {
                var duration = createDuration(posNegDuration).abs(),
                    seconds2 = round2(duration.as("s")),
                    minutes2 = round2(duration.as("m")),
                    hours2 = round2(duration.as("h")),
                    days2 = round2(duration.as("d")),
                    months2 = round2(duration.as("M")),
                    weeks2 = round2(duration.as("w")),
                    years2 = round2(duration.as("y")),
                    a2 =
                        (seconds2 <= thresholds2.ss && ["s", seconds2]) ||
                        (seconds2 < thresholds2.s && ["ss", seconds2]) ||
                        (minutes2 <= 1 && ["m"]) ||
                        (minutes2 < thresholds2.m && ["mm", minutes2]) ||
                        (hours2 <= 1 && ["h"]) ||
                        (hours2 < thresholds2.h && ["hh", hours2]) ||
                        (days2 <= 1 && ["d"]) ||
                        (days2 < thresholds2.d && ["dd", days2]);
                if (thresholds2.w != null) {
                    a2 = a2 || (weeks2 <= 1 && ["w"]) || (weeks2 < thresholds2.w && ["ww", weeks2]);
                }
                a2 = a2 ||
                    (months2 <= 1 && ["M"]) ||
                    (months2 < thresholds2.M && ["MM", months2]) ||
                    (years2 <= 1 && ["y"]) || ["yy", years2];
                a2[2] = withoutSuffix;
                a2[3] = +posNegDuration > 0;
                a2[4] = locale3;
                return substituteTimeAgo.apply(null, a2);
            }
            function getSetRelativeTimeRounding(roundingFunction) {
                if (roundingFunction === void 0) {
                    return round2;
                }
                if (typeof roundingFunction === "function") {
                    round2 = roundingFunction;
                    return true;
                }
                return false;
            }
            function getSetRelativeTimeThreshold(threshold, limit) {
                if (thresholds[threshold] === void 0) {
                    return false;
                }
                if (limit === void 0) {
                    return thresholds[threshold];
                }
                thresholds[threshold] = limit;
                if (threshold === "s") {
                    thresholds.ss = limit - 1;
                }
                return true;
            }
            function humanize(argWithSuffix, argThresholds) {
                if (!this.isValid()) {
                    return this.localeData().invalidDate();
                }
                var withSuffix = false,
                    th = thresholds,
                    locale3,
                    output;
                if (typeof argWithSuffix === "object") {
                    argThresholds = argWithSuffix;
                    argWithSuffix = false;
                }
                if (typeof argWithSuffix === "boolean") {
                    withSuffix = argWithSuffix;
                }
                if (typeof argThresholds === "object") {
                    th = Object.assign({}, thresholds, argThresholds);
                    if (argThresholds.s != null && argThresholds.ss == null) {
                        th.ss = argThresholds.s - 1;
                    }
                }
                locale3 = this.localeData();
                output = relativeTime$1(this, !withSuffix, th, locale3);
                if (withSuffix) {
                    output = locale3.pastFuture(+this, output);
                }
                return locale3.postformat(output);
            }
            var abs$1 = Math.abs;
            function sign2(x2) {
                return (x2 > 0) - (x2 < 0) || +x2;
            }
            function toISOString$1() {
                if (!this.isValid()) {
                    return this.localeData().invalidDate();
                }
                var seconds2 = abs$1(this._milliseconds) / 1e3,
                    days2 = abs$1(this._days),
                    months2 = abs$1(this._months),
                    minutes2,
                    hours2,
                    years2,
                    s2,
                    total = this.asSeconds(),
                    totalSign,
                    ymSign,
                    daysSign,
                    hmsSign;
                if (!total) {
                    return "P0D";
                }
                minutes2 = absFloor(seconds2 / 60);
                hours2 = absFloor(minutes2 / 60);
                seconds2 %= 60;
                minutes2 %= 60;
                years2 = absFloor(months2 / 12);
                months2 %= 12;
                s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
                totalSign = total < 0 ? "-" : "";
                ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
                daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
                hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
                return (
                    totalSign +
                    "P" +
                    (years2 ? ymSign + years2 + "Y" : "") +
                    (months2 ? ymSign + months2 + "M" : "") +
                    (days2 ? daysSign + days2 + "D" : "") +
                    (hours2 || minutes2 || seconds2 ? "T" : "") +
                    (hours2 ? hmsSign + hours2 + "H" : "") +
                    (minutes2 ? hmsSign + minutes2 + "M" : "") +
                    (seconds2 ? hmsSign + s2 + "S" : "")
                );
            }
            var proto$2 = Duration.prototype;
            proto$2.isValid = isValid$1;
            proto$2.abs = abs;
            proto$2.add = add$1;
            proto$2.subtract = subtract$1;
            proto$2.as = as;
            proto$2.asMilliseconds = asMilliseconds;
            proto$2.asSeconds = asSeconds;
            proto$2.asMinutes = asMinutes;
            proto$2.asHours = asHours;
            proto$2.asDays = asDays;
            proto$2.asWeeks = asWeeks;
            proto$2.asMonths = asMonths;
            proto$2.asQuarters = asQuarters;
            proto$2.asYears = asYears;
            proto$2.valueOf = valueOf$1;
            proto$2._bubble = bubble;
            proto$2.clone = clone$1;
            proto$2.get = get$2;
            proto$2.milliseconds = milliseconds;
            proto$2.seconds = seconds;
            proto$2.minutes = minutes;
            proto$2.hours = hours;
            proto$2.days = days;
            proto$2.weeks = weeks;
            proto$2.months = months;
            proto$2.years = years;
            proto$2.humanize = humanize;
            proto$2.toISOString = toISOString$1;
            proto$2.toString = toISOString$1;
            proto$2.toJSON = toISOString$1;
            proto$2.locale = locale2;
            proto$2.localeData = localeData;
            proto$2.toIsoString = deprecate(
                "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
                toISOString$1,
            );
            proto$2.lang = lang;
            addFormatToken("X", 0, 0, "unix");
            addFormatToken("x", 0, 0, "valueOf");
            addRegexToken("x", matchSigned);
            addRegexToken("X", matchTimestamp);
            addParseToken("X", function (input, array, config) {
                config._d = new Date(parseFloat(input) * 1e3);
            });
            addParseToken("x", function (input, array, config) {
                config._d = new Date(toInt(input));
            });
            hooks.version = "2.30.1";
            setHookCallback(createLocal);
            hooks.fn = proto;
            hooks.min = min;
            hooks.max = max;
            hooks.now = now2;
            hooks.utc = createUTC;
            hooks.unix = createUnix;
            hooks.months = listMonths;
            hooks.isDate = isDate;
            hooks.locale = getSetGlobalLocale;
            hooks.invalid = createInvalid;
            hooks.duration = createDuration;
            hooks.isMoment = isMoment;
            hooks.weekdays = listWeekdays;
            hooks.parseZone = createInZone;
            hooks.localeData = getLocale;
            hooks.isDuration = isDuration;
            hooks.monthsShort = listMonthsShort;
            hooks.weekdaysMin = listWeekdaysMin;
            hooks.defineLocale = defineLocale;
            hooks.updateLocale = updateLocale;
            hooks.locales = listLocales;
            hooks.weekdaysShort = listWeekdaysShort;
            hooks.normalizeUnits = normalizeUnits;
            hooks.relativeTimeRounding = getSetRelativeTimeRounding;
            hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
            hooks.calendarFormat = getCalendarFormat;
            hooks.prototype = proto;
            hooks.HTML5_FMT = {
                DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                // <input type="datetime-local" />
                DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                // <input type="datetime-local" step="1" />
                DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                // <input type="datetime-local" step="0.001" />
                DATE: "YYYY-MM-DD",
                // <input type="date" />
                TIME: "HH:mm",
                // <input type="time" />
                TIME_SECONDS: "HH:mm:ss",
                // <input type="time" step="1" />
                TIME_MS: "HH:mm:ss.SSS",
                // <input type="time" step="0.001" />
                WEEK: "GGGG-[W]WW",
                // <input type="week" />
                MONTH: "YYYY-MM",
                // <input type="month" />
            };
            return hooks;
        });
    },
});

// node_modules/pagerank.js/lib/index.js
var require_lib = __commonJS({
    "node_modules/pagerank.js/lib/index.js"(exports, module2) {
        "use strict";
        function forOwn(object, callback2) {
            if (typeof object === "object" && typeof callback2 === "function") {
                for (var key in object) {
                    if (object.hasOwnProperty(key) === true) {
                        if (callback2(key, object[key]) === false) {
                            break;
                        }
                    }
                }
            }
        }
        module2.exports = (function () {
            var self = {
                count: 0,
                edges: {},
                nodes: {},
            };
            self.link = function (source, target, weight) {
                if (isFinite(weight) !== true || weight === null) {
                    weight = 1;
                }
                weight = parseFloat(weight);
                if (self.nodes.hasOwnProperty(source) !== true) {
                    self.count++;
                    self.nodes[source] = {
                        weight: 0,
                        outbound: 0,
                    };
                }
                self.nodes[source].outbound += weight;
                if (self.nodes.hasOwnProperty(target) !== true) {
                    self.count++;
                    self.nodes[target] = {
                        weight: 0,
                        outbound: 0,
                    };
                }
                if (self.edges.hasOwnProperty(source) !== true) {
                    self.edges[source] = {};
                }
                if (self.edges[source].hasOwnProperty(target) !== true) {
                    self.edges[source][target] = 0;
                }
                self.edges[source][target] += weight;
            };
            self.rank = function (alpha2, epsilon, callback2) {
                var delta = 1,
                    inverse = 1 / self.count;
                forOwn(self.edges, function (source) {
                    if (self.nodes[source].outbound > 0) {
                        forOwn(self.edges[source], function (target) {
                            self.edges[source][target] /= self.nodes[source].outbound;
                        });
                    }
                });
                forOwn(self.nodes, function (key) {
                    self.nodes[key].weight = inverse;
                });
                while (delta > epsilon) {
                    var leak = 0,
                        nodes = {};
                    forOwn(self.nodes, function (key, value) {
                        nodes[key] = value.weight;
                        if (value.outbound === 0) {
                            leak += value.weight;
                        }
                        self.nodes[key].weight = 0;
                    });
                    leak *= alpha2;
                    forOwn(self.nodes, function (source) {
                        forOwn(self.edges[source], function (target, weight) {
                            self.nodes[target].weight += alpha2 * nodes[source] * weight;
                        });
                        self.nodes[source].weight += (1 - alpha2) * inverse + leak * inverse;
                    });
                    delta = 0;
                    forOwn(self.nodes, function (key, value) {
                        delta += Math.abs(value.weight - nodes[key]);
                    });
                }
                forOwn(self.nodes, function (key) {
                    return callback2(key, self.nodes[key].weight);
                });
            };
            self.reset = function () {
                self.count = 0;
                self.edges = {};
                self.nodes = {};
            };
            return self;
        })();
    },
});

// node_modules/clozecraft/dist/implementation/utils.js
var require_utils = __commonJS({
    "node_modules/clozecraft/dist/implementation/utils.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.simpleFormatter = exports.htmlFormatter = exports.escapeRegexString = void 0;
        function escapeRegexString(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        exports.escapeRegexString = escapeRegexString;
        var htmlFormatter = class {
            asking(answer, hint) {
                return `<span style='color:#2196f3'>${!hint ? "[...]" : `[${hint}]`}</span>`;
            }
            showingAnswer(answer, hint) {
                return `<span style='color:#2196f3'>${answer}</span>`;
            }
            hiding(answer, hint) {
                return `${!hint ? "..." : `[${hint}]`} `;
            }
        };
        exports.htmlFormatter = htmlFormatter;
        var simpleFormatter = class {
            asking(answer, hint) {
                return `${!hint ? "[...]" : `[${hint}]`}`;
            }
            showingAnswer(answer, hint) {
                return answer;
            }
            hiding(answer, hint) {
                return `...`;
            }
        };
        exports.simpleFormatter = simpleFormatter;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeFieldEnum.js
var require_ClozeFieldEnum = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeFieldEnum.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeFieldEnum = void 0;
        var ClozeFieldEnum;
        (function (ClozeFieldEnum2) {
            ClozeFieldEnum2["seq"] = "seq";
            ClozeFieldEnum2["answer"] = "answer";
            ClozeFieldEnum2["hint"] = "hint";
        })(ClozeFieldEnum || (exports.ClozeFieldEnum = ClozeFieldEnum = {}));
    },
});

// node_modules/clozecraft/dist/implementation/ClozeRegExp.js
var require_ClozeRegExp = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeRegExp.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeRegExp = void 0;
        var ClozeFieldEnum_1 = require_ClozeFieldEnum();
        var ClozeRegExp = class {
            constructor(pattern, clozeFieldsOrder, flags) {
                this.regex = new RegExp(pattern, flags);
                this.clozeFieldsOrder = clozeFieldsOrder;
            }
            exec(str) {
                let match2 = this.regex.exec(str);
                if (!match2) {
                    return null;
                }
                if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.answer) == -1) {
                    throw new Error("Cloze text not found in clozeFieldsOrder");
                }
                if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.hint) == -1) {
                    throw new Error("Cloze hint not found in clozeFieldsOrder");
                }
                if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.seq) == -1) {
                    match2.seq = null;
                } else {
                    match2.seq =
                        match2[
                            this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.seq) + 1
                        ];
                }
                match2.raw = match2[0];
                match2.answer =
                    match2[
                        this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.answer) + 1
                    ];
                match2.hint =
                    match2[this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.hint) + 1];
                return match2;
            }
            test(str) {
                return this.regex.test(str);
            }
        };
        exports.ClozeRegExp = ClozeRegExp;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeNote.js
var require_ClozeNote = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeNote.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeNote = void 0;
        var ClozeNote = class {
            /**
             * Creates a new ClozeNote instance.
             *
             * @param raw The raw text of the cloze note before processing.
             */
            constructor(raw, patterns) {
                this._raw = raw;
                const { clozeDeletions, numCards } = this.initParsing(raw, patterns);
                this._clozeDeletions = clozeDeletions;
                this._numCards = numCards;
            }
            get raw() {
                return this._raw;
            }
            get numCards() {
                return this._numCards;
            }
        };
        exports.ClozeNote = ClozeNote;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeNoteClassic.js
var require_ClozeNoteClassic = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeNoteClassic.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeNoteClassic = void 0;
        var ClozeNote_1 = require_ClozeNote();
        var utils_1 = require_utils();
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        var ClozeNoteClassic = class extends ClozeNote_1.ClozeNote {
            constructor(raw, patterns) {
                super(raw, patterns);
            }
            get clozeType() {
                return ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC;
            }
            initParsing(rawNote, patterns) {
                let clozeDeletions = [];
                let numCards = 0;
                patterns.forEach((pattern) => {
                    const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC);
                    let match2;
                    while ((match2 = regex.exec(rawNote))) {
                        if (!match2.seq) {
                            break;
                        }
                        let newCloze = {
                            raw: match2.raw,
                            answer: match2.answer,
                            seq: parseInt(match2.seq),
                            hint: match2.hint,
                        };
                        clozeDeletions.push(newCloze);
                        if (numCards < newCloze.seq) {
                            numCards = newCloze.seq;
                        }
                    }
                });
                return { clozeDeletions, numCards };
            }
            getCardFront(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let frontText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    if (deletion.seq !== cardIndex + 1) {
                        frontText = frontText.replace(deletion.raw, deletion.answer);
                        continue;
                    }
                    frontText = frontText.replace(
                        deletion.raw,
                        formatter.asking(deletion.answer, deletion.hint),
                    );
                }
                return frontText;
            }
            getCardBack(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let backText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    if (deletion.seq === cardIndex + 1) {
                        backText = backText.replace(
                            deletion.raw,
                            formatter.showingAnswer(deletion.answer, deletion.hint),
                        );
                    } else {
                        backText = backText.replace(deletion.raw, deletion.answer);
                    }
                }
                return backText;
            }
        };
        exports.ClozeNoteClassic = ClozeNoteClassic;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeNoteOL.js
var require_ClozeNoteOL = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeNoteOL.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeNoteOL = void 0;
        var ClozeNote_1 = require_ClozeNote();
        var utils_1 = require_utils();
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        var ClozeNoteOL = class extends ClozeNote_1.ClozeNote {
            constructor(raw, patterns) {
                super(raw, patterns);
            }
            get clozeType() {
                return ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING;
            }
            initParsing(rawNote, patterns) {
                let clozeDeletions = [];
                let numCards = 0;
                patterns.forEach((pattern) => {
                    const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING);
                    let match2;
                    while ((match2 = regex.exec(rawNote))) {
                        if (!match2.seq) {
                            break;
                        }
                        let newCloze = {
                            raw: match2.raw,
                            answer: match2.answer,
                            seq: match2.seq,
                            hint: match2.hint,
                        };
                        clozeDeletions.push(newCloze);
                        if (numCards < newCloze.seq.length) {
                            numCards = newCloze.seq.length;
                        }
                    }
                });
                return { clozeDeletions, numCards };
            }
            getCardFront(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let frontText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    let clozeAction = "s";
                    if (cardIndex < deletion.seq.length) {
                        clozeAction = deletion.seq[cardIndex];
                    }
                    switch (clozeAction) {
                        case "a":
                            frontText = frontText.replace(
                                deletion.raw,
                                formatter.asking(deletion.answer, deletion.hint),
                            );
                            break;
                        case "h":
                            frontText = frontText.replace(
                                deletion.raw,
                                formatter.hiding(deletion.answer, deletion.hint),
                            );
                            break;
                        case "s":
                            frontText = frontText.replace(deletion.raw, deletion.answer);
                            break;
                    }
                }
                return frontText;
            }
            getCardBack(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let backText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    let clozeAction = "s";
                    if (cardIndex < deletion.seq.length) {
                        clozeAction = deletion.seq[cardIndex];
                    }
                    switch (clozeAction) {
                        case "a":
                            backText = backText.replace(
                                deletion.raw,
                                formatter.showingAnswer(deletion.answer, deletion.hint),
                            );
                            break;
                        case "h":
                            backText = backText.replace(
                                deletion.raw,
                                formatter.hiding(deletion.answer, deletion.hint),
                            );
                            break;
                        case "s":
                            backText = backText.replace(deletion.raw, deletion.answer);
                            break;
                    }
                }
                return backText;
            }
        };
        exports.ClozeNoteOL = ClozeNoteOL;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeNoteSimple.js
var require_ClozeNoteSimple = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeNoteSimple.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeNoteSimple = void 0;
        var ClozeNote_1 = require_ClozeNote();
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        var utils_1 = require_utils();
        var ClozeNoteSimple = class extends ClozeNote_1.ClozeNote {
            constructor(raw, patterns) {
                super(raw, patterns);
            }
            get clozeType() {
                return ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE;
            }
            initParsing(rawNote, patterns) {
                let clozeDeletions = [];
                let numCards = 0;
                patterns.forEach((pattern) => {
                    const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE);
                    let match2;
                    while ((match2 = regex.exec(rawNote))) {
                        numCards++;
                        let newCloze = {
                            raw: match2.raw,
                            answer: match2.answer,
                            seq: numCards,
                            hint: match2.hint,
                        };
                        clozeDeletions.push(newCloze);
                    }
                });
                return { clozeDeletions, numCards };
            }
            getCardFront(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let frontText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    if (deletion.seq !== cardIndex + 1) {
                        frontText = frontText.replace(deletion.raw, deletion.answer);
                        continue;
                    }
                    frontText = frontText.replace(
                        deletion.raw,
                        formatter.asking(deletion.answer, deletion.hint),
                    );
                }
                return frontText;
            }
            getCardBack(cardIndex, formatter) {
                if (cardIndex >= this._numCards || cardIndex < 0) {
                    throw new Error(`Card ${cardIndex} does not exist`);
                }
                if (!formatter) {
                    formatter = new utils_1.simpleFormatter();
                }
                let backText = this.raw;
                for (const deletion of this._clozeDeletions) {
                    if (deletion.seq === cardIndex + 1) {
                        backText = backText.replace(
                            deletion.raw,
                            formatter.showingAnswer(deletion.answer, deletion.hint),
                        );
                    } else {
                        backText = backText.replace(deletion.raw, deletion.answer);
                    }
                }
                return backText;
            }
        };
        exports.ClozeNoteSimple = ClozeNoteSimple;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeTypeEnum.js
var require_ClozeTypeEnum = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeTypeEnum.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.NoteClassByClozeType = exports.ClozeTypesPriority = exports.ClozeTypeEnum = void 0;
        var ClozeNoteClassic_1 = require_ClozeNoteClassic();
        var ClozeNoteOL_1 = require_ClozeNoteOL();
        var ClozeNoteSimple_1 = require_ClozeNoteSimple();
        var ClozeTypeEnum;
        (function (ClozeTypeEnum2) {
            ClozeTypeEnum2["CLASSIC"] = "classic";
            ClozeTypeEnum2["OVERLAPPING"] = "overlapping";
            ClozeTypeEnum2["SIMPLE"] = "simple";
        })(ClozeTypeEnum || (exports.ClozeTypeEnum = ClozeTypeEnum = {}));
        exports.ClozeTypesPriority = [
            ClozeTypeEnum.CLASSIC,
            ClozeTypeEnum.OVERLAPPING,
            ClozeTypeEnum.SIMPLE,
            // Cloze Simple must be the last one because it is a subset of Cloze Classic and Cloze Overlapping
        ];
        exports.NoteClassByClozeType = {
            [ClozeTypeEnum.CLASSIC]: ClozeNoteClassic_1.ClozeNoteClassic,
            [ClozeTypeEnum.OVERLAPPING]: ClozeNoteOL_1.ClozeNoteOL,
            [ClozeTypeEnum.SIMPLE]: ClozeNoteSimple_1.ClozeNoteSimple,
        };
    },
});

// node_modules/clozecraft/dist/implementation/ClozePattern.js
var require_ClozePattern = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozePattern.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozePattern = void 0;
        var utils_1 = require_utils();
        var ClozeRegExp_1 = require_ClozeRegExp();
        var ClozeFieldEnum_1 = require_ClozeFieldEnum();
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        var numPatternRegex = new RegExp(
            `\\[(?:(?:\\\\\\])?[^\\]]?)+?\\d+(?:(?:\\\\\\])?[^\\]]?)+?\\]`,
        );
        var hintPatternRegex = new RegExp(
            `\\[(?:(?:\\\\\\])?[^\\]]?)+?hint(?:(?:\\\\\\])?[^\\]]?)+?\\]`,
        );
        var answerKeyword = `answer`;
        var ClozePattern = class _ClozePattern {
            constructor(raw) {
                this.clozeRegexByType = {
                    [ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC]: void 0,
                    [ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING]: void 0,
                    [ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE]: void 0,
                };
                this.generateClozeRegexByType = {
                    [ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC]: this.generateClozeClassicRegex,
                    [ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING]: this.generateClozeOLRegex,
                    [ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE]: this.generateClozeSimpleRegex,
                };
                this._raw = raw;
                let _numMatch = numPatternRegex.exec(raw);
                let _hintMatch = hintPatternRegex.exec(raw);
                if (!_numMatch) {
                    throw new Error("No cloze number pattern found");
                }
                if (!_hintMatch) {
                    throw new Error("No cloze hint pattern found");
                }
                if (raw.indexOf(answerKeyword) == -1) {
                    throw new Error(`No answer keyword (${answerKeyword}) found in the pattern.`);
                }
                this.numPattern = _numMatch;
                this.hintPattern = _hintMatch;
                this.numRegex = _ClozePattern.processPattern(_numMatch[0], (text) =>
                    text.replace(/\d+/g, "(\\d+)"),
                );
                this.seqRegex = _ClozePattern.processPattern(_numMatch[0], (text) =>
                    text.replace(/\d+/g, "([ash]+)"),
                );
                this.hintRegex = _ClozePattern.processPattern(_hintMatch[0], (text) =>
                    text.replace(/hint/g, "(.+?)"),
                );
                this.hintRegex = "(?:" + this.hintRegex + ")?";
                this._clozeFieldOrder = [
                    ClozeFieldEnum_1.ClozeFieldEnum.answer,
                    ClozeFieldEnum_1.ClozeFieldEnum.hint,
                    ClozeFieldEnum_1.ClozeFieldEnum.seq,
                ];
                let positions2 = {
                    [ClozeFieldEnum_1.ClozeFieldEnum.answer]: raw.indexOf(answerKeyword),
                    [ClozeFieldEnum_1.ClozeFieldEnum.hint]: this.hintPattern.index,
                    [ClozeFieldEnum_1.ClozeFieldEnum.seq]: this.numPattern.index,
                };
                this._clozeFieldOrder.sort((a2, b2) => positions2[a2] - positions2[b2]);
            }
            static processPattern(text, rplc) {
                let ans = text.substring(1, text.length - 1);
                ans = ans.replace(/\\\[/g, "[").replace(/\\]/g, "]");
                ans = (0, utils_1.escapeRegexString)(ans);
                ans = rplc(ans);
                return ans;
            }
            generateClozeRegexStr(first, firstReplace, second, secondReplace) {
                let begin = this._raw.slice(0, first.index);
                let middle = this._raw.slice(first.index + first[0].length, second.index);
                let ending = this._raw.slice(second.index + second[0].length, this._raw.length);
                let regexStr =
                    (0, utils_1.escapeRegexString)(begin) +
                    firstReplace +
                    (0, utils_1.escapeRegexString)(middle) +
                    secondReplace +
                    (0, utils_1.escapeRegexString)(ending);
                regexStr = regexStr.replace(answerKeyword, "(.+?)");
                return regexStr;
            }
            generateClozeSimpleRegex(pattern) {
                let regexStr;
                if (pattern.numPattern.index < pattern.hintPattern.index) {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.numPattern,
                        "",
                        pattern.hintPattern,
                        pattern.hintRegex,
                    );
                } else {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.hintPattern,
                        pattern.hintRegex,
                        pattern.numPattern,
                        "",
                    );
                }
                let clozeFieldsOrderWithoutSeq = pattern._clozeFieldOrder.filter(
                    (x2) => x2 != ClozeFieldEnum_1.ClozeFieldEnum.seq,
                );
                return new ClozeRegExp_1.ClozeRegExp(regexStr, clozeFieldsOrderWithoutSeq, "g");
            }
            generateClozeClassicRegex(pattern) {
                let regexStr;
                if (pattern.numPattern.index < pattern.hintPattern.index) {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.numPattern,
                        pattern.numRegex,
                        pattern.hintPattern,
                        pattern.hintRegex,
                    );
                } else {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.hintPattern,
                        pattern.hintRegex,
                        pattern.numPattern,
                        pattern.numRegex,
                    );
                }
                return new ClozeRegExp_1.ClozeRegExp(regexStr, pattern._clozeFieldOrder, "g");
            }
            generateClozeOLRegex(pattern) {
                let regexStr;
                if (pattern.numPattern.index < pattern.hintPattern.index) {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.numPattern,
                        pattern.seqRegex,
                        pattern.hintPattern,
                        pattern.hintRegex,
                    );
                } else {
                    regexStr = pattern.generateClozeRegexStr(
                        pattern.hintPattern,
                        pattern.hintRegex,
                        pattern.numPattern,
                        pattern.seqRegex,
                    );
                }
                return new ClozeRegExp_1.ClozeRegExp(regexStr, pattern._clozeFieldOrder, "g");
            }
            get clozeFieldsOrder() {
                return this._clozeFieldOrder;
            }
            getClozeRegex(clozeType) {
                let clozeRegex = this.clozeRegexByType[clozeType];
                if (clozeRegex != void 0) {
                    clozeRegex.regex.lastIndex = 0;
                    return clozeRegex;
                }
                clozeRegex = this.generateClozeRegexByType[clozeType](this);
                this.clozeRegexByType[clozeType] = clozeRegex;
                return clozeRegex;
            }
            hasClozeType(text, clozeType) {
                for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
                    if (this.getClozeRegex(priorityType).test(text)) {
                        return clozeType == priorityType;
                    }
                }
                return false;
            }
            getClozeTypes(text) {
                const clozeTypes = [];
                for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
                    if (this.getClozeRegex(priorityType).test(text)) {
                        clozeTypes.push(priorityType);
                    }
                }
                return clozeTypes;
            }
            getMainClozeType(text) {
                for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
                    if (this.getClozeRegex(priorityType).test(text)) {
                        return priorityType;
                    }
                }
                return null;
            }
        };
        exports.ClozePattern = ClozePattern;
    },
});

// node_modules/clozecraft/dist/implementation/ClozeCrafter.js
var require_ClozeCrafter = __commonJS({
    "node_modules/clozecraft/dist/implementation/ClozeCrafter.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeCrafter = void 0;
        var ClozePattern_1 = require_ClozePattern();
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        var ClozeCrafter3 = class {
            constructor(patterns) {
                this.patterns = patterns.map(
                    (patternStr) => new ClozePattern_1.ClozePattern(patternStr),
                );
            }
            createClozeNote(text) {
                const noteType = this.getNoteType(text);
                if (noteType === null) {
                    return null;
                }
                const selectedClass = ClozeTypeEnum_1.NoteClassByClozeType[noteType];
                const clozeNote = new selectedClass(text, this.patterns);
                return clozeNote;
            }
            getNoteType(text) {
                let noteType = null;
                for (const pattern of this.patterns) {
                    const currentType = pattern.getMainClozeType(text);
                    if (
                        currentType !== null &&
                        (noteType === null ||
                            ClozeTypeEnum_1.ClozeTypesPriority.indexOf(currentType) <
                                ClozeTypeEnum_1.ClozeTypesPriority.indexOf(noteType))
                    ) {
                        noteType = currentType;
                    }
                }
                return noteType;
            }
            isClozeNote(text) {
                return this.getNoteType(text) !== null;
            }
        };
        exports.ClozeCrafter = ClozeCrafter3;
    },
});

// node_modules/clozecraft/dist/index.js
var require_dist = __commonJS({
    "node_modules/clozecraft/dist/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ClozeTypesPriority = exports.ClozeTypeEnum = exports.ClozeCrafter = void 0;
        var ClozeCrafter_1 = require_ClozeCrafter();
        Object.defineProperty(exports, "ClozeCrafter", {
            enumerable: true,
            get: function () {
                return ClozeCrafter_1.ClozeCrafter;
            },
        });
        var ClozeTypeEnum_1 = require_ClozeTypeEnum();
        Object.defineProperty(exports, "ClozeTypeEnum", {
            enumerable: true,
            get: function () {
                return ClozeTypeEnum_1.ClozeTypeEnum;
            },
        });
        Object.defineProperty(exports, "ClozeTypesPriority", {
            enumerable: true,
            get: function () {
                return ClozeTypeEnum_1.ClozeTypesPriority;
            },
        });
    },
});

// node_modules/vhtml/dist/vhtml.js
var require_vhtml = __commonJS({
    "node_modules/vhtml/dist/vhtml.js"(exports, module2) {
        (function (global, factory) {
            typeof exports === "object" && typeof module2 !== "undefined"
                ? (module2.exports = factory())
                : typeof define === "function" && define.amd
                  ? define(factory)
                  : (global.vhtml = factory());
        })(exports, function () {
            "use strict";
            var emptyTags = [
                "area",
                "base",
                "br",
                "col",
                "command",
                "embed",
                "hr",
                "img",
                "input",
                "keygen",
                "link",
                "meta",
                "param",
                "source",
                "track",
                "wbr",
            ];
            var esc = function esc2(str) {
                return String(str).replace(/[&<>"']/g, function (s2) {
                    return "&" + map3[s2] + ";";
                });
            };
            var map3 = { "&": "amp", "<": "lt", ">": "gt", '"': "quot", "'": "apos" };
            var setInnerHTMLAttr = "dangerouslySetInnerHTML";
            var DOMAttributeNames = {
                className: "class",
                htmlFor: "for",
            };
            var sanitized = {};
            function h6(name, attrs) {
                var stack = [],
                    s2 = "";
                attrs = attrs || {};
                for (var i2 = arguments.length; i2-- > 2; ) {
                    stack.push(arguments[i2]);
                }
                if (typeof name === "function") {
                    attrs.children = stack.reverse();
                    return name(attrs);
                }
                if (name) {
                    s2 += "<" + name;
                    if (attrs)
                        for (var _i in attrs) {
                            if (
                                attrs[_i] !== false &&
                                attrs[_i] != null &&
                                _i !== setInnerHTMLAttr
                            ) {
                                s2 +=
                                    " " +
                                    (DOMAttributeNames[_i] ? DOMAttributeNames[_i] : esc(_i)) +
                                    '="' +
                                    esc(attrs[_i]) +
                                    '"';
                            }
                        }
                    s2 += ">";
                }
                if (emptyTags.indexOf(name) === -1) {
                    if (attrs[setInnerHTMLAttr]) {
                        s2 += attrs[setInnerHTMLAttr].__html;
                    } else
                        while (stack.length) {
                            var child = stack.pop();
                            if (child) {
                                if (child.pop) {
                                    for (var _i2 = child.length; _i2--; ) {
                                        stack.push(child[_i2]);
                                    }
                                } else {
                                    s2 += sanitized[child] === true ? child : esc(child);
                                }
                            }
                        }
                    s2 += name ? "</" + name + ">" : "";
                }
                sanitized[s2] = true;
                return s2;
            }
            return h6;
        });
    },
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
    default: () => SRPlugin,
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/algorithms/base/repetition-item.ts
var RepetitionItem = class {
    // scheduling
    get hasSchedule() {
        return this.scheduleInfo != null;
    }
    get isNew() {
        return !this.hasSchedule;
    }
    get isDue() {
        return this.hasSchedule && this.scheduleInfo.isDue();
    }
};

// src/algorithms/base/srs-algorithm.ts
var SrsAlgorithm = class _SrsAlgorithm {
    static getInstance() {
        if (!_SrsAlgorithm.instance) {
            throw new Error("there is no SrsAlgorithm instance.");
        }
        return _SrsAlgorithm.instance;
    }
};

// src/algorithms/osr/obsidian-vault-notelink-info-finder.ts
var ObsidianVaultNoteLinkInfoFinder = class {
    constructor(metadataCache) {
        this.metadataCache = metadataCache;
    }
    getResolvedTargetLinksForNotePath(path3) {
        return this.metadataCache.resolvedLinks[path3];
    }
};

// src/algorithms/osr/srs-algorithm-osr.ts
var import_moment2 = __toESM(require_moment());

// src/constants.ts
var SCHEDULING_INFO_REGEX =
    /^---\r?\n((?:.*\r?\n)*)sr-due: (.+)\r?\nsr-interval: (\d+)\r?\nsr-ease: (\d+)\r?\n((?:.*\r?\n)?)---/;
var YAML_FRONT_MATTER_REGEX = /^---\r?\n((?:.*\r?\n)*?)---/;
var MULTI_SCHEDULING_EXTRACTOR = /!([\d-]+),(\d+),(\d+)/gm;
var LEGACY_SCHEDULING_EXTRACTOR = /<!--SR:([\d-]+),(\d+),(\d+)-->/gm;
var OBSIDIAN_TAG_AT_STARTOFLINE_REGEX = /^#[^\s#]+/gi;
var OBSIDIAN_BLOCK_ID_ENDOFLINE_REGEX = / (\^[a-zA-Z0-9-]+)$/;
var PREFERRED_DATE_FORMAT = "YYYY-MM-DD";
var ALLOWED_DATE_FORMATS = [PREFERRED_DATE_FORMAT, "DD-MM-YYYY", "ddd MMM DD YYYY"];
var IMAGE_FORMATS = [
    "jpg",
    "jpeg",
    "gif",
    "png",
    "svg",
    "webp",
    "apng",
    "avif",
    "jfif",
    "pjpeg",
    "pjp",
    "bmp",
];
var AUDIO_FORMATS = ["mp3", "webm", "m4a", "wav", "ogg"];
var VIDEO_FORMATS = ["mp4", "mkv", "avi", "mov"];
var COLLAPSE_ICON =
    '<svg viewBox="0 0 100 100" width="8" height="8" class="svg-icon right-triangle"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>';
var TICKS_PER_DAY = 24 * 3600 * 1e3;
var SR_HTML_COMMENT_BEGIN = "<!--SR:";
var SR_HTML_COMMENT_END = "-->";
var SR_TAB_VIEW = "spaced-repetition-tab-view";

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/af.ts
var af_default = {};

// src/lang/locale/ar.ts
var ar_default = {
    // flashcard-modal.tsx
    DECKS: "\u0627\u0644\u0631\u064F\u0632\u0645\u064E\u0627\u062A",
    DUE_CARDS: "\u0628\u0637\u0627\u0642\u0627\u062A \u0645\u064F\u0633\u062A\u062D\u0642\u0629",
    NEW_CARDS: "\u0628\u0637\u0627\u0642\u0627\u062A \u062C\u062F\u064A\u062F\u0629",
    TOTAL_CARDS:
        "\u0625\u062C\u0645\u0627\u0644\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    BACK: "\u0631\u062C\u0648\u0639",
    SKIP: "Skip",
    EDIT_CARD: "\u062A\u0639\u062F\u064A\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
    RESET_CARD_PROGRESS:
        "\u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u062A\u0642\u062F\u0651\u064F\u0645\u0652 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
    HARD: "\u0635\u0639\u0628",
    GOOD: "\u062C\u064A\u062F",
    EASY: "\u0633\u0647\u0644",
    SHOW_ANSWER: "\u0623\u0638\u0647\u0650\u0631 \u0627\u0644\u0625\u062C\u0627\u0628\u0629",
    CARD_PROGRESS_RESET:
        ".\u062A\u0645\u0651\u064E\u062A \u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u062A\u0642\u062F\u0651\u064F\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
    SAVE: "\u062D\u0641\u0638",
    CANCEL: "\u0625\u0644\u063A\u0627\u0621",
    NO_INPUT:
        ".\u0644\u0645 \u064A\u062A\u0650\u0645 \u062A\u0642\u062F\u064A\u0645 \u0623\u064A \u0645\u064F\u062F\u062E\u0644\u0627\u062A",
    CURRENT_EASE_HELP_TEXT:
        ":\u0627\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u062D\u0627\u0644\u064A\u0629",
    CURRENT_INTERVAL_HELP_TEXT:
        ":\u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u0627\u0644\u062D\u0627\u0644\u064A",
    CARD_GENERATED_FROM:
        "${notePath} :\u062A\u0645 \u0625\u0646\u0634\u0627\u0624\u0647\u0627 \u0645\u0646",
    // main.ts
    OPEN_NOTE_FOR_REVIEW:
        "\u0627\u0641\u062A\u062D \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
    REVIEW_CARDS:
        "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    REVIEW_DIFFICULTY_FILE_MENU: "${difficulty} :\u0645\u0631\u0627\u062C\u0639\u0629",
    REVIEW_NOTE_DIFFICULTY_CMD:
        "${difficulty} \u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0643\u0640",
    CRAM_ALL_CARDS:
        "\u062D\u062F\u062F \u0631\u064F\u0632\u0645\u064E\u0629 \u0644\u0644\u062D\u0634\u0631",
    REVIEW_ALL_CARDS:
        "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0645\u0646 \u062C\u0645\u064A\u0639 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A",
    REVIEW_CARDS_IN_NOTE:
        "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A  \u0645\u0646 \u0647\u0630\u0647 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629",
    CRAM_CARDS_IN_NOTE:
        "\u0623\u062D\u0634\u0631 \u062C\u0645\u064A\u0639 \u0628\u0637\u0627\u0642\u0627\u062A \u0647\u0630\u0647 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629",
    VIEW_STATS: "\u0639\u0631\u0636 \u0627\u0644\u0625\u062D\u0635\u0627\u0626\u064A\u0627\u062A",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "\u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0633\u062A\u062D\u0642\u0629 ${dueFlashcardsCount},\u0645\u0644\u0627\u062D\u0638\u0627\u062A ${dueNotesCount}:\u0645\u0631\u0627\u062C\u0639\u0629",
    SYNC_TIME_TAKEN:
        "${t}ms \u0627\u0633\u062A\u063A\u0631\u0627\u0642 \u0627\u0644\u0645\u0632\u0627\u0645\u0646\u0629",
    NOTE_IN_IGNORED_FOLDER:
        ".\u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u064A\u062A\u0645 \u062D\u0641\u0638\u0647\u0627 \u0636\u0645\u0646 \u0627\u0644\u0645\u062C\u0644\u062F \u0627\u0644\u0630\u064A \u062A\u0645 \u062A\u062C\u0627\u0647\u0644\u0647 (\u062A\u062D\u0642\u0642 \u0645\u0646 \u0627\u0644\u0625\u0639\u062F\u0627\u062F\u0627\u062A)",
    PLEASE_TAG_NOTE:
        ".\u064A\u0631\u062C\u0649 \u0648\u0636\u0639 \u0648\u0633\u0645 \u0639\u0644\u0649 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0628\u0634\u0643\u0644 \u0645\u0646\u0627\u0633\u0628 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629 (\u0641\u064A \u0627\u0644\u0625\u0639\u062F\u0627\u062F\u0627\u062A)",
    RESPONSE_RECEIVED:
        ".\u0627\u0633\u062A\u064F\u0644\u0645\u062A \u0627\u0644\u0627\u0633\u062A\u062C\u0627\u0628\u0629",
    NO_DECK_EXISTS:
        "${deckName} \u0644\u0627 \u064A\u0648\u062C\u062F \u0631\u064F\u0632\u0645\u064E\u0629",
    ALL_CAUGHT_UP:
        "\u{1F606} \u0644\u0642\u062F \u062A\u0645 \u0627\u0644\u0642\u0628\u0636 \u0639\u0644\u064A\u0643\u0645 \u062C\u0645\u064A\u0639\u0627 \u0627\u0644\u0622\u0646",
    // scheduling.ts
    DAYS_STR_IVL: "\u064A\u0648\u0645/\u0623\u064A\u0627\u0645 ${interval}",
    MONTHS_STR_IVL: "\u0634\u0647\u0631/\u0623\u0634\u0647\u0631 ${interval}",
    YEARS_STR_IVL: "\u0633\u0646\u0629/\u0633\u0646\u0648\u0627\u062A ${interval}",
    DAYS_STR_IVL_MOBILE: "\u064A${interval}",
    MONTHS_STR_IVL_MOBILE: "\u0634${interval}",
    YEARS_STR_IVL_MOBILE: "\u0633${interval}",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI:
        '.<a href="${wikiUrl}">wiki</a> \u0644\u0645\u0632\u064A\u062F \u0645\u0646 \u0627\u0644\u0645\u0639\u0644\u0648\u0645\u0627\u062A \u060C \u062A\u062D\u0642\u0642 \u0645\u0646',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE:
        "\u0645\u062C\u0644\u062F\u0627\u062A \u0644\u062A\u062C\u0627\u0647\u0644\u0647\u0627",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    FLASHCARD_EASY_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u0633\u0647\u0644",
    FLASHCARD_GOOD_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u062C\u064A\u062F",
    FLASHCARD_HARD_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u0635\u0639\u0628",
    FLASHCARD_EASY_DESC:
        '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u0633\u0647\u0644',
    FLASHCARD_GOOD_DESC:
        '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u062C\u064A\u062F',
    FLASHCARD_HARD_DESC:
        '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u0635\u0639\u0628',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS:
        "\u0648\u064F\u0633\u0648\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    FLASHCARD_TAGS_DESC:
        "#2\u0623\u062F\u062E\u0644 \u0627\u0644\u0648\u064F\u0633\u0648\u0645 \u0645\u0641\u0635\u0648\u0644\u0629 \u0628\u0645\u0633\u0627\u0641\u0627\u062A \u0623\u0648 \u0623\u0633\u0637\u0631 \u062C\u062F\u064A\u062F\u0629 \u060C \u0623\u064A \u0628\u0637\u0627\u0642\u0627\u062A# \u0631\u0632\u0645\u06293# \u0631\u0632\u0645\u0629",
    CONVERT_FOLDERS_TO_DECKS:
        "\u062A\u062D\u0648\u064A\u0644 \u0627\u0644\u0645\u062C\u0644\u062F\u0627\u062A \u0625\u0644\u0649 \u0645\u0644\u0641\u0627\u062A \u0623\u0635\u0644\u064A\u0629 \u0648 \u0645\u0644\u0641\u0627\u062A \u0627\u0644\u0641\u0631\u0639\u064A\u0629\u061F",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        ".\u0647\u0630\u0627 \u0647\u0648 \u0628\u062F\u064A\u0644 \u0644\u062E\u064A\u0627\u0631 \u0648\u0633\u0648\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0623\u0639\u0644\u0627\u0647",
    INLINE_SCHEDULING_COMMENTS:
        "\u062D\u0641\u0638 \u062A\u0639\u0644\u064A\u0642 \u0627\u0644\u062C\u062F\u0648\u0644\u0629 \u0639\u0644\u0649 \u0646\u0641\u0633 \u0627\u0644\u0633\u0637\u0631 \u0645\u062B\u0644 \u0627\u0644\u0633\u0637\u0631 \u0627\u0644\u0623\u062E\u064A\u0631 \u0644\u0644\u0628\u0637\u0627\u0642\u0629 \u061F",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "\u0644\u0627 \u062A\u0643\u0633\u0631 \u062A\u0646\u0633\u064A\u0642 \u0627\u0644\u0642\u0627\u0626\u0645\u0629 HTML \u0633\u064A\u0624\u062F\u064A \u062A\u0634\u063A\u064A\u0644 \u0647\u0630\u0627 \u0625\u0644\u0649 \u062C\u0639\u0644 \u062A\u0639\u0644\u064A\u0642\u0627\u062A",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "\u0623\u062E\u0641\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0634\u0642\u064A\u0642\u0629 \u062D\u062A\u0649 \u0627\u0644\u064A\u0648\u0645 \u0627\u0644\u062A\u0627\u0644\u064A",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "cloze deletions : \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0634\u0642\u064A\u0642\u0629 \u0647\u064A \u0628\u0637\u0627\u0642\u0627\u062A \u062A\u0645 \u0625\u0646\u0634\u0627\u0624\u0647\u0627 \u0645\u0646 \u0646\u0641\u0633 \u0646\u0635 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0643\u0640",
    SHOW_CARD_CONTEXT:
        "\u0625\u0638\u0647\u0627\u0631 \u0627\u0644\u0633\u064A\u0627\u0642 \u0641\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A\u061F",
    SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT:
        "\u0646\u0633\u0628\u0629 \u0627\u0631\u062A\u0641\u0627\u0639 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\u064A\u062C\u0628 \u0636\u0628\u0637\u0647\u0627 \u0639\u0644\u0649 100 \u066A \u0639\u0644\u0649 \u0627\u0644\u0647\u0627\u062A\u0641 \u0627\u0644\u0645\u062D\u0645\u0648\u0644 \u0623\u0648 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0644\u062F\u064A\u0643 \u0635\u0648\u0631 \u0643\u0628\u064A\u0631\u0629 \u062C\u062F\u064B\u0627",
    RESET_DEFAULT:
        "\u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u0625\u0644\u0649 \u0627\u0644\u0627\u0641\u062A\u0631\u0627\u0636\u064A",
    CARD_MODAL_WIDTH_PERCENT:
        "\u0646\u0633\u0628\u0629 \u0639\u0631\u0636 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
    RANDOMIZE_CARD_ORDER:
        "\u062A\u0631\u062A\u064A\u0628 \u0628\u0637\u0627\u0642\u0629 \u0639\u0634\u0648\u0627\u0626\u064A \u0623\u062B\u0646\u0627\u0621 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629\u061F",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS:
        "\u061Fcloze \u062A\u0639\u0637\u064A\u0644 \u0628\u0637\u0627\u0642\u0627\u062A",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==highlights== to clozes",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CLOZE_PATTERNS: "Cloze Patterns",
    CLOZE_PATTERNS_DESC:
        'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR:
        "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0636\u0645\u0646\u0629",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\u0636\u0639 \u0641\u064A \u062D\u0633\u0627\u0628\u0643 \u0623\u0646\u0647 \u0628\u0639\u062F \u062A\u063A\u064A\u064A\u0631 \u0647\u0630\u0627 \u060C \u064A\u062C\u0628 \u0639\u0644\u064A\u0643 \u062A\u0639\u062F\u064A\u0644 \u0623\u064A \u0628\u0637\u0627\u0642\u0627\u062A \u0644\u062F\u064A\u0643 \u0628\u0627\u0644\u0641\u0639\u0644 \u064A\u062F\u0648\u064A\u064B\u0627",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0639\u0643\u0633\u064A\u0629 \u0627\u0644\u0645\u0636\u0645\u0646\u0629",
    MULTILINE_CARDS_SEPARATOR:
        "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0639\u0643\u0633\u064A\u0629 \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629",
    MULTILINE_CARDS_END_MARKER:
        "\u0627\u0644\u0623\u062D\u0631\u0641 \u0627\u0644\u062A\u064A \u062A\u062F\u0644 \u0639\u0644\u0649 \u0646\u0647\u0627\u064A\u0629 \u0627\u0644\u0643\u0644\u0648\u0632\u0627\u062A \u0648\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u062A\u0639\u0644\u0645 \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629 \u0627\u0644\u0623\u0633\u0637\u0631",
    NOTES: "\u0645\u0644\u0627\u062D\u0638\u0627\u062A",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP:
        "\u062A\u0645\u0643\u064A\u0646 \u062C\u0632\u0621 \u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0639\u0646\u062F \u0628\u062F\u0621 \u0627\u0644\u062A\u0634\u063A\u064A\u0644",
    TAGS_TO_REVIEW: "\u0648\u0633\u0648\u0645 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
    TAGS_TO_REVIEW_DESC:
        "#\u0623\u062F\u062E\u0644 \u0627\u0644\u0648\u0633\u0648\u0645 \u0645\u0641\u0635\u0648\u0644\u0629 \u0628\u0645\u0633\u0627\u0641\u0627\u062A \u0623\u0648 \u062E\u0637\u0648\u0637 \u062C\u062F\u064A\u062F\u0629 \u060C \u0623\u064A : \u0645\u0631\u0627\u062C\u0639\u0629# \u0648\u0633\u06452# \u0648\u0633\u06453",
    OPEN_RANDOM_NOTE:
        "\u0627\u0641\u062A\u062D \u0645\u0644\u0627\u062D\u0638\u0629 \u0639\u0634\u0648\u0627\u0626\u064A\u0629 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
    OPEN_RANDOM_NOTE_DESC:
        "(Pagerank) \u0639\u0646\u062F \u062A\u0639\u0637\u064A\u0644 \u0647\u0630\u0627 \u0627\u0644\u062E\u064A\u0627\u0631 \u060C\u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0633\u064A\u062A\u0645 \u062A\u0631\u062A\u064A\u0628\u064F\u0647\u0627 \u062D\u0633\u0628 \u0627\u0644\u0623\u0647\u0645\u064A\u0629",
    AUTO_NEXT_NOTE:
        "\u0627\u0641\u062A\u062D \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0627\u0644\u062A\u0627\u0644\u064A\u0629 \u062A\u0644\u0642\u0627\u0626\u064A\u064B\u0627 \u0628\u0639\u062F \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\u0641\u0639\u0651\u0644 \u062E\u064A\u0627\u0631\u0627\u062A \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629 \u0641\u064A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0644\u0641 (\u0645\u062B\u0627\u0644: \u0645\u0631\u0627\u062C\u0639\u0629: \u0633\u0647\u0644\u060C \u062C\u064A\u062F\u060C \u0635\u0639\u0628)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\u0625\u0630\u0627 \u0642\u0645\u062A \u0628\u062A\u0639\u0637\u064A\u0644 \u062E\u064A\u0627\u0631\u0627\u062A \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629 \u0641\u064A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0644\u0641\u060C \u064A\u0645\u0643\u0646\u0643 \u0645\u0631\u0627\u062C\u0639\u0629 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643 \u0628\u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0623\u0648\u0627\u0645\u0631 \u0627\u0644\u0625\u0636\u0627\u0641\u0629 \u0648\u0625\u0630\u0627 \u0643\u0646\u062A \u0642\u062F \u062D\u062F\u062F\u062A\u0647\u0627\u060C \u0628\u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0645\u0641\u0627\u062A\u064A\u062D \u0627\u0644\u0627\u062E\u062A\u0635\u0627\u0631 \u0627\u0644\u0645\u0631\u062A\u0628\u0637\u0629.",
    MAX_N_DAYS_REVIEW_QUEUE:
        "\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0639\u062F\u062F \u0627\u0644\u0623\u064A\u0627\u0645 \u0627\u0644\u062A\u064A \u064A\u062C\u0628 \u0639\u0631\u0636\u0647\u0627 \u0639\u0644\u0649 \u0627\u0644\u0644\u0648\u062D\u0629 \u0627\u0644\u064A\u0645\u0646\u0649",
    MIN_ONE_DAY:
        "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0639\u062F\u062F \u0627\u0644\u0623\u064A\u0627\u0645 1 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644",
    VALID_NUMBER_WARNING:
        "\u064A\u0631\u062C\u0649 \u062A\u0642\u062F\u064A\u0645 \u0631\u0642\u0645 \u0635\u0627\u0644\u062D",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0627\u0644\u0639\u0631\u0636 \u0627\u0644\u0634\u062C\u0631\u064A \u0644\u0644\u0631\u064F\u0632\u0645 \u0645\u0648\u0633\u0639 \u0628\u062D\u064A\u062B \u062A\u0637\u0647\u0631 \u0627\u0644\u0645\u0644\u0641\u0627\u062A \u0627\u0644\u0641\u0631\u0639\u064A\u0629 \u0643\u0644\u0647\u0627",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        " \u0639\u0637\u0644 \u0647\u0630\u0627 \u0627\u0644\u062E\u064A\u0627\u0631 \u0644\u0637\u064A \u0627\u0644\u0631\u064F\u0632\u0645 \u0627\u0644\u0645\u062A\u062F\u0627\u062E\u0644\u0629 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 , \u0645\u0641\u064A\u062F \u0625\u0630\u0627 \u0643\u0627\u0646 \u0644\u062F\u064A\u0643 \u0628\u0637\u0627\u0642\u0627\u062A \u062A\u0646\u062A\u0645\u064A \u0625\u0644\u0649 \u0627\u0644\u0639\u062F\u064A\u062F \u0645\u0646 \u0627\u0644\u0631\u064F\u0632\u0645 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0645\u0644\u0641",
    ALGORITHM: "\u062E\u0648\u0627\u0631\u0632\u0645\u064A\u0629",
    CHECK_ALGORITHM_WIKI:
        '<a href="${algoUrl}">algorithm details</a> :\u0644\u0645\u0632\u064A\u062F \u0645\u0646 \u0627\u0644\u0645\u0639\u0644\u0648\u0645\u0627\u062A \u062A\u062D\u0642\u0642 \u0645\u0646',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0642\u0627\u0639\u062F\u0629",
    BASE_EASE_DESC:
        "\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u062F\u0646\u0649 = 130 \u060C \u0648\u064A\u0641\u0636\u0644 \u062D\u0648\u0627\u0644\u064A 250.",
    BASE_EASE_MIN_WARNING:
        "\u064A\u062C\u0628 \u0623\u0646 \u062A\u0643\u0648\u0646 \u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0642\u0627\u0639\u062F\u0629 130 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
    LAPSE_INTERVAL_CHANGE:
        "\u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u064A\u062A\u063A\u064A\u0631 \u0639\u0646\u062F \u0645\u0631\u0627\u062C\u0639\u0629 \u0628\u0637\u0627\u0642\u0629/\u0645\u0644\u0627\u062D\u0638\u0629 \u0635\u0639\u0628\u0629",
    LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
    EASY_BONUS: "\u0645\u0643\u0627\u0641\u0623\u0629 \u0633\u0647\u0644\u0629",
    EASY_BONUS_DESC:
        "\u062A\u062A\u064A\u062D \u0644\u0643 \u0627\u0644\u0645\u0643\u0627\u0641\u0623\u0629 \u0627\u0644\u0633\u0647\u0644\u0629 \u0636\u0628\u0637 \u0627\u0644\u0641\u0631\u0642 \u0641\u064A \u0627\u0644\u0641\u0648\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A\u0629 \u0628\u064A\u0646 \u0627\u0644\u0631\u062F \u0627\u0644\u062C\u064A\u062F \u0648\u0627\u0644\u0633\u0647\u0644 \u0639\u0644\u0649 \u0628\u0637\u0627\u0642\u0629/\u0645\u0644\u0627\u062D\u0638\u0629 (\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u062F\u0646\u0649 = 100 \u066A).",
    EASY_BONUS_MIN_WARNING:
        "\u064A\u062C\u0628 \u0623\u0646 \u062A\u0643\u0648\u0646 \u0627\u0644\u0645\u0643\u0627\u0641\u0623\u0629 \u0627\u0644\u0633\u0647\u0644\u0629 100 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximum interval in days",
    MAX_INTERVAL_DESC:
        "\u064A\u062A\u064A\u062D \u0644\u0643 \u0648\u0636\u0639 \u062D\u062F \u0623\u0639\u0644\u0649  \u0644\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A (\u0627\u0641\u062A\u0631\u0627\u0636\u064A = 100 \u0639\u0627\u0645).",
    MAX_INTERVAL_MIN_WARNING:
        "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0627\u0644\u062D\u062F \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u0644\u0645\u062F\u0629 \u064A\u0648\u0645 \u0648\u0627\u062D\u062F \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
    MAX_LINK_CONTRIB:
        "\u0623\u0642\u0635\u0649 \u0645\u0633\u0627\u0647\u0645\u0629 \u0627\u0631\u062A\u0628\u0627\u0637",
    MAX_LINK_CONTRIB_DESC:
        "\u0623\u0642\u0635\u0649 \u0645\u0633\u0627\u0647\u0645\u0629 \u0644\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0645\u0631\u062C\u062D\u0629 \u0644\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0627\u0644\u0645\u0631\u062A\u0628\u0637\u0629 \u0628\u0627\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0623\u0648\u0644\u064A\u0629.",
    LOGGING: "\u062A\u0633\u062C\u064A\u0644",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\u0639\u0631\u0636 \u0645\u0639\u0644\u0648\u0645\u0627\u062A \u0627\u0644\u062A\u0635\u062D\u064A\u062D \u0639\u0644\u0649 \u0648\u062D\u062F\u0629 \u062A\u062D\u0643\u0645 \u0627\u0644\u0645\u0637\u0648\u0631",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE:
        "\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
    CLOSE: "\u0623\u063A\u0644\u0642",
    NEW: "\u062C\u062F\u064A\u062F",
    YESTERDAY: "\u0627\u0644\u0628\u0627\u0631\u062D\u0629",
    TODAY: "\u0627\u0644\u064A\u0648\u0645",
    TOMORROW: "\u0627\u0644\u063A\u062F",
    // stats-modal.tsx
    STATS_TITLE: "\u0625\u062D\u0635\u0627\u0626\u064A\u0627\u062A",
    MONTH: "\u0634\u0647\u0631",
    QUARTER: "\u0631\u0628\u0639 \u0627\u0644\u0633\u0646\u0629",
    YEAR: "\u0633\u0646\u0629",
    LIFETIME: "",
    FORECAST: "",
    FORECAST_DESC:
        "\u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0633\u062A\u062D\u0642\u0629 \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644",
    SCHEDULED: "\u0627\u0644\u0645\u0642\u0631\u0631",
    DAYS: "\u0623\u064A\u0627\u0645",
    NUMBER_OF_CARDS: "\u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    REVIEWS_PER_DAY:
        "\u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0627\u062A/\u0627\u0644\u064A\u0648\u0645 ${avg} :\u0645\u062A\u0648\u0633\u0637",
    INTERVALS: "\u0641\u0648\u0627\u0635\u0644 \u0632\u0645\u0646\u064A\u0629",
    INTERVALS_DESC:
        "\u0627\u0644\u062A\u0623\u062E\u064A\u0631 \u062D\u062A\u0649 \u064A\u062A\u0645 \u0639\u0631\u0636 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0627\u062A \u0645\u0631\u0629 \u0623\u062E\u0631\u0649",
    COUNT: "\u0639\u062F\u062F",
    INTERVALS_SUMMARY:
        "${longest} : \u0623\u0637\u0648\u0644 \u0641\u0627\u0635\u0644 \u0632\u0645\u0646\u064A ,${avg} :\u0645\u062A\u0648\u0633\u0637 \u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A",
    EASES: "\u0627\u0644\u0633\u0647\u0648\u0644\u0629",
    EASES_SUMMARY:
        "${avgEase} :\u0645\u062A\u0648\u0633\u0637 \u0627\u0644\u0633\u0647\u0648\u0644\u0629",
    EASE: "Ease",
    CARD_TYPES: "\u0623\u0646\u0648\u0627\u0639 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    CARD_TYPES_DESC:
        "\u0648\u0647\u0630\u0627 \u064A\u0634\u0645\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u062E\u0641\u064A\u0629 \u0643\u0630\u0644\u0643 \u060C \u0625\u0646 \u0648\u062C\u062F\u062A",
    CARD_TYPE_NEW: "\u062C\u062F\u064A\u062F\u0629",
    CARD_TYPE_YOUNG: "\u0635\u063A\u064A\u0631\u0629",
    CARD_TYPE_MATURE: "\u0646\u0627\u0636\u062C\u0629",
    CARD_TYPES_SUMMARY:
        " ${totalCardsCount} :\u0625\u062C\u0645\u0627\u0644\u064A \u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/bn.ts
var bn_default = {};

// src/lang/locale/cz.ts
var cz_default = {
    // flashcard-modal.tsx
    DECKS: "Bal\xED\u010Dky",
    DUE_CARDS: "Karti\u010Dky po term\xEDnu",
    NEW_CARDS: "Nov\xE9 karti\u010Dky",
    TOTAL_CARDS: "Karti\u010Dek celkem",
    BACK: "Back",
    SKIP: "Skip",
    EDIT_CARD: "Edit Card",
    RESET_CARD_PROGRESS: "Vynulovat pokrok karti\u010Dky",
    HARD: "T\u011B\u017Ek\xE9",
    GOOD: "Dobr\xE9",
    EASY: "Jednoduch\xE9",
    SHOW_ANSWER: "Uk\xE1zat odpov\u011B\u010F",
    CARD_PROGRESS_RESET: "Pokrok karti\u010Dky byl vynulov\xE1n.",
    SAVE: "Save",
    CANCEL: "Cancel",
    NO_INPUT: "No input provided.",
    CURRENT_EASE_HELP_TEXT: "Current Ease: ",
    CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
    CARD_GENERATED_FROM: "Generated from: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Otev\u0159\xEDt pozn\xE1mku k revizi",
    REVIEW_CARDS: "Pozn\xE1mek k revizi",
    REVIEW_DIFFICULTY_FILE_MENU: "Revize: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Ozna\u010Dit pozn\xE1mku jako ${difficulty}",
    REVIEW_ALL_CARDS: "Revidovat karti\u010Dky ve v\u0161ech pozn\xE1mk\xE1ch",
    CRAM_ALL_CARDS: "Select a deck to cram",
    REVIEW_CARDS_IN_NOTE: "Revidovat karti\u010Dky v t\xE9to pozn\xE1mce.",
    CRAM_CARDS_IN_NOTE: "Cram karti\u010Dky v t\xE9to pozn\xE1mce.",
    VIEW_STATS: "Uk\xE1zat statistiky",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "Revize: ${dueNotesCount} pozn\xE1mek, ${dueFlashcardsCount} karti\u010Dek po term\xEDnu",
    SYNC_TIME_TAKEN: "Synchronizace trvala ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "Pozn\xE1mka je ulo\u017Eena v ignorovan\xE9 slo\u017Ece (zkontrolujte nastaven\xED).",
    PLEASE_TAG_NOTE:
        "Pros\xEDm ozna\u010Dne pozn\xE1mku odpov\xEDdaj\xEDc\xEDm tagem pro revizi (v nastaven\xED).",
    RESPONSE_RECEIVED: "Odpov\u011B\u010F p\u0159ijata.",
    NO_DECK_EXISTS: "Neexistuje \u017E\xE1dn\xFD bal\xED\u010Dek pro ${deckName}",
    ALL_CAUGHT_UP: "V\u0161e zrevidov\xE1no",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} den/dn\xED",
    MONTHS_STR_IVL: "${interval} m\u011Bs\xEDc(\u016F)",
    YEARS_STR_IVL: "${interval} rok(\u016F)",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}r",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Ignorovan\xE9 slo\u017Eky",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Karti\u010Dky",
    FLASHCARD_EASY_LABEL: "Easy Button Text",
    FLASHCARD_GOOD_LABEL: "Good Button Text",
    FLASHCARD_HARD_LABEL: "Hard Button Text",
    FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
    FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
    FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Tag pro karti\u010Dky",
    FLASHCARD_TAGS_DESC:
        "Zadete tagy ood\u011Blen\xE9 mezerou nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad. #karti\u010Dky #bal\xED\u010Dke2 #bal\xED\u010Dek3.",
    CONVERT_FOLDERS_TO_DECKS:
        "P\u0159ev\xE9st slo\u017Eky na bal\xED\u010Dky a podbal\xED\u010Dky?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Toto je alternativa k tag\u016Fm karti\u010Dek viz nastaven\xED v\xFD\u0161e.",
    INLINE_SCHEDULING_COMMENTS:
        "Ulo\u017Eit pl\xE1novac\xED koment\xE1\u0159 na stejn\xFD \u0159\xE1dek jako posledn\xED polo\u017Eka karti\u010Dky?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Zapnut\xED t\xE9to volby zp\u016Fsob\xED, \u017Ee HTML koment\xE1\u0159e nebudou rozb\xEDjet form\xE1tov\xE1n\xED list\u016F.",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "Odlo\u017Eit p\u0159\xEDbuzn\xE9 karti\u010Dky na dal\u0161\xED den?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "P\u0159\xEDbuzn\xE9 karti\u010Dky jsou karti\u010Dky generovan\xE9 z textu stejn\xE9 pozn\xE1mky nap\u0159\xEDklad cloze smaz\xE1n\xED",
    SHOW_CARD_CONTEXT: "Uk\xE1zat kontext v karti\u010Dce?",
    SHOW_CARD_CONTEXT_DESC: "nap\u0159\xEDklad Titulek > Nadpis1 > Podnadpis > ... > Podnadpis",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "V\xFD\u0161ka karti\u010Dek v procentech",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "M\u011Blo by b\xFDt nastaveno na 100% na mobilu nebo kdy\u017E pou\u017E\xEDv\xE1te velk\xE9 obr\xE1zky",
    RESET_DEFAULT: "Resetovat v\xFDchoz\xED nastaven\xED",
    CARD_MODAL_WIDTH_PERCENT: "\u0160\xED\u0159ka karti\u010Dek v procentech",
    RANDOMIZE_CARD_ORDER:
        "N\xE1hodn\u011B zm\u011Bnit po\u0159ad\xED karti\u010Dek b\u011Bhem revize?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS: "Vypnout cloze karti\u010Dky?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "P\u0159ev\xE9st ==zv\xFDrazn\u011Bn\xED== na clozes?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "P\u0159ev\xE9st **tu\u010Dn\xFD text** na clozes?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "P\u0159ev\xE9st {{slo\u017Een\xE9 z\xE1vorky}} na clozes?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
    CLOZE_PATTERNS: "Cloze vzory",
    CLOZE_PATTERNS_DESC:
        'Zadejte cloze vzory odd\u011Blen\xE9 od\u0159\xE1dkov\xE1n\xEDm. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro inline karti\u010Dky",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Pozor. Jakmile toto zm\u011Bn\xEDte, budete muset ru\u010Dn\u011B upravit v\u0161echny existuj\xEDc\xED karti\u010Dky.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro oto\u010Den\xE9 inline karti\u010Dky",
    MULTILINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkov\xE9 karti\u010Dky",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkove oto\u010Den\xE9 karti\u010Dky",
    MULTILINE_CARDS_END_MARKER:
        "Znaky ozna\u010Duj\xEDc\xED konec clozes a v\xEDce\u0159\xE1dkov\xFDch flash karet",
    NOTES: "Pozn\xE1mky",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
    TAGS_TO_REVIEW: "Tag pro revizi",
    TAGS_TO_REVIEW_DESC:
        "Zadejte tagy odd\u011Blen\xE9 mezerami nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Otev\u0159\xEDt n\xE1hodnou pozn\xE1mku pro revizi",
    OPEN_RANDOM_NOTE_DESC:
        "Pokud toto vypnete, pozn\xE1mky budou \u0159azeny dle d\u016Fle\u017Eitosti (PageRank).",
    AUTO_NEXT_NOTE:
        "Otev\u0159\xEDt automaticky dal\u0161\xED pozn\xE1mku po dokon\u010Den\xED revize",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Povolte mo\u017Enosti revize v nab\xEDdce souboru (nap\u0159. Revize: Jednoduch\xE9, Dobr\xE9, T\u011B\u017Ek\xE9)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Pokud v nab\xEDdce souboru zak\xE1\u017Eete mo\u017Enosti revize, m\u016F\u017Eete sv\xE9 pozn\xE1mky revidovat pomoc\xED p\u0159\xEDkaz\u016F pluginu a, pokud jste je definovali, pomoc\xED p\u0159i\u0159azen\xFDch kl\xE1vesov\xFDch zkratek.",
    MAX_N_DAYS_REVIEW_QUEUE: "Maxim\xE1ln\xED po\u010Det dn\xED zobrazen\xFDch v prav\xE9m panelu",
    MIN_ONE_DAY: "Po\u010Det dn\xED mus\xED b\xFDt minim\xE1ln\u011B 1.",
    VALID_NUMBER_WARNING: "Pros\xEDm zadejte validn\xED \u010D\xEDslo.",
    UI: "P\u0159edvolby u\u017Eivatelsk\xE9ho rozhran\xED",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Stromy bal\xED\u010Dky by m\u011Bly b\xFDt zpo\u010D\xE1tku zobrazeny jako rozbalen\xE9",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Vypn\u011Bte toto, chcete-li sbalit vno\u0159en\xE9 bal\xED\u010Dky na stejn\xE9 kart\u011B. To je u\u017Eite\u010Dn\xE9, pokud m\xE1te karti\u010Dky, kter\xE9 pat\u0159\xED k mnoha bal\xED\u010Dk\u016Fm ve stejn\xE9m souboru.",
    ALGORITHM: "Algoritmus",
    CHECK_ALGORITHM_WIKI:
        'Pro v\xEDce informac\xED jd\u011Bte na <a href="${algoUrl}">popis algoritmu</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Z\xE1kladn\xED slo\u017Eitost",
    BASE_EASE_DESC: "minimum = 130, nejl\xE9pe p\u0159ibli\u017En\u011B 250.",
    BASE_EASE_MIN_WARNING: "Z\xE1kladn\xED slo\u017Eitost mus\xED b\xFDt minim\xE1ln\u011B 130.",
    LAPSE_INTERVAL_CHANGE:
        "Zm\u011Bna intervalu pokud karti\u010Dku/pozn\xE1mku ozna\u010D\xEDte jako slo\u017Eitou",
    LAPSE_INTERVAL_CHANGE_DESC: "nov\xFD_inteval = star\xFD_interval * zm\u011Bna_intevalu / 100.",
    EASY_BONUS: "Bonus pro jednoduch\xE9",
    EASY_BONUS_DESC:
        "Tento bonus umo\u017E\u0148uje nastavit rozd\xEDl intervalu mezi jednoduch\xFDmi a dobr\xFDmi karti\u010Dkami/pozn\xE1mkami (minimum = 100%).",
    EASY_BONUS_MIN_WARNING: "Bonus pro jednoduchost mus\xED b\xFDt minim\xE1ln\u011B 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximum interval in days",
    MAX_INTERVAL_DESC:
        "Umo\u017E\u0148uje nastavit horn\xED limit pro interval (defaultn\u011B = 100 let).",
    MAX_INTERVAL_MIN_WARNING: "Maxim\xE1ln\xED interval mus\xED b\xFDt alespo\u0148 1 den.",
    MAX_LINK_CONTRIB: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bv\u011Bk prolinkov\xE1n\xED",
    MAX_LINK_CONTRIB_DESC:
        "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bvek v\xE1\u017Een\xE9 slo\u017Eitosti prolinkovan\xFDch pozn\xE1mek pou\u017Eit\xFD pro ur\u010Den\xED po\u010D\xE1te\u010Dn\xED slo\u017Eitosti.",
    LOGGING: "Zaznamen\xE1v\xE1m",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Zobrazit informace pro lad\u011Bn\xED na v\xFDvoj\xE1\u0159sk\xE9 konzoli",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Fronta pozn\xE1mek k revizi",
    CLOSE: "Uzav\u0159en\xE9",
    NEW: "Nov\xE9",
    YESTERDAY: "V\u010Dera",
    TODAY: "Dnes",
    TOMORROW: "Z\xEDtra",
    // stats-modal.tsx
    STATS_TITLE: "Statistiky",
    MONTH: "M\u011Bs\xEDc",
    QUARTER: "\u010Ctvrtlet\xED",
    YEAR: "Rok",
    LIFETIME: "Celkov\u011B",
    FORECAST: "P\u0159edpov\u011B\u010F",
    FORECAST_DESC: "Celkov\xFD po\u010Det karti\u010Dek, kter\xFDm vypr\u0161\xED term\xEDn",
    SCHEDULED: "Napl\xE1nov\xE1no",
    DAYS: "Dn\xED",
    NUMBER_OF_CARDS: "Po\u010Det karti\u010Dek",
    REVIEWS_PER_DAY: "Pr\u016Fm\u011Br: ${avg} revize/den",
    INTERVALS: "Intervaly",
    INTERVALS_DESC: "Doba, za kterou bude znovu zobrazeno k revize",
    COUNT: "Po\u010Det",
    INTERVALS_SUMMARY:
        "Pr\u016Fm\u011Brn\xFD interval: ${avg}, Nejdel\u0161\xED interval: ${longest}",
    EASES: "Slo\u017Eitost",
    EASES_SUMMARY: "Pr\u016Fm\u011Brn\xE1 slo\u017Eitost: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Typy karti\u010Dek",
    CARD_TYPES_DESC: "Obsahuje i odlo\u017Een\xE9 karti\u010Dky (pokud existuj\xED)",
    CARD_TYPE_NEW: "Nov\xE1",
    CARD_TYPE_YOUNG: "Mlad\xE1",
    CARD_TYPE_MATURE: "Dosp\u011Bl\xE1",
    CARD_TYPES_SUMMARY: "Karti\u010Dek celkem: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {
    // flashcard-modal.tsx
    DECKS: "Stapel",
    DUE_CARDS: "Anstehende Karten",
    NEW_CARDS: "Neue Karten",
    TOTAL_CARDS: "Alle Karten",
    BACK: "Zur\xFCck",
    SKIP: "\xDCberspringen",
    EDIT_CARD: "Karte bearbeiten",
    RESET_CARD_PROGRESS: "Kartenfortschritt zur\xFCcksetzten",
    HARD: "Schwer",
    GOOD: "Gut",
    EASY: "Einfach",
    SHOW_ANSWER: "Zeige Antwort",
    CARD_PROGRESS_RESET: "Kartenfortschritt wurde zur\xFCckgesetzt.",
    SAVE: "Speichern",
    CANCEL: "Abbrechen",
    NO_INPUT: "Keine Eingabe erhalten.",
    CURRENT_EASE_HELP_TEXT: "Aktuelle Schwierigkeit: ",
    CURRENT_INTERVAL_HELP_TEXT: "Aktueller Intervall: ",
    CARD_GENERATED_FROM: "Erstellt von: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Notiz zur Wiederholung \xF6ffnen",
    REVIEW_CARDS: "Lernkarten wiederholen",
    REVIEW_DIFFICULTY_FILE_MENU: "Notizen wiederholen als: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Notizen wiederholen als: ${difficulty}",
    REVIEW_ALL_CARDS: "Alle Lernkarten wiederholen",
    CRAM_ALL_CARDS: "W\xE4hle ein Stapel zum pauken",
    REVIEW_CARDS_IN_NOTE: "Lernkarten in dieser Notiz wiederholen",
    CRAM_CARDS_IN_NOTE: "Lernkarten in dieser Notiz pauken.",
    VIEW_STATS: "Statistiken anzeigen",
    OPEN_REVIEW_QUEUE_VIEW: "\xD6ffne \xDCberpr\xFCfungswarteschlage in der Seitenleiste",
    STATUS_BAR:
        "Wiederholung: ${dueNotesCount} Notiz(en), ${dueFlashcardsCount} Karte(n) anstehend",
    SYNC_TIME_TAKEN: "Synchronisierung dauerte ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "Notiz befindet sich in einem ausgeschlossenen Ordner (siehe Einstellungen).",
    PLEASE_TAG_NOTE:
        "Bitte die Notiz f\xFCr Wiederholungen entsprechend taggen (siehe Einstellungen).",
    RESPONSE_RECEIVED: "Antwort erhalten.",
    NO_DECK_EXISTS: "Kein Stapel f\xFCr ${deckName} gefunden.",
    ALL_CAUGHT_UP: "Yuhu! Alles geschafft! :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} Tag(e)",
    MONTHS_STR_IVL: "${interval} Monat(e)",
    YEARS_STR_IVL: "${interval} Jahr(e)",
    DAYS_STR_IVL_MOBILE: "${interval}t",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}j",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'Weitere Informationen gibt es im <a href="${wikiUrl}">Wiki</a> (english).',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Ausgeschlossene Ordner",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Lernkarten",
    FLASHCARD_EASY_LABEL: "Einfach Knopf Text",
    FLASHCARD_GOOD_LABEL: "Gut Knopf Text",
    FLASHCARD_HARD_LABEL: "Schwer Knopf Text",
    FLASHCARD_GOOD_DESC: 'Passe die Beschriftung f\xFCr "Gut" Knopf an',
    FLASHCARD_EASY_DESC: 'Passe die Beschriftung f\xFCr "Einfach" Knopf an',
    FLASHCARD_HARD_DESC: 'Passe die Beschriftung f\xFCr "Schwer" Knopf an',
    REVIEW_BUTTON_DELAY: "Druckknopfverz\xF6gerung (ms)",
    REVIEW_BUTTON_DELAY_DESC:
        "F\xFCgt den \xDCberpr\xFCfungsschaltfl\xE4chen (\u201EEinfach\u201C, \u201EGut\u201C, \u201ESchwer\u201C, \u201EAntwort anzeigen\u201C) eine Verz\xF6gerung hinzu, bevor sie erneut gedr\xFCckt werden k\xF6nnen.",
    FLASHCARD_TAGS: "Lernkarten Tags",
    FLASHCARD_TAGS_DESC:
        "Mehrere Tags mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angeben. Bsp. #karte #stapel2 #stapel3.",
    CONVERT_FOLDERS_TO_DECKS: "Ordner in Stapel und Substapel umwandeln?",
    CONVERT_FOLDERS_TO_DECKS_DESC: 'Eine Alternative zur oberen "Lernkarten Tags" Option.',
    INLINE_SCHEDULING_COMMENTS:
        "Den Fortschritt in der gleichen Zeile wie die letzte Zeile einer Lernkartei speichern?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Wenn aktiviert, wird der HTML Kommentar die umgebende Liste nicht aufbrechen.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Verwandte Karten auf den n\xE4chsten Tag verlegen?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Verwandte Karten sind aus der gleichen Karte generiert worden (z.B. L\xFCckentextkarten oder beidseitige Karten).",
    SHOW_CARD_CONTEXT: "Kontext in den Karten anzeigen?",
    SHOW_CARD_CONTEXT_DESC: "Bsp. Titel > \xDCberschrift 1 > Sektion > ... > Untersektion",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "H\xF6he der Lernkartei in Prozent",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Auf kleinen Bildschirmen (z.B. Smartphones) oder bei sehr grossen Bildern sollte dieser Wert auf 100% gesetzt werden.",
    RESET_DEFAULT: "Standardeinstellung wiederherstellen",
    CARD_MODAL_WIDTH_PERCENT: "Breite einer Lernkarte in Prozent",
    RANDOMIZE_CARD_ORDER: "W\xE4hrend der Wiederhoung die Reihenfolge zuf\xE4llig mischen?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "Reihenfolge der Karten innerhalb eines Stapels w\xE4hrend der Wiederholung",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "Sequentielle Reihenfolge innerhalb eines Stapels (Alle neuen Karten zuerst)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "Sequentielle Reihenfolge innerhalb eines Stapels (Alle f\xE4lligen Karten zuerst)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM:
        "Zuf\xE4llige Reihenfolge innerhalb eines Stapels (Alle neuen Karten zuerst)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "Zuf\xE4llige Reihenfolge innerhalb eines Stapels (Alle f\xE4lligen Karten zuerst)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Zuf\xE4llige Karte von zuf\xE4lligem Stapel",
    REVIEW_DECK_ORDER: "Reihenfolge der Stapel w\xE4hrend der Wiederholung",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentielle Reihenfolge (sobald alle Karten im vorherigen Stapel wiederholt wurden)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Zuf\xE4llige Reihenfolge (sobald alle Karten im vorherigen Stapel wiederholt wurden)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Zuf\xE4llige Karte von zuf\xE4lligem Stapel",
    DISABLE_CLOZE_CARDS: "L\xFCckentextkarten deaktivieren?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "==Hervorgehobenen== Text in L\xFCckentextkarten umwandeln?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
    CONVERT_BOLD_TEXT_TO_CLOZES: "**Fettgedruckten** Text in L\xFCckentextkarten umwandeln?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "{{Geschweifte Klammern}} Text in L\xFCckentextkarten umwandeln?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
    CLOZE_PATTERNS: "L\xFCckentextmuster",
    CLOZE_PATTERNS_DESC:
        'Geben Sie L\xFCckentextmuster durch Zeilenumbr\xFCche getrennt ein. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige Lernkarten",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Wenn diese Einstellung ge\xE4ndert wird, dann m\xFCssen die entsprechenden Lernkarten manuell angepasst werden.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige beidseitige Lernkarten",
    MULTILINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige Lernkarten",
    MULTILINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige beidseitige Lernkarten",
    MULTILINE_CARDS_END_MARKER:
        "Zeichen, die das Ende von L\xFCckentexten und mehrzeiligen Flashcards kennzeichnen",
    NOTES: "Notizen",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "\xD6ffne \xDCberpr\xFCfungswarteschlage beim start",
    TAGS_TO_REVIEW: "Zu wiederholende Tags",
    TAGS_TO_REVIEW_DESC:
        "Mehrere Tags k\xF6nnen mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angegeben werden. Bsp. #karte #tag1 #tag2.",
    OPEN_RANDOM_NOTE: "Zuf\xE4llige Karten wiederholen",
    OPEN_RANDOM_NOTE_DESC:
        "Wenn dies deaktiviert wird, dann werden die Notizen nach Wichtigkeit wiederholt (PageRank).",
    AUTO_NEXT_NOTE: "Nach einer Wiederholung automatisch die n\xE4chste Karte \xF6ffnen",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Aktiviere die \xDCberpr\xFCfungsoptionen im Dateimen\xFC (z. B. Notizen wiederholen als: Einfach, Gut, Schwer)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Wenn du die \xDCberpr\xFCfungsoptionen im Dateimen\xFC deaktivierst, kannst du deine Notizen mit den Plugin-Befehlen und, falls definiert, den zugeh\xF6rigen Tastenkombinationen \xFCberpr\xFCfen.",
    MAX_N_DAYS_REVIEW_QUEUE:
        "Maximale Anzahl anstehender Notizen, die im rechten Fensterbereich angezeigt werden",
    MIN_ONE_DAY: "Anzahl der Tage muss mindestens 1 sein.",
    VALID_NUMBER_WARNING: "Bitte eine g\xFCltige Zahl eingeben.",
    UI: "User Interface",
    OPEN_IN_TAB: "\xD6ffne im neuen Tab",
    OPEN_IN_TAB_DESC: "Schalte dies aus, um die Notizen in einem Modalfenster zu \xF6ffnen",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Stapelverzeichnis soll beim \xF6ffnen erweitert angezeigt werden",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Deaktivieren Sie dies, um verschachtelte Stapel in derselben Karte zu reduzieren. N\xFCtzlich, wenn Sie Karten haben, die zu vielen Stapeln in derselben Datei geh\xF6ren.",
    ALGORITHM: "Algorithmus",
    CHECK_ALGORITHM_WIKI:
        'Weiterf\xFChrende Informationen: <a href="${algoUrl}">Implementierung des Algorithmus</a> (english).',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Basis der Schwierigkeit",
    BASE_EASE_DESC: "Minimum ist 130. Empfohlen wird ca. 250.",
    BASE_EASE_MIN_WARNING: "Basis der Schwierigkeit muss mindestens 130 sein.",
    LAPSE_INTERVAL_CHANGE:
        "Anpassungsfaktor des Intervalls wenn eine Notiz / Karte 'Schwer' abgeschlossen wird",
    LAPSE_INTERVAL_CHANGE_DESC: "neuesIntervall = altesIntervall * anpassungsfaktor / 100.",
    EASY_BONUS: "Einfachheit-Bonus",
    EASY_BONUS_DESC:
        "Der Einfachheit-Bonus gibt an um welchen Faktor (in Prozent) das Intervall l\xE4nger sein soll, wenn eine Notiz / Karte 'Einfach' statt 'Gut' abgeschlossen wird. Minimum ist 100%.",
    EASY_BONUS_MIN_WARNING: "Der Einfachheit-Bonus muss mindestens 100 sein.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximale Intervall in Tagen",
    MAX_INTERVAL_DESC:
        "Das maximale Intervall (in Tagen) f\xFCr Wiederholungen. Standard sind 100 Jahre.",
    MAX_INTERVAL_MIN_WARNING: "Das maximale Interall muss mindestens ein Tag sein.",
    MAX_LINK_CONTRIB: "Maximaler Einfluss von Links",
    MAX_LINK_CONTRIB_DESC:
        "Maximaler Einfluss der Einfachheiten verlinkter Notizen zur gewichteten initialen Einfachheit einer neuen Lernkarte.",
    LOGGING: "Protokollierung",
    DISPLAY_SCHEDULING_DEBUG_INFO: "Informationen zum Debugging in der Entwicklerkonsole anzeigen",
    DISPLAY_PARSER_DEBUG_INFO:
        "Informationen zum parser Debugging in der Entwicklerkonsole anzeigen",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Anstehende Notizen zur Wiederholung",
    CLOSE: "Schliessen",
    NEW: "Neu",
    YESTERDAY: "Gestern",
    TODAY: "Heute",
    TOMORROW: "Morgen",
    // stats-modal.tsx
    STATS_TITLE: "Statistiken",
    MONTH: "Monat",
    QUARTER: "Quartal",
    YEAR: "Jahr",
    LIFETIME: "Lebenslang",
    FORECAST: "Prognose",
    FORECAST_DESC: "Anzahl der k\xFCnftig anstehenden Karten",
    SCHEDULED: "Anstehend",
    DAYS: "Tage",
    NUMBER_OF_CARDS: "Anzahl der Karten",
    REVIEWS_PER_DAY: "Durchschnitt: ${avg} Wiederholungen/Tag",
    INTERVALS: "Intervalle",
    INTERVALS_DESC: "Intervalle bis Wiederholungen anstehen",
    COUNT: "Anzahl",
    INTERVALS_SUMMARY: "Durchschnittliches Intervall: ${avg}, L\xE4ngstes Intervall: ${longest}",
    EASES: "Schwierigkeit",
    EASES_SUMMARY: "Durchschnittliche Schwierigkeit: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Kategorisierung",
    CARD_TYPES_DESC: "Verlegte Karten eingeschlossen",
    CARD_TYPE_NEW: "Neu",
    CARD_TYPE_YOUNG: "Jung",
    CARD_TYPE_MATURE: "Ausgereift",
    CARD_TYPES_SUMMARY: "Insgesamt ${totalCardsCount} Karten",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/en.ts
var en_default = {
    // flashcard-modal.tsx
    DECKS: "Decks",
    DUE_CARDS: "Due Cards",
    NEW_CARDS: "New Cards",
    TOTAL_CARDS: "Total Cards",
    BACK: "Back",
    SKIP: "Skip",
    EDIT_CARD: "Edit Card",
    RESET_CARD_PROGRESS: "Reset card's progress",
    HARD: "Hard",
    GOOD: "Good",
    EASY: "Easy",
    SHOW_ANSWER: "Show Answer",
    CARD_PROGRESS_RESET: "Card's progress has been reset.",
    SAVE: "Save",
    CANCEL: "Cancel",
    NO_INPUT: "No input provided.",
    CURRENT_EASE_HELP_TEXT: "Current Ease: ",
    CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
    CARD_GENERATED_FROM: "Generated from: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Open a note for review",
    REVIEW_CARDS: "Review flashcards",
    REVIEW_DIFFICULTY_FILE_MENU: "Review: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Review note as ${difficulty}",
    CRAM_ALL_CARDS: "Select a deck to cram",
    REVIEW_ALL_CARDS: "Review flashcards from all notes",
    REVIEW_CARDS_IN_NOTE: "Review flashcards in this note",
    CRAM_CARDS_IN_NOTE: "Cram flashcards in this note",
    VIEW_STATS: "View statistics",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR: "Review: ${dueNotesCount} note(s), ${dueFlashcardsCount} card(s) due",
    SYNC_TIME_TAKEN: "Sync took ${t}ms",
    NOTE_IN_IGNORED_FOLDER: "Note is saved under ignored folder (check settings).",
    PLEASE_TAG_NOTE: "Please tag the note appropriately for reviewing (in settings).",
    RESPONSE_RECEIVED: "Response received.",
    NO_DECK_EXISTS: "No deck exists for ${deckName}",
    ALL_CAUGHT_UP: "You're all caught up now :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} day(s)",
    MONTHS_STR_IVL: "${interval} month(s)",
    YEARS_STR_IVL: "${interval} year(s)",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}y",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'For more information, check the <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Folders to ignore",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Flashcards",
    FLASHCARD_EASY_LABEL: "Easy Button Text",
    FLASHCARD_GOOD_LABEL: "Good Button Text",
    FLASHCARD_HARD_LABEL: "Hard Button Text",
    FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
    FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
    FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Flashcard tags",
    FLASHCARD_TAGS_DESC:
        "Enter tags separated by spaces or newlines i.e. #flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS: "Convert folders to decks and subdecks",
    CONVERT_FOLDERS_TO_DECKS_DESC: "This is an alternative to the Flashcard tags option above.",
    INLINE_SCHEDULING_COMMENTS:
        "Save scheduling comment on the same line as the flashcard's last line?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Turning this on will make the HTML comments not break list formatting.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Bury sibling cards until the next day",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Siblings are cards generated from the same card text i.e. cloze deletions",
    SHOW_CARD_CONTEXT: "Show context in cards",
    SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Flashcard Height Percentage",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Should be set to 100% on mobile or if you have very large images",
    RESET_DEFAULT: "Reset to default",
    CARD_MODAL_WIDTH_PERCENT: "Flashcard Width Percentage",
    RANDOMIZE_CARD_ORDER: "Randomize card order during review?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS: "Disable cloze cards?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==highlights== to clozes",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
    CLOZE_PATTERNS: "Cloze Patterns",
    CLOZE_PATTERNS_DESC:
        'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Separator for inline flashcards",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Note that after changing this you have to manually edit any flashcards you already have.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Separator for inline reversed flashcards",
    MULTILINE_CARDS_SEPARATOR: "Separator for multiline flashcards",
    MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator for multiline reversed flashcards",
    MULTILINE_CARDS_END_MARKER: "Characters denoting the end of clozes and multiline flashcards",
    NOTES: "Notes",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
    TAGS_TO_REVIEW: "Tags to review",
    TAGS_TO_REVIEW_DESC: "Enter tags separated by spaces or newlines i.e. #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Open a random note for review",
    OPEN_RANDOM_NOTE_DESC: "When you turn this off, notes are ordered by importance (PageRank).",
    AUTO_NEXT_NOTE: "Open next note automatically after a review",
    MAX_N_DAYS_REVIEW_QUEUE: "Maximum number of days to display on note review panel",
    MIN_ONE_DAY: "The number of days must be at least 1.",
    VALID_NUMBER_WARNING: "Please provide a valid number.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deck trees should be initially displayed as expanded",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Turn this off to collapse nested decks in the same card. Useful if you have cards which belong to many decks in the same file.",
    ALGORITHM: "Algorithm",
    CHECK_ALGORITHM_WIKI:
        'For more information, check the <a href="${algoUrl}">algorithm details</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Base ease",
    BASE_EASE_DESC: "minimum = 130, preferrably approximately 250.",
    BASE_EASE_MIN_WARNING: "The base ease must be at least 130.",
    LAPSE_INTERVAL_CHANGE: "Interval change when you review a flashcard/note as hard",
    LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
    EASY_BONUS: "Easy Bonus",
    EASY_BONUS_DESC:
        "The easy bonus allows you to set the difference in intervals between answering Good and Easy on a flashcard/note (minimum = 100%).",
    EASY_BONUS_MIN_WARNING: "The easy bonus must be at least 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximum interval in days",
    MAX_INTERVAL_DESC: "Allows you to place an upper limit on the interval (default = 100 years).",
    MAX_INTERVAL_MIN_WARNING: "The maximum interval must be at least 1 day.",
    MAX_LINK_CONTRIB: "Maximum link contribution",
    MAX_LINK_CONTRIB_DESC:
        "Maximum contribution of the weighted ease of linked notes to the initial ease.",
    LOGGING: "Logging",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Show the scheduler's debugging information on the developer console",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Notes Review Queue",
    CLOSE: "Close",
    NEW: "New",
    YESTERDAY: "Yesterday",
    TODAY: "Today",
    TOMORROW: "Tomorrow",
    // stats-modal.tsx
    STATS_TITLE: "Statistics",
    MONTH: "Month",
    QUARTER: "Quarter",
    YEAR: "Year",
    LIFETIME: "Lifetime",
    FORECAST: "Forecast",
    FORECAST_DESC: "The number of cards due in the future",
    SCHEDULED: "Scheduled",
    DAYS: "Days",
    NUMBER_OF_CARDS: "Number of cards",
    REVIEWS_PER_DAY: "Average: ${avg} reviews/day",
    INTERVALS: "Intervals",
    INTERVALS_DESC: "Delays until reviews are shown again",
    COUNT: "Count",
    INTERVALS_SUMMARY: "Average interval: ${avg}, Longest interval: ${longest}",
    EASES: "Eases",
    EASES_SUMMARY: "Average ease: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Card Types",
    CARD_TYPES_DESC: "This includes buried cards as well, if any",
    CARD_TYPE_NEW: "New",
    CARD_TYPE_YOUNG: "Young",
    CARD_TYPE_MATURE: "Mature",
    CARD_TYPES_SUMMARY: "Total cards: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {
    // flashcard-modal.tsx
    DECKS: "Mazos",
    DUE_CARDS: "Tarjetas Vencidas",
    NEW_CARDS: "Tarjetas Nuevas",
    TOTAL_CARDS: "Tarjetas Totales",
    BACK: "Atr\xE1s",
    SKIP: "Saltar",
    EDIT_CARD: "Editar Tarjeta",
    RESET_CARD_PROGRESS: "Reiniciar progreso de la tarjeta",
    HARD: "Dif\xEDcil",
    GOOD: "Bien",
    EASY: "F\xE1cil",
    SHOW_ANSWER: "Mostrar Respuesta",
    CARD_PROGRESS_RESET: "El progreso de la tarjeta se ha reiniciado.",
    SAVE: "Guardar",
    CANCEL: "Cancelar",
    NO_INPUT: "Se ha prove\xEDdo entrada.",
    CURRENT_EASE_HELP_TEXT: "Facilidad Actual: ",
    CURRENT_INTERVAL_HELP_TEXT: "Intervalo Actual: ",
    CARD_GENERATED_FROM: "Generado Desde: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Abrir nota para revisi\xF3n",
    REVIEW_CARDS: "Revisar Tarjetas",
    REVIEW_DIFFICULTY_FILE_MENU: "Revisar: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Revisar nota como ${difficulty}",
    CRAM_ALL_CARDS: "Selecciona un mazo a memorizar",
    REVIEW_ALL_CARDS: "Revisar tarjetas de todas las notas",
    REVIEW_CARDS_IN_NOTE: "Revisar tarjetas en esta nota",
    CRAM_CARDS_IN_NOTE: "Memorizar tarjetas en esta nota",
    VIEW_STATS: "Ver estad\xEDsticas",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR: "Revisar: ${dueNotesCount} nota(s), ${dueFlashcardsCount} tarjetas vencidas",
    SYNC_TIME_TAKEN: "La sincronizaci\xF3n tom\xF3 ${t} milisegundos",
    NOTE_IN_IGNORED_FOLDER:
        "La nota est\xE1 guardada en un directorio ignorado (revisa los ajustes).",
    PLEASE_TAG_NOTE: "Por favor etiquete apropiadamente la nota para revisi\xF3n (en los ajustes).",
    RESPONSE_RECEIVED: "Respuesta Recibida",
    NO_DECK_EXISTS: "No existen mazos para: ${deckName}",
    ALL_CAUGHT_UP: "\xA1Est\xE1s al d\xEDa! \u{1F603}",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} d\xEDa(s)",
    MONTHS_STR_IVL: "${interval} mes(es)",
    YEARS_STR_IVL: "${interval} a\xF1o(s)",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}a",
    // settings.ts
    SETTINGS_HEADER: "Extensi\xF3n de Repetici\xF3n Espaciada",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'Para m\xE1s informaci\xF3n revisa la <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Directorios a ignorar",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Tarjetas de Memorizaci\xF3n",
    FLASHCARD_EASY_LABEL: "Texto del bot\xF3n: F\xE1cil",
    FLASHCARD_GOOD_LABEL: "Texto del bot\xF3n: Bien",
    FLASHCARD_HARD_LABEL: "Texto del bot\xF3n: Dif\xEDcil",
    FLASHCARD_EASY_DESC: "Personalize la etiqueta para el bot\xF3n: F\xE1cil",
    FLASHCARD_GOOD_DESC: "Personalize la etiqueta para el bot\xF3n: Bien",
    FLASHCARD_HARD_DESC: "Personalize la etiqueta para el bot\xF3n: Dif\xEDcil",
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Etiquetas de las Tarjetas de Memorizaci\xF3n",
    FLASHCARD_TAGS_DESC:
        "Escriba las etiquetas separadas por espacios o saltos de l\xEDnea, por ejemplo, #memorizar #mazo2 #mazo3",
    CONVERT_FOLDERS_TO_DECKS: "\xBFConvertir directorios a mazos y submazos?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Esta es una opci\xF3n alternativa a las etiquetas de las Tarjetas de Memorizaci\xF3n.",
    INLINE_SCHEDULING_COMMENTS:
        "\xBFGuardar el comentario para programaci\xF3n de las tarjetas en la \xFAltima l\xEDnea?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Activar esto har\xE1 que los comentarios HTML no rompan el formato de las listas.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "\xBFEnterrar tarjetas hermanas hasta el siguiente d\xEDa?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Los hermanos son tarjetas generadas del mismo texto de la tarjeta, por ejemplo, deletreos de huecos (cloze deletions en ingl\xE9s)",
    SHOW_CARD_CONTEXT: "\xBFMostrar contexto en las tarjetas?",
    SHOW_CARD_CONTEXT_DESC: "Por Ejemplo: T\xEDtulo > Cabecera > Sub-Cabecera > ... > Sub-Cabecera",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Porcentaje de la altura de las tarjetas de memoria",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Deber\xEDa ser establecido en 100% si tienes im\xE1genes grandes",
    RESET_DEFAULT: "Reiniciar a la configuraci\xF3n por defecto",
    CARD_MODAL_WIDTH_PERCENT: "Porcentaje del ancho de las tarjetas de memoria",
    RANDOMIZE_CARD_ORDER: "\xBFAleatorizar el orden de las tarjetas para revisi\xF3n?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS: "\xBFDeshabilitar deletreo de huecos en las tarjetas?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "\xBFConvertir ==resaltados== a deletreo de huecos?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "\xBFConvertir **texto en negrita** a deletreo de huecos?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "\xBFConvertir {{llaves rizadas}} a deletreo de huecos?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
    CLOZE_PATTERNS: "Patrones de deletreo de huecos",
    CLOZE_PATTERNS_DESC:
        'Escriba los patrones de deletreo de huecos separados por saltos de l\xEDnea. . Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Separador de tarjetas de memorizaci\xF3n en l\xEDnea",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Note que despu\xE9s de cambiar este ajuste, tendr\xE1 que cambiar manualmente todas las notas que tenga.",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "Separador de tarjetas de memorizaci\xF3n para tarjetas de notas invertidas",
    MULTILINE_CARDS_SEPARATOR: "Separador para tarjetas de memorizaci\xF3n multil\xEDnea",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "Separador para tarjetas de memorizaci\xF3n multil\xEDnea invertidas",
    MULTILINE_CARDS_END_MARKER:
        "Caracteres que denotan el fin de los clozes y tarjetas did\xE1cticas de varias l\xEDneas",
    NOTES: "Notes",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Activar panel de revisi\xF3n de notas al arrancar",
    TAGS_TO_REVIEW: "Etiquetas a revisar",
    TAGS_TO_REVIEW_DESC:
        "Escriba las etiquetas separadas por espacios o saltos de l\xEDneas, por ejemplo, #revisi\xF3n #etiqueta2 #etiqueta3.",
    OPEN_RANDOM_NOTE: "Abrir una nota al azar para revisar",
    OPEN_RANDOM_NOTE_DESC:
        "Cuando deshabilita esto, las notas son ordenadas por importancia (Algoritmo PageRank).",
    AUTO_NEXT_NOTE: "Abrir la siguiente nota autom\xE1ticamente despu\xE9s de una revisi\xF3n",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Habilita las opciones de revisi\xF3n en el men\xFA Archivo (por ejemplo: Revisar: F\xE1cil, Bien, Dif\xEDcil)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Si desactivas las opciones de revisi\xF3n en el men\xFA Archivo, puedes revisar tus notas usando los comandos del plugin y, si los definiste, las teclas r\xE1pidas asociadas.",
    MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de d\xEDas a mostrar en el panel derecho.",
    MIN_ONE_DAY: "El n\xFAmero de d\xEDas debe ser al menos uno.",
    VALID_NUMBER_WARNING: "Por favor especifique un n\xFAmero v\xE1lido.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Los \xE1rboles de mazos deber\xEDan ser expandidos al inicio.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Desactiva esto para contraer mazos anidados en la misma tarjeta. \xDAtil si tienes tarjetas que pertenecen a muchos mazos en el mismo archivo.",
    ALGORITHM: "Algoritmo",
    CHECK_ALGORITHM_WIKI:
        'Para m\xE1s informaci\xF3n, revisa la <a href="${algoUrl}">implementaci\xF3n del algoritmo</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Base ease",
    BASE_EASE_DESC: "El m\xEDnimo es 130, es preferible que est\xE9 aproximado a 250.",
    BASE_EASE_MIN_WARNING: "La facilidad base de las tarjetas debe ser al menos 130.",
    LAPSE_INTERVAL_CHANGE:
        "El intervalo cambiar\xE1 cuando se revise una tarjeta o nota como Dif\xEDcil.",
    LAPSE_INTERVAL_CHANGE_DESC: "NuevoInterval = ViejoIntervalo * CambioDeIntervalo / 100.",
    EASY_BONUS: "Bonificaci\xF3n para F\xE1cil",
    EASY_BONUS_DESC:
        "La bonificaci\xF3n para F\xE1cil te permite establecer la diferencia entre intervalos al responder Bien y F\xE1cil en las tarjetas o notas (m\xEDnimo = 100%).",
    EASY_BONUS_MIN_WARNING: "El bono de facilidad debe ser al menos 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Intervalo m\xE1ximo en d\xEDas",
    MAX_INTERVAL_DESC:
        "Te permite establecer un l\xEDmite mayor en el intervalo (por defecto es de 100 a\xF1os).",
    MAX_INTERVAL_MIN_WARNING: "El intervalo m\xE1ximo debe ser de al menos un d\xEDa.",
    MAX_LINK_CONTRIB: "Contribuci\xF3n m\xE1xima de las notas vinculadas.",
    MAX_LINK_CONTRIB_DESC:
        "Contribuci\xF3n m\xE1xima de la facilidad ponderada de las notas vinculadas a la facilidad inicial.",
    LOGGING: "Registro",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\xBFMostrar informaci\xF3n de depuraci\xF3n en la consola de desarrollador",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Cola de notas a revisar",
    CLOSE: "Cerrar",
    NEW: "Nuevo",
    YESTERDAY: "Ayer",
    TODAY: "Hoy",
    TOMORROW: "Ma\xF1ana",
    // stats-modal.tsx
    STATS_TITLE: "Estad\xEDsticas",
    MONTH: "Mes",
    QUARTER: "Trimestre o Cuatrimestre",
    // En Ingls: Quarter.
    YEAR: "A\xF1o",
    LIFETIME: "Tiempo de Vida",
    FORECAST: "Pron\xF3stico",
    FORECAST_DESC: "El n\xFAmero de tarjetas vencidas en el futuro",
    SCHEDULED: "Programado",
    DAYS: "D\xEDas",
    NUMBER_OF_CARDS: "N\xFAmero de tarjetas",
    REVIEWS_PER_DAY: "Carga: ${avg} Revisiones por d\xEDa",
    INTERVALS: "Intervalos",
    INTERVALS_DESC: "Retrasos hasta que las revisiones se muestren de nuevo",
    COUNT: "Conteo",
    INTERVALS_SUMMARY: "Intervalo de carga: ${avg}, Intervalo mayor: ${longest}",
    EASES: "Facilidad",
    EASES_SUMMARY: "Carga de Facilidad: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Tipos de tarjetas",
    CARD_TYPES_DESC: "Esto incluye tambi\xE9n a las tarjetas enterradas, si las hay",
    CARD_TYPE_NEW: "Nueva",
    CARD_TYPE_YOUNG: "Joven",
    CARD_TYPE_MATURE: "Madura",
    CARD_TYPES_SUMMARY: "Tarjetas Totales: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/fr.ts
var fr_default = {
    // flashcard-modal.tsx
    DECKS: "Paquets",
    DUE_CARDS: "Cartes dues",
    NEW_CARDS: "Nouvelles cartes",
    TOTAL_CARDS: "Total de cartes",
    BACK: "Pr\xE9c\xE9dent",
    SKIP: "Sauter",
    EDIT_CARD: "Modifier la carte",
    RESET_CARD_PROGRESS: "Remettre \xE0 z\xE9ro le niveau de cette carte",
    HARD: "Difficile",
    GOOD: "Correct",
    EASY: "Facile",
    SHOW_ANSWER: "Montrer la r\xE9ponse",
    CARD_PROGRESS_RESET: "Le niveau de la carte a \xE9t\xE9 remis \xE0 z\xE9ro.",
    SAVE: "Sauvegarder",
    CANCEL: "Annuler",
    NO_INPUT: "Pas de contenu.",
    CURRENT_EASE_HELP_TEXT: "Facilit\xE9 actuelle : ",
    CURRENT_INTERVAL_HELP_TEXT: "Intervalle actuel : ",
    CARD_GENERATED_FROM: "G\xE9n\xE9r\xE9 depuis : ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Ouvrir une note \xE0 apprendre",
    REVIEW_CARDS: "Apprendre les flashcards",
    REVIEW_DIFFICULTY_FILE_MENU: "Apprentissage : ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Difficult\xE9 de la r\xE9vision : ${difficulty}",
    CRAM_ALL_CARDS: "Choisir un deck \xE0 r\xE9viser",
    REVIEW_ALL_CARDS: "Apprendre les flashcards dans toutes les notes",
    REVIEW_CARDS_IN_NOTE: "Apprendre les flashcards dans cette note",
    CRAM_CARDS_IN_NOTE: "R\xE9viser les flashcards dans cette note",
    VIEW_STATS: "Voir les statistiques",
    OPEN_REVIEW_QUEUE_VIEW:
        "Ouvrir la file d'attente des notes \xE0 apprendre dans la barre verticale",
    STATUS_BAR: "Apprentissage : ${dueNotesCount} note(s), ${dueFlashcardsCount} carte(s) dues",
    SYNC_TIME_TAKEN: "Synchronis\xE9 en ${t}ms",
    NOTE_IN_IGNORED_FOLDER: "La note est dans un dossier ignor\xE9 (voir param\xE8tres).",
    PLEASE_TAG_NOTE: "Ajoutez le bon tag \xE0 la note pour l'apprendre (dans les param\xE8tres).",
    RESPONSE_RECEIVED: "R\xE9ponse enregistr\xE9e.",
    NO_DECK_EXISTS: "Pas de paquet sous le nom ${deckName}",
    ALL_CAUGHT_UP: "Bravo, vous \xEAtes \xE0 jour !",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} jour(s)",
    MONTHS_STR_IVL: "${interval} mois(s)",
    YEARS_STR_IVL: "${interval} an(s)",
    DAYS_STR_IVL_MOBILE: "${interval}j",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}a",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Dossiers",
    GROUP_FLASHCARD_REVIEW: "Apprentissage des flashcards",
    GROUP_FLASHCARD_SEPARATORS: "S\xE9parateurs de flashcards",
    GROUP_DATA_STORAGE: "Stockage des informations de planification",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contribuer",
    CHECK_WIKI: 'Pour plus d\'informations, visitez le <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visitez les <a href="${discussionsUrl}">discussions</a> pour des questions-r\xE9ponses, des retours ou une discussion g\xE9n\xE9raliste.',
    GITHUB_ISSUES:
        'Cr\xE9ez un ticket <a href="${issuesUrl}">sur GitHub</a> si vous trouvez un bug ou voulez demander une fonctionnalit\xE9.',
    GITHUB_SOURCE_CODE:
        'Code source du projet disponible sur <a href="${githubProjectUrl}">GitHub</a>',
    CODE_CONTRIBUTION_INFO:
        'Information sur les <a href="${codeContributionUrl}">contributions au code</a>',
    TRANSLATION_CONTRIBUTION_INFO:
        'Informations sur la <a href="${translationContributionUrl}">traduction du plugin</a> dans votre langue',
    FOLDERS_TO_IGNORE: "Dossiers \xE0 ignorer",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Flashcards",
    FLASHCARD_EASY_LABEL: "Bouton Facile",
    FLASHCARD_GOOD_LABEL: "Bouton Correct",
    FLASHCARD_HARD_LABEL: "Bouton Difficile",
    FLASHCARD_EASY_DESC: "Changez le texte du bouton Facile",
    FLASHCARD_GOOD_DESC: "Changez le texte du bouton Correct",
    FLASHCARD_HARD_DESC: "Changez le texte du bouton Difficile",
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Tags des flashcards",
    FLASHCARD_TAGS_DESC:
        "Entrez les tags s\xE9par\xE9s par un espace ou une ligne i.e. #flashcards #paquet2 #paquet3.",
    CONVERT_FOLDERS_TO_DECKS: "Convertir les dossiers en paquets et sous-paquets ?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Ceci est une alternative aux tags de flashcards pr\xE9sent\xE9s ci-dessus.",
    INLINE_SCHEDULING_COMMENTS:
        "Sauvegarder le commentaire de planification dans la derni\xE8re ligne de la flashcard ?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Activer ceci emp\xEAche les commentaires HTML de casser la mise en page des listes.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrer les cartes s\u0153urs jusqu'au lendemain ?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Les cartes s\u0153urs sont les cartes g\xE9n\xE9r\xE9es depuis le m\xEAme texte, par exemple pour les textes \xE0 trous",
    SHOW_CARD_CONTEXT: "Montrer le contexte dans les cartes ?",
    SHOW_CARD_CONTEXT_DESC: "ex. Titre de la note > Titre 1 > Sous-titre > ... > Sous-titre",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Pourcentage de hauteur de la flashcard",
    CARD_MODAL_SIZE_PERCENT_DESC: "Devrait \xEAtre 100% sur mobile ou en cas de grandes images",
    RESET_DEFAULT: "R\xE9initialiser les param\xE8tres",
    CARD_MODAL_WIDTH_PERCENT: "Pourcentage de largeur de la flashcard",
    RANDOMIZE_CARD_ORDER: "Apprendre les cartes dans un ordre al\xE9atoire ?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "Ordre d'affichage des cartes d'un paquet pendant les r\xE9visions",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Dans l'ordre du paquet (Nouvelles cartes d'abord)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Dans l'ordre du paquet (Cartes dues d'abord)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM:
        "Al\xE9atoirement dans le paquet (Nouvelles cartes d'abord)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Al\xE9atoirement dans le paquet (Cartes dues d'abord)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Carte au hasard dans un paquet au hasard",
    REVIEW_DECK_ORDER: "Ordre d'affichage des paquets pendant les r\xE9visions",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "S\xE9quentiel (quand toutes les cartes du paquet pr\xE9c\xE9dent sont apprises)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Al\xE9atoire (quand toutes les cartes du paquet pr\xE9c\xE9dent sont apprises)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Carte au hasard dans un paquet au hasard",
    DISABLE_CLOZE_CARDS: "D\xE9sactiver les textes \xE0 trous ?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Convertir ==soulignages== en trous ?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Convertir **gras** en trous ?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convertir {{crochets}} en trous ?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
    CLOZE_PATTERNS: "Cloze Patterns",
    CLOZE_PATTERNS_DESC:
        'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "S\xE9parateur pour flashcards en une ligne",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Apr\xE8s avoir chang\xE9 ce r\xE9glage, vous devrez manuellement mettre \xE0 jour toutes vos flashcards.",
    INLINE_REVERSED_CARDS_SEPARATOR: "S\xE9parateur pour flashcards invers\xE9es en une ligne",
    MULTILINE_CARDS_SEPARATOR: "S\xE9parateur pour flashcards en plusieurs lignes",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "S\xE9parateur pour flashcards invers\xE9es en plusieurs lignes",
    MULTILINE_CARDS_END_MARKER:
        "Caract\xE8res de fin de textes \xE0 trous ou de flashcards en plusieurs lignes",
    NOTES: "Notes",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Montrer le module d'apprentissage des notes au d\xE9marrage",
    TAGS_TO_REVIEW: "Tags \xE0 apprendre",
    TAGS_TO_REVIEW_DESC:
        "Entrez les tags s\xE9par\xE9s par un espace ou une ligne i.e. #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Ouvrir une note \xE0 apprendre au hasard",
    OPEN_RANDOM_NOTE_DESC:
        "Si vous d\xE9sactivez cette option, les notes sont tri\xE9es par importance (PageRank).",
    AUTO_NEXT_NOTE: "Ouvrir la prochaine note automatiquement apr\xE8s un apprentissage",
    MAX_N_DAYS_REVIEW_QUEUE: "Jours maximum affich\xE9s dans la barre de droite",
    MIN_ONE_DAY: "Le nombre de jours doit \xEAtre au moins 1.",
    VALID_NUMBER_WARNING: "Entrez un nombre valide.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Les dossiers de paquets devraient initialement tous \xEAtre ouverts",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "D\xE9sactivez pour r\xE9duire les paquets dans la m\xEAme carte. Ce r\xE9glage est utile si vous avez des cartes qui appartiennent \xE0 beaucoup de paquets \xE0 la fois.",
    ALGORITHM: "Algorithme",
    CHECK_ALGORITHM_WIKI: `Pour en savoir plus, lisez l'<a href="\${algoUrl}">impl\xE9mentation de l'algorithme</a>.`,
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Facilit\xE9 de base",
    BASE_EASE_DESC: "minimum = 130, recommand\xE9 = vers 250.",
    BASE_EASE_MIN_WARNING: "La facilit\xE9 de base doit \xEAtre sup\xE9rieure \xE0 130.",
    LAPSE_INTERVAL_CHANGE:
        "Changement d'intervalle quand vous indiquez qu'une flashcard/note a \xE9t\xE9 difficile",
    LAPSE_INTERVAL_CHANGE_DESC: "nouvelIntervalle = ancienIntervalle * changementIntervalle / 100.",
    EASY_BONUS: "Bonus Facile",
    EASY_BONUS_DESC:
        "Le bonus Facile vous permet d'augmenter l'intervalle entre une r\xE9ponse Correct et une r\xE9ponse Facile sur une flashcard/note (minimum = 100%).",
    EASY_BONUS_MIN_WARNING: "Le bonus Facile doit \xEAtre au moins 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Intervalle maximum (en jours)",
    MAX_INTERVAL_DESC:
        "Vous permet de mettre une limite maximale sur l'intervalle (par d\xE9faut, 100 ans).",
    MAX_INTERVAL_MIN_WARNING: "L'intervalle maximum doit \xEAtre au moins 1 jour.",
    MAX_LINK_CONTRIB: "Contribution maximum des liens",
    MAX_LINK_CONTRIB_DESC:
        "Contribution maximum de la facilit\xE9 pond\xE9r\xE9e des notes li\xE9es \xE0 la facilit\xE9 initiale.",
    LOGGING: "Logging",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Afficher les informations de d\xE9bogage dans la console de d\xE9veloppement",
    DISPLAY_PARSER_DEBUG_INFO:
        "Afficher les informations de d\xE9bogage pour le parser dans la console de d\xE9veloppement",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Cartes \xE0 apprendre",
    CLOSE: "Fermer",
    NEW: "Nouveau",
    YESTERDAY: "Hier",
    TODAY: "Aujourd'hui",
    TOMORROW: "Demain",
    // stats-modal.tsx
    STATS_TITLE: "Statistiques",
    MONTH: "Mois",
    QUARTER: "Trimestre",
    YEAR: "Ann\xE9e",
    LIFETIME: "Toujours",
    FORECAST: "Pr\xE9visions",
    FORECAST_DESC: "Le nombre de cartes dues dans le futur",
    SCHEDULED: "Planifi\xE9",
    DAYS: "Jours",
    NUMBER_OF_CARDS: "Nombre de cartes",
    REVIEWS_PER_DAY: "Moyenne : ${avg} apprentissages / jour",
    INTERVALS: "Intervalles",
    INTERVALS_DESC: "Dur\xE9e avant de remontrer une carte",
    COUNT: "Total",
    INTERVALS_SUMMARY: "Intervalle moyen : ${avg}. Intervalle maximum: ${longest}",
    EASES: "Facilit\xE9",
    EASES_SUMMARY: "Facilit\xE9 moyenne : ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Types de cartes",
    CARD_TYPES_DESC: "Ceci inclut les cartes enterr\xE9es, s'il y en a",
    CARD_TYPE_NEW: "Nouvelles",
    CARD_TYPE_YOUNG: "En cours d'apprentissage",
    CARD_TYPE_MATURE: "Matures",
    CARD_TYPES_SUMMARY: "Total de cartes : ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {
    // flashcard-modal.tsx
    DECKS: "Mazzi",
    DUE_CARDS: "Schede da fare",
    NEW_CARDS: "Schede nuove",
    TOTAL_CARDS: "Schede totali",
    BACK: "Indietro",
    SKIP: "Salta",
    EDIT_CARD: "Modifica scheda",
    RESET_CARD_PROGRESS: "Ripristina i progressi della scheda",
    HARD: "Difficile",
    GOOD: "Buono",
    EASY: "Facile",
    SHOW_ANSWER: "Mostra risposta",
    CARD_PROGRESS_RESET: "I progressi della scheda sono stati ripristinati",
    SAVE: "Salva",
    CANCEL: "Cancella",
    NO_INPUT: "Non \xE8 stato provvisto alcun input",
    CURRENT_EASE_HELP_TEXT: "Difficolt\xE0 attuale: ",
    CURRENT_INTERVAL_HELP_TEXT: "Intervallo attuale: ",
    CARD_GENERATED_FROM: "Generato da: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Apri una nota per rivisita",
    REVIEW_CARDS: "Rivisita schede",
    REVIEW_DIFFICULTY_FILE_MENU: "Rivisita: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Revisita note come ${difficulty}",
    CRAM_ALL_CARDS: "Seleziona un mazzo da memorizzare",
    REVIEW_ALL_CARDS: "Seleziona schede da rivedere",
    REVIEW_CARDS_IN_NOTE: "Rivedi schede in questa nota",
    CRAM_CARDS_IN_NOTE: "Memorizza schede in questa nota",
    VIEW_STATS: "Vedi statistiche",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR: "Da rivedere: ${dueNotesCount} scheda/e, ${dueFlashcardsCount} schede in ritardo",
    SYNC_TIME_TAKEN: "Sincronizzato in ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "La nota \xE8 salvata in una cartella ignorata (rivedi le impostazioni).",
    PLEASE_TAG_NOTE:
        "Per favore etichetta la nota appropriatamente per la revisione (nelle impostazioni).",
    RESPONSE_RECEIVED: "Risposta ricevuta.",
    NO_DECK_EXISTS: "Non esistono mazzi per ${deckName}",
    ALL_CAUGHT_UP: "Sei al passo! :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} giorno/i",
    MONTHS_STR_IVL: "${interval} mese/i",
    YEARS_STR_IVL: "${interval} anno/i",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}y",
    // settings.ts
    SETTINGS_HEADER: "Plugin per ripetizione spaziata",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'Per maggiori informazioni, rivolgersi alla <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Cartelle da ignorare",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Schede",
    FLASHCARD_EASY_LABEL: "Testo del bottone facile",
    FLASHCARD_GOOD_LABEL: "Testo del bottone buono",
    FLASHCARD_HARD_LABEL: "Testo del bottone difficile",
    FLASHCARD_EASY_DESC: 'Personalizza il testo per il pulsante "Facile"',
    FLASHCARD_GOOD_DESC: 'Personalizza il testo per il pulsante "Buono"',
    FLASHCARD_HARD_DESC: 'Personalizza il testo per il pulsante "Difficile"',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Etichette delle schede",
    FLASHCARD_TAGS_DESC:
        "Inserire etichette separate da spazi o a capi, per esempio #flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS: "Trasformare cartelle in mazzi e sotto-mazzi?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Questa \xE8 un'alternativa all'opzione delle etichette delle schede sopra.",
    INLINE_SCHEDULING_COMMENTS:
        "Salvare il commento per l'orario sulla stessa linea dell'ultimna linea della scheda?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Attivando quest'impostazione far\xF2 s\xEC che i commento HTML non rompino la formattazione delle liste.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Sotterrare schede sorelle fino al giorno dopo?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Le schede sorelle sono schede generate dallo stesso testo della scheda, per esempio i.e. cloze deletions",
    SHOW_CARD_CONTEXT: "Mostrare contesto nelle schede?",
    SHOW_CARD_CONTEXT_DESC:
        "per esempio, Titolo > Intestazione 1 > Sottotitolo 1 > ... > Sottotitolo",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Percentuale altezza schede",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Dovrebbe essere 100% se sei su telefono o se hai immagini molto grandi",
    RESET_DEFAULT: "Reimposta alle impostazioni iniziali",
    CARD_MODAL_WIDTH_PERCENT: "Percentuale di larghezza delle schede",
    RANDOMIZE_CARD_ORDER: "Rendere casuale l'ordine delle schede durante la revisione?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "L'ordine in cui le schede saranno visualizzate all'interno del mazzo",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequenzialmente dentro il mazzo (prima schede nuove)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "Sequenzialmente dentro il mazzo (prima schede in ritardo)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "A caso dentro il mazzo (prima schede nuove)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "A caso dentro il mazzo (prima schede in ritardo)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Scheda a caso da mazzo a caso",
    REVIEW_DECK_ORDER: "L'ordine in cui i mazzi vengono mostrati durante la revisione",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequenzialmente (quando le schede nel mazzo precedente saranno state riviste)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "A caso (quando le schede nel mazzo precedente saranno state riviste)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Scheda a caso da mazzo a caso",
    DISABLE_CLOZE_CARDS: "Disabilita schede con spazi da riempire?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Convertire ==testo evidenziato== in spazi da riempire?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Convertire **testo in grassetto** in spazi da riempire",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convertire {{parentesi graffe}} in spazi da riempire?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
    CLOZE_PATTERNS: "Modelli di spazi da riempire",
    CLOZE_PATTERNS_DESC:
        'Inserisci i modelli di spazi da riempire separati da a capo. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Separatore per schede sulla stessa riga",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Si avvisa che dopo aver cambiato questo dovrai manualmente modificare le schede che hai gi\xE0.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Separatore per schede all'incontrario sulla stessa riga",
    MULTILINE_CARDS_SEPARATOR: "Separatore per schede su pi\xF9 righe",
    MULTILINE_REVERSED_CARDS_SEPARATOR: "Separatore per schede all'incontrario su pi\xF9 righe",
    MULTILINE_CARDS_END_MARKER:
        "Caratteri che denotano la fine di carte con spazi da riempiere e carte multilinea",
    NOTES: "Note",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Abilita il pannello di revisione note all'avvio",
    TAGS_TO_REVIEW: "Etichette da rivedere",
    TAGS_TO_REVIEW_DESC:
        "Inserisci le etichette separate da spazi o a capi, tipo #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Apri una nota a caso per revisione",
    OPEN_RANDOM_NOTE_DESC:
        "Quando lo disabiliti, le note saranno ordinate per importanza (PageRank).",
    AUTO_NEXT_NOTE: "Apri la prossima nota automaticamente dopo la revisione",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Abilita le opzioni di revisione nel menu File (es.: Rivisita: Facile, Buono, Difficile)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Se disabiliti le opzioni di revisione nel menu File, puoi rivedere le tue note utilizzando i comandi del plugin e, se li hai definiti, le scorciatoie da tastiera associate.",
    MAX_N_DAYS_REVIEW_QUEUE: "Numero di giorni massimi da visualizzare nel pannello di destra",
    MIN_ONE_DAY: "Il numero di giorni deve essere almeno 1.",
    VALID_NUMBER_WARNING: "Per favore, mettere un numero valido.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Alberti di mazzi dovrebbero essere inizialmente visualizzate come espansi",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Disabilitami per collassare mazzi annidati nella stessa scheda. Utile se hai schede che appartengono a pi\xF9 mazzi nello stesso file.",
    ALGORITHM: "Algoritmo",
    CHECK_ALGORITHM_WIKI:
        "Per maggiori informazioni, visita <a href='${algoUrl}'>l'implementazione dell'algoritmo</a>.",
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Difficolt\xE0 base",
    BASE_EASE_DESC: "mino = 130, preferibilmente circa 250.",
    BASE_EASE_MIN_WARNING: "La difficolt\xE0 base deve essere di almeno 130.",
    LAPSE_INTERVAL_CHANGE: "L'intervallo cambier\xE0 segnando una scheda / nota come difficile",
    LAPSE_INTERVAL_CHANGE_DESC: "Intervallo nuovo = intervallo vecchio * cambio intervallo / 100.",
    EASY_BONUS: "Bonus facilit\xE0",
    EASY_BONUS_DESC:
        "Il bonus facilit\xE0 ti permette di impostare le differenze negli intervalli tra il rispondere Buono e Facile su una scheda o nota (minimo 100%).",
    EASY_BONUS_MIN_WARNING: "Il bonus facilit\xE0 deve essere di almeno 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Intervallo massimo in giorni",
    MAX_INTERVAL_DESC:
        "Ti permette di mettere un limite massimo all'intervallo (default 100 anni).",
    MAX_INTERVAL_MIN_WARNING: "L'intervallo massimo deve essere di almeno 1 giorno.",
    MAX_LINK_CONTRIB: "Contributo massimo delle note collegate",
    MAX_LINK_CONTRIB_DESC:
        "Contributo massimo della difficolt\xE0 pasata delle note collegate alla difficolt\xE0 iniziale.",
    LOGGING: "Registrando",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Visualizza informazione di debug sulla console per sviluppatori",
    DISPLAY_PARSER_DEBUG_INFO:
        "Visualizza informazione di debug riguardanti il parser sulla console per sviluppatori",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Coda di note da rivedere",
    CLOSE: "Chiusi",
    NEW: "Nuovo/a",
    YESTERDAY: "Ieri",
    TODAY: "Oggi",
    TOMORROW: "Domani",
    // stats-modal.tsx
    STATS_TITLE: "Statistiche",
    MONTH: "Mese",
    QUARTER: "Trimestre",
    YEAR: "Anno",
    LIFETIME: "Per tutta la vita",
    FORECAST: "Previsione",
    FORECAST_DESC: "Il numero di schede che saranno in ritardo in futuro",
    SCHEDULED: "Programmate",
    DAYS: "Giorni",
    NUMBER_OF_CARDS: "Numero di schede",
    REVIEWS_PER_DAY: "Media: ${avg} revisioni/giorno",
    INTERVALS: "Intervalli",
    INTERVALS_DESC: "Ritardi finch\xE9 le revisioni saranno visualizzate di nuovo",
    COUNT: "Conta",
    INTERVALS_SUMMARY: "Intervallo medio: ${avg}, Intervallo massimo: ${longest}",
    EASES: "Difficolt\xE0",
    EASES_SUMMARY: "Difficolt\xE0 media: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Tipi di schede",
    CARD_TYPES_DESC: "Include eventuali schede sepolte",
    CARD_TYPE_NEW: "Nuove",
    CARD_TYPE_YOUNG: "Giovani",
    CARD_TYPE_MATURE: "Mature",
    CARD_TYPES_SUMMARY: "Schede tottali: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/ja.ts
var ja_default = {
    // flashcard-modal.tsx
    DECKS: "\u30C7\u30C3\u30AD",
    DUE_CARDS: "\u671F\u65E5\u306E\u30AB\u30FC\u30C9",
    NEW_CARDS: "\u65B0\u898F\u306E\u30AB\u30FC\u30C9",
    TOTAL_CARDS: "\u30AB\u30FC\u30C9\u5408\u8A08",
    BACK: "Back",
    SKIP: "Skip",
    EDIT_CARD: "Edit Card",
    RESET_CARD_PROGRESS: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u3092\u30EA\u30BB\u30C3\u30C8",
    HARD: "Hard",
    GOOD: "Good",
    EASY: "Easy",
    SHOW_ANSWER: "\u89E3\u7B54\u3092\u8868\u793A",
    CARD_PROGRESS_RESET:
        "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u304C\u30EA\u30BB\u30C3\u30C8\u3055\u308C\u307E\u3057\u305F\u3002",
    SAVE: "Save",
    CANCEL: "Cancel",
    NO_INPUT: "No input provided.",
    CURRENT_EASE_HELP_TEXT: "Current Ease: ",
    CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
    CARD_GENERATED_FROM: "Generated from: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW:
        "\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u30CE\u30FC\u30C8\u3092\u958B\u304F",
    REVIEW_CARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u30EC\u30D3\u30E5\u30FC",
    REVIEW_DIFFICULTY_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD:
        "\u30CE\u30FC\u30C8\u3092${difficulty}\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
    REVIEW_ALL_CARDS:
        "\u3059\u3079\u3066\u306E\u30CE\u30FC\u30C8\u304B\u3089\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
    CRAM_ALL_CARDS: "Select a deck to cram",
    REVIEW_CARDS_IN_NOTE:
        "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
    CRAM_CARDS_IN_NOTE:
        "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u8A70\u3081\u8FBC\u307F\u5B66\u7FD2\u3059\u308B",
    VIEW_STATS: "\u7D71\u8A08\u3092\u95B2\u89A7\u3059\u308B",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "\u30EC\u30D3\u30E5\u30FC: ${dueNotesCount}\u30CE\u30FC\u30C8, ${dueFlashcardsCount}\u30AB\u30FC\u30C9\u304C\u671F\u65E5",
    SYNC_TIME_TAKEN: "\u540C\u671F\u306B${t}ms\u304B\u304B\u308A\u307E\u3057\u305F\u3002",
    NOTE_IN_IGNORED_FOLDER:
        "\u30CE\u30FC\u30C8\u304C\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306B\u4FDD\u5B58\u3055\u308C\u3066\u3044\u307E\u3059(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
    PLEASE_TAG_NOTE:
        "\u30EC\u30D3\u30E5\u30FC\u3092\u884C\u3046\u306B\u306F\u30CE\u30FC\u30C8\u306B\u5BFE\u3057\u3066\u6B63\u3057\u304F\u30BF\u30B0\u4ED8\u3051\u3057\u3066\u304F\u3060\u3055\u3044(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
    RESPONSE_RECEIVED: "\u7B54\u3048\u3092\u53D7\u3051\u53D6\u308A\u307E\u3057\u305F\u3002",
    NO_DECK_EXISTS:
        "${deckName}\u306B\u306F\u30C7\u30C3\u30AD\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002",
    ALL_CAUGHT_UP:
        "\u4ECA\u65E5\u306E\u8AB2\u984C\u3092\u3059\u3079\u3066\u9054\u6210\u3057\u307E\u3057\u305F :D",
    // scheduling.ts
    DAYS_STR_IVL: "${interval}\u65E5\u5F8C",
    MONTHS_STR_IVL: "${interval}\u6708\u5F8C",
    YEARS_STR_IVL: "${interval}\u5E74\u5F8C",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}y",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI:
        '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${wikiUrl}">wiki</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9",
    FLASHCARD_EASY_LABEL: "Easy Button Text",
    FLASHCARD_GOOD_LABEL: "Good Button Text",
    FLASHCARD_HARD_LABEL: "Hard Button Text",
    FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
    FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
    FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS:
        "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
    FLASHCARD_TAGS_DESC:
        '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#flashcards #deck2 #deck3"',
    CONVERT_FOLDERS_TO_DECKS:
        "\u30D5\u30A9\u30EB\u30C0\u3092\u30C7\u30C3\u30AD\u3068\u30B5\u30D6\u30C7\u30C3\u30AD\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "\u3053\u308C\u306F\u4E0A\u8A18\u306E\u30BF\u30B0\u3092\u4F7F\u7528\u3057\u305F\u30C7\u30C3\u30AD\u69CB\u7BC9\u306E\u4EE3\u66FF\u3068\u306A\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3059\u3002",
    INLINE_SCHEDULING_COMMENTS:
        "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6700\u7D42\u884C\u3068\u540C\u4E00\u306E\u884C\u306B\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3059\u304B\uFF1F",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001HTML\u30B3\u30E1\u30F3\u30C8\u306B\u3088\u3063\u3066Markdown\u306E\u30EA\u30B9\u30C8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u304C\u5D29\u308C\u306A\u304F\u306A\u308A\u307E\u3059\u3002",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u307E\u3067\u30B7\u30D6\u30EA\u30F3\u30B0\u3092\u5EF6\u671F\u3057\u307E\u3059\u304B\uFF1F",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "\u30B7\u30D6\u30EA\u30F3\u30B0\u306F\u540C\u4E00\u306E\u30AB\u30FC\u30C9\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u751F\u6210\u3055\u308C\u305F\u30AB\u30FC\u30C9\u3001\u3064\u307E\u308A\u7A74\u57CB\u3081\u554F\u984C\u306E\u6D3E\u751F\u30AB\u30FC\u30C9\u3067\u3059\u3002",
    SHOW_CARD_CONTEXT:
        "\u30AB\u30FC\u30C9\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
    SHOW_CARD_CONTEXT_DESC:
        "\uFF62\u30BF\u30A4\u30C8\u30EB > \u898B\u51FA\u3057 1 > \u526F\u898B\u51FA\u3057 > ... > \u526F\u898B\u51FA\u3057\uFF63\u306E\u8868\u793A\u3092\u884C\u3046\u304B\u3069\u3046\u304B\u3092\u6C7A\u3081\u307E\u3059\u3002",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT:
        "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7E26\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\u30E2\u30D0\u30A4\u30EB\u7248\u3001\u307E\u305F\u306F\u975E\u5E38\u306B\u5927\u304D\u306A\u30B5\u30A4\u30BA\u306E\u753B\u50CF\u304C\u3042\u308B\u5834\u5408\u306B\u306F100%\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002",
    RESET_DEFAULT: "\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306B\u30EA\u30BB\u30C3\u30C8\u3059\u308B",
    CARD_MODAL_WIDTH_PERCENT:
        "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6A2A\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
    RANDOMIZE_CARD_ORDER:
        "\u30EC\u30D3\u30E5\u30FC\u4E2D\u306E\u30AB\u30FC\u30C9\u306E\u9806\u756A\u3092\u30E9\u30F3\u30C0\u30E0\u306B\u3057\u307E\u3059\u304B\uFF1F",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS:
        "\u7A74\u57CB\u3081\u30AB\u30FC\u30C9\u3092\u7121\u52B9\u5316\u3057\u307E\u3059\u304B\uFF1F",
    CONVERT_HIGHLIGHTS_TO_CLOZES:
        "==\u30CF\u30A4\u30E9\u30A4\u30C8==\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
    CONVERT_BOLD_TEXT_TO_CLOZES:
        "**\u30DC\u30FC\u30EB\u30C9\u4F53**\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "{{\u4E2D\u62EC\u5F27}}\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
    CLOZE_PATTERNS: "\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3",
    CLOZE_PATTERNS_DESC:
        '\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002 Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR:
        "\u30A4\u30F3\u30E9\u30A4\u30F3\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3059\u308B\u5834\u5408\u306B\u306F\u3001\u4F5C\u6210\u6E08\u307F\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u624B\u52D5\u3067\u7DE8\u96C6\u3057\u76F4\u3059\u5FC5\u8981\u304C\u3042\u308B\u3053\u3068\u306B\u6CE8\u610F\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "\u30A4\u30F3\u30E9\u30A4\u30F3\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
    MULTILINE_CARDS_SEPARATOR:
        "\u8907\u6570\u884C\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\u8907\u6570\u884C\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
    MULTILINE_CARDS_END_MARKER:
        "\u30AF\u30ED\u30FC\u30BA\u3068\u8907\u6570\u884C\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7D42\u308F\u308A\u3092\u793A\u3059\u6587\u5B57",
    NOTES: "\u30CE\u30FC\u30C8",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
    TAGS_TO_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
    TAGS_TO_REVIEW_DESC:
        '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#review #tag2 #tag3"',
    OPEN_RANDOM_NOTE:
        "\u30E9\u30F3\u30C0\u30E0\u306B\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
    OPEN_RANDOM_NOTE_DESC:
        "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u7121\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u72B6\u614B\u3067\u306F\u3001\u30CE\u30FC\u30C8\u306F\u91CD\u8981\u5EA6(\u30DA\u30FC\u30B8\u30E9\u30F3\u30AF)\u306B\u3088\u308B\u9806\u756A\u3067\u8868\u793A\u3055\u308C\u307E\u3059\u3002",
    AUTO_NEXT_NOTE:
        "\u30EC\u30D3\u30E5\u30FC\u5F8C\u306B\u6B21\u306E\u30CE\u30FC\u30C8\u3092\u81EA\u52D5\u7684\u306B\u958B\u304F",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\uFF08\u4F8B: Easy, Good, Hard\uFF09",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u7121\u52B9\u306B\u3057\u305F\u5834\u5408\u3001\u30D7\u30E9\u30B0\u30A4\u30F3\u30B3\u30DE\u30F3\u30C9\u3084\u3001\u8A2D\u5B9A\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u5BFE\u5FDC\u3059\u308B\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30E1\u30E2\u3092\u30EC\u30D3\u30E5\u30FC\u3067\u304D\u307E\u3059\u3002",
    MAX_N_DAYS_REVIEW_QUEUE:
        "\u53F3\u30D1\u30CD\u30EB\u306B\u8868\u793A\u3059\u308B\u6700\u5927\u306E\u65E5\u6570",
    MIN_ONE_DAY:
        "\u65E5\u6570\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    VALID_NUMBER_WARNING:
        "\u6709\u52B9\u306A\u6570\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\u30C7\u30C3\u30AD \u30C4\u30EA\u30FC\u306F\u6700\u521D\u306F\u5C55\u958B\u3057\u3066\u8868\u793A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "\u3053\u308C\u3092\u30AA\u30D5\u306B\u3059\u308B\u3068\u3001\u540C\u3058\u30AB\u30FC\u30C9\u5185\u306E\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30C7\u30C3\u30AD\u304C\u6298\u308A\u305F\u305F\u307E\u308C\u307E\u3059\u3002\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u591A\u304F\u306E\u30C7\u30C3\u30AD\u306B\u5C5E\u3059\u308B\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u4FBF\u5229\u3067\u3059\u3002",
    ALGORITHM: "\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0",
    CHECK_ALGORITHM_WIKI:
        '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${algoUrl}">\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u5B9F\u88C5</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055",
    BASE_EASE_DESC:
        "\u6700\u5C0F\u5024\u306F130\u3067\u3059\u304C\u3001 \u9069\u6B63\u5024\u306F\u304A\u304A\u3088\u305D250\u3067\u3059\u3002",
    BASE_EASE_MIN_WARNING:
        "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055\u306B\u306F130\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    LAPSE_INTERVAL_CHANGE:
        "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3057\u305F\u969B\u306E\u9593\u9694\u5909\u66F4",
    LAPSE_INTERVAL_CHANGE_DESC:
        '"\u65B0\u3057\u3044\u9593\u9694 = \u4EE5\u524D\u306E\u9593\u9694 * \u9593\u9694\u5909\u66F4 / 100" \u3068\u3057\u3066\u8A08\u7B97\u3055\u308C\u307E\u3059\u3002',
    EASY_BONUS: "Easy\u30DC\u30FC\u30CA\u30B9",
    EASY_BONUS_DESC:
        "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u3088\u3063\u3066\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u306B\u304A\u3051\u308B\u9593\u9694\u306E\u5DEE\u5206\u3092\u8A2D\u5B9A\u3067\u304D\u307E\u3059(\u6700\u5C0F\u5024 = 100%)\u3002",
    EASY_BONUS_MIN_WARNING:
        "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u306F100\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximum interval in days",
    MAX_INTERVAL_DESC:
        "\u9593\u9694\u306B\u4E0A\u9650\u5024\u3092\u8A2D\u5B9A\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8\u5024 = 100\u5E74)\u3002",
    MAX_INTERVAL_MIN_WARNING:
        "\u9593\u9694\u306E\u6700\u5927\u5024\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    MAX_LINK_CONTRIB:
        "\u30EA\u30F3\u30AF\u30B3\u30F3\u30C8\u30EA\u30D3\u30E5\u30FC\u30B7\u30E7\u30F3\u306E\u6700\u5927\u5024",
    MAX_LINK_CONTRIB_DESC:
        "\u6700\u521D\u306E\u6613\u3057\u3055\u306B\u5BFE\u3057\u3066\u3001\u30EA\u30F3\u30AF\u3055\u308C\u305F\u30CE\u30FC\u30C8\u306E\u91CD\u307F\u4ED8\u3051\u3055\u308C\u305F\u6613\u3057\u3055\u304C\u5BC4\u4E0E\u3059\u308B\u6700\u5927\u5024\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    LOGGING: "\u30ED\u30B0\u7BA1\u7406",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u3066\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u8868\u793A\u3057\u307E\u3059\u304B",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "\u30CE\u30FC\u30C8\u30EC\u30D3\u30E5\u30FC\u306E\u30AD\u30E5\u30FC",
    CLOSE: "\u9589\u3058\u308B",
    NEW: "\u65B0\u898F",
    YESTERDAY: "\u6628\u65E5",
    TODAY: "\u4ECA\u65E5",
    TOMORROW: "\u660E\u65E5",
    // stats-modal.tsx
    STATS_TITLE: "\u7D71\u8A08",
    MONTH: "Month",
    QUARTER: "Quarter",
    YEAR: "Year",
    LIFETIME: "Lifetime",
    FORECAST: "\u4E88\u6E2C",
    FORECAST_DESC: "\u5FA9\u7FD2\u671F\u65E5\u304C\u6765\u308B\u30AB\u30FC\u30C9\u306E\u679A\u6570",
    SCHEDULED: "\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u6E08\u307F",
    DAYS: "\u65E5",
    NUMBER_OF_CARDS: "\u30AB\u30FC\u30C9\u6570",
    REVIEWS_PER_DAY: "\u5E73\u5747: ${avg}\u30EC\u30D3\u30E5\u30FC/\u65E5",
    INTERVALS: "\u9593\u9694",
    INTERVALS_DESC: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u4E88\u5B9A\u65E5",
    COUNT: "\u30AB\u30A6\u30F3\u30C8",
    INTERVALS_SUMMARY:
        "\u9593\u9694\u306E\u5E73\u5747\u5024: ${avg}, \u6700\u9577\u306E\u9593\u9694: ${longest}",
    EASES: "\u6613\u3057\u3055",
    EASES_SUMMARY: "\u6613\u3057\u3055\u306E\u5E73\u5747\u5024: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "\u30AB\u30FC\u30C9\u30BF\u30A4\u30D7",
    CARD_TYPES_DESC:
        "\u5EF6\u671F\u306E\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u306F\u3053\u308C\u306B\u542B\u307E\u308C\u307E\u3059",
    CARD_TYPE_NEW: "\u65B0\u898F",
    CARD_TYPE_YOUNG: "\u5FA9\u7FD2(\u521D\u671F)",
    CARD_TYPE_MATURE: "\u5FA9\u7FD2(\u5F8C\u671F)",
    CARD_TYPES_SUMMARY: "\u30AB\u30FC\u30C9\u306E\u5408\u8A08: ${totalCardsCount}\u679A",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/ko.ts
var ko_default = {
    // flashcard-modal.tsx
    DECKS: "\uB371",
    DUE_CARDS: "\uB2E4\uC2DC \uBCFC \uCE74\uB4DC\uB4E4",
    NEW_CARDS: "\uC0C8\uB85C\uC6B4 \uCE74\uB4DC\uB4E4",
    TOTAL_CARDS: "\uC804\uCCB4 \uCE74\uB4DC\uB4E4",
    BACK: "Back",
    SKIP: "Skip",
    EDIT_CARD: "Edit Card",
    RESET_CARD_PROGRESS:
        "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC744 \uCD08\uAE30\uD654\uD569\uB2C8\uB2E4.",
    HARD: "\uC5B4\uB824\uC6C0(Hard)",
    GOOD: "\uC88B\uC74C(Good)",
    EASY: "\uC26C\uC6C0(Easy)",
    SHOW_ANSWER: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30",
    CARD_PROGRESS_RESET:
        "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC774 \uCD08\uAE30\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
    SAVE: "Save",
    CANCEL: "Cancel",
    NO_INPUT: "No input provided.",
    CURRENT_EASE_HELP_TEXT: "Current Ease: ",
    CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
    CARD_GENERATED_FROM: "Generated from: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uC5F4\uAE30",
    REVIEW_CARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0",
    REVIEW_DIFFICULTY_FILE_MENU: "\uB9AC\uBDF0: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD:
        "\uB178\uD2B8\uB97C ${difficulty}\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
    REVIEW_ALL_CARDS:
        "\uBAA8\uB4E0 \uB178\uD2B8\uB4E4\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
    CRAM_ALL_CARDS: "Select a deck to cram",
    REVIEW_CARDS_IN_NOTE:
        "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
    CRAM_CARDS_IN_NOTE:
        "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uBCBC\uB77D\uCE58\uAE30\uD569\uB2C8\uB2E4.",
    VIEW_STATS: "\uD1B5\uACC4 \uD655\uC778",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "--\uB9AC\uBDF0: ${dueNotesCount} \uB178\uD2B8, ${dueFlashcardsCount} \uCE74\uB4DC \uB0A8\uC558\uC2B5\uB2C8\uB2E4.",
    SYNC_TIME_TAKEN:
        "\uB3D9\uAE30\uD654\uC5D0 ${t}\uBC00\uB9AC\uCD08 \uAC78\uB838\uC2B5\uB2C8\uB2E4",
    NOTE_IN_IGNORED_FOLDER:
        "\uB178\uD2B8\uAC00 \uBB34\uC2DC\uB41C \uD3F4\uB354 \uC544\uB798\uC5D0 \uC800\uC7A5\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
    PLEASE_TAG_NOTE:
        "\uB9AC\uBDF0\uB97C \uD558\uAE30\uC704\uD574 \uB178\uD2B8\uC5D0 \uC801\uC808\uD788 \uD0DC\uADF8\uD574\uC8FC\uC138\uC694. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
    RESPONSE_RECEIVED: "\uC694\uCCAD\uC774 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
    NO_DECK_EXISTS:
        "${deckName}\uC774\uB77C\uB294 \uC774\uB984\uC758 \uB371\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
    ALL_CAUGHT_UP: "\uBAA8\uB450 \uD655\uC778\uD588\uC2B5\uB2C8\uB2E4. :D",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} \uC77C \uD6C4",
    MONTHS_STR_IVL: "${interval} \uAC1C\uC6D4 \uD6C4",
    YEARS_STR_IVL: "${interval} \uB144 \uD6C4",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}y",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI:
        '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${wikiUrl}">wiki</a>\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "\uBB34\uC2DC\uD560 \uD3F4\uB354\uB4E4",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC",
    FLASHCARD_EASY_LABEL: "Easy Button Text",
    FLASHCARD_GOOD_LABEL: "Good Button Text",
    FLASHCARD_HARD_LABEL: "Hard Button Text",
    FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
    FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
    FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8",
    FLASHCARD_TAGS_DESC:
        "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#flashcards #deck2 #deck3'",
    CONVERT_FOLDERS_TO_DECKS:
        "\uD3F4\uB354\uB97C \uB371\uACFC \uC11C\uBE0C\uB371\uC73C\uB85C \uC0AC\uC6A9\uD560\uAE4C\uC694?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "\uC774 \uAE30\uB2A5\uC740 \uC704\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8 \uC635\uC158\uC744 \uB300\uCCB4\uD569\uB2C8\uB2E4.",
    INLINE_SCHEDULING_COMMENTS:
        "\uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB9C8\uC9C0\uB9C9 \uC904\uACFC \uB3D9\uC77C\uD55C \uC904\uC5D0 \uC2A4\uCF00\uC904\uB9C1 \uCF54\uBA58\uD2B8\uB97C \uC800\uC7A5\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "\uC774 \uC635\uC158\uC744 \uC0AC\uC6A9\uD558\uBA74 HTML \uC8FC\uC11D\uC774 \uBAA9\uB85D\uC758 \uD3EC\uB9E4\uD305\uC744 \uBB34\uB108\uD2B8\uB9AC\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "Sibling \uCE74\uB4DC\uB97C \uB2E4\uC74C\uB0A0\uAE4C\uC9C0 \uBB3B\uC5B4\uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Sibling \uCE74\uB4DC\uB294 \uB3D9\uC77C\uD55C \uCE74\uB4DC \uD14D\uC2A4\uD2B8\uC5D0\uC11C \uC0DD\uC131\uB41C \uCE74\uB4DC\uC785\uB2C8\uB2E4. i.e. cloze deletions",
    SHOW_CARD_CONTEXT:
        "\uCE74\uB4DC\uC758 \uBB38\uB9E5(context)\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    SHOW_CARD_CONTEXT_DESC:
        "\uCE74\uB4DC\uC5D0\uC11C 'Title > Heading 1 > Subheading > ... > Subheading' \uC758 \uD45C\uC2DC\uB97C \uD560\uC9C0 \uC124\uC815\uD569\uB2C8\uB2E4.",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB192\uC774 \uBE44\uC728",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\uBAA8\uBC14\uC77C \uBC84\uC804 \uD639\uC740 \uB9E4\uC6B0 \uD070 \uC774\uBBF8\uC9C0\uAC00 \uC788\uB294 \uACBD\uC6B0 100%\uB85C \uC124\uC815\uD574\uC57C \uD569\uB2C8\uB2E4.",
    RESET_DEFAULT: "\uAE30\uBCF8\uAC12\uC73C\uB85C \uCD08\uAE30\uD654",
    CARD_MODAL_WIDTH_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB108\uBE44 \uBE44\uC728",
    RANDOMIZE_CARD_ORDER:
        "\uB9AC\uBDF0\uC911\uC778 \uCE74\uB4DC\uC758 \uC21C\uC11C\uB97C \uB79C\uB364\uC73C\uB85C \uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS:
        "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uCE74\uB4DC\uB97C \uBE44\uD65C\uC131\uD654\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    CONVERT_HIGHLIGHTS_TO_CLOZES:
        "==highlights== \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
    CONVERT_BOLD_TEXT_TO_CLOZES:
        "**bolded text** \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "{{curly brackets}} \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
    CLOZE_PATTERNS: "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134",
    CLOZE_PATTERNS_DESC:
        '\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC904\uBC14\uAFC8\uC73C\uB85C \uAD6C\uBD84\uD569\uB2C8\uB2E4. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\uC8FC\uC758: \uC774 \uC635\uC158\uC744 \uC218\uC815\uD55C \uD6C4\uC5D0\uB294 \uC774\uBBF8 \uC791\uC131\uB41C \uD50C\uB798\uC2DC\uCE74\uB4DC\uB97C \uC218\uB3D9\uC73C\uB85C \uC218\uC815\uD574\uC57C \uD568\uC744 \uC8FC\uC758\uD558\uC2ED\uC2DC\uC624.",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "\uC778\uB77C\uC778 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
    MULTILINE_CARDS_SEPARATOR:
        "\uC5EC\uB7EC \uC904 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\uC5EC\uB7EC \uC904 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
    MULTILINE_CARDS_END_MARKER:
        "\uD074\uB85C\uC988\uC640 \uB2E4\uC911 \uD589 \uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB05D\uC744 \uB098\uD0C0\uB0B4\uB294 \uBB38\uC790",
    NOTES: "\uB178\uD2B8",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
    TAGS_TO_REVIEW: "\uB9AC\uBDF0\uC5D0 \uC0AC\uC6A9\uD560 \uD0DC\uADF8",
    TAGS_TO_REVIEW_DESC:
        "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#review #tag2 #tag3'",
    OPEN_RANDOM_NOTE:
        "\uB9AC\uBDF0\uB97C \uC704\uD574 \uB79C\uB364 \uB178\uD2B8\uB97C \uC5FD\uB2C8\uB2E4.",
    OPEN_RANDOM_NOTE_DESC:
        "\uC774 \uC635\uC158\uC774 \uAEBC\uC838\uC788\uC73C\uBA74, \uB178\uD2B8\uB294 \uC911\uC694\uB3C4(\uD398\uC774\uC9C0 \uB7AD\uD06C)\uC5D0 \uB530\uB77C \uC815\uB82C\uB429\uB2C8\uB2E4.",
    AUTO_NEXT_NOTE:
        "\uB9AC\uBDF0 \uD6C4\uC5D0 \uB2E4\uC74C \uB178\uD2B8\uB97C \uC790\uB3D9\uC73C\uB85C \uC5FD\uB2C8\uB2E4.",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C \uAC80\uD1A0 \uC635\uC158\uC744 \uD65C\uC131\uD654\uD558\uC138\uC694 (\uC608: \uAC80\uD1A0: \uC26C\uC6C0, \uC88B\uC74C, \uC5B4\uB824\uC6C0)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C \uAC80\uD1A0 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654\uD558\uBA74 \uD50C\uB7EC\uADF8\uC778 \uBA85\uB839\uC744 \uC0AC\uC6A9\uD574 \uB178\uD2B8\uB97C \uAC80\uD1A0\uD560 \uC218 \uC788\uC73C\uBA70, \uC815\uC758\uB41C \uACBD\uC6B0\uC5D0\uB294 \uAD00\uB828\uB41C \uB2E8\uCD95\uD0A4\uB3C4 \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
    MAX_N_DAYS_REVIEW_QUEUE:
        "\uC624\uB978\uCABD \uD328\uB110\uC5D0 \uD45C\uC2DC\uD560 \uCD5C\uB300 \uC77C\uC218",
    MIN_ONE_DAY: "\uC801\uC5B4\uB3C4 1\uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
    VALID_NUMBER_WARNING:
        "\uC720\uD6A8\uD55C \uC22B\uC790\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\uB371 \uD2B8\uB9AC\uB294 \uCC98\uC74C\uC5D0 \uD655\uC7A5\uB41C \uAC83\uC73C\uB85C \uD45C\uC2DC\uB418\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "\uAC19\uC740 \uCE74\uB4DC\uC5D0 \uC911\uCCA9\uB41C \uB371\uC744 \uC811\uC73C\uB824\uBA74 \uC774 \uC635\uC158\uC744 \uB044\uC2ED\uC2DC\uC624. \uAC19\uC740 \uD30C\uC77C\uC5D0 \uC5EC\uB7EC \uB371\uC5D0 \uC18D\uD55C \uCE74\uB4DC\uAC00 \uC788\uB294 \uACBD\uC6B0 \uC720\uC6A9\uD569\uB2C8\uB2E4.",
    ALGORITHM: "\uC54C\uACE0\uB9AC\uC998",
    CHECK_ALGORITHM_WIKI:
        '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${algoUrl}">algorithm details</a>\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "\uAE30\uBCF8 ease",
    BASE_EASE_DESC:
        "\uCD5C\uC19F\uAC12 = 130, \uC801\uC815\uCE58\uB294 \uB300\uB7B5 250\uC785\uB2C8\uB2E4.",
    BASE_EASE_MIN_WARNING:
        "\uAE30\uBCF8 ease\uB294 \uC801\uC5B4\uB3C4 130 \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
    LAPSE_INTERVAL_CHANGE:
        "\uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(Hard)\uC73C\uB85C \uB9AC\uBDF0\uD588\uC744 \uB54C\uC758 \uAC04\uACA9 \uBCC0\uACBD",
    LAPSE_INTERVAL_CHANGE_DESC:
        "\uC0C8\uB85C\uC6B4 \uAC04\uACA9 = \uC774\uC804 \uAC04\uACA9 * \uAC04\uACA9\uBCC0\uACBD \uAC12 / 100.",
    EASY_BONUS: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4",
    EASY_BONUS_DESC:
        "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uC5D0\uC11C \uC88B\uC74C(Good)\uACFC \uC26C\uC6C0(Easy) \uC0AC\uC774\uC758 \uAC04\uACA9 \uCC28\uC774\uB97C \uC124\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uCD5C\uC18C = 100%)",
    EASY_BONUS_MIN_WARNING:
        "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uC801\uC5B4\uB3C4 100\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maximum interval in days",
    MAX_INTERVAL_DESC:
        "\uAC04\uACA9\uC758 \uC0C1\uD55C\uC120\uC744 \uB458 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uAE30\uBCF8\uAC12 = 100\uB144)",
    MAX_INTERVAL_MIN_WARNING:
        "\uCD5C\uB300 \uAC04\uACA9\uC740 \uC801\uC5B4\uB3C4 1\uC77C\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
    MAX_LINK_CONTRIB: "\uCD5C\uB300 \uC5F0\uACB0 \uAE30\uC5EC\uB3C4",
    MAX_LINK_CONTRIB_DESC:
        "\uB9C1\uD06C\uB41C \uB178\uD2B8\uC758 \uCD08\uAE30 ease\uC5D0 \uB300\uD55C \uAC00\uC911\uCE58\uAC00 \uC801\uC6A9\uB41C ease\uC758 \uCD5C\uB300 \uAE30\uC5EC\uB3C4\uC785\uB2C8\uB2E4.",
    LOGGING: "\uB85C\uAE45",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\uB514\uBC84\uAE45 \uC815\uBCF4\uB97C \uAC1C\uBC1C\uC790 \uCF58\uC194\uC5D0 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uB300\uAE30\uC5F4",
    CLOSE: "\uB2EB\uAE30",
    NEW: "New",
    YESTERDAY: "\uC5B4\uC81C",
    TODAY: "\uC624\uB298",
    TOMORROW: "\uB0B4\uC77C",
    // stats-modal.tsx
    STATS_TITLE: "\uD1B5\uACC4",
    MONTH: "\uC6D4",
    QUARTER: "\uBD84\uAE30",
    YEAR: "\uB144",
    LIFETIME: "\uD3C9\uC0DD",
    FORECAST: "\uC608\uCE21",
    FORECAST_DESC: "\uC774\uD6C4\uC5D0 \uD559\uC2B5\uD560 \uCE74\uB4DC\uC758 \uC218",
    SCHEDULED: "Scheduled",
    DAYS: "\uC77C",
    NUMBER_OF_CARDS: "\uCE74\uB4DC\uC758 \uC218",
    REVIEWS_PER_DAY: "\uD3C9\uADE0: ${avg} \uB9AC\uBDF0/\uC77C",
    INTERVALS: "\uAC04\uACA9",
    INTERVALS_DESC: "\uB9AC\uBDF0\uB97C \uB2E4\uC2DC \uD560 \uB54C \uAE4C\uC9C0\uC758 \uAE30\uAC04",
    COUNT: "Count",
    INTERVALS_SUMMARY:
        "\uD3C9\uADE0 \uAC04\uACA9: ${avg}, \uAC00\uC7A5 \uAE34 \uAC04\uACA9: ${longest}",
    EASES: "Eases",
    EASES_SUMMARY: "Average ease: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "\uCE74\uB4DC \uD0C0\uC785",
    CARD_TYPES_DESC:
        "\uC5EC\uAE30\uC5D0\uB294 \uBB3B\uC5B4\uB454 \uCE74\uB4DC\uB3C4 \uD3EC\uD568\uB429\uB2C8\uB2E4.",
    CARD_TYPE_NEW: "New",
    CARD_TYPE_YOUNG: "Young",
    CARD_TYPE_MATURE: "Mature",
    CARD_TYPES_SUMMARY: "\uC804\uCCB4 \uCE74\uB4DC \uC218: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/mr.ts
var mr_default = {};

// src/lang/locale/nl.ts
var nl_default = {
    // flashcard-modal.tsx
    DECKS: "Stapel",
    DUE_CARDS: "Te beoordelen kaarten",
    NEW_CARDS: "Nieuwe kaarten",
    TOTAL_CARDS: "Totaal aantal kaarten",
    BACK: "Terug",
    SKIP: "Overslaan",
    EDIT_CARD: "Kaart bewerken",
    RESET_CARD_PROGRESS: "Voortgang van kaart resetten",
    HARD: "Moeilijk",
    GOOD: "Goed",
    EASY: "Gemakkelijk",
    SHOW_ANSWER: "Toon antwoord",
    CARD_PROGRESS_RESET: "Voortgang van kaart is gereset.",
    SAVE: "Opslaan",
    CANCEL: "Annuleren",
    NO_INPUT: "Geen invoer opgegeven.",
    CURRENT_EASE_HELP_TEXT: "Huidige Moeilijkheid: ",
    CURRENT_INTERVAL_HELP_TEXT: "Huidige Interval: ",
    CARD_GENERATED_FROM: "Gegenereerd van: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Open een notitie voor beoordeling",
    REVIEW_CARDS: "Beoordeel flitskaarten",
    REVIEW_DIFFICULTY_FILE_MENU: "Beoordelen: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Beoordeel notitie als ${difficulty}",
    CRAM_ALL_CARDS: "Selecteer een stapel om te stampen",
    REVIEW_ALL_CARDS: "Beoordeel flitskaarten van alle notities",
    REVIEW_CARDS_IN_NOTE: "Beoordeel flitskaarten in deze notitie",
    CRAM_CARDS_IN_NOTE: "Stamp flitskaarten in deze notitie",
    VIEW_STATS: "Bekijk statistieken",
    OPEN_REVIEW_QUEUE_VIEW: "Open notities beoordelingswachtrij in zijbalk",
    STATUS_BAR:
        "Beoordeling: ${dueNotesCount} notitie(s), ${dueFlashcardsCount} kaart(en) te beoordelen",
    SYNC_TIME_TAKEN: "Synchronisatie duurde ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "Notitie is opgeslagen in een genegeerde map (controleer instellingen).",
    PLEASE_TAG_NOTE: "Tag de notitie correct voor beoordeling (in instellingen).",
    RESPONSE_RECEIVED: "Reactie ontvangen.",
    NO_DECK_EXISTS: "Er bestaat geen stapel voor ${deckName}",
    ALL_CAUGHT_UP: "Je bent nu helemaal bij :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} dag(en)",
    MONTHS_STR_IVL: "${interval} maand(en)",
    YEARS_STR_IVL: "${interval} jaar",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}j",
    // settings.ts
    SETTINGS_HEADER: "Gespreide Herhaling",
    GROUP_TAGS_FOLDERS: "Tags & Mappen",
    GROUP_FLASHCARD_REVIEW: "Flitskaart Beoordeling",
    GROUP_FLASHCARD_SEPARATORS: "Flitskaart Scheidingstekens",
    GROUP_DATA_STORAGE: "Opslag van planningsgegevens",
    GROUP_DATA_STORAGE_DESC: "Kies waar de planningsgegevens worden opgeslagen",
    GROUP_FLASHCARDS_NOTES: "Flitskaarten & Notities",
    GROUP_CONTRIBUTING: "Bijdragen",
    CHECK_WIKI: 'Voor meer informatie, bekijk de <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Bezoek de <a href="${discussionsUrl}">discussies</a> sectie voor Q&A hulp, feedback, en algemene discussie.',
    GITHUB_ISSUES:
        'Meld een probleem <a href="${issuesUrl}">hier</a> als je een functieverzoek of een bugrapport hebt.',
    GITHUB_SOURCE_CODE:
        'De broncode van het project is beschikbaar op <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Hier</a> lees je hoe je code kunt bijdragen aan de plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Hier</a> lees je hoe je de plugin in een andere taal kunt vertalen.',
    FOLDERS_TO_IGNORE: "Mappen om te negeren",
    FOLDERS_TO_IGNORE_DESC:
        "Voer mappaden of globpatronen in op aparte regels, bijvoorbeeld Templates/Scripts of **/*.excalidraw.md. Deze instelling is gemeenschappelijk voor zowel flitskaarten als notities.",
    OBSIDIAN_INTEGRATION: "Integratie in Obsidian",
    FLASHCARDS: "Flitskaarten",
    FLASHCARD_EASY_LABEL: "Gemakkelijk-knoptekst",
    FLASHCARD_GOOD_LABEL: "Goed-knoptekst",
    FLASHCARD_HARD_LABEL: "Moeilijk-knoptekst",
    FLASHCARD_EASY_DESC: 'Pas het label aan voor de "Gemakkelijk" knop',
    FLASHCARD_GOOD_DESC: 'Pas het label aan voor de "Goed" knop',
    FLASHCARD_HARD_DESC: 'Pas het label aan voor de "Moeilijk" knop',
    REVIEW_BUTTON_DELAY: "Vertraging knopindrukken (ms)",
    REVIEW_BUTTON_DELAY_DESC:
        "Voeg een vertraging toe aan de beoordelingsknoppen voordat ze opnieuw kunnen worden ingedrukt.",
    FLASHCARD_TAGS: "Flitskaarttags",
    FLASHCARD_TAGS_DESC:
        "Voer tags in, gescheiden door spaties of nieuwe regels, bijvoorbeeld #flitskaarten #stapel2 #stapel3.",
    CONVERT_FOLDERS_TO_DECKS: "Converteer mappen naar stapels en substapels",
    CONVERT_FOLDERS_TO_DECKS_DESC: "Dit is een alternatief voor de optie flitskaarttags hierboven.",
    INLINE_SCHEDULING_COMMENTS:
        "Planningsopmerking opslaan op dezelfde regel als de laatste regel van de flitskaart?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Als u dit inschakelt, wordt de opmaak van de lijst niet verbroken door de HTML-opmerkingen.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Begraaf de broer-/zuskaarten tot de volgende dag",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Broer-/zuskaarten zijn kaarten die zijn gegenereerd uit dezelfde kaarttekst, bijvoorbeeld cloze-deleties",
    SHOW_CARD_CONTEXT: "Toon context in kaarten",
    SHOW_CARD_CONTEXT_DESC: "Bijv. Titel > Kop 1 > Subkop > ... > Subkop",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Toon volgende herzieningstijd in de beoordelingsknoppen",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Handig om te weten hoe ver in de toekomst je kaarten worden uitgesteld.",
    CARD_MODAL_HEIGHT_PERCENT: "Flitskaart hoogtepercentage",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Moet worden ingesteld op 100% op mobiel of als je zeer grote afbeeldingen hebt",
    RESET_DEFAULT: "Reset naar standaard",
    CARD_MODAL_WIDTH_PERCENT: "Flitskaart breedtepercentage",
    RANDOMIZE_CARD_ORDER: "Flitskaartvolgorde willekeurig tijdens herziening?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Volgorde van kaarten in een stapel tijdens herziening",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "Opeenvolgend binnen een stapel (Alle nieuwe kaarten eerst)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "Opeenvolgend binnen een stapel (Alle kaarten die aan de beurt zijn eerst)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Willekeurig binnen een stapel (Alle nieuwe kaarten eerst)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "Willekeurig binnen een stapel (Alle kaarten die aan de beurt zijn eerst)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Willekeurige kaart uit willekeurige stapel",
    REVIEW_DECK_ORDER: "Volgorde waarin stapels worden weergegeven tijdens herziening",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Opeenvolgend (als alle kaarten in de vorige stapel zijn herzien)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Willekeurig (als alle kaarten in de vorige stapel zijn herzien)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Willekeurige kaart uit willekeurige stapel",
    DISABLE_CLOZE_CARDS: "Cloze-kaarten uitschakelen?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Converteer ==highlights== naar clozes",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Voeg de <code>${defaultPattern}</code> toe aan/verwijder deze uit uw "Cloze-patronen"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Converteer **vetgedrukte tekst** naar clozes",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Voeg de <code>${defaultPattern}</code> toe aan/verwijder deze uit uw "Cloze-patronen"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Converteer {{accolades}} naar clozes",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Voeg de <code>${defaultPattern}</code> toe aan/verwijder deze uit uw "Cloze-patronen"',
    CLOZE_PATTERNS: "Cloze-patronen",
    CLOZE_PATTERNS_DESC:
        'Voer cloze-patronen in, gescheiden door nieuwe regels. Raadpleeg de <a href="${docsUrl}">wiki</a> voor meer informatie.',
    INLINE_CARDS_SEPARATOR: "Scheidingsteken voor inline flitskaarten",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Houd er rekening mee dat u na het wijzigen hiervan handmatig alle flitskaarten die u al hebt, moet bewerken.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Scheidingsteken voor inline omgekeerde flitskaarten",
    MULTILINE_CARDS_SEPARATOR: "Scheidingsteken voor meerregelige flitskaarten",
    MULTILINE_REVERSED_CARDS_SEPARATOR: "Scheidingsteken voor meerregelige omgekeerde flitskaarten",
    MULTILINE_CARDS_END_MARKER:
        "Tekens die het einde van clozes en meerregelige flitskaarten aangeven",
    NOTES: "Notities",
    NOTE: "Notitie",
    REVIEW_PANE_ON_STARTUP: "Notitiebeoordelingsvenster inschakelen bij opstarten",
    TAGS_TO_REVIEW: "Tags om te beoordelen",
    TAGS_TO_REVIEW_DESC:
        "Voer tags in, gescheiden door spaties of nieuwe regels, bijv. #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Open een willekeurige notitie voor beoordeling",
    OPEN_RANDOM_NOTE_DESC:
        "Wanneer u dit uitschakelt, worden notities geordend op belangrijkheid (PageRank).",
    AUTO_NEXT_NOTE: "Open automatisch de volgende notitie na een beoordeling",
    MAX_N_DAYS_REVIEW_QUEUE:
        "Maximum aantal dagen om weer te geven in het notitiebeoordelingspaneel",
    MIN_ONE_DAY: "Het aantal dagen moet minimaal 1 zijn.",
    VALID_NUMBER_WARNING: "Geef een geldig getal op.",
    UI: "Gebruikersinterface",
    OPEN_IN_TAB: "Open in nieuw tabblad",
    OPEN_IN_TAB_DESC: "Schakel dit uit om de plugin in een modaal venster te openen",
    SHOW_STATUS_BAR: "Statusbalk weergeven",
    SHOW_STATUS_BAR_DESC:
        "Schakel dit uit om de beoordelingsstatus van de flitskaart te verbergen in de statusbalk van Obsidian",
    SHOW_RIBBON_ICON: "Pictogram weergeven in de lintbalk",
    SHOW_RIBBON_ICON_DESC:
        "Schakel dit uit om het pictogram van de plugin in de lintbalk van Obsidian te verbergen",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Schakel de beoordelingsopties in het bestandsmenu in (bijv. Beoordelen: Gemakkelijk, Goed, Moeilijk)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Schakel deze optie uit om uw notities te beoordelen met behulp van de plugin-opdrachten en, indien gedefinieerd, de bijbehorende sneltoetsen voor opdrachten.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Stapelstructuren: Vouw substapels aanvankelijk uit",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Schakel dit uit om geneste stapels in dezelfde kaart samen te vouwen. Handig als je kaarten hebt die tot meerdere stapels in hetzelfde bestand behoren.",
    ALGORITHM: "Algoritme",
    CHECK_ALGORITHM_WIKI:
        'Voor meer informatie, bekijk de <a href="${algoUrl}">algoritmedetails</a>.',
    SM2_OSR_VARIANT: "OSR's variant van SM-2",
    BASE_EASE: "Basisgemak",
    BASE_EASE_DESC: "minimum = 130, bij voorkeur ongeveer 250.",
    BASE_EASE_MIN_WARNING: "Het basisgemak moet minimaal 130 zijn.",
    LAPSE_INTERVAL_CHANGE:
        "Intervalwijziging wanneer u een flitskaart/notitie als moeilijk beoordeelt",
    LAPSE_INTERVAL_CHANGE_DESC: "nieuwInterval = oudInterval * intervalWijziging / 100.",
    EASY_BONUS: "Gemakkelijk Bonus",
    EASY_BONUS_DESC:
        "De Gemakkelijk Bonus stelt u in staat het verschil in intervallen in te stellen tussen het beantwoorden van Goed en Gemakkelijk op een flitskaart/notitie (minimum = 100%).",
    EASY_BONUS_MIN_WARNING: "De Gemakkelijk Bonus moet minimaal 100 zijn.",
    LOAD_BALANCE: "Schakel load balancer in",
    LOAD_BALANCE_DESC: `Het interval wordt iets aangepast, zodat het aantal beoordelingen per dag consistenter is.
        Het is vergelijkbaar met Anki's fuzz, maar in plaats van willekeurig te zijn, kiest het de dag met het minste aantal beoordelingen.
        Het is uitgeschakeld voor kleine intervallen.`,
    MAX_INTERVAL: "Maximum interval in dagen",
    MAX_INTERVAL_DESC:
        "Hiermee kunt u een bovengrens voor het interval instellen (standaard = 100 jaar).",
    MAX_INTERVAL_MIN_WARNING: "Het maximale interval moet minimaal 1 dag zijn.",
    MAX_LINK_CONTRIB: "Maximale linkbijdrage",
    MAX_LINK_CONTRIB_DESC:
        "Maximale bijdrage van de gewogen gemak van gekoppelde notities aan het initi\xEBle gemak.",
    LOGGING: "Loggen",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Toon de foutopsporingsinformatie van de planner op de ontwikkelaarsconsole",
    DISPLAY_PARSER_DEBUG_INFO:
        "Toon de foutopsporingsinformatie van de parser op de ontwikkelaarsconsole",
    SCHEDULING: "Plannen",
    EXPERIMENTAL: "Experimenteel",
    HELP: "Help",
    STORE_IN_NOTES: "In de notities",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Notities beoordelingswachtrij",
    CLOSE: "Sluiten",
    NEW: "Nieuw",
    YESTERDAY: "Gisteren",
    TODAY: "Vandaag",
    TOMORROW: "Morgen",
    // stats-modal.tsx
    STATS_TITLE: "Statistieken",
    MONTH: "Maand",
    QUARTER: "Kwartaal",
    YEAR: "Jaar",
    LIFETIME: "Levensduur",
    FORECAST: "Voorspelling",
    FORECAST_DESC: "Het aantal kaarten dat in de toekomst aan de beurt is",
    SCHEDULED: "Gepland",
    DAYS: "Dagen",
    NUMBER_OF_CARDS: "Aantal kaarten",
    REVIEWS_PER_DAY: "Gemiddeld: ${avg} beoordelingen/dag",
    INTERVALS: "Intervallen",
    INTERVALS_DESC: "Vertragingen totdat beoordelingen opnieuw worden weergegeven",
    COUNT: "Aantal",
    INTERVALS_SUMMARY: "Gemiddeld interval: ${avg}, Langste interval: ${longest}",
    EASES: "Gemakken",
    EASES_SUMMARY: "Gemiddeld gemak: ${avgEase}",
    EASE: "Gemak",
    CARD_TYPES: "Kaarttypen",
    CARD_TYPES_DESC: "Dit omvat ook begraven kaarten, indien aanwezig",
    CARD_TYPE_NEW: "Nieuw",
    CARD_TYPE_YOUNG: "Jong",
    CARD_TYPE_MATURE: "Volwassen",
    CARD_TYPES_SUMMARY: "Totaal aantal kaarten: ${totalCardsCount}",
    SEARCH: "Zoeken",
    PREVIOUS: "Vorige",
    NEXT: "Volgende",
};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {
    // flashcard-modal.tsx
    DECKS: "Talie",
    DUE_CARDS: "Fiszki z terminem",
    NEW_CARDS: "Nowe fiszki",
    TOTAL_CARDS: "Wszystkie karty",
    BACK: "Wstecz",
    SKIP: "Pomi\u0144",
    EDIT_CARD: "Edytuj kart\u0119",
    RESET_CARD_PROGRESS: "Zresetuj post\u0119p karty",
    HARD: "Trudne",
    GOOD: "\u015Arednio Trudne",
    EASY: "\u0141atwe",
    SHOW_ANSWER: "Poka\u017C odpowied\u017A",
    CARD_PROGRESS_RESET: "Post\u0119p karty zosta\u0142 zresetowany.",
    SAVE: "Zapisz",
    CANCEL: "Anuluj",
    NO_INPUT: "Nie wprowadzono warto\u015Bci.",
    CURRENT_EASE_HELP_TEXT: "Aktualna \u0142atwo\u015B\u0107: ",
    CURRENT_INTERVAL_HELP_TEXT: "Aktualny interwa\u0142: ",
    CARD_GENERATED_FROM: "Wygenerowano z: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Otw\xF3rz notatk\u0119 do przegl\u0105du",
    REVIEW_CARDS: "Przegl\u0105daj fiszki",
    REVIEW_DIFFICULTY_FILE_MENU: "Przegl\u0105daj: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Przegl\u0105daj notatk\u0119 jako ${difficulty}",
    CRAM_ALL_CARDS: "Wybierz tali\u0119 do intensywnego uczenia",
    REVIEW_ALL_CARDS: "Przegl\u0105daj fiszki ze wszystkich notatek",
    REVIEW_CARDS_IN_NOTE: "Przegl\u0105daj fiszki w tej notatce",
    CRAM_CARDS_IN_NOTE: "Intensywne uczenie fiszek w tej notatce",
    VIEW_STATS: "Wy\u015Bwietl statystyki",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "Przegl\u0105daj: ${dueNotesCount} notatek, ${dueFlashcardsCount} fiszek z terminem",
    SYNC_TIME_TAKEN: "Synchronizacja zaj\u0119\u0142a ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "Notatka jest zapisana w folderze zignorowanym (sprawd\u017A ustawienia).",
    PLEASE_TAG_NOTE:
        "Prosz\u0119 odpowiednio otagowa\u0107 notatk\u0119 do przegl\u0105du (w ustawieniach).",
    RESPONSE_RECEIVED: "Otrzymano odpowied\u017A.",
    NO_DECK_EXISTS: "Nie istnieje talia o nazwie ${deckName}",
    ALL_CAUGHT_UP: "Jeste\u015B teraz na bie\u017C\u0105co :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} dni",
    MONTHS_STR_IVL: "${interval} miesi\u0119cy",
    YEARS_STR_IVL: "${interval} lata",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}r",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI:
        'Aby uzyska\u0107 wi\u0119cej informacji, sprawd\u017A <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Foldery do zignorowania",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Fiszki",
    FLASHCARD_EASY_LABEL: "Tekst przycisku \u0141atwe",
    FLASHCARD_GOOD_LABEL: "Tekst przycisku \u015Arednio trudne",
    FLASHCARD_HARD_LABEL: "Tekst przycisku Trudne",
    FLASHCARD_EASY_DESC: 'Dostosuj etykiet\u0119 dla przycisku "\u0141atwe"',
    FLASHCARD_GOOD_DESC: 'Dostosuj etykiet\u0119 dla przycisku "\u015Arednio trudne"',
    FLASHCARD_HARD_DESC: 'Dostosuj etykiet\u0119 dla przycisku "Trudne"',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Tagi fiszek",
    FLASHCARD_TAGS_DESC:
        "Wprowad\u017A tagi oddzielone spacj\u0105 lub nowymi liniami, np. #fiszki #talia2 #talia3.",
    CONVERT_FOLDERS_TO_DECKS: "Czy konwertowa\u0107 foldery na talie i podtalie?",
    CONVERT_FOLDERS_TO_DECKS_DESC: "Jest to alternatywa dla opcji tag\xF3w fiszek powy\u017Cej.",
    INLINE_SCHEDULING_COMMENTS:
        "Czy zachowa\u0107 komentarz harmonogramowania w tej samej linii co ostatnia linia fiszki?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "W\u0142\u0105czenie tej opcji sprawi, \u017Ce komentarze HTML nie b\u0119d\u0105 przerywa\u0107 formatowania listy.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Czy ukrywa\u0107 karty rodze\u0144stwa do nast\u0119pnego dnia?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Rodze\u0144stwo to karty wygenerowane z tego samego tekstu karty, np. usuni\u0119cia zamaskowane",
    SHOW_CARD_CONTEXT: "Czy pokazywa\u0107 kontekst na kartach?",
    SHOW_CARD_CONTEXT_DESC:
        "np. Tytu\u0142 > Nag\u0142\xF3wek 1 > Podnag\u0142\xF3wek > ... > Podnag\u0142\xF3wek",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Procentowa wysoko\u015B\u0107 fiszki",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Powinno by\u0107 ustawione na 100% na urz\u0105dzeniach mobilnych lub gdy masz bardzo du\u017Ce obrazy",
    RESET_DEFAULT: "Zresetuj do domy\u015Blnych",
    CARD_MODAL_WIDTH_PERCENT: "Procentowa szeroko\u015B\u0107 fiszki",
    RANDOMIZE_CARD_ORDER: "Czy losowa\u0107 kolejno\u015B\u0107 kart podczas przegl\u0105du?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "Kolejno\u015B\u0107 kart w talii wy\u015Bwietlana podczas przegl\u0105dania",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "Kolejno w ramach talii (Najpierw wszystkie nowe karty)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "Kolejno w ramach talii (Najpierw wszystkie karty z terminem)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Losowo w ramach talii (Najpierw wszystkie nowe karty)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "Losowo w ramach talii (Najpierw wszystkie karty z terminem)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Losowa karta z losowej talii",
    REVIEW_DECK_ORDER: "Kolejno\u015B\u0107 talii wy\u015Bwietlana podczas przegl\u0105dania",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Kolejno (gdy wszystkie karty w poprzedniej talii przegl\u0105dni\u0119te)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Losowo (gdy wszystkie karty w poprzedniej talii przegl\u0105dni\u0119te)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Losowa karta z losowej talii",
    DISABLE_CLOZE_CARDS: "Wy\u0142\u0105czy\u0107 karty zamaskowane?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Konwertowa\u0107 ==pod\u015Bwietlenia== na karty zamaskowane?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Konwertowa\u0107 pogrubiony tekst na karty zamaskowane?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Konwertowa\u0107 {{klamry}} na karty zamaskowane?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
    CLOZE_PATTERNS: "Wzory kart zamaskowanych",
    CLOZE_PATTERNS_DESC:
        'Wprowad\u017A wzory kart zamaskowanych oddzielone nowymi liniami. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Separator dla kart zamaskowanych w linii",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Pami\u0119taj, \u017Ce po zmianie tego musisz r\u0119cznie edytowa\u0107 wszystkie karty zamaskowane, kt\xF3re ju\u017C masz.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Separator dla kart zamaskowanych odwr\xF3conych w linii",
    MULTILINE_CARDS_SEPARATOR: "Separator dla kart zamaskowanych wieloliniowych",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "Separator dla kart zamaskowanych odwr\xF3conych wieloliniowych",
    MULTILINE_CARDS_END_MARKER: "Caracteres que denotam o fim de clozes e flashcards multilineares",
    NOTES: "Notatki",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "W\u0142\u0105czy\u0107 panel przegl\u0105du notatek przy starcie",
    TAGS_TO_REVIEW: "Tagi do przegl\u0105du",
    TAGS_TO_REVIEW_DESC:
        "Wprowad\u017A tagi oddzielone spacj\u0105 lub nowymi liniami, np. #przegl\u0105d #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "Otw\xF3rz losow\u0105 notatk\u0119 do przegl\u0105du",
    OPEN_RANDOM_NOTE_DESC:
        "Po wy\u0142\u0105czeniu tej opcji notatki s\u0105 uporz\u0105dkowane wed\u0142ug istotno\u015Bci (PageRank).",
    AUTO_NEXT_NOTE:
        "Automatycznie otwiera\u0107 nast\u0119pn\u0105 notatk\u0119 po przegl\u0105dzie",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Wy\u0142\u0105czy\u0107 opcje przegl\u0105du w menu pliku, tj. Przegl\u0105daj: \u0141atwe Dobrze Trudne",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Je\u015Bli wy\u0142\u0105czysz opcje przegl\u0105du w menu Plik, mo\u017Cesz przegl\u0105da\u0107 swoje notatki za pomoc\u0105 polece\u0144 wtyczki i, je\u015Bli je zdefiniowa\u0142e\u015B, przypisanych skr\xF3t\xF3w klawiszowych.",
    MAX_N_DAYS_REVIEW_QUEUE: "Maksymalna liczba dni do wy\u015Bwietlenia w panelu prawym",
    MIN_ONE_DAY: "Liczba dni musi wynosi\u0107 co najmniej 1.",
    VALID_NUMBER_WARNING: "Podaj prawid\u0142ow\u0105 liczb\u0119.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Podtalie powinny by\u0107 pocz\u0105tkowo wy\u015Bwietlane rozszerzone",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Wy\u0142\u0105cz to, aby zwin\u0105\u0107 zagnie\u017Cd\u017Cone talie w tej samej karcie. Przydatne, je\u015Bli karty nale\u017C\u0105 do wielu talii w tym samym pliku.",
    ALGORITHM: "Algorytm",
    CHECK_ALGORITHM_WIKI:
        'Aby uzyska\u0107 wi\u0119cej informacji, sprawd\u017A <a href="${algoUrl}">implementacj\u0119 algorytmu</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Podstawowa \u0142atwo\u015B\u0107",
    BASE_EASE_DESC: "minimum = 130, preferowana warto\u015B\u0107 to oko\u0142o 250.",
    BASE_EASE_MIN_WARNING: "Podstawowa \u0142atwo\u015B\u0107 musi wynosi\u0107 co najmniej 130.",
    LAPSE_INTERVAL_CHANGE:
        "Zmiana interwa\u0142u podczas przegl\u0105dania fiszki/notatki jako trudne",
    LAPSE_INTERVAL_CHANGE_DESC:
        "nowyInterwa\u0142 = staryInterwa\u0142 * zmianaInterwa\u0142u / 100.",
    EASY_BONUS: "Bonus za \u0142atwe",
    EASY_BONUS_DESC:
        "Bonus za \u0142atwe pozwala ustawi\u0107 r\xF3\u017Cnic\u0119 w interwa\u0142ach mi\u0119dzy odpowiedziami \u015Arednio trudne i \u0141atwe na fiszce/notatce (minimum = 100%).",
    EASY_BONUS_MIN_WARNING: "Bonus za \u0142atwe musi wynosi\u0107 co najmniej 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maksymalny interwa\u0142 w dniach",
    MAX_INTERVAL_DESC:
        "Pozwala na ustawienie g\xF3rnego limitu interwa\u0142u (domy\u015Blnie = 100 lat).",
    MAX_INTERVAL_MIN_WARNING:
        "Maksymalny interwa\u0142 musi wynosi\u0107 co najmniej 1 dzie\u0144.",
    MAX_LINK_CONTRIB: "Maksymalny wk\u0142ad \u0142\u0105cza",
    MAX_LINK_CONTRIB_DESC:
        "Maksymalny wk\u0142ad wa\u017Conej \u0142atwo\u015Bci po\u0142\u0105czonych notatek do pocz\u0105tkowej \u0142atwo\u015Bci.",
    LOGGING: "Logowanie",
    DISPLAY_SCHEDULING_DEBUG_INFO: "Wy\u015Bwietl informacje debugowania w konsoli deweloperskiej",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Kolejka przegl\u0105du notatek",
    CLOSE: "Zamknij",
    NEW: "Nowe",
    YESTERDAY: "Wczoraj",
    TODAY: "Dzisiaj",
    TOMORROW: "Jutro",
    // stats-modal.tsx
    STATS_TITLE: "Statystyki",
    MONTH: "Miesi\u0105c",
    QUARTER: "Kwarta\u0142",
    YEAR: "Rok",
    LIFETIME: "Ca\u0142e \u017Cycie",
    FORECAST: "Prognoza",
    FORECAST_DESC: "Liczba kart z terminem w przysz\u0142o\u015Bci",
    SCHEDULED: "Zaplanowane",
    DAYS: "Dni",
    NUMBER_OF_CARDS: "Liczba kart",
    REVIEWS_PER_DAY: "\u015Arednio: ${avg} przegl\u0105d\xF3w/dzie\u0144",
    INTERVALS: "Interwa\u0142y",
    INTERVALS_DESC: "Op\xF3\u017Anienia przed ponownym pokazaniem przegl\u0105d\xF3w",
    COUNT: "Liczba",
    INTERVALS_SUMMARY:
        "\u015Aredni interwa\u0142: ${avg}, Najd\u0142u\u017Cszy interwa\u0142: ${longest}",
    EASES: "\u0141atwo\u015Bci",
    EASES_SUMMARY: "\u015Arednia \u0142atwo\u015B\u0107: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Typy kart",
    CARD_TYPES_DESC: "Obejmuje tak\u017Ce ukryte karty, je\u015Bli takie s\u0105",
    CARD_TYPE_NEW: "Nowe",
    CARD_TYPE_YOUNG: "M\u0142ode",
    CARD_TYPE_MATURE: "Stare",
    CARD_TYPES_SUMMARY: "\u0141\u0105czna liczba kart: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {
    // flashcard-modal.tsx
    DECKS: "Baralhos",
    DUE_CARDS: "Cartas para Colocar em Dia",
    NEW_CARDS: "Novas Cartas",
    TOTAL_CARDS: "Total de Cartas",
    BACK: "Voltar",
    SKIP: "Pular",
    EDIT_CARD: "Editar Cart\xE3o",
    RESET_CARD_PROGRESS: "Reiniciar o Progresso da Carta",
    HARD: "Dif\xEDcil",
    GOOD: "OK",
    EASY: "F\xE1cil",
    SHOW_ANSWER: "Mostrar Resposta",
    CARD_PROGRESS_RESET: "O Progresso da Carta foi reiniciado",
    SAVE: "Salvar",
    CANCEL: "Cancelar",
    NO_INPUT: "Nenhuma entrada fornecida.",
    CURRENT_EASE_HELP_TEXT: "Facilidade atual: ",
    CURRENT_INTERVAL_HELP_TEXT: "Intervalo atual: ",
    CARD_GENERATED_FROM: "Gerada a partir de: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "Abrir uma nota para revisar",
    REVIEW_CARDS: "Revisar flashcards",
    REVIEW_DIFFICULTY_FILE_MENU: "Revis\xE3o: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Revisar nota como ${difficulty}",
    REVIEW_ALL_CARDS: "Revisar flashcards de todas as notas",
    CRAM_ALL_CARDS: "Selecione um baralho para revisar",
    REVIEW_CARDS_IN_NOTE: "Revisar flashcards nessa nota",
    CRAM_CARDS_IN_NOTE: "Revisar todas as flashcards nessa nota",
    VIEW_STATS: "Ver estat\xEDsticas",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "Revis\xE3o: ${dueNotesCount} nota(s), ${dueFlashcardsCount} Carta(s) para colocar em dia",
    SYNC_TIME_TAKEN: "Sincroniza\xE7\xE3o levou ${t}ms",
    NOTE_IN_IGNORED_FOLDER: "Nota \xE9 salva na pasta ignorada (cheque as configura\xE7\xF5es).",
    PLEASE_TAG_NOTE:
        "Por favor etiquete a nota apropriadamente para revisar (nas configura\xE7\xF5es).",
    RESPONSE_RECEIVED: "Resposta recebida.",
    NO_DECK_EXISTS: "Nenhum baralho existe para ${deckName}",
    ALL_CAUGHT_UP: "Voc\xEA colocou tudo em dia agora :D.",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} dia(s)",
    MONTHS_STR_IVL: "${interval} m\xEAs(es)",
    YEARS_STR_IVL: "${interval} ano(s)",
    DAYS_STR_IVL_MOBILE: "${interval}d",
    MONTHS_STR_IVL_MOBILE: "${interval}m",
    YEARS_STR_IVL_MOBILE: "${interval}a",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: 'Para mais informa\xE7\xF5es, cheque a <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "Pastas para ignorar",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Flashcards",
    FLASHCARD_EASY_LABEL: "Texto do Bot\xE3o de F\xE1cil",
    FLASHCARD_GOOD_LABEL: "Texto do Bot\xE3o de OK",
    FLASHCARD_HARD_LABEL: "Texto do Bot\xE3o de Dif\xEDcil",
    FLASHCARD_EASY_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "F\xE1cil"',
    FLASHCARD_GOOD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "OK"',
    FLASHCARD_HARD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "Dif\xEDcil"',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Etiquetas dos Flashcards",
    FLASHCARD_TAGS_DESC:
        "Insira etiquetas separadas por espa\xE7os ou quebras de linha ex: #flashcards #baralho2 #baralho3.",
    CONVERT_FOLDERS_TO_DECKS: "Converter pastas para baralhos e sub-baralhos?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Isso \xE9 uma alternativa para a op\xE7\xE3o de etiqueta dos Flashcards em cima.",
    INLINE_SCHEDULING_COMMENTS:
        "Salvar coment\xE1rios de agendamento na mesma linha que a \xFAltima linha do flashcard?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Ligar isso vai fazer com que os coment\xE1rios em HTML n\xE3o quebrem a formata\xE7\xE3o de listas.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrar cartas irm\xE3s at\xE9 o pr\xF3ximo dia?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Cartas irm\xE3s s\xE3o geradas pelo texto da mesma carta ex: omiss\xE3o de palavras",
    SHOW_CARD_CONTEXT: "Mostrar contexto nas cartas?",
    SHOW_CARD_CONTEXT_DESC:
        "ex: T\xEDtulo > Cabe\xE7alho 1 > Subcabe\xE7alho > ... > Subcabe\xE7alho",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Porcentagem da Altura do Flashcard",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Deveria estar configurado em 100% em dispositivos m\xF3veis ou se voc\xEA tem imagens muito grandes",
    RESET_DEFAULT: "Reiniciar para a pr\xE9-defini\xE7\xE3o",
    CARD_MODAL_WIDTH_PERCENT: "Porcentagem de Largura do Flashcard",
    RANDOMIZE_CARD_ORDER: "Aleatorizar a ordem das cartas durante a revis\xE3o?",
    REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    REVIEW_DECK_ORDER: "Order decks are displayed during review",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "Sequentially (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Randomly (once all cards in previous deck reviewed)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
    DISABLE_CLOZE_CARDS: "Desabilitar cartas que usam omiss\xE3o de palavras?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "Converter ==marca-texto== em omiss\xF5es?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
    CONVERT_BOLD_TEXT_TO_CLOZES: "Converter **texto em negrito** em omiss\xF5es?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES: "Converter {{chaves}} em omiss\xF5es?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
    CLOZE_PATTERNS: "Padr\xF5es de Omiss\xE3o",
    CLOZE_PATTERNS_DESC:
        'Entre os padr\xF5es de omiss\xE3o separados por quebras de linha. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Separador para flashcards inline",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Note que depois de mudar isso voc\xEA vai ter que manualmente mudar quaisquer flashcards que voc\xEA tenha.",
    INLINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards inline reversos",
    MULTILINE_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas",
    MULTILINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas reversos",
    MULTILINE_CARDS_END_MARKER: "Caracteres que denotam o fim de clozes e flashcards multilinha",
    NOTES: "Notas",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Habilitar painel de revis\xE3o de notas na inicializa\xE7\xE3o",
    TAGS_TO_REVIEW: "Etiquetas para revisar",
    TAGS_TO_REVIEW_DESC:
        "Insira etiquetas separadas por espa\xE7os ou quebra de linhas ex: #revisar #etiqueta2 #etiqueta3.",
    OPEN_RANDOM_NOTE: "Abrir uma nota aleat\xF3ria para revisar",
    OPEN_RANDOM_NOTE_DESC:
        "Quando voc\xEA desabilitar isso, as notas v\xE3o ser ordenadas por import\xE2ncia (PageRank).",
    AUTO_NEXT_NOTE: "Abrir a pr\xF3xima nota automaticamente depois de uma revis\xE3o",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Ative as op\xE7\xF5es de revis\xE3o no menu Arquivo (ex.: Revis\xE3o: F\xE1cil, OK, Dif\xEDcil)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "Se voc\xEA desativar as op\xE7\xF5es de revis\xE3o no menu Arquivo, poder\xE1 revisar suas anota\xE7\xF5es usando os comandos do plugin e, se os tiver definido, as teclas de atalho associadas.",
    MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de dias para exibir no painel direito",
    MIN_ONE_DAY: "O n\xFAmero de dias deve ser pelo menos 1.",
    VALID_NUMBER_WARNING: "Por favor Insira um n\xFAmero v\xE1lido.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\xC1rvores de baralhos devem inicialmente ser exibidas como expandidas",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Desabilite isso para colapsar baralhos que est\xE3o um dentro do outro na mesma carta. \xDAtil se voc\xEA tem cartas que pertencem a muitos baralhos em um mesmo arquivo.",
    ALGORITHM: "Algor\xEDtmo",
    CHECK_ALGORITHM_WIKI:
        'Para mais informa\xE7\xF5es, cheque a <a href="${algoUrl}">implementa\xE7\xE3o do algor\xEDtmo</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Facilidade base",
    BASE_EASE_DESC: "m\xEDnimo = 130, preferivelmente por volta de 250.",
    BASE_EASE_MIN_WARNING: "A facilidade base deve ser pelo menos 130.",
    LAPSE_INTERVAL_CHANGE:
        "Mudan\xE7a de intervalo quando voc\xEA revisa um(a) flashcard/nota como dif\xEDcil",
    LAPSE_INTERVAL_CHANGE_DESC: "novoIntervalo = velhoIntervalo * mudancaIntervalo / 100.",
    EASY_BONUS: "B\xF4nus de F\xE1cil",
    EASY_BONUS_DESC:
        "O b\xF4nus de f\xE1cil te permite mudar a difer\xEAncia entre intervalos de responder OK e F\xE1cil em um(a) flashcard/nota (m\xEDnimo = 100%).",
    EASY_BONUS_MIN_WARNING: "O b\xF4nus de f\xE1cil deve ser pelo menos 100.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Intervalo m\xE1ximo em dias",
    MAX_INTERVAL_DESC:
        "Te permite colocar um limite m\xE1ximo no intervalo (pr\xE9-defini\xE7\xE3o = 100 anos).",
    MAX_INTERVAL_MIN_WARNING: "O intervalo m\xE1ximo deve ser pelo menos 1 dia.",
    MAX_LINK_CONTRIB: "Contribui\xE7\xE3o M\xE1xima de Links",
    MAX_LINK_CONTRIB_DESC:
        "Contribui\xE7\xE3o m\xE1xima da facilidade ponderada das notas linkadas \xE0 facilidade inicial.",
    LOGGING: "Logging",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Mostrar informa\xE7\xE3o de debugging no console de desenvolvimento",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Fila de Notas para Revisar",
    CLOSE: "Fechar",
    NEW: "Novo",
    YESTERDAY: "Ontem",
    TODAY: "Hoje",
    TOMORROW: "Amanh\xE3",
    // stats-modal.tsx
    STATS_TITLE: "Estat\xEDsticas",
    MONTH: "M\xEAs",
    QUARTER: "Trimestre",
    YEAR: "Ano",
    LIFETIME: "Tempo Total",
    FORECAST: "Previs\xE3o",
    FORECAST_DESC: "O n\xFAmero de cartas a serem colocadas em dia no futuro",
    SCHEDULED: "Agendado",
    DAYS: "Dias",
    NUMBER_OF_CARDS: "N\xFAmero de cartas",
    REVIEWS_PER_DAY: "M\xE9dia: ${avg} revis\xF5es/dia",
    INTERVALS: "Intervalos",
    INTERVALS_DESC: "Atrasos at\xE9 que as revis\xF5es sejam exibidas de novo",
    COUNT: "Contagem",
    INTERVALS_SUMMARY: "Intervalo em m\xE9dia: ${avg}, Maior intervalo: ${longest}",
    EASES: "Facilidades",
    EASES_SUMMARY: "Facilidade em m\xE9dia: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Tipos de Cartas",
    CARD_TYPES_DESC: "Isso tamb\xE9m inclui cartas enterradas, caso existam",
    CARD_TYPE_NEW: "Novo",
    CARD_TYPE_YOUNG: "Jovem",
    CARD_TYPE_MATURE: "Amadurecido",
    CARD_TYPES_SUMMARY: "Total de cartas: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {
    // flashcard-modal.tsx
    DECKS: "\u041A\u043E\u043B\u043E\u0434\u044B",
    DUE_CARDS:
        "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    NEW_CARDS: "\u041D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    TOTAL_CARDS: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    BACK: "\u041D\u0430\u0437\u0430\u0434",
    SKIP: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
    EDIT_CARD:
        "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0443",
    RESET_CARD_PROGRESS:
        "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    HARD: "\u0421\u043B\u043E\u0436\u043D\u043E",
    GOOD: "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
    EASY: "\u041B\u0435\u0433\u043A\u043E",
    SHOW_ANSWER: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u0442\u0432\u0435\u0442",
    CARD_PROGRESS_RESET:
        "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    SAVE: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
    CANCEL: "\u041E\u0442\u043C\u0435\u043D\u0430",
    NO_INPUT: "\u041F\u0443\u0441\u0442\u043E\u0439 \u0432\u0432\u043E\u0434.",
    CURRENT_EASE_HELP_TEXT:
        "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: ",
    CURRENT_INTERVAL_HELP_TEXT:
        "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B: ",
    CARD_GENERATED_FROM:
        "\u0421\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E \u0438\u0437: ${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW:
        "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    REVIEW_CARDS:
        "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    REVIEW_DIFFICULTY_FILE_MENU: "\u0418\u0437\u0443\u0447\u0435\u043D\u0438\u0435: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD:
        "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A ${difficulty}",
    CRAM_ALL_CARDS:
        "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u0435",
    REVIEW_ALL_CARDS:
        "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
    REVIEW_CARDS_IN_NOTE:
        "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
    CRAM_CARDS_IN_NOTE:
        "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
    VIEW_STATS:
        "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443",
    OPEN_REVIEW_QUEUE_VIEW:
        "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043E\u0447\u0435\u0440\u0435\u0434\u044C \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u0431\u043E\u043A\u043E\u0432\u043E\u0439 \u043F\u0430\u043D\u0435\u043B\u0438",
    STATUS_BAR:
        "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C: ${dueNotesCount} \u0437\u0430\u043C\u0435\u0442\u043E\u043A, ${dueFlashcardsCount} \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    SYNC_TIME_TAKEN:
        "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u043D\u044F\u043B\u0430 ${t}\u043C\u0441",
    NOTE_IN_IGNORED_FOLDER:
        "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u0443\u044E \u043F\u0430\u043F\u043A\u0443 (\u0441\u043C. \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
    PLEASE_TAG_NOTE:
        "\u0414\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F, \u043F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E \u043F\u043E\u043C\u0435\u0442\u044C\u0442\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0442\u0435\u0433\u043E\u043C (\u0441\u043C. \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
    RESPONSE_RECEIVED: "\u041E\u0442\u0432\u0435\u0442 \u043F\u043E\u043B\u0443\u0447\u0435\u043D.",
    NO_DECK_EXISTS:
        "\u041D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u0440\u043E\u0432\u043D\u044F ${deckName}",
    ALL_CAUGHT_UP:
        "\u041C\u043E\u043B\u043E\u0434\u0435\u0446! \u0422\u044B \u0441\u043F\u0440\u0430\u0432\u0438\u043B\u0441\u044F \u0438 \u0434\u043E\u0448\u0435\u043B \u0434\u043E \u043A\u043E\u043D\u0446\u0430! :D",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} \u0434\u043D\u0435\u0439",
    MONTHS_STR_IVL: "${interval} \u043C\u0435\u0441\u044F\u0446\u0435\u0432",
    YEARS_STR_IVL: "${interval} \u0433\u043E\u0434\u043E\u0432",
    DAYS_STR_IVL_MOBILE: "${interval}\u0434.",
    MONTHS_STR_IVL_MOBILE: "${interval}\u043C.",
    YEARS_STR_IVL_MOBILE: "${interval}\u0433.",
    // settings.ts
    SETTINGS_HEADER: "Spaced Repetition",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI:
        '\u0414\u043B\u044F \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043F\u043E\u0441\u0435\u0442\u0438\u0442\u0435: <a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE:
        "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    FLASHCARD_EASY_LABEL:
        '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u041B\u0435\u0433\u043A\u043E"',
    FLASHCARD_GOOD_LABEL:
        '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E"',
    FLASHCARD_HARD_LABEL:
        '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u0421\u043B\u043E\u0436\u043D\u043E"',
    FLASHCARD_EASY_DESC:
        '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u041B\u0435\u0433\u043A\u043E"',
    FLASHCARD_GOOD_DESC:
        '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E"',
    FLASHCARD_HARD_DESC:
        '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u0421\u043B\u043E\u0436\u043D\u043E"',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "\u0422\u0435\u0433\u0438 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    FLASHCARD_TAGS_DESC:
        "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0442\u0435\u0433\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 Enter-\u043E\u043C \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u043C, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: #flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS:
        "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0432 \u0443\u0440\u043E\u0432\u043D\u0438 \u0438 \u043F\u043E\u0434\u0443\u0440\u043E\u0432\u043D\u0438?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "\u042D\u0442\u043E \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u0430 \u043E\u043F\u0438\u0441\u0430\u043D\u043D\u043E\u043C\u0443 \u0432\u044B\u0448\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0443 \u0442\u0435\u0433\u043E\u0432 \u0444\u043B\u044D\u0448-\u043A\u0430\u0440\u0442",
    INLINE_SCHEDULING_COMMENTS:
        "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0439 \u0441\u0442\u0440\u043E\u043A\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0439 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u0434\u0435\u043B\u0430\u0435\u0442 \u0442\u0430\u043A, \u0447\u0442\u043E HTML \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043C\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430.",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "\u041F\u0440\u044F\u0442\u0430\u0442\u044C \u0440\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u0434\u043D\u044F?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "\u0420\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 - \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u044B \u0438\u0437 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438 ([...])",
    SHOW_CARD_CONTEXT:
        "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 (\u0443\u0440\u043E\u0432\u0435\u043D\u044C) \u0432 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0430\u0445 (\u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F)?",
    SHOW_CARD_CONTEXT_DESC:
        "\u043F\u0440\u0438\u043C\u0435\u0440: Title > Heading 1 > Subheading > ... > Subheading",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT:
        "\u0412\u044B\u0441\u043E\u0442\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\u0415\u0441\u043B\u0438 \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0435\u0441\u044C \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u043C \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u043E\u043C, \u0432\u044B\u0441\u0442\u0430\u0432\u044C\u0442\u0435 100%. \u0418\u043D\u0430\u0447\u0435 \u0443 \u0432\u0430\u0441 \u0431\u0443\u0434\u0443\u0442 \u043E\u0433\u0440\u043E\u043C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
    RESET_DEFAULT:
        "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043E-\u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
    CARD_MODAL_WIDTH_PERCENT:
        "\u0428\u0438\u0440\u0438\u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
    RANDOMIZE_CARD_ORDER:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u044B\u0439 \u043F\u043E\u0440\u044F\u0434\u043E\u043A \u043A\u0430\u0440\u0442 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442 \u043A\u043E\u043B\u043E\u0434\u044B \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u0430\u044F \u043A\u0430\u0440\u0442\u0430 \u0438\u0437 \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u044B",
    REVIEW_DECK_ORDER:
        "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043A\u043E\u043B\u043E\u0434 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E  (\u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0432\u0441\u0435\u0445 \u043A\u0430\u0440\u0442 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439 \u043A\u043E\u043B\u043E\u0434\u044B)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E (\u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0432\u0441\u0435\u0445 \u043A\u0430\u0440\u0442 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439 \u043A\u043E\u043B\u043E\u0434\u044B)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD:
        "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u0430\u044F \u043A\u0430\u0440\u0442\u0430 \u0438\u0437 \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u044B",
    DISABLE_CLOZE_CARDS:
        "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u044B \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
    CONVERT_HIGHLIGHTS_TO_CLOZES:
        "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C ==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442== \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
    CONVERT_BOLD_TEXT_TO_CLOZES:
        "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C **\u0436\u0438\u0440\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442** \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C {{\u0444\u0438\u0433\u0443\u0440\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438}} \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
    CLOZE_PATTERNS:
        "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432",
    CLOZE_PATTERNS_DESC:
        '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u0432\u043E\u0434\u0430\u043C\u0438 \u0441\u0442\u0440\u043E\u043A. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR:
        "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435! \u041F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u0432\u0430\u043C \u043F\u0440\u0438\u0434\u0451\u0442\u0441\u044F \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    MULTILINE_CARDS_SEPARATOR:
        "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    MULTILINE_CARDS_END_MARKER:
        "\u0421\u0438\u043C\u0432\u043E\u043B\u044B, \u043E\u0431\u043E\u0437\u043D\u0430\u0447\u0430\u044E\u0449\u0438\u0435 \u043A\u043E\u043D\u0435\u0446 \u043A\u043B\u043E\u0437\u043E\u0432 \u0438 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    NOTES: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP:
        "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B",
    TAGS_TO_REVIEW:
        "\u0422\u0435\u0433\u0438 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    TAGS_TO_REVIEW_DESC:
        "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433\u0438, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 Enter-\u0430\u043C\u0438 \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u0430\u043C\u0438, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE:
        "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    OPEN_RANDOM_NOTE_DESC:
        "\u0415\u0441\u043B\u0438 \u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C, \u0442\u043E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u044B \u043F\u043E \u0432\u0430\u0436\u043D\u043E\u0441\u0442\u0438 (PageRank).",
    AUTO_NEXT_NOTE:
        "\u041F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043E\u0431\u0437\u043E\u0440\u0430 \u0432 \u043C\u0435\u043D\u044E \u0424\u0430\u0439\u043B (\u0442.\u0435.: \u0418\u0437\u0443\u0447\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E, \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E, \u0421\u043B\u043E\u0436\u043D\u043E)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\u0415\u0441\u043B\u0438 \u0432\u044B \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043E\u0431\u0437\u043E\u0440\u0430 \u0432 \u043C\u0435\u043D\u044E \u0424\u0430\u0439\u043B, \u0432\u044B \u0441\u043C\u043E\u0436\u0435\u0442\u0435 \u043F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044C \u0441\u0432\u043E\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u043A\u043E\u043C\u0430\u043D\u0434 \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u0438, \u0435\u0441\u043B\u0438 \u0432\u044B \u0438\u0445 \u0437\u0430\u0434\u0430\u043B\u0438, \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0433\u043E\u0440\u044F\u0447\u0438\u0445 \u043A\u043B\u0430\u0432\u0438\u0448.",
    MAX_N_DAYS_REVIEW_QUEUE:
        "\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u043F\u0440\u0430\u0432\u0430",
    MIN_ONE_DAY:
        "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
    VALID_NUMBER_WARNING:
        "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0435\u0435 \u0447\u0438\u0441\u043B\u043E.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\u0414\u0435\u0440\u0435\u0432\u044C\u044F \u043A\u043E\u043B\u043E\u0434 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0437\u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u0440\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044B\u0435",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u044D\u0442\u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440, \u0447\u0442\u043E\u0431\u044B \u0441\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u043A\u043E\u043B\u043E\u0434\u044B \u043D\u0430 \u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435. \u041F\u043E\u043B\u0435\u0437\u043D\u043E, \u0435\u0441\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044C \u043A\u0430\u0440\u0442\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043F\u0440\u0438\u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0442 \u043C\u043D\u043E\u0433\u0438\u043C \u043A\u043E\u043B\u043E\u0434\u0430\u043C \u0432 \u043E\u0434\u043D\u043E\u043C \u0444\u0430\u0439\u043B\u0435.",
    ALGORITHM: "\u0410\u043B\u0433\u043E\u0440\u0438\u0442\u043C",
    CHECK_ALGORITHM_WIKI:
        '\u0417\u0430 \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E\u0431\u0440\u0430\u0449\u0430\u0439\u0442\u0435\u0441\u044C \u043A <a href="${algoUrl}">\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE:
        "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C",
    BASE_EASE_DESC:
        "\u043C\u0438\u043D\u0438\u043C\u0443\u043C = 130, \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043E\u043A\u043E\u043B\u043E 250.",
    BASE_EASE_MIN_WARNING:
        "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C 130.",
    LAPSE_INTERVAL_CHANGE:
        '\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u0430 \u043F\u0440\u0438 \u0432\u044B\u0431\u043E\u0440\u0435 "\u0421\u043B\u043E\u0436\u043D\u043E" \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438/\u0437\u0430\u043C\u0435\u0442\u043A\u0438',
    LAPSE_INTERVAL_CHANGE_DESC:
        "\u043D\u043E\u0432\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A = \u0441\u0442\u0430\u0440\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A * \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 / 100.",
    EASY_BONUS: "\u041B\u0435\u0433\u043A\u043E: \u0431\u043E\u043D\u0443\u0441",
    EASY_BONUS_DESC:
        "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u043D\u0438\u0446\u0443 \u0432 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043E\u0442\u0432\u0435\u0442\u0430\u043C\u0438 \u0425\u043E\u0440\u043E\u0448\u043E \u0438 \u041B\u0435\u0433\u043A\u043E \u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435/\u0437\u0430\u043C\u0435\u0442\u043A\u0435 (\u043C\u0438\u043D. = 100%).",
    EASY_BONUS_MIN_WARNING:
        '\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 "\u041B\u0435\u0433\u043A\u043E" \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 100.',
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL:
        "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0432 \u0434\u043D\u044F\u0445",
    MAX_INTERVAL_DESC:
        "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u044E\u044E \u0433\u0440\u0430\u043D\u0438\u0446\u0443 \u043D\u0430 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E = 100 \u043B\u0435\u0442).",
    MAX_INTERVAL_MIN_WARNING:
        "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
    MAX_LINK_CONTRIB:
        "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0432\u044F\u0437\u0438 (\u0441\u0441\u044B\u043B\u043A\u0438)",
    MAX_LINK_CONTRIB_DESC:
        '\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0440\u0435\u0434\u043D\u0435\u0433\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438" \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u0443\u044E "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C".',
    LOGGING: "\u0416\u0443\u0440\u043D\u0430\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u043E\u0442\u043B\u0430\u0434\u043E\u0447\u043D\u0443\u044E \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE:
        "\u041E\u0447\u0435\u0440\u0435\u0434\u044C \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435",
    CLOSE: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
    NEW: "\u041D\u043E\u0432\u044B\u0435",
    YESTERDAY: "\u0412\u0447\u0435\u0440\u0430\u0448\u043D\u0438\u0435",
    TODAY: "\u0421\u0435\u0433\u043E\u0434\u043D\u044F\u0448\u043D\u0438\u0435",
    TOMORROW: "\u0417\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
    // stats-modal.tsx
    STATS_TITLE: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430",
    MONTH: "\u041C\u0435\u0441\u044F\u0446",
    QUARTER: "\u041A\u0432\u0430\u0440\u0442\u0430\u043B",
    YEAR: "\u0413\u043E\u0434",
    LIFETIME: "\u0412\u0441\u0451 \u0432\u0440\u0435\u043C\u044F",
    FORECAST: "\u041F\u0440\u043E\u0433\u043D\u043E\u0437",
    FORECAST_DESC:
        "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0445 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
    SCHEDULED: "\u0417\u0430\u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
    DAYS: "\u0414\u043D\u0438",
    NUMBER_OF_CARDS:
        "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    REVIEWS_PER_DAY:
        "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E: ${avg} \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0439 \u0432 \u0434\u0435\u043D\u044C",
    INTERVALS: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B",
    INTERVALS_DESC:
        "\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
    COUNT: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E",
    INTERVALS_SUMMARY:
        "\u0421\u0440\u0435\u0434\u043D\u0438\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${avg}, \u0421\u0430\u043C\u044B\u0439 \u0434\u043B\u0438\u043D\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${longest}",
    EASES: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
    EASES_SUMMARY:
        "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441\u0430: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "\u0422\u0438\u043F\u044B \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
    CARD_TYPES_DESC:
        "\u0412\u043A\u043B\u044E\u0447\u0430\u044F \u0441\u043F\u0440\u044F\u0442\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0435\u0441\u043B\u0438 \u0442\u0430\u043A\u0438\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0442.",
    CARD_TYPE_NEW: "\u041D\u043E\u0432\u044B\u0445",
    CARD_TYPE_YOUNG: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0445",
    CARD_TYPE_MATURE: "\u0418\u0437\u0443\u0447\u0435\u043D\u043D\u044B\u0445",
    CARD_TYPES_SUMMARY:
        "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/sw.ts
var sw_default = {};

// src/lang/locale/ta.ts
var ta_default = {};

// src/lang/locale/te.ts
var te_default = {};

// src/lang/locale/th.ts
var th_default = {};

// src/lang/locale/tr.ts
var tr_default = {
    // flashcard-modal.tsx
    DECKS: "Desteler",
    DUE_CARDS: "G\xFCncel Kartlar",
    NEW_CARDS: "Yeni Kartlar",
    TOTAL_CARDS: "Toplam Kartlar",
    BACK: "Geri",
    SKIP: "Atla",
    EDIT_CARD: "Kart\u0131 D\xFCzenle",
    RESET_CARD_PROGRESS: "Kart\u0131n ilerlemesini s\u0131f\u0131rla",
    HARD: "Zor",
    GOOD: "Orta",
    EASY: "Kolay",
    SHOW_ANSWER: "Cevab\u0131 G\xF6ster",
    CARD_PROGRESS_RESET: "Kart\u0131n ilerlemesi s\u0131f\u0131rland\u0131.",
    SAVE: "Kaydet",
    CANCEL: "\u0130ptal",
    NO_INPUT: "Girdi sa\u011Flanmad\u0131.",
    CURRENT_EASE_HELP_TEXT: "Mevcut Kolayl\u0131k: ",
    CURRENT_INTERVAL_HELP_TEXT: "Mevcut Aral\u0131k: ",
    CARD_GENERATED_FROM: "${notePath} kayna\u011F\u0131ndan olu\u015Fturuldu.",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "G\xF6zden ge\xE7irmek i\xE7in bir not a\xE7",
    REVIEW_CARDS: "Flash kartlar\u0131 g\xF6zden ge\xE7ir",
    REVIEW_DIFFICULTY_FILE_MENU: "G\xF6zden Ge\xE7ir: ${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "Notu ${difficulty} derecesiyle g\xF6zden ge\xE7ir",
    CRAM_ALL_CARDS: "T\xFCm destelerden yo\u011Fun tekrar yap",
    REVIEW_ALL_CARDS: "T\xFCm notlardaki flash kartlar\u0131 g\xF6zden ge\xE7ir",
    REVIEW_CARDS_IN_NOTE: "Bu nottaki flash kartlar\u0131 g\xF6zden ge\xE7ir",
    CRAM_CARDS_IN_NOTE: "Bu nottaki flash kartlar\u0131 yo\u011Fun tekrar yap",
    VIEW_STATS: "\u0130statistikleri g\xF6r\xFCnt\xFCle",
    OPEN_REVIEW_QUEUE_VIEW:
        "Kenar \xE7ubu\u011Funda Not G\xF6zden Ge\xE7irme S\u0131ras\u0131n\u0131 a\xE7",
    STATUS_BAR: "G\xF6zden Ge\xE7ir: ${dueNotesCount} not, ${dueFlashcardsCount} kart g\xFCncel",
    SYNC_TIME_TAKEN: "Senkronizasyon ${t}ms s\xFCrd\xFC",
    NOTE_IN_IGNORED_FOLDER:
        "Not, d\u0131\u015Flanan klas\xF6rde kay\u0131tl\u0131 (ayarlar\u0131 kontrol edin).",
    PLEASE_TAG_NOTE:
        "L\xFCtfen g\xF6zden ge\xE7irmek i\xE7in notu uygun \u015Fekilde etiketleyin (ayarlar i\xE7inde).",
    RESPONSE_RECEIVED: "Yan\u0131t al\u0131nd\u0131.",
    NO_DECK_EXISTS: "${deckName} ad\u0131nda bir deste yok",
    ALL_CAUGHT_UP: "\u{1F3C6} \u015Eampiyon gibi bitirdin! \u{1F604}",
    // scheduling.ts
    DAYS_STR_IVL: "${interval} g\xFCn",
    MONTHS_STR_IVL: "${interval} ay",
    YEARS_STR_IVL: "${interval} y\u0131l",
    DAYS_STR_IVL_MOBILE: "${interval}g",
    MONTHS_STR_IVL_MOBILE: "${interval}a",
    YEARS_STR_IVL_MOBILE: "${interval}y",
    // settings.ts
    SETTINGS_HEADER: "Aral\u0131kl\u0131 Tekrar",
    GROUP_TAGS_FOLDERS: "Etiketler ve Klas\xF6rler",
    GROUP_FLASHCARD_REVIEW: "Flash Kartlar\u0131 G\xF6zden Ge\xE7irme",
    GROUP_FLASHCARD_SEPARATORS: "Flash Kart Ay\u0131r\u0131c\u0131lar\u0131",
    GROUP_DATA_STORAGE: "Planlama Verilerinin Saklanmas\u0131",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flash Kartlar ve Notlar",
    GROUP_CONTRIBUTING: "Katk\u0131da Bulunma",
    CHECK_WIKI:
        'Daha fazla bilgi i\xE7in <a href="${wikiUrl}">wiki</a> sayfas\u0131na g\xF6z at\u0131n.',
    GITHUB_DISCUSSIONS:
        'Soru-cevap, geri bildirim ve genel tart\u0131\u015Fmalar i\xE7in <a href="${discussionsUrl}">tart\u0131\u015Fmalar</a> b\xF6l\xFCm\xFCne g\xF6z at\u0131n.',
    GITHUB_ISSUES:
        'Bir \xF6zellik iste\u011Finiz ya da hata bildiriminiz varsa <a href="${issuesUrl}">buradan</a> bildirin.',
    GITHUB_SOURCE_CODE:
        'Proje kaynak koduna <a href="${githubProjectUrl}">GitHub</a> \xFCzerinden ula\u015Fabilirsiniz.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Kod katk\u0131lar\u0131</a> hakk\u0131nda bilgi al\u0131n.',
    TRANSLATION_CONTRIBUTION_INFO:
        'Eklentiyi kendi dilinize \xE7evirmek hakk\u0131nda bilgi i\xE7in <a href="${translationContributionUrl}">\xE7eviri katk\u0131lar\u0131</a> sayfas\u0131n\u0131 ziyaret edin.',
    FOLDERS_TO_IGNORE: "Yoksay\u0131lan Klas\xF6rler",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "Flash Kartlar",
    FLASHCARD_EASY_LABEL: "Kolay Butonu Metni",
    FLASHCARD_GOOD_LABEL: "Orta Butonu Metni",
    FLASHCARD_HARD_LABEL: "Zor Butonu Metni",
    FLASHCARD_EASY_DESC: '"Kolay" butonunun metnini \xF6zelle\u015Ftirin',
    FLASHCARD_GOOD_DESC: '"Orta" butonunun metnini \xF6zelle\u015Ftirin',
    FLASHCARD_HARD_DESC: '"Zor" butonunun metnini \xF6zelle\u015Ftirin',
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "Flash Kart Etiketleri",
    FLASHCARD_TAGS_DESC:
        "Etiketleri bo\u015Fluklar veya yeni sat\u0131rlarla ay\u0131rarak girin, \xF6rne\u011Fin: #flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS: "Klas\xF6rleri destelere ve alt destelere d\xF6n\xFC\u015Ft\xFCr?",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "Bu, yukar\u0131daki Flash Kart etiketleri se\xE7ene\u011Fine bir alternatiftir.",
    INLINE_SCHEDULING_COMMENTS:
        "Planlama yorumunu flash kart\u0131n son sat\u0131r\u0131yla ayn\u0131 sat\u0131ra kaydet?",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "Bunu a\xE7mak, HTML yorumlar\u0131n\u0131n liste bi\xE7imlendirmesini bozmamas\u0131n\u0131 sa\u011Flar.",
    BURY_SIBLINGS_TILL_NEXT_DAY: "Karde\u015F kartlar\u0131 bir sonraki g\xFCne kadar gizle?",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "Karde\u015F kartlar, ayn\u0131 kart metninden \xFCretilen kartlard\u0131r (\xF6rne\u011Fin gizlemeler).",
    SHOW_CARD_CONTEXT: "Kartlarda ba\u011Flam\u0131 g\xF6ster?",
    SHOW_CARD_CONTEXT_DESC:
        "\xD6rne\u011Fin: Ba\u015Fl\u0131k > Ba\u015Fl\u0131k 1 > Alt Ba\u015Fl\u0131k > ... > Alt Ba\u015Fl\u0131k",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "Flash Kart Y\xFCkseklik Y\xFCzdesi",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "Mobilde veya \xE7ok b\xFCy\xFCk resimleriniz varsa %100 olarak ayarlay\u0131n.",
    RESET_DEFAULT: "Varsay\u0131lana s\u0131f\u0131rla",
    CARD_MODAL_WIDTH_PERCENT: "Flash Kart Geni\u015Flik Y\xFCzdesi",
    RANDOMIZE_CARD_ORDER:
        "\u0130nceleme s\u0131ras\u0131nda kart s\u0131ras\u0131n\u0131 rastgele yap?",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "\u0130nceleme s\u0131ras\u0131nda bir destede kartlar\u0131n g\xF6r\xFCnt\xFClenme s\u0131ras\u0131",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "S\u0131ral\u0131 olarak (\xF6nce t\xFCm yeni kartlar)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "S\u0131ral\u0131 olarak (\xF6nce t\xFCm g\xFCncel kartlar)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Rastgele olarak (\xF6nce t\xFCm yeni kartlar)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Rastgele olarak (\xF6nce t\xFCm g\xFCncel kartlar)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Rastgele desteden rastgele kart",
    REVIEW_DECK_ORDER:
        "\u0130nceleme s\u0131ras\u0131nda destelerin g\xF6r\xFCnt\xFClenme s\u0131ras\u0131",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "S\u0131ral\u0131 olarak (\xD6nceki destedeki t\xFCm kartlar g\xF6zden ge\xE7irildikten sonra)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "Rastgele olarak (\xD6nceki destedeki t\xFCm kartlar g\xF6zden ge\xE7irildikten sonra)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Rastgele desteden rastgele kart",
    DISABLE_CLOZE_CARDS: "Gizli kartlar\u0131 devre d\u0131\u015F\u0131 b\u0131rak?",
    CONVERT_HIGHLIGHTS_TO_CLOZES: "==Vurgulanan== metni gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
    CONVERT_BOLD_TEXT_TO_CLOZES: "**Kal\u0131n metni** gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "{{K\u0131v\u0131rc\u0131k parantezleri}} gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
    CLOZE_PATTERNS: "Cloze Patterns",
    CLOZE_PATTERNS_DESC:
        'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "Sat\u0131r i\xE7i flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "Bunu de\u011Fi\u015Ftirdikten sonra mevcut flash kartlar\u0131n\u0131z\u0131 manuel olarak d\xFCzenlemeniz gerekti\u011Fini unutmay\u0131n.",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "Sat\u0131r i\xE7i ters flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
    MULTILINE_CARDS_SEPARATOR:
        "\xC7ok sat\u0131rl\u0131 flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\xC7ok sat\u0131rl\u0131 ters flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
    MULTILINE_CARDS_END_MARKER:
        "Gizli kartlar ve \xE7ok sat\u0131rl\u0131 flash kartlar\u0131n sonunu belirten karakterler",
    NOTES: "Notlar",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "Ba\u015Flang\u0131\xE7ta not inceleme panelini etkinle\u015Ftir",
    TAGS_TO_REVIEW: "G\xF6zden ge\xE7irilecek etiketler",
    TAGS_TO_REVIEW_DESC:
        "Etiketleri bo\u015Fluklar veya yeni sat\u0131rlarla ay\u0131rarak girin, \xF6rne\u011Fin: #review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "G\xF6zden ge\xE7irmek i\xE7in rastgele bir not a\xE7",
    OPEN_RANDOM_NOTE_DESC:
        "Bunu kapatt\u0131\u011F\u0131n\u0131zda, notlar \xF6nem s\u0131ras\u0131na g\xF6re s\u0131ralan\u0131r (PageRank).",
    AUTO_NEXT_NOTE: "Bir incelemeden sonra otomatik olarak bir sonraki notu a\xE7",
    MAX_N_DAYS_REVIEW_QUEUE: "Sa\u011F panelde g\xF6sterilecek maksimum g\xFCn say\u0131s\u0131",
    MIN_ONE_DAY: "G\xFCn say\u0131s\u0131 en az 1 olmal\u0131d\u0131r.",
    VALID_NUMBER_WARNING: "L\xFCtfen ge\xE7erli bir say\u0131 girin.",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "Deste a\u011Fa\xE7lar\u0131 ba\u015Flang\u0131\xE7ta geni\u015Fletilmi\u015F olarak g\xF6sterilmeli mi",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "Bunu kapat\u0131n, ayn\u0131 dosyada bir\xE7ok desteye ait kartlar\u0131n\u0131z varsa i\xE7 i\xE7e desteleri daraltmak i\xE7in kullan\u0131\u015Fl\u0131d\u0131r.",
    ALGORITHM: "Algoritma",
    CHECK_ALGORITHM_WIKI:
        'Daha fazla bilgi i\xE7in <a href="${algoUrl}">algoritma uygulamas\u0131na</a> g\xF6z at\u0131n.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "Temel kolayl\u0131k",
    BASE_EASE_DESC: "minimum = 130, tercihen yakla\u015F\u0131k 250.",
    BASE_EASE_MIN_WARNING: "Temel kolayl\u0131k en az 130 olmal\u0131d\u0131r.",
    LAPSE_INTERVAL_CHANGE:
        "Bir flash kart\u0131/notu zor olarak inceledi\u011Finizde aral\u0131k de\u011Fi\u015Fikli\u011Fi",
    LAPSE_INTERVAL_CHANGE_DESC:
        "yeniAral\u0131k = eskiAral\u0131k * aral\u0131kDe\u011Fi\u015Fikli\u011Fi / 100.",
    EASY_BONUS: "Kolayl\u0131k Bonusu",
    EASY_BONUS_DESC:
        "Kolayl\u0131k bonusu, bir flash kart\u0131/notu \u0130yi ve Kolay yan\u0131tlad\u0131\u011F\u0131n\u0131zda aral\u0131klardaki fark\u0131 ayarlaman\u0131za olanak tan\u0131r (minimum = %100).",
    EASY_BONUS_MIN_WARNING: "Kolayl\u0131k bonusu en az %100 olmal\u0131d\u0131r.",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "Maksimum aral\u0131k (g\xFCn)",
    MAX_INTERVAL_DESC:
        "Aral\u0131\u011Fa bir \xFCst s\u0131n\u0131r koyman\u0131za olanak tan\u0131r (varsay\u0131lan = 100 y\u0131l).",
    MAX_INTERVAL_MIN_WARNING: "Maksimum aral\u0131k en az 1 g\xFCn olmal\u0131d\u0131r.",
    MAX_LINK_CONTRIB: "Maksimum ba\u011Flant\u0131 katk\u0131s\u0131",
    MAX_LINK_CONTRIB_DESC:
        "Ba\u011Flant\u0131l\u0131 notlar\u0131n a\u011F\u0131rl\u0131kl\u0131 kolayl\u0131k de\u011Ferinin ba\u015Flang\u0131\xE7 kolayl\u0131\u011F\u0131na maksimum katk\u0131s\u0131.",
    LOGGING: "Kay\u0131t tutma",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "Geli\u015Ftirici konsolunda hata ay\u0131klama bilgilerini g\xF6ster",
    DISPLAY_PARSER_DEBUG_INFO:
        "Ayr\u0131\u015Ft\u0131r\u0131c\u0131 i\xE7in hata ay\u0131klama bilgilerini geli\u015Ftirici konsolunda g\xF6ster",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "Not \u0130nceleme S\u0131ras\u0131",
    CLOSE: "Kapat",
    NEW: "Yeni",
    YESTERDAY: "D\xFCn",
    TODAY: "Bug\xFCn",
    TOMORROW: "Yar\u0131n",
    // stats-modal.tsx
    STATS_TITLE: "\u0130statistikler",
    MONTH: "Ay",
    QUARTER: "\xC7eyrek",
    YEAR: "Y\u0131l",
    LIFETIME: "\xD6m\xFCr Boyu",
    FORECAST: "Tahmin",
    FORECAST_DESC: "Gelecekte incelemeye al\u0131nacak kartlar\u0131n say\u0131s\u0131",
    SCHEDULED: "Planlanm\u0131\u015F",
    DAYS: "G\xFCnler",
    NUMBER_OF_CARDS: "Kart Say\u0131s\u0131",
    REVIEWS_PER_DAY: "Ortalama: ${avg} inceleme/g\xFCn",
    INTERVALS: "Aral\u0131klar",
    INTERVALS_DESC: "\u0130ncelemelerin tekrar g\xF6sterilme gecikmeleri",
    COUNT: "Say\u0131",
    INTERVALS_SUMMARY: "Ortalama aral\u0131k: ${avg}, En uzun aral\u0131k: ${longest}",
    EASES: "Kolayl\u0131klar",
    EASES_SUMMARY: "Ortalama kolayl\u0131k: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "Kart T\xFCrleri",
    CARD_TYPES_DESC: "Bu, g\xF6m\xFCl\xFC kartlar\u0131 da i\xE7erir (varsa)",
    CARD_TYPE_NEW: "Yeni",
    CARD_TYPE_YOUNG: "Gen\xE7",
    CARD_TYPE_MATURE: "Olgun",
    CARD_TYPES_SUMMARY: "Toplam kart: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/uk.ts
var uk_default = {};

// src/lang/locale/ur.ts
var ur_default = {};

// src/lang/locale/vi.ts
var vi_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
    // flashcard-modal.tsx
    DECKS: "\u5361\u7EC4",
    DUE_CARDS: "\u5230\u671F\u5361\u7247",
    NEW_CARDS: "\u65B0\u5361\u7247",
    TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
    BACK: "\u8FD4\u56DE",
    SKIP: "\u7565\u8FC7",
    EDIT_CARD: "\u7F16\u8F91\u5361\u7247",
    RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
    HARD: "\u8F83\u96BE",
    GOOD: "\u8BB0\u5F97",
    EASY: "\u7B80\u5355",
    SHOW_ANSWER: "\u663E\u793A\u7B54\u6848",
    CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
    SAVE: "\u4FDD\u5B58",
    CANCEL: "\u53D6\u6D88",
    NO_INPUT: "\u6CA1\u6709\u63D0\u4F9B\u8F93\u5165\u3002",
    CURRENT_EASE_HELP_TEXT: "\u76EE\u524D\u638C\u63E1\u7A0B\u5EA6\uFF1A",
    CURRENT_INTERVAL_HELP_TEXT: "\u76EE\u524D\u95F4\u9694\uFF1A",
    CARD_GENERATED_FROM: "\u751F\u6210\u81EA\uFF1A${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u5F00\u59CB\u590D\u4E60",
    REVIEW_CARDS: "\u590D\u4E60\u5361\u7247",
    REVIEW_DIFFICULTY_FILE_MENU: "\u590D\u4E60\uFF1A${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "\u6807\u8BB0\u4E3A\u201C${difficulty}\u201D",
    REVIEW_ALL_CARDS: "\u590D\u4E60\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
    CRAM_ALL_CARDS: "\u9009\u62E9\u8981\u96C6\u4E2D\u590D\u4E60\u7684\u5361\u7EC4",
    REVIEW_CARDS_IN_NOTE: "\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
    CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
    VIEW_STATS: "\u67E5\u770B\u6570\u636E",
    OPEN_REVIEW_QUEUE_VIEW:
        "\u5728\u4FA7\u8FB9\u680F\u4E2D\u6253\u5F00\u7B14\u8BB0\u590D\u4E60\u961F\u5217",
    STATUS_BAR:
        "\u590D\u4E60: ${dueNotesCount} \u7B14\u8BB0, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
    SYNC_TIME_TAKEN: "\u540C\u6B65\u65F6\u95F4 ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "\u7B14\u8BB0\u4FDD\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F84\u4E2D\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
    PLEASE_TAG_NOTE:
        "\u8BF7\u5C06\u9700\u8981\u590D\u4E60\u7684\u7B14\u8BB0\u4E2D\u52A0\u5165\u6B63\u786E\u7684\u6807\u7B7E\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
    RESPONSE_RECEIVED: "\u53CD\u9988\u5DF2\u6536\u5230",
    NO_DECK_EXISTS: "\u6CA1\u6709 ${deckName} \u5361\u7EC4",
    ALL_CAUGHT_UP: "\u90FD\u590D\u4E60\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
    // scheduling.ts
    DAYS_STR_IVL: "${interval}\u5929",
    MONTHS_STR_IVL: "${interval}\u6708",
    YEARS_STR_IVL: "${interval}\u5E74",
    DAYS_STR_IVL_MOBILE: "${interval}\u5929",
    MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
    YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
    // settings.ts
    SETTINGS_HEADER: "\u95F4\u9694\u91CD\u590D\u63D2\u4EF6",
    GROUP_TAGS_FOLDERS: "\u6807\u7B7E\u548C\u6587\u4EF6\u5939",
    GROUP_FLASHCARD_REVIEW: "\u95EA\u5361\u590D\u4E60",
    GROUP_FLASHCARD_SEPARATORS: "\u95EA\u5B58\u5361\u5206\u9694\u7B26",
    GROUP_DATA_STORAGE: "\u5B58\u50A8\u8BA1\u5212\u6570\u636E",
    GROUP_DATA_STORAGE_DESC: "\u9009\u62E9\u5B58\u50A8\u8BA1\u5212\u6570\u636E\u4F4D\u7F6E",
    GROUP_FLASHCARDS_NOTES: "\u95EA\u5361\u548C\u7B14\u8BB0",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB<a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u6587\u4EF6\u5939",
    FOLDERS_TO_IGNORE_DESC:
        "\u5728\u5355\u72EC\u4E00\u884C\u4E2D\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84\u6216\u5168\u5C40\u6A21\u5F0F\uFF0C\u4F8B\u5982 Templates/Scripts \u6216 .excalidraw.md\u3002\u6B64\u8BBE\u7F6E\u5BF9\u95EA\u5B58\u5361\u548C\u7B14\u8BB0\u90FD\u901A\u7528\u3002",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\u5361\u7247",
    FLASHCARD_EASY_LABEL: "\u201C\u7B80\u5355\u201D\u6309\u94AE\u6587\u672C",
    FLASHCARD_GOOD_LABEL: "\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u6587\u672C",
    FLASHCARD_HARD_LABEL: "\u201C\u8F83\u96BE\u201D\u6309\u94AE\u6587\u672C",
    FLASHCARD_EASY_DESC: "\u81EA\u5B9A\u4E49\u201C\u7B80\u5355\u201D\u6309\u94AE\u7684\u6807\u7B7E",
    FLASHCARD_GOOD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u7684\u6807\u7B7E",
    FLASHCARD_HARD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8F83\u96BE\u201D\u6309\u94AE\u7684\u6807\u7B7E",
    REVIEW_BUTTON_DELAY: "\u6309\u94AE\u6309\u4E0B\u5EF6\u8FDF\uFF08\u6BEB\u79D2\uFF09",
    REVIEW_BUTTON_DELAY_DESC:
        "\u5728\u518D\u6B21\u6309\u4E0B\u590D\u4E60\u6309\u94AE\u524D\u589E\u52A0\u5EF6\u8FDF\u3002",
    FLASHCARD_TAGS: "\u5361\u7247\u6807\u7B7E",
    FLASHCARD_TAGS_DESC:
        "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS:
        "\u5C06\u6587\u4EF6\u5939\u5185\u5BB9\u8F6C\u6362\u4E3A\u5361\u7247\u7EC4\u548C\u5B50\u5361\u7247\u7EC4",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "\u6B64\u9009\u9879\u4E3A\u5361\u7247\u6807\u7B7E\u9009\u9879\u7684\u66FF\u4EE3\u9009\u9879\u3002",
    INLINE_SCHEDULING_COMMENTS:
        "\u5C06\u8BA1\u5212\u91CD\u590D\u65E5\u671F\u4FDD\u5B58\u5728\u5361\u7247\u6700\u540E\u4E00\u884C\u7684\u540C\u4E00\u884C",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "HTML\u6CE8\u91CA\u4E0D\u518D\u7834\u574F\u5217\u8868\u683C\u5F0F",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "\u5C06\u5173\u8054\u5361\u7247\u9690\u85CF\u81F3\u4E0B\u4E00\u5929",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "\u5173\u8054\u5361\u7247\u662F\u6765\u81EA\u540C\u4E00\u5361\u7247\u7684\u4E0D\u540C\u5F62\u5F0F\uFF0C \u4F8B\u5982\uFF1A\u5B8C\u5F62\u586B\u7A7A\u5361\u7247",
    SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u663E\u793A\u4E0A\u4E0B\u6587",
    SHOW_CARD_CONTEXT_DESC:
        "\u4F8B\u5982\uFF1A\u6807\u9898 > \u526F\u6807\u9898 > \u5C0F\u6807\u9898 > ... > \u5C0F\u6807\u9898",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS:
        "\u5C06\u4E0B\u6B21\u590D\u4E60\u65F6\u95F4\u663E\u793A\u5728\u590D\u4E60\u6309\u94AE",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "\u4E86\u89E3\u4F60\u7684\u5361\u7247\u88AB\u63A8\u8FDF\u4E86\u591A\u4E45\u5BF9\u4F60\u5F88\u6709\u7528",
    CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\u8BF7\u5728\u79FB\u52A8\u7AEF\u4F7F\u7528\u5E76\u9700\u8981\u6D4F\u89C8\u8F83\u5927\u56FE\u7247\u65F6\u8BBE\u4E3A100%",
    RESET_DEFAULT: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4",
    CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BBD\u5EA6\u767E\u5206\u6BD4",
    RANDOMIZE_CARD_ORDER: "\u590D\u4E60\u65F6\u968F\u673A\u663E\u793A\u5361\u7247\uFF1F",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "\u590D\u4E60\u65F6\u5361\u7247\u7EC4\u5185\u7684\u5361\u7247\u6392\u5E8F",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "\u5361\u7247\u7EC4\u5185\u987A\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u4F18\u5148)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "\u5361\u7247\u7EC4\u5185\u987A\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u4F18\u5148)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM:
        "\u5361\u7247\u7EC4\u5185\u4E71\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u4F18\u5148)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "\u5361\u7247\u7EC4\u5185\u4E71\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u4F18\u5148)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD:
        "\u5361\u7247\u7EC4\u53CA\u5361\u7247\u90FD\u4E71\u5E8F",
    REVIEW_DECK_ORDER: "\u590D\u4E60\u65F6\u5361\u7247\u7EC4\u7684\u6392\u5E8F",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "\u987A\u5E8F (\u5728\u524D\u4E00\u5361\u7247\u7EC4\u5185\u5361\u7247\u90FD\u590D\u4E60\u5B8C\u540E)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "\u4E71\u5E8F (\u5728\u524D\u4E00\u5361\u7247\u7EC4\u5185\u5361\u7247\u90FD\u590D\u4E60\u5B8C\u540E)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD:
        "\u5361\u7247\u7EC4\u53CA\u5361\u7247\u90FD\u4E71\u5E8F",
    DISABLE_CLOZE_CARDS: "\u4E0D\u8FDB\u884C\u5B8C\u5F62\u586B\u7A7A",
    CONVERT_HIGHLIGHTS_TO_CLOZES:
        "\u5C06 ==\u9AD8\u4EAE== \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
    CONVERT_BOLD_TEXT_TO_CLOZES:
        "\u5C06 **\u7C97\u4F53** \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "\u5C06 {{\u5927\u62EC\u53F7}} \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
    CLOZE_PATTERNS: "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F",
    CLOZE_PATTERNS_DESC:
        '\u8F93\u5165\u4EE5\u6362\u884C\u7B26\u5206\u9694\u7684\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "\u5355\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9009\u9879\u540E\u4F60\u5C06\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u7B26\u3002",
    INLINE_REVERSED_CARDS_SEPARATOR: "\u5355\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
    MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\u591A\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
    MULTILINE_CARDS_END_MARKER:
        "\u8868\u793A\u586B\u7A7A\u548C\u591A\u884C\u95EA\u5361\u7ED3\u675F\u7684\u5B57\u7B26",
    NOTES: "\u7B14\u8BB0",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "\u542F\u52A8\u65F6\u5F00\u542F\u7B14\u8BB0\u590D\u4E60\u7A97\u683C",
    TAGS_TO_REVIEW: "\u590D\u4E60\u6807\u7B7E",
    TAGS_TO_REVIEW_DESC:
        "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "\u590D\u4E60\u968F\u673A\u7B14\u8BB0",
    OPEN_RANDOM_NOTE_DESC:
        "\u5173\u95ED\u6B64\u9009\u9879\uFF0C\u7B14\u8BB0\u5C06\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
    AUTO_NEXT_NOTE: "\u590D\u4E60\u540E\u81EA\u52A8\u6253\u5F00\u4E0B\u4E00\u4E2A\u7B14\u8BB0",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\u8BF7\u5728\u6587\u4EF6\u83DC\u5355\u4E2D\u542F\u7528\u590D\u4E60\u9009\u9879\uFF08\u4F8B\u5982\uFF1A\u590D\u4E60\uFF1A\u7B80\u5355\u3001\u826F\u597D\u3001\u56F0\u96BE",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\u5982\u679C\u60A8\u5728\u6587\u4EF6\u83DC\u5355\u4E2D\u7981\u7528\u590D\u4E60\u9009\u9879\uFF0C\u60A8\u53EF\u4EE5\u4F7F\u7528\u63D2\u4EF6\u547D\u4EE4\u6765\u590D\u4E60\u7B14\u8BB0\uFF0C\u5982\u679C\u60A8\u5B9A\u4E49\u4E86\u76F8\u5173\u5FEB\u6377\u952E\uFF0C\u4E5F\u53EF\u4EE5\u4F7F\u7528\u5B83\u4EEC\u3002",
    MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u8FB9\u680F\u4E2D\u663E\u793A\u7684\u6700\u5927\u5929\u6570",
    MIN_ONE_DAY: "\u5929\u6570\u6700\u5C0F\u503C\u4E3A1",
    VALID_NUMBER_WARNING: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u6570\u5B57\u3002",
    UI: "User Interface",
    OPEN_IN_TAB: "\u5728\u65B0\u6807\u7B7E\u6253\u5F00",
    OPEN_IN_TAB_DESC:
        "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u5728\u6A21\u5F0F\u7A97\u53E3\u4E2D\u6253\u5F00\u63D2\u4EF6",
    SHOW_STATUS_BAR: "\u663E\u793A\u5728\u72B6\u6001\u680F",
    SHOW_STATUS_BAR_DESC:
        "\u5C06\u6B64\u5173\u95ED\u4EE5\u9690\u85CF Obsidian \u72B6\u6001\u680F\u4E2D\u7684\u5361\u7247\u590D\u4E60\u72B6\u6001\u3002",
    SHOW_RIBBON_ICON: "\u5728\u529F\u80FD\u533A\u4E2D\u663E\u793A\u56FE\u6807",
    SHOW_RIBBON_ICON_DESC:
        "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u9690\u85CF Obsidian \u529F\u80FD\u533A\u680F\u4E2D\u7684\u63D2\u4EF6\u56FE\u6807",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\u9ED8\u8BA4\u5728\u5217\u8868\u4E2D\u5C55\u5F00\u5D4C\u5957\u5B50\u724C\u7EC4",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u6298\u53E0\u540C\u4E00\u5F20\u5361\u7247\u4E2D\u7684\u5D4C\u5957\u724C\u7EC4\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C5E\u4E8E\u540C\u4E00\u6587\u4EF6\u4E2D\u7684\u8BB8\u591A\u5957\u724C\uFF0C\u5219\u5F88\u6709\u7528\u3002",
    ALGORITHM: "\u7B97\u6CD5",
    CHECK_ALGORITHM_WIKI:
        '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB<a href="${algoUrl}">\u7B97\u6CD5\u5B9E\u73B0</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6",
    BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u8350\u503C\u7EA6250.",
    BASE_EASE_MIN_WARNING:
        "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u4E3A130\u3002",
    LAPSE_INTERVAL_CHANGE:
        "\u5C06\u590D\u4E60\u65F6\u6807\u6CE8\u4E3A\u201C\u8F83\u96BE\u201D\u7684\u5361\u7247\u6216\u7B14\u8BB0\u590D\u4E60\u95F4\u9694\u7F29\u77ED",
    LAPSE_INTERVAL_CHANGE_DESC:
        "\u65B0\u590D\u4E60\u95F4\u9694 = \u539F\u590D\u4E60\u95F4\u9694 * \u95F4\u9694\u6539\u53D8\u7CFB\u6570 / 100.",
    EASY_BONUS: "\u7B80\u5355\u5956\u52B1",
    EASY_BONUS_DESC:
        "\u7B80\u5355\u5956\u52B1\u8BBE\u5B9A\u201C\u8BB0\u5F97\u201D\u548C\u201C\u7B80\u5355\u201D\u5361\u7247\u6216\u7B14\u8BB0\u7684\u590D\u4E60\u95F4\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
    EASY_BONUS_MIN_WARNING: "\u7B80\u5355\u5956\u52B1\u81F3\u5C11\u4E3A100\u3002",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "\u6700\u5927\u95F4\u9694\uFF08\u5929\uFF09",
    MAX_INTERVAL_DESC:
        "\u8BBE\u5B9A\u590D\u4E60\u7684\u6700\u5927\u95F4\u9694\u65F6\u95F4\uFF08\u9ED8\u8BA4\u503C100\u5E74\uFF09\u3002",
    MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u95F4\u9694\u81F3\u5C11\u4E3A1\u5929",
    MAX_LINK_CONTRIB: "\u6700\u5927\u94FE\u63A5\u6536\u76CA",
    MAX_LINK_CONTRIB_DESC:
        "\u94FE\u63A5\u7B14\u8BB0\u7684\u52A0\u6743\u638C\u63E1\u7A0B\u5EA6\u5BF9\u539F\u59CB\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5927\u8D21\u732E\u3002",
    LOGGING: "\u8BB0\u5F55\u4E2D",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\u5728\u5F00\u53D1\u8005\u63A7\u5236\u53F0\u4E2D\u663E\u793A\u8C03\u8BD5\u4FE1\u606F",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "\u7B14\u8BB0\u590D\u4E60\u5E8F\u5217",
    CLOSE: "\u4E34\u8FD1",
    NEW: "\u65B0",
    YESTERDAY: "\u6628\u5929",
    TODAY: "\u4ECA\u5929",
    TOMORROW: "\u660E\u5929",
    // stats-modal.tsx
    STATS_TITLE: "\u6570\u636E",
    MONTH: "\u6708",
    QUARTER: "\u5B63",
    YEAR: "\u5E74",
    LIFETIME: "\u5168\u90E8",
    FORECAST: "\u9884\u671F",
    FORECAST_DESC: "\u5C06\u8981\u5230\u671F\u7684\u5361\u7247\u6570\u91CF",
    SCHEDULED: "\u5DF2\u6392\u671F",
    DAYS: "\u5929",
    NUMBER_OF_CARDS: "\u5361\u7247\u6570\u91CF",
    REVIEWS_PER_DAY: "\u5E73\u5747: \u590D\u4E60${avg} /\u5929",
    INTERVALS: "\u95F4\u9694",
    INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u590D\u4E60\u7684\u65F6\u95F4\u95F4\u9694",
    COUNT: "\u8BA1\u6570",
    INTERVALS_SUMMARY:
        "\u5E73\u5747\u95F4\u9694\u65F6\u95F4: ${avg}, \u6700\u957F\u95F4\u9694\u65F6\u95F4: ${longest}",
    EASES: "\u638C\u63E1\u7A0B\u5EA6",
    EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "\u5361\u7247\u7C7B\u578B",
    CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C06\u663E\u793A\u9690\u85CF\u7684\u5361\u7247",
    CARD_TYPE_NEW: "\u65B0",
    CARD_TYPE_YOUNG: "\u8F83\u65B0",
    CARD_TYPE_MATURE: "\u719F\u6089",
    CARD_TYPES_SUMMARY: "\u603B\u5361\u7247\u6570: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {
    // flashcard-modal.tsx
    DECKS: "\u724C\u7D44",
    DUE_CARDS: "\u5230\u671F\u5361\u7247",
    NEW_CARDS: "\u65B0\u5361\u7247",
    TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
    BACK: "\u8FD4\u56DE",
    SKIP: "\u7565\u904E",
    EDIT_CARD: "\u7DE8\u8F2F\u5361\u7247",
    RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
    HARD: "\u8F03\u96E3",
    GOOD: "\u8A18\u5F97",
    EASY: "\u7C21\u55AE",
    SHOW_ANSWER: "\u986F\u793A\u7B54\u6848",
    CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
    SAVE: "\u5132\u5B58",
    CANCEL: "\u53D6\u6D88",
    NO_INPUT: "\u6C92\u6709\u63D0\u4F9B\u8F38\u5165\u3002",
    CURRENT_EASE_HELP_TEXT: "\u76EE\u524D\u638C\u63E1\u7A0B\u5EA6\uFF1A",
    CURRENT_INTERVAL_HELP_TEXT: "\u76EE\u524D\u9593\u9694\u6642\u9593\uFF1A",
    CARD_GENERATED_FROM: "\u751F\u6210\u81EA\uFF1A${notePath}",
    // main.ts
    OPEN_NOTE_FOR_REVIEW: "\u6253\u958B\u4E00\u500B\u7B46\u8A18\u958B\u59CB\u5FA9\u7FD2",
    REVIEW_CARDS: "\u5FA9\u7FD2\u5361\u7247",
    REVIEW_DIFFICULTY_FILE_MENU: "\u5FA9\u7FD2\uFF1A${difficulty}",
    REVIEW_NOTE_DIFFICULTY_CMD: "\u6A19\u8A18\u70BA\u300C${difficulty}\u300D",
    REVIEW_CARDS_IN_NOTE: "\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
    CRAM_ALL_CARDS:
        "\u9078\u64C7\u8981\u4E0D\u8A08\u96E3\u6613\u5EA6\u5FA9\u7FD2\u7684\u724C\u7D44",
    REVIEW_ALL_CARDS: "\u5FA9\u7FD2\u6240\u6709\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
    CRAM_CARDS_IN_NOTE:
        "\u4E0D\u8A08\u96E3\u6613\u5EA6\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
    VIEW_STATS: "\u6AA2\u8996\u6578\u64DA",
    OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
    STATUS_BAR:
        "\u5FA9\u7FD2: ${dueNotesCount} \u7B46\u8A18, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
    SYNC_TIME_TAKEN: "\u540C\u6B65\u6642\u9593 ${t}ms",
    NOTE_IN_IGNORED_FOLDER:
        "\u7B46\u8A18\u5132\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F91\u4E2D\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
    PLEASE_TAG_NOTE:
        "\u8ACB\u5C07\u9700\u8981\u5FA9\u7FD2\u7684\u7B46\u8A18\u4E2D\u52A0\u5165\u6B63\u78BA\u7684\u6A19\u7C64\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
    RESPONSE_RECEIVED: "\u56DE\u994B\u5DF2\u6536\u5230",
    NO_DECK_EXISTS: "\u6C92\u6709 ${deckName} \u724C\u7D44",
    ALL_CAUGHT_UP: "\u90FD\u5FA9\u7FD2\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
    // scheduling.ts
    DAYS_STR_IVL: "${interval}\u5929",
    MONTHS_STR_IVL: "${interval}\u6708",
    YEARS_STR_IVL: "${interval}\u5E74",
    DAYS_STR_IVL_MOBILE: "${interval}\u5929",
    MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
    YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
    // settings.ts
    SETTINGS_HEADER: "\u9593\u9694\u91CD\u8907\u5916\u639B",
    GROUP_TAGS_FOLDERS: "Tags & Folders",
    GROUP_FLASHCARD_REVIEW: "Flashcard Review",
    GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
    GROUP_DATA_STORAGE: "Storage of Scheduling Data",
    GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
    GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
    GROUP_CONTRIBUTING: "Contributing",
    CHECK_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078<a href="${wikiUrl}">wiki</a>.',
    GITHUB_DISCUSSIONS:
        'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
    GITHUB_ISSUES:
        'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
    GITHUB_SOURCE_CODE:
        'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
    CODE_CONTRIBUTION_INFO:
        '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
    TRANSLATION_CONTRIBUTION_INFO:
        '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
    FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u8CC7\u6599\u593E",
    FOLDERS_TO_IGNORE_DESC:
        "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
    OBSIDIAN_INTEGRATION: "Integration into Obsidian",
    FLASHCARDS: "\u5361\u7247",
    FLASHCARD_EASY_LABEL: "\u7C21\u55AE\u6309\u9215\u6587\u5B57",
    FLASHCARD_GOOD_LABEL: "\u8A18\u5F97\u6309\u9215\u6587\u5B57",
    FLASHCARD_HARD_LABEL: "\u8F03\u96E3\u6309\u9215\u6587\u5B57",
    FLASHCARD_EASY_DESC: "\u81EA\u8A02\u300C\u7C21\u55AE\u300D\u6309\u9215\u7684\u6A19\u7C64",
    FLASHCARD_GOOD_DESC: "\u81EA\u8A02\u300C\u8A18\u5F97\u300D\u6309\u9215\u7684\u6A19\u7C64",
    FLASHCARD_HARD_DESC: "\u81EA\u8A02\u300C\u8F03\u96E3\u300D\u6309\u9215\u7684\u6A19\u7C64",
    REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
    REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
    FLASHCARD_TAGS: "\u5361\u7247\u6A19\u7C64",
    FLASHCARD_TAGS_DESC:
        "\u8F38\u5165\u6A19\u7C64\uFF08\u7528\u7A7A\u767D\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
    CONVERT_FOLDERS_TO_DECKS:
        "\u662F\u5426\u5C07\u8CC7\u6599\u593E\u5167\u5BB9\u8F49\u63DB\u70BA\u724C\u7D44\u548C\u5B50\u724C\u7D44\uFF1F",
    CONVERT_FOLDERS_TO_DECKS_DESC:
        "\u6B64\u9078\u9805\u70BA\u5361\u7247\u6A19\u7C64\u9078\u9805\u7684\u66FF\u4EE3\u9078\u9805\u3002",
    INLINE_SCHEDULING_COMMENTS:
        "\u662F\u5426\u5C07\u8A08\u5283\u91CD\u8907\u6642\u9593\u5132\u5B58\u5728\u5361\u7247\u6700\u5F8C\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
    INLINE_SCHEDULING_COMMENTS_DESC:
        "\u52FE\u9078\u5F8CHTML\u8A3B\u89E3\u4E0D\u6703\u7834\u58DE\u5217\u8868\u683C\u5F0F\u554F\u984C\u3002",
    BURY_SIBLINGS_TILL_NEXT_DAY:
        "\u5C07\u53CD\u8F49\u5361\u7247\u96B1\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
    BURY_SIBLINGS_TILL_NEXT_DAY_DESC:
        "\u53CD\u8F49\u5361\u7247\u7531\u540C\u4E00\u5361\u7247\u6587\u5B57\u7522\u751F\uFF0C\u4F8B\u5982\uFF1A\u586B\u7A7A\u514B\u6F0F\u5B57",
    SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u986F\u793A\u4E0A\u4E0B\u6587\uFF1F",
    SHOW_CARD_CONTEXT_DESC:
        "\u4F8B\u5982\uFF1A\u6A19\u984C > \u526F\u6A19\u984C > \u5C0F\u6A19\u984C > ... > \u5C0F\u6A19\u984C",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
    SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC:
        "Useful to know how far in the future your cards are being pushed.",
    CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
    CARD_MODAL_SIZE_PERCENT_DESC:
        "\u5728\u79FB\u52D5\u7AEF\u6216\u9700\u8981\u8F03\u5927\u5716\u7247\u6642\u61C9\u8A2D\u5B9A\u70BA100%",
    RESET_DEFAULT: "\u91CD\u7F6E\u70BA\u9810\u8A2D\u503C",
    CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BEC\u5EA6\u767E\u5206\u6BD4",
    RANDOMIZE_CARD_ORDER: "\u5FA9\u7FD2\u6642\u96A8\u6A5F\u986F\u793A\u5361\u7247\uFF1F",
    REVIEW_CARD_ORDER_WITHIN_DECK:
        "\u5FA9\u7FD2\u6642\u724C\u7D44\u5167\u7684\u5361\u7247\u6392\u5E8F",
    REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL:
        "\u724C\u7D44\u5167\u9806\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u512A\u5148)",
    REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL:
        "\u724C\u7D44\u5167\u9806\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u512A\u5148)",
    REVIEW_CARD_ORDER_NEW_FIRST_RANDOM:
        "\u724C\u7D44\u5167\u4E82\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u512A\u5148)",
    REVIEW_CARD_ORDER_DUE_FIRST_RANDOM:
        "\u724C\u7D44\u5167\u4E82\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u512A\u5148)",
    REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "\u724C\u7D44\u53CA\u5361\u7247\u90FD\u4E82\u5E8F",
    REVIEW_DECK_ORDER: "\u5FA9\u7FD2\u6642\u724C\u7D44\u7684\u6392\u5E8F",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL:
        "\u9806\u5E8F (\u5728\u524D\u4E00\u724C\u7D44\u5167\u5361\u7247\u90FD\u5FA9\u7FD2\u5B8C\u5F8C)",
    REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM:
        "\u4E82\u5E8F (\u5728\u524D\u4E00\u724C\u7D44\u5167\u5361\u7247\u90FD\u5FA9\u7FD2\u5B8C\u5F8C)",
    REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "\u724C\u7D44\u53CA\u5361\u7247\u90FD\u4E82\u5E8F",
    DISABLE_CLOZE_CARDS: "\u505C\u7528\u586B\u7A7A\u514B\u6F0F\u5B57\u5361\u7247\uFF1F",
    CONVERT_HIGHLIGHTS_TO_CLOZES:
        "\u5C07 ==\u9AD8\u4EAE== \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
    CONVERT_HIGHLIGHTS_TO_CLOZES_DESC:
        '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
    CONVERT_BOLD_TEXT_TO_CLOZES:
        "\u5C07 **\u7C97\u9AD4** \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
    CONVERT_BOLD_TEXT_TO_CLOZES_DESC:
        '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
    CONVERT_CURLY_BRACKETS_TO_CLOZES:
        "\u5C07 {{\u5927\u62EC\u865F}} \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
    CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC:
        '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
    CLOZE_PATTERNS: "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F",
    CLOZE_PATTERNS_DESC:
        '\u8F38\u5165\u4EE5\u63DB\u884C\u7B26\u5206\u9694\u7684\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F. Check the <a href="${docsUrl}">wiki</a> for guidance.',
    INLINE_CARDS_SEPARATOR: "\u55AE\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
    FIX_SEPARATORS_MANUALLY_WARNING:
        "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9078\u9805\u5F8C\u4F60\u5C07\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u5B57\u5143\u3002",
    INLINE_REVERSED_CARDS_SEPARATOR:
        "\u55AE\u884C\u53CD\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
    MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
    MULTILINE_REVERSED_CARDS_SEPARATOR:
        "\u591A\u884C\u7FFB\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
    MULTILINE_CARDS_END_MARKER:
        "\u8868\u793A\u586B\u7A7A\u548C\u591A\u884C\u95EA\u5361\u7ED3\u675F\u7684\u5B57\u7B26",
    NOTES: "\u7B46\u8A18",
    NOTE: "Note",
    REVIEW_PANE_ON_STARTUP: "\u555F\u52D5\u6642\u958B\u555F\u7B46\u8A18\u5FA9\u7FD2\u7A97\u683C",
    TAGS_TO_REVIEW: "\u5FA9\u7FD2\u6A19\u7C64",
    TAGS_TO_REVIEW_DESC:
        "\u8F38\u5165\u6A19\u7C64\uFF0C\u7528\u7A7A\u683C\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
    OPEN_RANDOM_NOTE: "\u5FA9\u7FD2\u96A8\u6A5F\u7B46\u8A18",
    OPEN_RANDOM_NOTE_DESC:
        "\u95DC\u9589\u6B64\u9078\u9805\uFF0C\u7B46\u8A18\u5C07\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
    AUTO_NEXT_NOTE: "\u5FA9\u7FD2\u5F8C\u81EA\u52D5\u6253\u958B\u4E0B\u4E00\u500B\u7B46\u8A18",
    ENABLE_FILE_MENU_REVIEW_OPTIONS:
        "\u8ACB\u5728\u6A94\u6848\u9078\u55AE\u4E2D\u555F\u7528\u6AA2\u8996\u9078\u9805\uFF08\u4F8B\u5982\uFF1A\u6AA2\u8996\uFF1A\u7C21\u55AE\u3001\u8A18\u5F97\u3001\u8F03\u96E3\uFF09",
    ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC:
        "\u5982\u679C\u60A8\u5728\u6A94\u6848\u9078\u55AE\u4E2D\u505C\u7528\u6AA2\u8996\u9078\u9805\uFF0C\u60A8\u53EF\u4EE5\u4F7F\u7528\u63D2\u4EF6\u6307\u4EE4\u6AA2\u8996\u7B46\u8A18\uFF0C\u5982\u679C\u6709\u8A2D\u5B9A\uFF0C\u4E5F\u53EF\u4EE5\u4F7F\u7528\u76F8\u95DC\u7684\u5FEB\u6377\u9375\u3002",
    MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u908A\u9762\u677F\u986F\u793A\u7684\u6700\u5927\u5929\u6578",
    MIN_ONE_DAY: "\u5929\u6578\u6700\u5C0F\u503C\u70BA1",
    VALID_NUMBER_WARNING: "\u8ACB\u8F38\u5165\u6709\u6548\u7684\u6578\u5B57\u3002",
    UI: "User Interface",
    OPEN_IN_TAB: "Open in new tab",
    OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
    SHOW_STATUS_BAR: "Show status bar",
    SHOW_STATUS_BAR_DESC:
        "Turn this off to hide the flashcard's review status in Obsidian's status bar",
    SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
    SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE:
        "\u724C\u7D44\u6A39\u6700\u521D\u61C9\u986F\u793A\u70BA\u5C55\u958B",
    INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC:
        "\u95DC\u9589\u6B64\u9078\u9805\u53EF\u647A\u758A\u540C\u4E00\u5F35\u5361\u7247\u4E2D\u7684\u5DE2\u72C0\u724C\u7D44\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C6C\u65BC\u540C\u4E00\u6A94\u6848\u4E2D\u7684\u8A31\u591A\u5957\u724C\uFF0C\u5247\u5F88\u6709\u7528\u3002",
    ALGORITHM: "\u6F14\u7B97\u6CD5",
    CHECK_ALGORITHM_WIKI:
        '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078<a href="${algoUrl}">\u7B97\u6CD5\u5BE6\u73FE</a>.',
    SM2_OSR_VARIANT: "OSR's variant of SM-2",
    BASE_EASE: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6",
    BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u85A6\u503C\u7D04250.",
    BASE_EASE_MIN_WARNING:
        "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u70BA130\u3002",
    LAPSE_INTERVAL_CHANGE:
        "\u5C07\u5FA9\u7FD2\u6642\u6A19\u8A3B\u70BA\u300C\u8F03\u96E3\u300D\u7684\u5361\u7247\u6216\u7B46\u8A18\u5FA9\u7FD2\u9593\u9694\u7E2E\u77ED",
    LAPSE_INTERVAL_CHANGE_DESC:
        "\u65B0\u5FA9\u7FD2\u9593\u9694 = \u539F\u5FA9\u7FD2\u9593\u9694 * \u9593\u9694\u6539\u8B8A\u4FC2\u6578 / 100.",
    EASY_BONUS: "\u7C21\u55AE\u734E\u52F5",
    EASY_BONUS_DESC:
        "\u7C21\u55AE\u734E\u52F5\u8A2D\u5B9A\u300C\u8A18\u5F97\u300D\u548C\u300C\u7C21\u55AE\u300D\u5361\u7247\u6216\u7B46\u8A18\u7684\u5FA9\u7FD2\u9593\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
    EASY_BONUS_MIN_WARNING: "\u7C21\u55AE\u734E\u52F5\u81F3\u5C11\u70BA100\u3002",
    LOAD_BALANCE: "Enable load balancer",
    LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
    MAX_INTERVAL: "\u6700\u5927\u9593\u9694\uFF08\u5929\uFF09",
    MAX_INTERVAL_DESC:
        "\u8A2D\u5B9A\u5FA9\u7FD2\u7684\u6700\u5927\u9593\u9694\u6642\u9593\uFF08\u9810\u8A2D\u503C100\u5E74\uFF09\u3002",
    MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u9593\u9694\u81F3\u5C11\u70BA1\u5929",
    MAX_LINK_CONTRIB: "\u6700\u5927\u93C8\u63A5\u8CA2\u737B",
    MAX_LINK_CONTRIB_DESC:
        "\u93C8\u63A5\u7B46\u8A18\u7684\u52A0\u6B0A\u638C\u63E1\u7A0B\u5EA6\u5C0D\u539F\u59CB\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5927\u8CA2\u737B\u3002",
    LOGGING: "\u8A18\u9304\u4E2D",
    DISPLAY_SCHEDULING_DEBUG_INFO:
        "\u5728\u958B\u767C\u8005\u63A7\u5236\u53F0\u4E2D\u986F\u793A\u9664\u932F\u8CC7\u8A0A",
    DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
    SCHEDULING: "Scheduling",
    EXPERIMENTAL: "Experimental",
    HELP: "Help",
    STORE_IN_NOTES: "In the notes",
    // sidebar.ts
    NOTES_REVIEW_QUEUE: "\u7B46\u8A18\u5FA9\u7FD2\u5E8F\u5217",
    CLOSE: "\u81E8\u8FD1",
    NEW: "\u65B0",
    YESTERDAY: "\u6628\u5929",
    TODAY: "\u4ECA\u5929",
    TOMORROW: "\u660E\u5929",
    // stats-modal.tsx
    STATS_TITLE: "\u7D71\u8A08",
    MONTH: "\u6708",
    QUARTER: "\u5B63",
    YEAR: "\u5E74",
    LIFETIME: "\u5168\u90E8",
    FORECAST: "\u9810\u6E2C",
    FORECAST_DESC: "\u5C07\u8981\u5230\u671F\u7684\u5361\u7247\u6578\u91CF",
    SCHEDULED: "\u5DF2\u6392\u7A0B",
    DAYS: "\u5929",
    NUMBER_OF_CARDS: "\u5361\u7247\u6578\u91CF",
    REVIEWS_PER_DAY: "\u5E73\u5747: \u5FA9\u7FD2${avg} /\u5929",
    INTERVALS: "\u9593\u9694",
    INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u5FA9\u7FD2\u7684\u6642\u9593\u9593\u9694",
    COUNT: "\u8A08\u6578",
    INTERVALS_SUMMARY:
        "\u5E73\u5747\u9593\u9694\u6642\u9593: ${avg}, \u6700\u9577\u9593\u9694\u6642\u9593: ${longest}",
    EASES: "\u638C\u63E1\u7A0B\u5EA6",
    EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
    EASE: "Ease",
    CARD_TYPES: "\u5361\u7247\u578B\u5225",
    CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C07\u986F\u793A\u96B1\u85CF\u7684\u5361\u7247",
    CARD_TYPE_NEW: "\u65B0",
    CARD_TYPE_YOUNG: "\u8F03\u65B0",
    CARD_TYPE_MATURE: "\u719F\u6089",
    CARD_TYPES_SUMMARY: "\u7E3D\u5361\u7247\u6578: ${totalCardsCount}",
    SEARCH: "Search",
    PREVIOUS: "Previous",
    NEXT: "Next",
};

// src/lang/helpers.ts
var localeMap = {
    af: af_default,
    ar: ar_default,
    bn: bn_default,
    cs: cz_default,
    da: da_default,
    de: de_default,
    en: en_default,
    "en-gb": en_gb_default,
    es: es_default,
    fr: fr_default,
    hi: hi_default,
    id: id_default,
    it: it_default,
    ja: ja_default,
    ko: ko_default,
    mr: mr_default,
    nl: nl_default,
    nn: no_default,
    pl: pl_default,
    pt: pt_default,
    "pt-br": pt_br_default,
    ro: ro_default,
    ru: ru_default,
    sw: sw_default,
    ta: ta_default,
    te: te_default,
    th: th_default,
    tr: tr_default,
    uk: uk_default,
    ur: ur_default,
    vi: vi_default,
    "zh-cn": zh_cn_default,
    "zh-tw": zh_tw_default,
};
var locale = localeMap[import_obsidian.moment.locale()];
function interpolate(str, params) {
    const names2 = Object.keys(params);
    const vals = Object.values(params);
    return new Function(...names2, `return \`${str}\`;`)(...vals);
}
function t(str, params) {
    if (!locale) {
        console.error(`SRS error: Locale ${import_obsidian.moment.locale()} not found.`);
    }
    const result = (locale && locale[str]) || en_default[str];
    if (params) {
        return interpolate(result, params);
    }
    return result;
}

// src/algorithms/osr/note-scheduling.ts
function osrSchedule(
    response,
    originalInterval,
    ease,
    delayedBeforeReview,
    settings,
    dueDateHistogram,
) {
    const delayedBeforeReviewDays = Math.max(0, Math.floor(delayedBeforeReview / TICKS_PER_DAY));
    let interval = originalInterval;
    if (response === 0 /* Easy */) {
        ease += 20;
        interval = ((interval + delayedBeforeReviewDays) * ease) / 100;
        interval *= settings.easyBonus;
    } else if (response === 1 /* Good */) {
        interval = ((interval + delayedBeforeReviewDays / 2) * ease) / 100;
    } else if (response === 2 /* Hard */) {
        ease = Math.max(130, ease - 20);
        interval = Math.max(
            1,
            (interval + delayedBeforeReviewDays / 4) * settings.lapsesIntervalChange,
        );
    }
    if (settings.loadBalance && dueDateHistogram !== void 0) {
        interval = Math.round(interval);
        if (interval > 7) {
            let fuzz;
            if (interval <= 21) fuzz = 1;
            else if (interval <= 180) fuzz = Math.min(3, Math.floor(interval * 0.05));
            else fuzz = Math.min(7, Math.floor(interval * 0.025));
            interval = dueDateHistogram.findLeastUsedIntervalOverRange(interval, fuzz);
        }
    }
    interval = Math.min(interval, settings.maximumInterval);
    interval = Math.round(interval * 10) / 10;
    return { interval, ease };
}
function textInterval(interval, isMobile) {
    if (interval === void 0) {
        return t("NEW");
    }
    const m2 = Math.round(interval / 3.04375) / 10,
        y2 = Math.round(interval / 36.525) / 10;
    if (isMobile) {
        if (m2 < 1) return t("DAYS_STR_IVL_MOBILE", { interval });
        else if (y2 < 1) return t("MONTHS_STR_IVL_MOBILE", { interval: m2 });
        else return t("YEARS_STR_IVL_MOBILE", { interval: y2 });
    } else {
        if (m2 < 1) return t("DAYS_STR_IVL", { interval });
        else if (y2 < 1) return t("MONTHS_STR_IVL", { interval: m2 });
        else return t("YEARS_STR_IVL", { interval: y2 });
    }
}

// src/utils/dates.ts
var import_moment = __toESM(require_moment());
function formatDateYYYYMMDD(ticks) {
    return ticks.format(PREFERRED_DATE_FORMAT);
}
var LiveDateProvider = class {
    get now() {
        return (0, import_moment.default)();
    }
    get today() {
        return (0, import_moment.default)().startOf("day");
    }
};
var DateUtil = class {
    static dateStrToMoment(str) {
        return (0, import_moment.default)(str, ALLOWED_DATE_FORMATS);
    }
};
var globalDateProvider = new LiveDateProvider();

// src/algorithms/base/rep-item-schedule-info.ts
var RepItemScheduleInfo = class {
    get dueDateAsUnix() {
        return this.dueDate.valueOf();
    }
    isDue() {
        return this.dueDate && this.dueDate.isSameOrBefore(globalDateProvider.today);
    }
    formatDueDate() {
        return formatDateYYYYMMDD(this.dueDate);
    }
    delayedBeforeReviewDaysInt() {
        return Math.max(0, Math.floor(this.delayedBeforeReviewTicks / TICKS_PER_DAY));
    }
};

// src/algorithms/osr/rep-item-schedule-info-osr.ts
var _RepItemScheduleInfoOsr = class _RepItemScheduleInfoOsr extends RepItemScheduleInfo {
    constructor(dueDate, interval, latestEase, delayedBeforeReviewTicks = null) {
        super();
        this.dueDate = dueDate;
        this.interval = Math.round(interval);
        this.latestEase = latestEase;
        this.delayedBeforeReviewTicks = delayedBeforeReviewTicks;
        if (dueDate && delayedBeforeReviewTicks == null) {
            this.delayedBeforeReviewTicks = globalDateProvider.today.valueOf() - dueDate.valueOf();
        }
    }
    formatCardScheduleForHtmlComment() {
        const dateStr = this.dueDate
            ? this.formatDueDate()
            : _RepItemScheduleInfoOsr.dummyDueDateForNewCard;
        return `!${dateStr},${this.interval},${this.latestEase}`;
    }
    static get initialInterval() {
        return 1;
    }
    static getDummyScheduleForNewCard(settings) {
        return _RepItemScheduleInfoOsr.fromDueDateStr(
            _RepItemScheduleInfoOsr.dummyDueDateForNewCard,
            _RepItemScheduleInfoOsr.initialInterval,
            settings.baseEase,
        );
    }
    static fromDueDateStr(dueDateStr, interval, ease, delayedBeforeReviewTicks = null) {
        const dueDate = DateUtil.dateStrToMoment(dueDateStr);
        return new _RepItemScheduleInfoOsr(dueDate, interval, ease, delayedBeforeReviewTicks);
    }
};
// A question can have multiple cards. The schedule info for all sibling cards are formatted together
// in a single <!--SR: --> comment, such as:
// <!--SR:!2023-09-02,4,270!2023-09-02,5,270!2023-09-02,6,270!2023-09-02,7,270-->
//
// However, not all sibling cards may have been reviewed. Therefore we need a method of indicating that a particular card
// has not been reviewed, and should be considered "new"
// This is done by using this magic value for the date
_RepItemScheduleInfoOsr.dummyDueDateForNewCard = "2000-01-01";
var RepItemScheduleInfoOsr = _RepItemScheduleInfoOsr;

// src/note-ease-list.ts
var NoteEaseList = class {
    constructor(settings) {
        this.dict = {};
        this.settings = settings;
    }
    get baseEase() {
        return this.settings.baseEase;
    }
    hasEaseForPath(path3) {
        return Object.prototype.hasOwnProperty.call(this.dict, path3);
    }
    getEaseByPath(path3) {
        let ease = null;
        if (this.hasEaseForPath(path3)) {
            ease = Math.round(this.dict[path3]);
        }
        return ease;
    }
    setEaseForPath(path3, ease) {
        this.dict[path3] = ease;
    }
};

// src/algorithms/osr/srs-algorithm-osr.ts
var SrsAlgorithmOsr = class _SrsAlgorithmOsr {
    constructor(settings) {
        this.settings = settings;
        this.noteEaseList = new NoteEaseList(settings);
    }
    static get initialInterval() {
        return 1;
    }
    noteCalcNewSchedule(notePath, osrNoteGraph, response, dueDateNoteHistogram) {
        const noteLinkStat = osrNoteGraph.calcNoteLinkStat(notePath, this.noteEaseList);
        const linkContribution =
            this.settings.maxLinkFactor *
            Math.min(1, Math.log(noteLinkStat.totalLinkCount + 0.5) / Math.log(64));
        let ease =
            (1 - linkContribution) * this.settings.baseEase +
            (noteLinkStat.totalLinkCount > 0
                ? (linkContribution * noteLinkStat.linkTotal) / noteLinkStat.linkPGTotal
                : linkContribution * this.settings.baseEase);
        if (this.noteEaseList.hasEaseForPath(notePath)) {
            ease = (ease + this.noteEaseList.getEaseByPath(notePath)) / 2;
        }
        const dueDate = null;
        const interval = _SrsAlgorithmOsr.initialInterval;
        ease = Math.round(ease);
        const temp = new RepItemScheduleInfoOsr(dueDate, interval, ease);
        const result = this.calcSchedule(temp, response, dueDateNoteHistogram);
        result.dueDate = (0, import_moment2.default)(
            globalDateProvider.today.add(result.interval, "d"),
        );
        return result;
    }
    noteOnLoadedNote(path3, note, noteEase) {
        let flashcardsInNoteAvgEase = null;
        if (note) {
            flashcardsInNoteAvgEase = _SrsAlgorithmOsr.calculateFlashcardAvgEase(
                note.questionList,
                this.settings,
            );
        }
        let ease = null;
        if (flashcardsInNoteAvgEase && noteEase) {
            ease = (flashcardsInNoteAvgEase + noteEase) / 2;
        } else {
            ease = flashcardsInNoteAvgEase ? flashcardsInNoteAvgEase : noteEase;
        }
        if (ease) {
            this.noteEaseList.setEaseForPath(path3, ease);
        }
    }
    static calculateFlashcardAvgEase(questionList, settings) {
        let totalEase = 0;
        let scheduledCount = 0;
        questionList.forEach((question) => {
            question.cards
                .filter((card) => card.hasSchedule)
                .forEach((card) => {
                    totalEase += card.scheduleInfo.latestEase;
                    scheduledCount++;
                });
        });
        let result = 0;
        if (scheduledCount > 0) {
            const flashcardsInNoteAvgEase = totalEase / scheduledCount;
            const flashcardContribution = Math.min(
                1,
                Math.log(scheduledCount + 0.5) / Math.log(64),
            );
            result =
                flashcardsInNoteAvgEase * flashcardContribution +
                settings.baseEase * (1 - flashcardContribution);
        }
        return result;
    }
    noteCalcUpdatedSchedule(notePath, noteSchedule, response, dueDateNoteHistogram) {
        const noteScheduleOsr = noteSchedule;
        const temp = this.calcSchedule(noteScheduleOsr, response, dueDateNoteHistogram);
        const interval = temp.interval;
        const ease = temp.latestEase;
        const dueDate = (0, import_moment2.default)(globalDateProvider.today.add(interval, "d"));
        this.noteEaseList.setEaseForPath(notePath, ease);
        return new RepItemScheduleInfoOsr(dueDate, interval, ease);
    }
    calcSchedule(schedule, response, dueDateHistogram) {
        const temp = osrSchedule(
            response,
            schedule.interval,
            schedule.latestEase,
            schedule.delayedBeforeReviewTicks,
            this.settings,
            dueDateHistogram,
        );
        return new RepItemScheduleInfoOsr(globalDateProvider.today, temp.interval, temp.ease);
    }
    cardGetResetSchedule() {
        const interval = _SrsAlgorithmOsr.initialInterval;
        const ease = this.settings.baseEase;
        const dueDate = globalDateProvider.today.add(interval, "d");
        return new RepItemScheduleInfoOsr(dueDate, interval, ease);
    }
    cardGetNewSchedule(response, notePath, dueDateFlashcardHistogram) {
        let initialEase = this.settings.baseEase;
        if (this.noteEaseList.hasEaseForPath(notePath)) {
            initialEase = Math.round(this.noteEaseList.getEaseByPath(notePath));
        }
        const delayBeforeReview = 0;
        const schedObj = osrSchedule(
            response,
            _SrsAlgorithmOsr.initialInterval,
            initialEase,
            delayBeforeReview,
            this.settings,
            dueDateFlashcardHistogram,
        );
        const interval = schedObj.interval;
        const ease = schedObj.ease;
        const dueDate = globalDateProvider.today.add(interval, "d");
        return new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReview);
    }
    cardCalcUpdatedSchedule(response, cardSchedule, dueDateFlashcardHistogram) {
        const cardScheduleOsr = cardSchedule;
        const schedObj = osrSchedule(
            response,
            cardScheduleOsr.interval,
            cardSchedule.latestEase,
            cardSchedule.delayedBeforeReviewTicks,
            this.settings,
            dueDateFlashcardHistogram,
        );
        const interval = schedObj.interval;
        const ease = schedObj.ease;
        const dueDate = globalDateProvider.today.add(interval, "d");
        const delayBeforeReview = 0;
        return new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReview);
    }
    noteStats() {
        return this.noteEaseList;
    }
};

// src/algorithms/osr/osr-note-graph.ts
var graph = __toESM(require_lib());

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a2, b2, str) => {
    const ma = a2 instanceof RegExp ? maybeMatch(a2, str) : a2;
    const mb = b2 instanceof RegExp ? maybeMatch(b2, str) : b2;
    const r2 = ma !== null && mb != null && range(ma, mb, str);
    return (
        r2 && {
            start: r2[0],
            end: r2[1],
            pre: str.slice(0, r2[0]),
            body: str.slice(r2[0] + ma.length, r2[1]),
            post: str.slice(r2[1] + mb.length),
        }
    );
};
var maybeMatch = (reg, str) => {
    const m2 = str.match(reg);
    return m2 ? m2[0] : null;
};
var range = (a2, b2, str) => {
    let begs,
        beg,
        left,
        right = void 0,
        result;
    let ai = str.indexOf(a2);
    let bi = str.indexOf(b2, ai + 1);
    let i2 = ai;
    if (ai >= 0 && bi > 0) {
        if (a2 === b2) {
            return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
            if (i2 === ai) {
                begs.push(i2);
                ai = str.indexOf(a2, i2 + 1);
            } else if (begs.length === 1) {
                const r2 = begs.pop();
                if (r2 !== void 0) result = [r2, bi];
            } else {
                beg = begs.pop();
                if (beg !== void 0 && beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b2, i2 + 1);
            }
            i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== void 0) {
            result = [left, right];
        }
    }
    return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str
        .replace(slashPattern, escSlash)
        .replace(openPattern, escOpen)
        .replace(closePattern, escClose)
        .replace(commaPattern, escComma)
        .replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
    return str
        .replace(escSlashPattern, "\\")
        .replace(escOpenPattern, "{")
        .replace(escClosePattern, "}")
        .replace(escCommaPattern, ",")
        .replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
    if (!str) {
        return [""];
    }
    const parts = [];
    const m2 = balanced("{", "}", str);
    if (!m2) {
        return str.split(",");
    }
    const { pre, body, post } = m2;
    const p2 = pre.split(",");
    p2[p2.length - 1] += "{" + body + "}";
    const postParts = parseCommaParts(post);
    if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
    }
    parts.push.apply(parts, p2);
    return parts;
}
function expand(str) {
    if (!str) {
        return [];
    }
    if (str.slice(0, 2) === "{}") {
        str = "\\{\\}" + str.slice(2);
    }
    return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return "{" + str + "}";
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i2, y2) {
    return i2 <= y2;
}
function gte(i2, y2) {
    return i2 >= y2;
}
function expand_(str, isTop) {
    const expansions = [];
    const m2 = balanced("{", "}", str);
    if (!m2) return [str];
    const pre = m2.pre;
    const post = m2.post.length ? expand_(m2.post, false) : [""];
    if (/\$$/.test(m2.pre)) {
        for (let k = 0; k < post.length; k++) {
            const expansion = pre + "{" + m2.body + "}" + post[k];
            expansions.push(expansion);
        }
    } else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m2.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
            if (m2.post.match(/,(?!,).*\}/)) {
                str = m2.pre + "{" + m2.body + escClose + m2.post;
                return expand_(str);
            }
            return [str];
        }
        let n2;
        if (isSequence) {
            n2 = m2.body.split(/\.\./);
        } else {
            n2 = parseCommaParts(m2.body);
            if (n2.length === 1 && n2[0] !== void 0) {
                n2 = expand_(n2[0], false).map(embrace);
                if (n2.length === 1) {
                    return post.map((p2) => m2.pre + n2[0] + p2);
                }
            }
        }
        let N2;
        if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
            const x2 = numeric(n2[0]);
            const y2 = numeric(n2[1]);
            const width = Math.max(n2[0].length, n2[1].length);
            let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
            let test = lte;
            const reverse = y2 < x2;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            const pad = n2.some(isPadded);
            N2 = [];
            for (let i2 = x2; test(i2, y2); i2 += incr) {
                let c2;
                if (isAlphaSequence) {
                    c2 = String.fromCharCode(i2);
                    if (c2 === "\\") {
                        c2 = "";
                    }
                } else {
                    c2 = String(i2);
                    if (pad) {
                        const need = width - c2.length;
                        if (need > 0) {
                            const z2 = new Array(need + 1).join("0");
                            if (i2 < 0) {
                                c2 = "-" + z2 + c2.slice(1);
                            } else {
                                c2 = z2 + c2;
                            }
                        }
                    }
                }
                N2.push(c2);
            }
        } else {
            N2 = [];
            for (let j2 = 0; j2 < n2.length; j2++) {
                N2.push.apply(N2, expand_(n2[j2], false));
            }
        }
        for (let j2 = 0; j2 < N2.length; j2++) {
            for (let k = 0; k < post.length; k++) {
                const expansion = pre + N2[j2] + post[k];
                if (!isTop || isSequence || expansion) {
                    expansions.push(expansion);
                }
            }
        }
    }
    return expansions;
}

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
    }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x00-\\x7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false],
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
    const pos = position;
    if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i2 = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE: while (i2 < glob.length) {
        const c2 = glob.charAt(i2);
        if ((c2 === "!" || c2 === "^") && i2 === pos + 1) {
            negate = true;
            i2++;
            continue;
        }
        if (c2 === "]" && sawStart && !escaping) {
            endPos = i2 + 1;
            break;
        }
        sawStart = true;
        if (c2 === "\\") {
            if (!escaping) {
                escaping = true;
                i2++;
                continue;
            }
        }
        if (c2 === "[" && !escaping) {
            for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i2)) {
                    if (rangeStart) {
                        return ["$.", false, glob.length - pos, true];
                    }
                    i2 += cls.length;
                    if (neg) negs.push(unip);
                    else ranges.push(unip);
                    uflag = uflag || u2;
                    continue WHILE;
                }
            }
        }
        escaping = false;
        if (rangeStart) {
            if (c2 > rangeStart) {
                ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
            } else if (c2 === rangeStart) {
                ranges.push(braceEscape(c2));
            }
            rangeStart = "";
            i2++;
            continue;
        }
        if (glob.startsWith("-]", i2 + 1)) {
            ranges.push(braceEscape(c2 + "-"));
            i2 += 2;
            continue;
        }
        if (glob.startsWith("-", i2 + 1)) {
            rangeStart = c2;
            i2 += 2;
            continue;
        }
        ranges.push(braceEscape(c2));
        i2++;
    }
    if (endPos < i2) {
        return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r2), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb =
        ranges.length && negs.length
            ? "(" + sranges + "|" + snegs + ")"
            : ranges.length
              ? sranges
              : snegs;
    return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape = (s2, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s2.replace(/\[([^\/\\])\]/g, "$1")
            : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    }
    return windowsPathsNoEscape
        ? s2.replace(/\[([^\/\\{}])\]/g, "$1")
        : s2.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root,
    _hasMagic,
    _uflag,
    _parts,
    _parent,
    _parentIndex,
    _negs,
    _filledNegs,
    _options,
    _toString,
    _emptyExt,
    _AST_instances,
    fillNegs_fn,
    _AST_static,
    parseAST_fn,
    partsToRegExp_fn,
    parseGlob_fn;
var _AST = class _AST {
    constructor(type, parent, options = {}) {
        __privateAdd(this, _AST_instances);
        __publicField(this, "type");
        __privateAdd(this, _root);
        __privateAdd(this, _hasMagic);
        __privateAdd(this, _uflag, false);
        __privateAdd(this, _parts, []);
        __privateAdd(this, _parent);
        __privateAdd(this, _parentIndex);
        __privateAdd(this, _negs);
        __privateAdd(this, _filledNegs, false);
        __privateAdd(this, _options);
        __privateAdd(this, _toString);
        // set to true if it's an extglob with no children
        // (which really means one child of '')
        __privateAdd(this, _emptyExt, false);
        this.type = type;
        if (type) __privateSet(this, _hasMagic, true);
        __privateSet(this, _parent, parent);
        __privateSet(
            this,
            _root,
            __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this,
        );
        __privateSet(
            this,
            _options,
            __privateGet(this, _root) === this
                ? options
                : __privateGet(__privateGet(this, _root), _options),
        );
        __privateSet(
            this,
            _negs,
            __privateGet(this, _root) === this
                ? []
                : __privateGet(__privateGet(this, _root), _negs),
        );
        if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
            __privateGet(this, _negs).push(this);
        __privateSet(
            this,
            _parentIndex,
            __privateGet(this, _parent)
                ? __privateGet(__privateGet(this, _parent), _parts).length
                : 0,
        );
    }
    get hasMagic() {
        if (__privateGet(this, _hasMagic) !== void 0) return __privateGet(this, _hasMagic);
        for (const p2 of __privateGet(this, _parts)) {
            if (typeof p2 === "string") continue;
            if (p2.type || p2.hasMagic) return __privateSet(this, _hasMagic, true);
        }
        return __privateGet(this, _hasMagic);
    }
    // reconstructs the pattern
    toString() {
        if (__privateGet(this, _toString) !== void 0) return __privateGet(this, _toString);
        if (!this.type) {
            return __privateSet(
                this,
                _toString,
                __privateGet(this, _parts)
                    .map((p2) => String(p2))
                    .join(""),
            );
        } else {
            return __privateSet(
                this,
                _toString,
                this.type +
                    "(" +
                    __privateGet(this, _parts)
                        .map((p2) => String(p2))
                        .join("|") +
                    ")",
            );
        }
    }
    push(...parts) {
        for (const p2 of parts) {
            if (p2 === "") continue;
            if (
                typeof p2 !== "string" &&
                !(p2 instanceof _AST && __privateGet(p2, _parent) === this)
            ) {
                throw new Error("invalid part: " + p2);
            }
            __privateGet(this, _parts).push(p2);
        }
    }
    toJSON() {
        var _a;
        const ret =
            this.type === null
                ? __privateGet(this, _parts)
                      .slice()
                      .map((p2) => (typeof p2 === "string" ? p2 : p2.toJSON()))
                : [this.type, ...__privateGet(this, _parts).map((p2) => p2.toJSON())];
        if (this.isStart() && !this.type) ret.unshift([]);
        if (
            this.isEnd() &&
            (this === __privateGet(this, _root) ||
                (__privateGet(__privateGet(this, _root), _filledNegs) &&
                    ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!"))
        ) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        var _a;
        if (__privateGet(this, _root) === this) return true;
        if (!((_a = __privateGet(this, _parent)) == null ? void 0 : _a.isStart())) return false;
        if (__privateGet(this, _parentIndex) === 0) return true;
        const p2 = __privateGet(this, _parent);
        for (let i2 = 0; i2 < __privateGet(this, _parentIndex); i2++) {
            const pp = __privateGet(p2, _parts)[i2];
            if (!(pp instanceof _AST && pp.type === "!")) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        var _a, _b, _c;
        if (__privateGet(this, _root) === this) return true;
        if (((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") return true;
        if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd())) return false;
        if (!this.type) return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
        const pl = __privateGet(this, _parent)
            ? __privateGet(__privateGet(this, _parent), _parts).length
            : 0;
        return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
        if (typeof part === "string") this.push(part);
        else this.push(part.clone(this));
    }
    clone(parent) {
        const c2 = new _AST(this.type, parent);
        for (const p2 of __privateGet(this, _parts)) {
            c2.copyIn(p2);
        }
        return c2;
    }
    static fromGlob(pattern, options = {}) {
        var _a;
        const ast = new _AST(null, void 0, options);
        __privateMethod((_a = _AST), _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        if (this !== __privateGet(this, _root)) return __privateGet(this, _root).toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic =
            hasMagic ||
            __privateGet(this, _hasMagic) ||
            (__privateGet(this, _options).nocase &&
                !__privateGet(this, _options).nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return __privateGet(this, _options);
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        var _a;
        const dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
        if (__privateGet(this, _root) === this)
            __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
        if (!this.type) {
            const noEmpty =
                this.isStart() &&
                this.isEnd() &&
                !__privateGet(this, _parts).some((s2) => typeof s2 !== "string");
            const src = __privateGet(this, _parts)
                .map((p2) => {
                    var _a2;
                    const [re, _2, hasMagic, uflag] =
                        typeof p2 === "string"
                            ? __privateMethod((_a2 = _AST), _AST_static, parseGlob_fn).call(
                                  _a2,
                                  p2,
                                  __privateGet(this, _hasMagic),
                                  noEmpty,
                              )
                            : p2.toRegExpSource(allowDot);
                    __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
                    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
                    return re;
                })
                .join("");
            let start2 = "";
            if (this.isStart()) {
                if (typeof __privateGet(this, _parts)[0] === "string") {
                    const dotTravAllowed =
                        __privateGet(this, _parts).length === 1 &&
                        justDots.has(__privateGet(this, _parts)[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        const needNoTrav =
                            // dots are allowed, and the pattern starts with [ or .
                            (dot && aps.has(src.charAt(0))) || // the pattern starts with \., and then [ or .
                            (src.startsWith("\\.") && aps.has(src.charAt(2))) || // the pattern starts with \.\., and then [ or .
                            (src.startsWith("\\.\\.") && aps.has(src.charAt(4)));
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
                    }
                }
            }
            let end = "";
            if (
                this.isEnd() &&
                __privateGet(__privateGet(this, _root), _filledNegs) &&
                ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!"
            ) {
                end = "(?:$|\\/)";
            }
            const final2 = start2 + src + end;
            return [
                final2,
                unescape(src),
                __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
                __privateGet(this, _uflag),
            ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
            const s2 = this.toString();
            __privateSet(this, _parts, [s2]);
            this.type = null;
            __privateSet(this, _hasMagic, void 0);
            return [s2, unescape(this.toString()), false, false];
        }
        let bodyDotAllowed =
            !repeated || allowDot || dot || !startNoDot
                ? ""
                : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && __privateGet(this, _emptyExt)) {
            final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
            const close =
                this.type === "!"
                    ? // !() must match something,but !(x) can match ''
                      "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
                    : this.type === "@"
                      ? ")"
                      : this.type === "?"
                        ? ")?"
                        : this.type === "+" && bodyDotAllowed
                          ? ")"
                          : this.type === "*" && bodyDotAllowed
                            ? `)?`
                            : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
            __privateGet(this, _uflag),
        ];
    }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_AST_instances = new WeakSet();
fillNegs_fn = function () {
    if (this !== __privateGet(this, _root)) throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs)) return this;
    this.toString();
    __privateSet(this, _filledNegs, true);
    let n2;
    while ((n2 = __privateGet(this, _negs).pop())) {
        if (n2.type !== "!") continue;
        let p2 = n2;
        let pp = __privateGet(p2, _parent);
        while (pp) {
            for (
                let i2 = __privateGet(p2, _parentIndex) + 1;
                !pp.type && i2 < __privateGet(pp, _parts).length;
                i2++
            ) {
                for (const part of __privateGet(n2, _parts)) {
                    if (typeof part === "string") {
                        throw new Error("string part in extglob AST??");
                    }
                    part.copyIn(__privateGet(pp, _parts)[i2]);
                }
            }
            p2 = pp;
            pp = __privateGet(p2, _parent);
        }
    }
    return this;
};
_AST_static = new WeakSet();
parseAST_fn = function (str, ast, pos, opt) {
    var _a, _b;
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
        let i3 = pos;
        let acc2 = "";
        while (i3 < str.length) {
            const c2 = str.charAt(i3++);
            if (escaping || c2 === "\\") {
                escaping = !escaping;
                acc2 += c2;
                continue;
            }
            if (inBrace) {
                if (i3 === braceStart + 1) {
                    if (c2 === "^" || c2 === "!") {
                        braceNeg = true;
                    }
                } else if (c2 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc2 += c2;
                continue;
            } else if (c2 === "[") {
                inBrace = true;
                braceStart = i3;
                braceNeg = false;
                acc2 += c2;
                continue;
            }
            if (!opt.noext && isExtglobType(c2) && str.charAt(i3) === "(") {
                ast.push(acc2);
                acc2 = "";
                const ext2 = new _AST(c2, ast);
                i3 = __privateMethod((_a = _AST), _AST_static, parseAST_fn).call(
                    _a,
                    str,
                    ext2,
                    i3,
                    opt,
                );
                ast.push(ext2);
                continue;
            }
            acc2 += c2;
        }
        ast.push(acc2);
        return i3;
    }
    let i2 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i2 < str.length) {
        const c2 = str.charAt(i2++);
        if (escaping || c2 === "\\") {
            escaping = !escaping;
            acc += c2;
            continue;
        }
        if (inBrace) {
            if (i2 === braceStart + 1) {
                if (c2 === "^" || c2 === "!") {
                    braceNeg = true;
                }
            } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
            }
            acc += c2;
            continue;
        } else if (c2 === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc += c2;
            continue;
        }
        if (isExtglobType(c2) && str.charAt(i2) === "(") {
            part.push(acc);
            acc = "";
            const ext2 = new _AST(c2, part);
            part.push(ext2);
            i2 = __privateMethod((_b = _AST), _AST_static, parseAST_fn).call(
                _b,
                str,
                ext2,
                i2,
                opt,
            );
            continue;
        }
        if (c2 === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
        }
        if (c2 === ")") {
            if (acc === "" && __privateGet(ast, _parts).length === 0) {
                __privateSet(ast, _emptyExt, true);
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i2;
        }
        acc += c2;
    }
    ast.type = null;
    __privateSet(ast, _hasMagic, void 0);
    __privateSet(ast, _parts, [str.substring(pos - 1)]);
    return i2;
};
partsToRegExp_fn = function (dot) {
    return __privateGet(this, _parts)
        .map((p2) => {
            if (typeof p2 === "string") {
                throw new Error("string type in extglob ast??");
            }
            const [re, _2, _hasMagic2, uflag] = p2.toRegExpSource(dot);
            __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
            return re;
        })
        .filter((p2) => !(this.isStart() && this.isEnd()) || !!p2)
        .join("|");
};
parseGlob_fn = function (glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i2 = 0; i2 < glob.length; i2++) {
        const c2 = glob.charAt(i2);
        if (escaping) {
            escaping = false;
            re += (reSpecials.has(c2) ? "\\" : "") + c2;
            continue;
        }
        if (c2 === "\\") {
            if (i2 === glob.length - 1) {
                re += "\\\\";
            } else {
                escaping = true;
            }
            continue;
        }
        if (c2 === "[") {
            const [src, needUflag, consumed, magic] = parseClass(glob, i2);
            if (consumed) {
                re += src;
                uflag = uflag || needUflag;
                i2 += consumed - 1;
                hasMagic = hasMagic || magic;
                continue;
            }
        }
        if (c2 === "*") {
            re += noEmpty && glob === "*" ? starNoEmpty : star;
            hasMagic = true;
            continue;
        }
        if (c2 === "?") {
            re += qmark;
            hasMagic = true;
            continue;
        }
        re += regExpEscape(c2);
    }
    return [re, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _AST_static);
var AST = _AST;

// node_modules/minimatch/dist/esm/escape.js
var escape = (s2, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s2.replace(/[?*()[\]{}]/g, "[$&]")
            : s2.replace(/[?*()[\]\\{}]/g, "\\$&");
    }
    return windowsPathsNoEscape
        ? s2.replace(/[?*()[\]]/g, "[$&]")
        : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
    }
    return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => f2.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2) return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2) return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && !f2.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
};
var defaultPlatform =
    typeof process === "object" && process
        ? (typeof process.env === "object" &&
              process.env &&
              process.env.__MINIMATCH_TESTING_PLATFORM__) ||
          process.platform
        : "posix";
var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" },
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter =
    (pattern, options = {}) =>
    (p2) =>
        minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m2 = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
    return Object.assign(m2, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
        escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR,
    });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f2) => mm.match(f2));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
    constructor(pattern, options = {}) {
        __publicField(this, "options");
        __publicField(this, "set");
        __publicField(this, "pattern");
        __publicField(this, "windowsPathsNoEscape");
        __publicField(this, "nonegate");
        __publicField(this, "negate");
        __publicField(this, "comment");
        __publicField(this, "empty");
        __publicField(this, "preserveMultipleSlashes");
        __publicField(this, "partial");
        __publicField(this, "globSet");
        __publicField(this, "globParts");
        __publicField(this, "nocase");
        __publicField(this, "isWindows");
        __publicField(this, "platform");
        __publicField(this, "windowsNoMagicRoot");
        __publicField(this, "regexp");
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== void 0
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== "string") return true;
            }
        }
        return false;
    }
    debug(..._2) {}
    make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set2 = this.globParts.map((s2, _2, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                const isUNC =
                    s2[0] === "" &&
                    s2[1] === "" &&
                    (s2[2] === "?" || !globMagic.test(s2[2])) &&
                    !globMagic.test(s2[3]);
                const isDrive = /^[a-z]:/i.test(s2[0]);
                if (isUNC) {
                    return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
                } else if (isDrive) {
                    return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
                }
            }
            return s2.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set2);
        this.set = set2.filter((s2) => s2.indexOf(false) === -1);
        if (this.isWindows) {
            for (let i2 = 0; i2 < this.set.length; i2++) {
                const p2 = this.set[i2];
                if (
                    p2[0] === "" &&
                    p2[1] === "" &&
                    this.globParts[i2][2] === "?" &&
                    typeof p2[3] === "string" &&
                    /^[a-z]:$/i.test(p2[3])
                ) {
                    p2[2] = "?";
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        if (this.options.noglobstar) {
            for (let i2 = 0; i2 < globParts.length; i2++) {
                for (let j2 = 0; j2 < globParts[i2].length; j2++) {
                    if (globParts[i2][j2] === "**") {
                        globParts[i2][j2] = "*";
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
            globParts = this.levelOneOptimize(globParts);
        } else {
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
                let i2 = gs;
                while (parts[i2 + 1] === "**") {
                    i2++;
                }
                if (i2 !== gs) {
                    parts.splice(gs, i2 - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map((parts) => {
            parts = parts.reduce((set2, part) => {
                const prev = set2[set2.length - 1];
                if (part === "**" && prev === "**") {
                    return set2;
                }
                if (part === "..") {
                    if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                        set2.pop();
                        return set2;
                    }
                }
                set2.push(part);
                return set2;
            }, []);
            return parts.length === 0 ? [""] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            if (!this.preserveMultipleSlashes) {
                for (let i2 = 1; i2 < parts.length - 1; i2++) {
                    const p2 = parts[i2];
                    if (i2 === 1 && p2 === "" && parts[0] === "") continue;
                    if (p2 === "." || p2 === "") {
                        didSomething = true;
                        parts.splice(i2, 1);
                        i2--;
                    }
                }
                if (
                    parts[0] === "." &&
                    parts.length === 2 &&
                    (parts[1] === "." || parts[1] === "")
                ) {
                    didSomething = true;
                    parts.pop();
                }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
                const p2 = parts[dd - 1];
                if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === "**") {
                        gss++;
                    }
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p2 = parts[gs + 2];
                    const p22 = parts[gs + 3];
                    if (next !== "..") continue;
                    if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
                        continue;
                    }
                    didSomething = true;
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = "**";
                    globParts.push(other);
                    gs--;
                }
                if (!this.preserveMultipleSlashes) {
                    for (let i2 = 1; i2 < parts.length - 1; i2++) {
                        const p2 = parts[i2];
                        if (i2 === 1 && p2 === "" && parts[0] === "") continue;
                        if (p2 === "." || p2 === "") {
                            didSomething = true;
                            parts.splice(i2, 1);
                            i2--;
                        }
                    }
                    if (
                        parts[0] === "." &&
                        parts.length === 2 &&
                        (parts[1] === "." || parts[1] === "")
                    ) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                let dd = 0;
                while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
                    const p2 = parts[dd - 1];
                    if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === "**";
                        const splin = needDot ? ["."] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0) parts.push("");
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i2 = 0; i2 < globParts.length - 1; i2++) {
            for (let j2 = i2 + 1; j2 < globParts.length; j2++) {
                const matched = this.partsMatch(
                    globParts[i2],
                    globParts[j2],
                    !this.preserveMultipleSlashes,
                );
                if (matched) {
                    globParts[i2] = [];
                    globParts[j2] = matched;
                    break;
                }
            }
        }
        return globParts.filter((gs) => gs.length);
    }
    partsMatch(a2, b2, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a2.length && bi < b2.length) {
            if (a2[ai] === b2[bi]) {
                result.push(which === "b" ? b2[bi] : a2[ai]);
                ai++;
                bi++;
            } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
                result.push(a2[ai]);
                ai++;
            } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
                result.push(b2[bi]);
                bi++;
            } else if (
                a2[ai] === "*" &&
                b2[bi] &&
                (this.options.dot || !b2[bi].startsWith(".")) &&
                b2[bi] !== "**"
            ) {
                if (which === "b") return false;
                which = "a";
                result.push(a2[ai]);
                ai++;
                bi++;
            } else if (
                b2[bi] === "*" &&
                a2[ai] &&
                (this.options.dot || !a2[ai].startsWith(".")) &&
                a2[ai] !== "**"
            ) {
                if (which === "a") return false;
                which = "b";
                result.push(b2[bi]);
                ai++;
                bi++;
            } else {
                return false;
            }
        }
        return a2.length === b2.length && result;
    }
    parseNegate() {
        if (this.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
            const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
            const fileUNC =
                !fileDrive &&
                file[0] === "" &&
                file[1] === "" &&
                file[2] === "?" &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC =
                !patternDrive &&
                pattern[0] === "" &&
                pattern[1] === "" &&
                pattern[2] === "?" &&
                typeof pattern[3] === "string" &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
            if (typeof fdi === "number" && typeof pdi === "number") {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    } else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (
            var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
            fi < fl && pi < pl;
            fi++, pi++
        ) {
            this.debug("matchOne loop");
            var p2 = pattern[pi];
            var f2 = file[fi];
            this.debug(pattern, p2, f2);
            if (p2 === false) {
                return false;
            }
            if (p2 === GLOBSTAR) {
                this.debug("GLOBSTAR", [pattern, p2, f2]);
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug("** at the end");
                    for (; fi < fl; fi++) {
                        if (
                            file[fi] === "." ||
                            file[fi] === ".." ||
                            (!options.dot && file[fi].charAt(0) === ".")
                        )
                            return false;
                    }
                    return true;
                }
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug("globstar found match!", fr, fl, swallowee);
                        return true;
                    } else {
                        if (
                            swallowee === "." ||
                            swallowee === ".." ||
                            (!options.dot && swallowee.charAt(0) === ".")
                        ) {
                            this.debug("dot detected!", file, fr, pattern, pr);
                            break;
                        }
                        this.debug("globstar swallow a segment, and continue");
                        fr++;
                    }
                }
                if (partial) {
                    this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                return false;
            }
            let hit;
            if (typeof p2 === "string") {
                hit = f2 === p2;
                this.debug("string match", p2, f2, hit);
            } else {
                hit = p2.test(f2);
                this.debug("pattern match", p2, f2, hit);
            }
            if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
            return true;
        } else if (fi === fl) {
            return partial;
        } else if (pi === pl) {
            return fi === fl - 1 && file[fi] === "";
        } else {
            throw new Error("wtf?");
        }
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") return GLOBSTAR;
        if (pattern === "") return "";
        let m2;
        let fastTest = null;
        if ((m2 = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        } else if ((m2 = pattern.match(starDotExtRE))) {
            fastTest = (
                options.nocase
                    ? options.dot
                        ? starDotExtTestNocaseDot
                        : starDotExtTestNocase
                    : options.dot
                      ? starDotExtTestDot
                      : starDotExtTest
            )(m2[1]);
        } else if ((m2 = pattern.match(qmarksRE))) {
            fastTest = (
                options.nocase
                    ? options.dot
                        ? qmarksTestNocaseDot
                        : qmarksTestNocase
                    : options.dot
                      ? qmarksTestDot
                      : qmarksTest
            )(m2);
        } else if ((m2 = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if ((m2 = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
            Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        const set2 = this.set;
        if (!set2.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set2
            .map((pattern) => {
                const pp = pattern.map((p2) => {
                    if (p2 instanceof RegExp) {
                        for (const f2 of p2.flags.split("")) flags.add(f2);
                    }
                    return typeof p2 === "string"
                        ? regExpEscape2(p2)
                        : p2 === GLOBSTAR
                          ? GLOBSTAR
                          : p2._src;
                });
                pp.forEach((p2, i2) => {
                    const next = pp[i2 + 1];
                    const prev = pp[i2 - 1];
                    if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
                        return;
                    }
                    if (prev === void 0) {
                        if (next !== void 0 && next !== GLOBSTAR) {
                            pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
                        } else {
                            pp[i2] = twoStar;
                        }
                    } else if (next === void 0) {
                        pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
                    } else if (next !== GLOBSTAR) {
                        pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
                        pp[i2 + 1] = GLOBSTAR;
                    }
                });
                const filtered = pp.filter((p2) => p2 !== GLOBSTAR);
                if (this.partial && filtered.length >= 1) {
                    const prefixes = [];
                    for (let i2 = 1; i2 <= filtered.length; i2++) {
                        prefixes.push(filtered.slice(0, i2).join("/"));
                    }
                    return "(?:" + prefixes.join("|") + ")";
                }
                return filtered.join("/");
            })
            .join("|");
        const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.partial) {
            re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
        }
        if (this.negate) re = "^(?!" + re + ").+$";
        try {
            this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
            this.regexp = false;
        }
        return this.regexp;
    }
    slashSplit(p2) {
        if (this.preserveMultipleSlashes) {
            return p2.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
            return ["", ...p2.split(/\/+/)];
        } else {
            return p2.split(/\/+/);
        }
    }
    match(f2, partial = this.partial) {
        this.debug("match", f2, this.pattern);
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f2 === "";
        }
        if (f2 === "/" && partial) {
            return true;
        }
        const options = this.options;
        if (this.isWindows) {
            f2 = f2.split("\\").join("/");
        }
        const ff = this.slashSplit(f2);
        this.debug(this.pattern, "split", ff);
        const set2 = this.set;
        this.debug(this.pattern, "set", set2);
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
                filename = ff[i2];
            }
        }
        for (let i2 = 0; i2 < set2.length; i2++) {
            const pattern = set2[i2];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// src/utils/fs.ts
function isSupportedFileType(path3) {
    return path3.split(".").pop().toLowerCase() === "md";
}
function pathMatchesPattern(path3, pattern) {
    return path3.startsWith(pattern) || minimatch(path3, pattern);
}

// src/algorithms/osr/osr-note-graph.ts
var OsrNoteGraph = class {
    constructor(vaultNoteLinkInfoFinder) {
        // Key: targetFilename
        // Value: Map<sourceFilename, linkCount>
        // This is the number of links from sourceFilename to targetFilename
        // For simplicity, we just store the filename without the directory or filename extension
        this.incomingLinks = {};
        this.pageranks = {};
        this.vaultNoteLinkInfoFinder = vaultNoteLinkInfoFinder;
        this.reset();
    }
    reset() {
        this.incomingLinks = {};
        this.pageranks = {};
        graph.reset();
    }
    processLinks(path3) {
        if (this.incomingLinks[path3] === void 0) {
            this.incomingLinks[path3] = [];
        }
        const targetLinks =
            this.vaultNoteLinkInfoFinder.getResolvedTargetLinksForNotePath(path3) || {};
        for (const targetPath in targetLinks) {
            if (this.incomingLinks[targetPath] === void 0) this.incomingLinks[targetPath] = [];
            if (isSupportedFileType(targetPath)) {
                const linkCount = targetLinks[targetPath];
                this.incomingLinks[targetPath].push({
                    sourcePath: path3,
                    linkCount,
                });
                graph.link(path3, targetPath, linkCount);
            }
        }
    }
    calcNoteLinkStat(notePath, noteEaseList) {
        let linkTotal = 0,
            linkPGTotal = 0,
            totalLinkCount = 0;
        for (const statObj of this.incomingLinks[notePath] || []) {
            const ease = noteEaseList.getEaseByPath(statObj.sourcePath);
            if (ease) {
                linkTotal += statObj.linkCount * this.pageranks[statObj.sourcePath] * ease;
                linkPGTotal += this.pageranks[statObj.sourcePath] * statObj.linkCount;
                totalLinkCount += statObj.linkCount;
            }
        }
        const outgoingLinks =
            this.vaultNoteLinkInfoFinder.getResolvedTargetLinksForNotePath(notePath) || {};
        for (const outgoingLink in outgoingLinks) {
            const ease = noteEaseList.getEaseByPath(outgoingLink);
            const linkCount = outgoingLinks[outgoingLink];
            const pageRank = this.pageranks[outgoingLink];
            if (ease) {
                linkTotal += linkCount * pageRank * ease;
                linkPGTotal += pageRank * linkCount;
                totalLinkCount += linkCount;
            }
        }
        return { linkTotal, linkPGTotal, totalLinkCount };
    }
    generatePageRanks() {
        graph.rank(0.85, 1e-6, (node, rank2) => {
            this.pageranks[node] = rank2 * 1e4;
        });
    }
};

// src/data-store-algorithm/data-store-algorithm.ts
var DataStoreAlgorithm = class _DataStoreAlgorithm {
    static getInstance() {
        if (!_DataStoreAlgorithm.instance) {
            throw new Error("there is no DataStoreAlgorithm instance.");
        }
        return _DataStoreAlgorithm.instance;
    }
};

// src/data-stores/base/data-store.ts
var DataStore = class _DataStore {
    static getInstance() {
        if (!_DataStore.instance) {
            throw new Error("there is no DataStore instance.");
        }
        return _DataStore.instance;
    }
};

// src/topic-path.ts
var TopicPath = class _TopicPath {
    constructor(path3) {
        if (path3 == null) throw "null path";
        if (path3.some((str) => str.includes("/"))) throw "path entries must not contain '/'";
        this.path = path3;
    }
    get hasPath() {
        return this.path.length > 0;
    }
    get isEmptyPath() {
        return !this.hasPath;
    }
    static get emptyPath() {
        return new _TopicPath([]);
    }
    shift() {
        if (this.isEmptyPath) throw "can't shift an empty path";
        return this.path.shift();
    }
    clone() {
        return new _TopicPath([...this.path]);
    }
    formatAsTag() {
        if (this.isEmptyPath) throw "Empty path";
        const result = "#" + this.path.join("/");
        return result;
    }
    static getTopicPathOfFile(noteFile, settings) {
        let deckPath = [];
        let result = _TopicPath.emptyPath;
        if (settings.convertFoldersToDecks) {
            deckPath = noteFile.path.split("/");
            deckPath.pop();
            if (deckPath.length != 0) {
                result = new _TopicPath(deckPath);
            }
        } else {
            const tagList = this.getTopicPathsFromTagList(noteFile.getAllTagsFromCache());
            outer: for (const tagToReview of this.getTopicPathsFromTagList(
                settings.flashcardTags,
            )) {
                for (const tag of tagList) {
                    if (tagToReview.isSameOrAncestorOf(tag)) {
                        result = tag;
                        break outer;
                    }
                }
            }
        }
        return result;
    }
    isSameOrAncestorOf(topicPath) {
        if (this.isEmptyPath) return topicPath.isEmptyPath;
        if (this.path.length > topicPath.path.length) return false;
        for (let i2 = 0; i2 < this.path.length; i2++) {
            if (this.path[i2] != topicPath.path[i2]) return false;
        }
        return true;
    }
    static getTopicPathFromCardText(cardText) {
        var _a;
        const path3 =
            (_a = cardText.trimStart().match(OBSIDIAN_TAG_AT_STARTOFLINE_REGEX)) == null
                ? void 0
                : _a.slice(-1)[0];
        return (path3 == null ? void 0 : path3.length) > 0
            ? _TopicPath.getTopicPathFromTag(path3)
            : null;
    }
    static getTopicPathsFromTagList(tagList) {
        const result = [];
        for (const tag of tagList) {
            if (this.isValidTag(tag)) result.push(_TopicPath.getTopicPathFromTag(tag));
        }
        return result;
    }
    static isValidTag(tag) {
        if (tag == null || tag.length == 0) return false;
        if (tag[0] != "#") return false;
        if (tag.length == 1) return false;
        return true;
    }
    static getTopicPathFromTag(tag) {
        if (tag == null || tag.length == 0) throw "Null/empty tag";
        if (tag[0] != "#") throw "Tag must start with #";
        if (tag.length == 1) throw "Invalid tag";
        const path3 = tag
            .replace("#", "")
            .split("/")
            .filter((str) => str);
        return new _TopicPath(path3);
    }
    static getFolderPathFromFilename(noteFile, settings) {
        let result = _TopicPath.emptyPath;
        if (settings.convertFoldersToDecks) {
            const deckPath = noteFile.path.split("/");
            deckPath.pop();
            if (deckPath.length != 0) {
                result = new _TopicPath(deckPath);
            }
        }
        return result;
    }
};
var TopicPathList = class _TopicPathList {
    constructor(list, lineNum = null) {
        if (list == null) throw "TopicPathList null";
        this.list = list;
        this.lineNum = lineNum;
    }
    get length() {
        return this.list.length;
    }
    isAnyElementSameOrAncestorOf(topicPath) {
        return this.list.some((item) => item.isSameOrAncestorOf(topicPath));
    }
    formatPsv() {
        return this.format("|");
    }
    format(sep2) {
        return this.list.map((topicPath) => topicPath.formatAsTag()).join(sep2);
    }
    static empty() {
        return new _TopicPathList([]);
    }
    static fromPsv(str, lineNum) {
        const result = _TopicPathList.convertTagListToTopicPathList(str.split("|"));
        result.lineNum = lineNum;
        return result;
    }
    //
    // tagList is a list of tags such as:
    //      ["#flashcards/computing", "#boring-stuff", "#news-worthy"]
    // validTopicPathList is a list of valid tags, such as those from settings.flashcardTags,E.g.
    //      ["#flashcards"]
    //
    // This returns a filtered version of tagList, containing only topic paths that are considered valid.
    // Validity is defined as "isAnyElementSameOrAncestorOf", and "#flashcards" is considered the ancestor of
    // "#flashcards/computing".
    //
    // Therefore this would return:
    //      "#flashcards/computing" (but not "#boring-stuff" or "#news-worthy")
    //
    static filterValidTopicPathsFromTagList(list, validTopicPathList, lineNum = null) {
        const result = [];
        for (const tag of list.list) {
            if (validTopicPathList.isAnyElementSameOrAncestorOf(tag)) result.push(tag);
        }
        return new _TopicPathList(result, lineNum);
    }
    static convertTagListToTopicPathList(tagList) {
        const result = [];
        for (const tag of tagList) {
            if (TopicPath.isValidTag(tag)) result.push(TopicPath.getTopicPathFromTag(tag));
        }
        return new _TopicPathList(result);
    }
};
var TopicPathWithWs = class {
    constructor(topicPath, preWhitespace, postWhitespace) {
        if (!topicPath || topicPath.isEmptyPath) throw "topicPath null";
        this.topicPath = topicPath;
        this.preWhitespace = preWhitespace;
        this.postWhitespace = postWhitespace;
    }
    formatWithWs() {
        return `${this.preWhitespace}${this.topicPath.formatAsTag()}${this.postWhitespace}`;
    }
};

// src/flashcard-review-sequencer.ts
var DeckStats = class {
    constructor(
        totalCount,
        dueCount,
        newCount,
        cardsInQueueCount,
        dueCardsInQueueOfThisDeckCount,
        newCardsInQueueOfThisDeckCount,
        cardsInQueueOfThisDeckCount,
        subDecksInQueueOfThisDeckCount,
        decksInQueueOfThisDeckCount,
    ) {
        this.dueCount = dueCount;
        this.newCount = newCount;
        this.totalCount = totalCount;
        this.cardsInQueueCount = cardsInQueueCount;
        this.dueCardsInQueueOfThisDeckCount = dueCardsInQueueOfThisDeckCount;
        this.newCardsInQueueOfThisDeckCount = newCardsInQueueOfThisDeckCount;
        this.cardsInQueueOfThisDeckCount = cardsInQueueOfThisDeckCount;
        this.subDecksInQueueOfThisDeckCount = subDecksInQueueOfThisDeckCount;
        this.decksInQueueOfThisDeckCount = decksInQueueOfThisDeckCount;
    }
};
var FlashcardReviewSequencer = class {
    constructor(
        reviewMode,
        cardSequencer,
        settings,
        srsAlgorithm,
        questionPostponementList,
        dueDateFlashcardHistogram,
    ) {
        this.reviewMode = reviewMode;
        this.cardSequencer = cardSequencer;
        this.settings = settings;
        this.srsAlgorithm = srsAlgorithm;
        this.questionPostponementList = questionPostponementList;
        this.dueDateFlashcardHistogram = dueDateFlashcardHistogram;
    }
    get hasCurrentCard() {
        return this.cardSequencer.currentCard != null;
    }
    get currentCard() {
        return this.cardSequencer.currentCard;
    }
    get currentQuestion() {
        var _a;
        return (_a = this.currentCard) == null ? void 0 : _a.question;
    }
    get currentDeck() {
        return this.cardSequencer.currentDeck;
    }
    get currentNote() {
        return this.currentQuestion.note;
    }
    // originalDeckTree isn't modified by the review process
    // Only remainingDeckTree
    setDeckTree(originalDeckTree, remainingDeckTree) {
        this.cardSequencer.setBaseDeck(remainingDeckTree);
        this._originalDeckTree = originalDeckTree;
        this.remainingDeckTree = remainingDeckTree;
        this.setCurrentDeck(TopicPath.emptyPath);
    }
    setCurrentDeck(topicPath) {
        this.cardSequencer.setIteratorTopicPath(topicPath);
        this.cardSequencer.nextCard();
    }
    get originalDeckTree() {
        return this._originalDeckTree;
    }
    getDeckStats(topicPath) {
        const totalCount = this._originalDeckTree
            .getDeck(topicPath)
            .getDistinctCardCount(2 /* All */, true);
        const remainingDeck = this.remainingDeckTree.getDeck(topicPath);
        const newCount = remainingDeck.getDistinctCardCount(0 /* NewCard */, true);
        const dueCount = remainingDeck.getDistinctCardCount(1 /* DueCard */, true);
        const newCardsInQueueOfThisDeckCount = remainingDeck.getDistinctCardCount(
            0 /* NewCard */,
            false,
        );
        const dueCardsInQueueOfThisDeckCount = remainingDeck.getDistinctCardCount(
            1 /* DueCard */,
            false,
        );
        const cardsInQueueOfThisDeckCount =
            newCardsInQueueOfThisDeckCount + dueCardsInQueueOfThisDeckCount;
        const subDecksInQueueOfThisDeckCount =
            this.getSubDecksWithCardsInQueue(remainingDeck).length;
        const decksInQueueOfThisDeckCount =
            cardsInQueueOfThisDeckCount > 0
                ? subDecksInQueueOfThisDeckCount + 1
                : subDecksInQueueOfThisDeckCount;
        return new DeckStats(
            totalCount,
            dueCount,
            newCount,
            dueCount + newCount,
            dueCardsInQueueOfThisDeckCount,
            newCardsInQueueOfThisDeckCount,
            cardsInQueueOfThisDeckCount,
            subDecksInQueueOfThisDeckCount,
            decksInQueueOfThisDeckCount,
        );
    }
    getSubDecksWithCardsInQueue(deck) {
        let subDecksWithCardsInQueue = [];
        deck.subdecks.forEach((subDeck) => {
            subDecksWithCardsInQueue = subDecksWithCardsInQueue.concat(
                this.getSubDecksWithCardsInQueue(subDeck),
            );
            const newCount = subDeck.getDistinctCardCount(0 /* NewCard */, false);
            const dueCount = subDeck.getDistinctCardCount(1 /* DueCard */, false);
            if (newCount + dueCount > 0) subDecksWithCardsInQueue.push(subDeck);
        });
        return subDecksWithCardsInQueue;
    }
    skipCurrentCard() {
        this.cardSequencer.deleteCurrentQuestionFromAllDecks();
    }
    deleteCurrentCard() {
        this.cardSequencer.deleteCurrentCardFromAllDecks();
    }
    async processReview(response) {
        switch (this.reviewMode) {
            case 1 /* Review */:
                await this.processReviewReviewMode(response);
                break;
            case 0 /* Cram */:
                await this.processReviewCramMode(response);
                break;
        }
    }
    async processReviewReviewMode(response) {
        if (response != 3 /* Reset */ || this.currentCard.hasSchedule) {
            const oldSchedule = this.currentCard.scheduleInfo;
            this.currentCard.scheduleInfo = this.determineCardSchedule(response, this.currentCard);
            await DataStore.getInstance().questionWriteSchedule(this.currentQuestion);
            if (oldSchedule) {
                const today = globalDateProvider.today.valueOf();
                const nDays = Math.ceil((oldSchedule.dueDateAsUnix - today) / TICKS_PER_DAY);
                this.dueDateFlashcardHistogram.decrement(nDays);
            }
            this.dueDateFlashcardHistogram.increment(this.currentCard.scheduleInfo.interval);
        }
        if (response == 3 /* Reset */) {
            this.cardSequencer.moveCurrentCardToEndOfList();
            this.cardSequencer.nextCard();
        } else {
            if (this.settings.burySiblingCards) {
                await this.burySiblingCards();
                this.cardSequencer.deleteCurrentQuestionFromAllDecks();
            } else {
                this.deleteCurrentCard();
            }
        }
    }
    async burySiblingCards() {
        const remaining = this.currentDeck.getQuestionCardCount(this.currentQuestion);
        if (remaining > 1) {
            this.questionPostponementList.add(this.currentQuestion);
            await this.questionPostponementList.write();
        }
    }
    async processReviewCramMode(response) {
        if (response == 0 /* Easy */) this.deleteCurrentCard();
        else {
            this.cardSequencer.moveCurrentCardToEndOfList();
            this.cardSequencer.nextCard();
        }
    }
    determineCardSchedule(response, card) {
        let result;
        if (response == 3 /* Reset */) {
            result = this.srsAlgorithm.cardGetResetSchedule();
        } else {
            if (card.hasSchedule) {
                result = this.srsAlgorithm.cardCalcUpdatedSchedule(
                    response,
                    card.scheduleInfo,
                    this.dueDateFlashcardHistogram,
                );
            } else {
                const currentNote = card.question.note;
                result = this.srsAlgorithm.cardGetNewSchedule(
                    response,
                    currentNote.filePath,
                    this.dueDateFlashcardHistogram,
                );
            }
        }
        return result;
    }
    async updateCurrentQuestionText(text) {
        const q2 = this.currentQuestion.questionText;
        q2.actualQuestion = text;
        await DataStore.getInstance().questionWrite(this.currentQuestion);
    }
};

// src/deck.ts
var Deck2 = class _Deck {
    constructor(deckName, parent) {
        this.deckName = deckName;
        this.newFlashcards = [];
        this.dueFlashcards = [];
        this.subdecks = [];
        this.parent = parent;
    }
    getCardCount(cardListType, includeSubdeckCounts) {
        let result = 0;
        if (cardListType == 0 /* NewCard */ || cardListType == 2 /* All */)
            result += this.newFlashcards.length;
        if (cardListType == 1 /* DueCard */ || cardListType == 2 /* All */)
            result += this.dueFlashcards.length;
        if (includeSubdeckCounts) {
            for (const deck of this.subdecks) {
                result += deck.getCardCount(cardListType, includeSubdeckCounts);
            }
        }
        return result;
    }
    getDistinctCardCount(cardListType, includeSubdeckCounts) {
        const cardList = this.getFlattenedCardArray(cardListType, includeSubdeckCounts);
        const distinctCardSet = new Set(cardList);
        return distinctCardSet.size;
    }
    getFlattenedCardArray(cardListType, includeSubdeckCounts) {
        let result = [];
        switch (cardListType) {
            case 0 /* NewCard */:
                result = this.newFlashcards;
                break;
            case 1 /* DueCard */:
                result = this.dueFlashcards;
                break;
            case 2 /* All */:
                result = this.newFlashcards.concat(this.dueFlashcards);
        }
        if (includeSubdeckCounts) {
            for (const subdeck of this.subdecks) {
                result = result.concat(
                    subdeck.getFlattenedCardArray(cardListType, includeSubdeckCounts),
                );
            }
        }
        return result;
    }
    // Returns a count of the number of this question's cards are present in this deck.
    // (The returned value would be <= question.cards.length)
    getQuestionCardCount(question) {
        let result = 0;
        result += this.getQuestionCardCountForCardListType(question, this.newFlashcards);
        result += this.getQuestionCardCountForCardListType(question, this.dueFlashcards);
        return result;
    }
    getQuestionCardCountForCardListType(question, cards) {
        let result = 0;
        for (let i2 = 0; i2 < cards.length; i2++) {
            if (Object.is(question, cards[i2].question)) result++;
        }
        return result;
    }
    static get emptyDeck() {
        return new _Deck("Root", null);
    }
    get isRootDeck() {
        return this.parent == null;
    }
    getDeckByTopicTag(tag) {
        return this.getDeck(TopicPath.getTopicPathFromTag(tag));
    }
    getDeck(topicPath) {
        return this._getOrCreateDeck(topicPath, false);
    }
    getOrCreateDeck(topicPath) {
        return this._getOrCreateDeck(topicPath, true);
    }
    _getOrCreateDeck(topicPath, createAllowed) {
        if (!topicPath.hasPath) {
            return this;
        }
        const t3 = topicPath.clone();
        const deckName = t3.shift();
        for (const subdeck of this.subdecks) {
            if (deckName === subdeck.deckName) {
                return subdeck._getOrCreateDeck(t3, createAllowed);
            }
        }
        let result = null;
        if (createAllowed) {
            const subdeck = new _Deck(
                deckName,
                this,
                /* parent */
            );
            this.subdecks.push(subdeck);
            result = subdeck._getOrCreateDeck(t3, createAllowed);
        }
        return result;
    }
    getTopicPath() {
        const list = [];
        let deck = this;
        while (!deck.isRootDeck) {
            list.push(deck.deckName);
            deck = deck.parent;
        }
        return new TopicPath(list.reverse());
    }
    getRootDeck() {
        let deck = this;
        while (!deck.isRootDeck) {
            deck = deck.parent;
        }
        return deck;
    }
    getCard(index, cardListType) {
        const cardList = this.getCardListForCardType(cardListType);
        return cardList[index];
    }
    getCardListForCardType(cardListType) {
        return cardListType == 1 /* DueCard */ ? this.dueFlashcards : this.newFlashcards;
    }
    appendCard(topicPathList, cardObj) {
        if (topicPathList.list.length == 0) {
            this.appendCardToRootDeck(cardObj);
        } else {
            for (const topicPath of topicPathList.list) {
                this.appendCardSingleTopic(topicPath, cardObj);
            }
        }
    }
    appendCardToRootDeck(cardObj) {
        this.appendCardSingleTopic(TopicPath.emptyPath, cardObj);
    }
    appendCardSingleTopic(topicPath, cardObj) {
        const deck = this.getOrCreateDeck(topicPath);
        const cardList = deck.getCardListForCardType(cardObj.cardListType);
        cardList.push(cardObj);
    }
    // The question lists all the topics in which this card is included.
    // The topics are relative to the base deck, and this method must be called on that deck
    deleteQuestionFromAllDecks(question, exceptionIfMissing) {
        for (const card of question.cards) {
            this.deleteCardFromAllDecks(card, exceptionIfMissing);
        }
    }
    deleteQuestion(question, exceptionIfMissing) {
        for (const card of question.cards) {
            this.deleteCardFromThisDeck(card, exceptionIfMissing);
        }
    }
    // The card's question lists all the topics in which this card is included.
    // The topics are relative to the base deck, and this method must be called on that deck
    deleteCardFromAllDecks(card, exceptionIfMissing) {
        for (const topicPath of card.question.topicPathList.list) {
            const deck = this.getDeck(topicPath);
            deck.deleteCardFromThisDeck(card, exceptionIfMissing);
        }
    }
    deleteCardFromThisDeck(card, exceptionIfMissing) {
        const newIdx = this.newFlashcards.indexOf(card);
        if (newIdx != -1) this.newFlashcards.splice(newIdx, 1);
        const dueIdx = this.dueFlashcards.indexOf(card);
        if (dueIdx != -1) this.dueFlashcards.splice(dueIdx, 1);
        if (newIdx == -1 && dueIdx == -1 && exceptionIfMissing) {
            throw `deleteCardFromThisDeck: Card: ${card.front} not found in deck: ${this.deckName}`;
        }
    }
    deleteCardAtIndex(index, cardListType) {
        const cardList = this.getCardListForCardType(cardListType);
        cardList.splice(index, 1);
    }
    toDeckArray() {
        const result = [];
        result.push(this);
        for (const subdeck of this.subdecks) {
            result.push(...subdeck.toDeckArray());
        }
        return result;
    }
    sortSubdecksList() {
        this.subdecks.sort((a2, b2) => {
            if (a2.deckName < b2.deckName) {
                return -1;
            } else if (a2.deckName > b2.deckName) {
                return 1;
            }
            return 0;
        });
        for (const deck of this.subdecks) {
            deck.sortSubdecksList();
        }
    }
    debugLogToConsole(desc = null, indent = 0) {
        let str = desc != null ? `${desc}: ` : "";
        console.log((str += this.toString(indent)));
    }
    toString(indent = 0) {
        let result = "";
        let indentStr = " ".repeat(indent * 4);
        result += `${indentStr}${this.deckName}\r
`;
        indentStr += "  ";
        for (let i2 = 0; i2 < this.newFlashcards.length; i2++) {
            const card = this.newFlashcards[i2];
            result += `${indentStr}New: ${i2}: ${card.front}::${card.back}\r
`;
        }
        for (let i2 = 0; i2 < this.dueFlashcards.length; i2++) {
            const card = this.dueFlashcards[i2];
            const s2 = card.isDue ? "Due" : "Not due";
            result += `${indentStr}${s2}: ${i2}: ${card.front}::${card.back}\r
`;
        }
        for (const subdeck of this.subdecks) {
            result += subdeck.toString(indent + 1);
        }
        return result;
    }
    clone() {
        return this.copyWithCardFilter(() => true);
    }
    copyWithCardFilter(predicate, parent = null) {
        const result = new _Deck(this.deckName, parent);
        result.newFlashcards = [...this.newFlashcards.filter((card) => predicate(card))];
        result.dueFlashcards = [...this.dueFlashcards.filter((card) => predicate(card))];
        for (const s2 of this.subdecks) {
            const newParent = result;
            const newDeck = s2.copyWithCardFilter(predicate, newParent);
            result.subdecks.push(newDeck);
        }
        return result;
    }
    static otherListType(cardListType) {
        let result;
        if (cardListType == 0 /* NewCard */) result = 1 /* DueCard */;
        else if (cardListType == 1 /* DueCard */) result = 0 /* NewCard */;
        else throw "Invalid cardListType";
        return result;
    }
};
var DeckTreeFilter = class {
    static filterForReviewableCards(reviewableDeckTree) {
        return reviewableDeckTree.copyWithCardFilter((card) => !card.question.hasEditLaterTag);
    }
    static filterForRemainingCards(questionPostponementList, deckTree, reviewMode) {
        return deckTree.copyWithCardFilter(
            (card) =>
                (reviewMode == 0 /* Cram */ || card.isNew || card.isDue) &&
                !questionPostponementList.includes(card.question),
        );
    }
};

// src/utils/types.ts
function getTypedObjectEntries(obj) {
    return Object.entries(obj);
}
var getKeysPreserveType = Object.keys;
function mapRecord(record, transform) {
    return Object.fromEntries(Object.entries(record).map(([key, value]) => transform(key, value)));
}

// src/utils/numbers.ts
var ValueCountDict = class {
    constructor() {
        this.dict = {};
    }
    // Record<value, count>
    clearCountIfMissing(value) {
        if (!this.hasValue(value)) this.dict[value] = 0;
    }
    hasValue(value) {
        return Object.prototype.hasOwnProperty.call(this.dict, value);
    }
    incrementCount(value) {
        this.clearCountIfMissing(value);
        this.dict[value]++;
    }
    getMaxValue() {
        return Math.max(...getKeysPreserveType(this.dict)) || 0;
    }
    getTotalOfValueMultiplyCount() {
        const v2 =
            getTypedObjectEntries(this.dict)
                .map(([value, count]) => value * count)
                .reduce((a2, b2) => a2 + b2, 0) || 0;
        return v2;
    }
};
var RandomNumberProvider = class {
    getInteger(lowerBound, upperBound) {
        const range2 = upperBound - lowerBound + 1;
        return Math.floor(Math.random() * range2) + lowerBound;
    }
};
var StaticRandomNumberProvider = class {
    getInteger(lowerBound, upperBound) {
        if (lowerBound != this.expectedLowerBound || upperBound != this.expectedUpperBound)
            throw `lowerBound: A${lowerBound}/E${this.expectedLowerBound}, upperBound: A${upperBound}/E${this.expectedUpperBound}`;
        return this.next;
    }
};
var WeightedRandomNumber = class _WeightedRandomNumber {
    constructor(provider) {
        this.provider = provider;
    }
    static create() {
        return new _WeightedRandomNumber(globalRandomNumberProvider);
    }
    // weights is a dictionary:
    //      first number - a key that can be returned
    //      second number - the "bucket size" - this is a weight that influences the probability of the
    //          first number being returned
    //
    // returns:
    //      first number - one of the keys from the weights parameter
    //      second number - an "index" value; 0 <= index < bucketSize
    getRandomValues(weights) {
        const total = _WeightedRandomNumber.calcTotalOfCount(weights);
        if (Object.values(weights).some((i2) => !Number.isInteger(i2) || i2 < 0))
            throw "All weights must be positive integers";
        const v2 = this.provider.getInteger(0, total - 1);
        let x2 = 0;
        for (const kvp in weights) {
            const [value, count] = [Number(kvp), weights[kvp]];
            if (v2 < x2 + count) {
                const index = v2 - x2;
                return [value, index];
            }
            x2 += count;
        }
        throw "";
    }
    static calcTotalOfCount(weights) {
        const total =
            getTypedObjectEntries(weights)
                .map(([_2, count]) => count)
                .reduce((a2, b2) => a2 + b2, 0) || 0;
        return total;
    }
};
var globalRandomNumberProvider = new RandomNumberProvider();
var staticRandomNumberProvider = new StaticRandomNumberProvider();

// src/deck-tree-iterator.ts
var CardOrder = /* @__PURE__ */ ((CardOrder2) => {
    CardOrder2[(CardOrder2["NewFirstSequential"] = 0)] = "NewFirstSequential";
    CardOrder2[(CardOrder2["NewFirstRandom"] = 1)] = "NewFirstRandom";
    CardOrder2[(CardOrder2["DueFirstSequential"] = 2)] = "DueFirstSequential";
    CardOrder2[(CardOrder2["DueFirstRandom"] = 3)] = "DueFirstRandom";
    CardOrder2[(CardOrder2["EveryCardRandomDeckAndCard"] = 4)] = "EveryCardRandomDeckAndCard";
    return CardOrder2;
})(CardOrder || {});
var DeckOrder = /* @__PURE__ */ ((DeckOrder2) => {
    DeckOrder2[(DeckOrder2["PrevDeckComplete_Sequential"] = 0)] = "PrevDeckComplete_Sequential";
    DeckOrder2[(DeckOrder2["PrevDeckComplete_Random"] = 1)] = "PrevDeckComplete_Random";
    return DeckOrder2;
})(DeckOrder || {});
var SingleDeckIterator = class _SingleDeckIterator {
    get hasCurrentCard() {
        return this.cardIdx != null;
    }
    get currentCard() {
        let result = null;
        if (this.cardIdx != null) result = this.deck.getCard(this.cardIdx, this.cardListType);
        return result;
    }
    constructor(iteratorOrder) {
        this.iteratorOrder = iteratorOrder;
        this.preferredCardListType = _SingleDeckIterator.getCardListTypeForIterator(
            this.iteratorOrder,
        );
        this.weightedRandomNumber = WeightedRandomNumber.create();
    }
    setDeck(deck) {
        this.deck = deck;
        this.setCardListType(null);
    }
    //
    // 0 <= cardIndex < newFlashcards.length + dueFlashcards.length
    //
    setNewOrDueCardIdx(cardIndex) {
        let cardListType = 0; /* NewCard */
        let index = cardIndex;
        if (cardIndex >= this.deck.newFlashcards.length) {
            cardListType = 1 /* DueCard */;
            index = cardIndex - this.deck.newFlashcards.length;
        }
        this.setCardListType(cardListType, index);
    }
    setCardListType(cardListType, cardIdx = null) {
        this.cardListType = cardListType;
        this.cardIdx = cardIdx;
    }
    nextCard() {
        if (this.iteratorOrder.cardOrder == 4 /* EveryCardRandomDeckAndCard */) {
            this.nextRandomCard();
        } else {
            if (this.cardListType == null) {
                this.setCardListType(this.preferredCardListType);
            }
            if (!this.nextCardWithinCurrentList()) {
                if (this.cardListType == this.preferredCardListType) {
                    this.setCardListType(Deck2.otherListType(this.cardListType));
                    if (!this.nextCardWithinCurrentList()) {
                        this.setCardListType(null);
                    }
                } else {
                    this.cardIdx = null;
                }
            }
        }
        return this.cardIdx != null;
    }
    nextRandomCard() {
        const newCount = this.deck.newFlashcards.length;
        const dueCount = this.deck.dueFlashcards.length;
        if (newCount + dueCount > 0) {
            const weights = {};
            if (newCount > 0) weights[0 /* NewCard */] = newCount;
            if (dueCount > 0) weights[1 /* DueCard */] = dueCount;
            const [cardListType, index] = this.weightedRandomNumber.getRandomValues(weights);
            this.setCardListType(cardListType, index);
        } else {
            this.setCardListType(null);
        }
    }
    nextCardWithinCurrentList() {
        const cardList = this.deck.getCardListForCardType(this.cardListType);
        const result = cardList.length > 0;
        if (result) {
            switch (this.iteratorOrder.cardOrder) {
                case 2 /* DueFirstSequential */:
                case 0 /* NewFirstSequential */:
                    this.cardIdx = 0;
                    break;
                case 3 /* DueFirstRandom */:
                case 1 /* NewFirstRandom */:
                    this.cardIdx = globalRandomNumberProvider.getInteger(0, cardList.length - 1);
                    break;
            }
        }
        return result;
    }
    moveCurrentCardToEndOfList() {
        this.ensureCurrentCard();
        const cardList = this.deck.getCardListForCardType(this.cardListType);
        if (cardList.length <= 1) return;
        const card = this.currentCard;
        this.deck.deleteCardAtIndex(this.cardIdx, this.cardListType);
        this.deck.appendCardToRootDeck(card);
        this.setNoCurrentCard();
    }
    setNoCurrentCard() {
        this.cardIdx = null;
    }
    ensureCurrentCard() {
        if (this.cardIdx == null || this.cardListType == null) throw "no current card";
    }
    static getCardListTypeForIterator(iteratorOrder) {
        let result = null;
        switch (iteratorOrder.cardOrder) {
            case 3 /* DueFirstRandom */:
            case 2 /* DueFirstSequential */:
                result = 1 /* DueCard */;
                break;
            case 1 /* NewFirstRandom */:
            case 0 /* NewFirstSequential */:
                result = 0 /* NewCard */;
                break;
        }
        return result;
    }
};
var DeckTreeIterator = class _DeckTreeIterator {
    get hasCurrentCard() {
        return this.deckIdx != null && this.singleDeckIterator.hasCurrentCard;
    }
    get currentTopicPath() {
        var _a;
        return (_a = this.currentDeck) == null ? void 0 : _a.getTopicPath();
    }
    get currentDeck() {
        if (this.deckIdx == null) return null;
        return this.deckArray[this.deckIdx];
    }
    get currentCard() {
        let result = null;
        if (this.deckIdx != null && this.singleDeckIterator.hasCurrentCard)
            result = this.singleDeckIterator.currentCard;
        return result;
    }
    get currentQuestion() {
        var _a;
        return (_a = this.currentCard) == null ? void 0 : _a.question;
    }
    constructor(iteratorOrder, baseDeckTree) {
        this.singleDeckIterator = new SingleDeckIterator(iteratorOrder);
        this.iteratorOrder = iteratorOrder;
        this.weightedRandomNumber = WeightedRandomNumber.create();
        this.setBaseDeck(baseDeckTree);
    }
    setBaseDeck(baseDeck) {
        this.baseDeckTree = baseDeck;
        this.singleDeckIterator.setNoCurrentCard();
    }
    setIteratorTopicPath(topicPath) {
        const iteratorDeck = this.baseDeckTree.getDeck(topicPath);
        this.deckArray = _DeckTreeIterator.filterForDecksWithCards(iteratorDeck.toDeckArray());
        this.setDeckIdx(null);
    }
    static filterForDecksWithCards(sourceArray) {
        const result = [];
        for (let idx = 0; idx < sourceArray.length; idx++) {
            const deck = sourceArray[idx];
            const hasAnyCards = deck.getCardCount(2 /* All */, false) > 0;
            if (hasAnyCards) {
                result.push(deck);
            }
        }
        return result;
    }
    setDeckIdx(deckIdx) {
        this.deckIdx = deckIdx;
        if (deckIdx != null) this.singleDeckIterator.setDeck(this.deckArray[deckIdx]);
    }
    nextCard() {
        let result = false;
        if (this.hasCurrentCard) {
            this.baseDeckTree.deleteCardFromAllDecks(this.currentCard, true);
        }
        if (this.iteratorOrder.cardOrder == 4 /* EveryCardRandomDeckAndCard */) {
            result = this.nextCardEveryCardRandomDeck();
        } else {
            if (this.deckIdx == null) {
                this.chooseNextDeck(true);
            }
            while (this.deckIdx < this.deckArray.length) {
                if (this.singleDeckIterator.nextCard()) {
                    result = true;
                    break;
                }
                this.chooseNextDeck(false);
            }
        }
        if (!result) this.deckIdx = null;
        return result;
    }
    chooseNextDeck(firstTime) {
        switch (this.iteratorOrder.deckOrder) {
            case 0 /* PrevDeckComplete_Sequential */:
                this.deckIdx = firstTime ? 0 : this.deckIdx + 1;
                break;
            case 1 /* PrevDeckComplete_Random */: {
                const weights = {};
                let hasDeck = false;
                for (let i2 = 0; i2 < this.deckArray.length; i2++) {
                    if (this.deckArray[i2].getCardCount(2 /* All */, false)) {
                        weights[i2] = 1;
                        hasDeck = true;
                    }
                }
                if (hasDeck) {
                    const [deckIdx, _2] = this.weightedRandomNumber.getRandomValues(weights);
                    this.deckIdx = deckIdx;
                } else {
                    this.deckIdx = this.deckArray.length;
                }
                break;
            }
        }
        if (this.deckIdx < this.deckArray.length) {
            this.singleDeckIterator.setDeck(this.deckArray[this.deckIdx]);
        }
    }
    nextCardEveryCardRandomDeck() {
        const weights = {};
        for (let i2 = 0; i2 < this.deckArray.length; i2++) {
            const cardCount = this.deckArray[i2].getCardCount(2 /* All */, false);
            if (cardCount) {
                weights[i2] = cardCount;
            }
        }
        if (Object.keys(weights).length == 0) return false;
        const [deckIdx, cardIdx] = this.weightedRandomNumber.getRandomValues(weights);
        this.setDeckIdx(deckIdx);
        this.singleDeckIterator.setNewOrDueCardIdx(cardIdx);
        return true;
    }
    deleteCurrentQuestionFromAllDecks() {
        this.singleDeckIterator.ensureCurrentCard();
        this.baseDeckTree.deleteQuestionFromAllDecks(this.currentQuestion, false);
        this.singleDeckIterator.setNoCurrentCard();
        return this.nextCard();
    }
    deleteCurrentCardFromAllDecks() {
        this.singleDeckIterator.ensureCurrentCard();
        this.baseDeckTree.deleteCardFromAllDecks(this.currentCard, true);
        this.singleDeckIterator.setNoCurrentCard();
        return this.nextCard();
    }
    moveCurrentCardToEndOfList() {
        this.singleDeckIterator.moveCurrentCardToEndOfList();
    }
    removeCurrentDeckIfEmpty() {
        if (this.currentDeck.getCardCount(2 /* All */, false) == 0) {
            this.deckArray.splice(this.deckIdx, 1);
            if (this.deckIdx < this.deckArray.length) this.setDeckIdx(this.deckIdx);
        }
    }
};

// src/stats.ts
var Stats = class {
    constructor() {
        this.eases = new ValueCountDict();
        this.intervals = new ValueCountDict();
        this.delayedDays = new ValueCountDict();
        this.newCount = 0;
        this.youngCount = 0;
        this.matureCount = 0;
    }
    get totalCount() {
        return this.youngCount + this.matureCount;
    }
    incrementNew() {
        this.newCount++;
    }
    update(delayedDays, interval, ease) {
        this.intervals.incrementCount(interval);
        this.eases.incrementCount(ease);
        this.delayedDays.incrementCount(delayedDays);
        if (interval >= 32) {
            this.matureCount++;
        } else {
            this.youngCount++;
        }
    }
    getMaxInterval() {
        return this.intervals.getMaxValue();
    }
    getAverageInterval() {
        return this.intervals.getTotalOfValueMultiplyCount() / this.totalCount;
    }
    getAverageEases() {
        return this.eases.getTotalOfValueMultiplyCount() / this.totalCount;
    }
};

// src/deck-tree-stats-calculator.ts
var DeckTreeStatsCalculator = class {
    calculate(deckTree) {
        const iteratorOrder = {
            deckOrder: 0 /* PrevDeckComplete_Sequential */,
            cardOrder: 2 /* DueFirstSequential */,
        };
        const iterator = new DeckTreeIterator(iteratorOrder, deckTree.clone());
        const result = new Stats();
        iterator.setIteratorTopicPath(TopicPath.emptyPath);
        while (iterator.nextCard()) {
            const card = iterator.currentCard;
            if (card.hasSchedule) {
                const schedule = card.scheduleInfo;
                result.update(
                    schedule.delayedBeforeReviewDaysInt(),
                    schedule.interval,
                    schedule.latestEase,
                );
            } else {
                result.incrementNew();
            }
        }
        return result;
    }
};

// src/due-date-histogram.ts
var _DueDateHistogram = class _DueDateHistogram {
    constructor(rec = null) {
        // Key - # of days in future
        // Value - Count of notes due
        this.dueDatesMap = /* @__PURE__ */ new Map();
        this.dueDatesMap = /* @__PURE__ */ new Map();
        if (rec != null) {
            Object.entries(rec).forEach(([key, value]) => {
                this.dueDatesMap.set(Number(key), value);
            });
        }
    }
    get dueNotesCount() {
        let result = 0;
        if (this.dueDatesMap.has(_DueDateHistogram.dueNowNDays))
            result = this.dueDatesMap.get(_DueDateHistogram.dueNowNDays);
        return result;
    }
    hasEntryForDays(days) {
        return this.dueDatesMap.has(days);
    }
    set(days, value) {
        this.dueDatesMap.set(days, value);
    }
    get(days) {
        return this.dueDatesMap.get(days);
    }
    increment(days) {
        let value = 0;
        if (this.dueDatesMap.has(days)) {
            value = this.dueDatesMap.get(days);
        }
        this.dueDatesMap.set(days, value + 1);
    }
    decrement(days) {
        let value = 0;
        if (this.dueDatesMap.has(days)) value = this.dueDatesMap.get(days);
        if (value > 0) {
            this.dueDatesMap.set(days, value - 1);
        }
    }
    findLeastUsedIntervalOverRange(originalInterval, fuzz) {
        if (!this.hasEntryForDays(originalInterval)) {
            return originalInterval;
        }
        let interval = originalInterval;
        outer: for (let i2 = 1; i2 <= fuzz; i2++) {
            for (const ivl of [originalInterval - i2, originalInterval + i2]) {
                if (!this.hasEntryForDays(ivl)) {
                    interval = ivl;
                    break outer;
                }
                if (this.dueDatesMap.get(ivl) < this.dueDatesMap.get(interval)) interval = ivl;
            }
        }
        return interval;
    }
};
// The key for dueDatesNotes is the number of days after today
// therefore the key to lookup how many cards are due today is 0
_DueDateHistogram.dueNowNDays = 0;
var DueDateHistogram = _DueDateHistogram;
var NoteDueDateHistogram = class extends DueDateHistogram {
    calculateFromReviewDecksAndSort(reviewDecks, osrNoteGraph) {
        this.dueDatesMap = /* @__PURE__ */ new Map();
        const today = globalDateProvider.today.valueOf();
        reviewDecks.forEach((reviewDeck) => {
            reviewDeck.scheduledNotes.forEach((scheduledNote) => {
                const nDays = Math.ceil((scheduledNote.dueUnix - today) / TICKS_PER_DAY);
                this.increment(nDays);
            });
            reviewDeck.sortNotesByDateAndImportance(osrNoteGraph.pageranks);
        });
    }
};
var CardDueDateHistogram = class extends DueDateHistogram {
    calculateFromDeckTree(deckTree) {
        this.dueDatesMap = /* @__PURE__ */ new Map();
        const iteratorOrder = {
            deckOrder: 0 /* PrevDeckComplete_Sequential */,
            cardOrder: 2 /* DueFirstSequential */,
        };
        const today = globalDateProvider.today.valueOf();
        const iterator = new DeckTreeIterator(iteratorOrder, deckTree.clone());
        iterator.setIteratorTopicPath(TopicPath.emptyPath);
        while (iterator.nextCard()) {
            const card = iterator.currentCard;
            if (card.hasSchedule) {
                const scheduledCard = card.scheduleInfo;
                const nDays = Math.ceil((scheduledCard.dueDateAsUnix - today) / TICKS_PER_DAY);
                this.increment(nDays);
            }
        }
    }
};

// src/file.ts
var import_obsidian2 = require("obsidian");

// src/utils/strings.ts
function literalStringReplace(text, searchStr, replacementStr) {
    let result = text;
    const startIdx = text.indexOf(searchStr);
    if (startIdx >= 0) {
        const startStr = text.substring(0, startIdx);
        const endIdx = startIdx + searchStr.length;
        const endStr = text.substring(endIdx);
        result = startStr + replacementStr + endStr;
    }
    return result;
}
function cyrb53(str, seed = 0) {
    let h12 = 3735928559 ^ seed,
        h22 = 1103547991 ^ seed;
    for (let i2 = 0, ch; i2 < str.length; i2++) {
        ch = str.charCodeAt(i2);
        h12 = Math.imul(h12 ^ ch, 2654435761);
        h22 = Math.imul(h22 ^ ch, 1597334677);
    }
    h12 = Math.imul(h12 ^ (h12 >>> 16), 2246822507) ^ Math.imul(h22 ^ (h22 >>> 13), 3266489909);
    h22 = Math.imul(h22 ^ (h22 >>> 16), 2246822507) ^ Math.imul(h12 ^ (h12 >>> 13), 3266489909);
    return (4294967296 * (2097151 & h22) + (h12 >>> 0)).toString(16);
}
function convertToStringOrEmpty(v2) {
    let result = "";
    if (v2 != null && v2 != void 0) {
        result = v2 + "";
    }
    return result;
}
function splitTextIntoLineArray(text) {
    return text.replaceAll(/\r\n|\r/g, "\n").split("\n");
}
function stringTrimStart(str) {
    if (!str) {
        return ["", ""];
    }
    const trimmed = str.trimStart();
    const wsCount = str.length - trimmed.length;
    const ws = str.substring(0, wsCount);
    return [ws, trimmed];
}
function splitNoteIntoFrontmatterAndContent(str) {
    const lines = splitTextIntoLineArray(str);
    let lineIndex = 0;
    let hasFrontmatter = false;
    do {
        if (lineIndex === 0 && lines[lineIndex] === "---") {
            hasFrontmatter = true;
        } else if (hasFrontmatter && lines[lineIndex] === "---") {
            hasFrontmatter = false;
            lineIndex++;
        }
        if (hasFrontmatter) {
            lineIndex++;
        }
    } while (hasFrontmatter && lineIndex < lines.length);
    if (hasFrontmatter) {
        lineIndex = 0;
    }
    const frontmatter = lines.slice(0, lineIndex).join("\n");
    const emptyLines = lineIndex > 0 ? Array(lineIndex).join(".").split(".") : [];
    const content = emptyLines.concat(lines.slice(lineIndex)).join("\n");
    return [frontmatter, content];
}
function findLineIndexOfSearchStringIgnoringWs(lines, searchString) {
    let result = -1;
    for (let i2 = 0; i2 < lines.length; i2++) {
        if (lines[i2].trim() == searchString) {
            result = i2;
            break;
        }
    }
    return result;
}
function parseObsidianFrontmatterTag(tagStr) {
    const result = [];
    if (tagStr) {
        const tagStrList = tagStr.split(",");
        for (const tag of tagStrList) {
            if (tag !== "") {
                result.push(tag.startsWith("#") ? tag : "#" + tag);
            }
        }
    }
    return result;
}
var MultiLineTextFinder = class _MultiLineTextFinder {
    static findAndReplace(sourceText, searchText, replacementText) {
        let result = null;
        if (sourceText.includes(searchText)) {
            result = literalStringReplace(sourceText, searchText, replacementText);
        } else {
            const sourceTextArray = splitTextIntoLineArray(sourceText);
            const searchTextArray = splitTextIntoLineArray(searchText);
            const lineNo = _MultiLineTextFinder.find(sourceTextArray, searchTextArray);
            if (lineNo !== null) {
                const replacementTextArray = splitTextIntoLineArray(replacementText);
                const linesToRemove = searchTextArray.length;
                sourceTextArray.splice(lineNo, linesToRemove, ...replacementTextArray);
                result = sourceTextArray.join("\n");
            }
        }
        return result;
    }
    static find(sourceText, searchText) {
        let result = null;
        let searchIdx = 0;
        const maxSearchIdx = searchText.length - 1;
        for (let sourceIdx = 0; sourceIdx < sourceText.length; sourceIdx++) {
            const sourceLine = sourceText[sourceIdx].trim();
            const searchLine = searchText[searchIdx].trim();
            if (searchLine == sourceLine) {
                if (searchIdx == maxSearchIdx) {
                    result = sourceIdx - searchIdx;
                    break;
                }
                searchIdx++;
            } else {
                searchIdx = 0;
            }
        }
        return result;
    }
};

// src/file.ts
var frontmatterTagPseudoLineNum = -1;
var SrTFile = class {
    constructor(vault, metadataCache, file) {
        this.vault = vault;
        this.metadataCache = metadataCache;
        this.file = file;
    }
    get path() {
        return this.file.path;
    }
    get basename() {
        return this.file.basename;
    }
    get tfile() {
        return this.file;
    }
    async getFrontmatter() {
        const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
        const frontmatter = fileCachedData.frontmatter || {};
        const result = /* @__PURE__ */ new Map();
        for (const [key, value] of Object.entries(frontmatter)) {
            const v2 = Array.isArray(value) && value.length > 0 ? value[0] : value;
            const vStr = v2 + "";
            result.set(key, vStr);
        }
        return result;
    }
    getAllTagsFromCache() {
        const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
        const result = (0, import_obsidian2.getAllTags)(fileCachedData) || [];
        return result;
    }
    getAllTagsFromText() {
        var _a;
        const result = [];
        const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
        if (((_a = fileCachedData.tags) == null ? void 0 : _a.length) > 0) {
            result.push(...fileCachedData.tags);
        }
        result.push(...this.getFrontmatterTags(fileCachedData.frontmatter));
        return result;
    }
    getFrontmatterTags(frontmatter) {
        const result = [];
        const frontmatterTags = frontmatter != null ? frontmatter["tags"] + "" : null;
        if (frontmatterTags) {
            const tagStrList = parseObsidianFrontmatterTag(frontmatterTags);
            for (const str of tagStrList) {
                const tag = {
                    tag: str,
                    position: {
                        start: {
                            line: frontmatterTagPseudoLineNum,
                            col: null,
                            offset: null,
                        },
                        end: {
                            line: frontmatterTagPseudoLineNum,
                            col: null,
                            offset: null,
                        },
                    },
                };
                result.push(tag);
            }
        }
        return result;
    }
    getQuestionContext(cardLine) {
        const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
        const headings = fileCachedData.headings || [];
        const stack = [];
        for (const heading of headings) {
            if (heading.position.start.line > cardLine) {
                break;
            }
            while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
                stack.pop();
            }
            stack.push(heading);
        }
        const result = [];
        for (const headingObj of stack) {
            headingObj.heading = headingObj.heading.replace(/\[\^\d+\]/gm, "").trim();
            result.push(headingObj.heading);
        }
        return result;
    }
    getTextDirection() {
        let result = 0; /* Unspecified */
        const fileCache = this.metadataCache.getFileCache(this.file);
        const frontMatter = fileCache == null ? void 0 : fileCache.frontmatter;
        if (frontMatter && (frontMatter == null ? void 0 : frontMatter.direction)) {
            const str = (frontMatter.direction + "").toLowerCase();
            result = str == "rtl" ? 2 /* Rtl */ : 1 /* Ltr */;
        }
        return result;
    }
    async read() {
        return await this.vault.read(this.file);
    }
    async write(content) {
        await this.vault.modify(this.file, content);
    }
};

// src/note.ts
var Note = class {
    get hasChanged() {
        return this.questionList.some((question) => question.hasChanged);
    }
    get filePath() {
        return this.file.path;
    }
    constructor(file, questionList) {
        this.file = file;
        this.questionList = questionList;
        questionList.forEach((question) => (question.note = this));
    }
    appendCardsToDeck(deck) {
        for (const question of this.questionList) {
            for (const card of question.cards) {
                deck.appendCard(question.topicPathList, card);
            }
        }
    }
    debugLogToConsole(desc = "") {
        var _a;
        let str = `Note: ${desc}: ${this.questionList.length} questions\r
`;
        for (let i2 = 0; i2 < this.questionList.length; i2++) {
            const q2 = this.questionList[i2];
            str += `[${i2}]: ${q2.questionType}: ${q2.lineNo}: ${(_a = q2.topicPathList) == null ? void 0 : _a.format("|")}: ${q2.questionText.original}\r
`;
        }
        console.debug(str);
    }
    async writeNoteFile(settings) {
        let fileText = await this.file.read();
        for (const question of this.questionList) {
            if (question.hasChanged) {
                fileText = question.updateQuestionWithinNoteText(fileText, settings);
            }
        }
        await this.file.write(fileText);
        this.questionList.forEach((question) => (question.hasChanged = false));
    }
};

// src/card.ts
var Card = class extends RepetitionItem {
    constructor(init) {
        super();
        Object.assign(this, init);
    }
    get cardListType() {
        return this.isNew ? 0 /* NewCard */ : 1 /* DueCard */;
    }
    formatSchedule() {
        let result = "";
        if (this.hasSchedule) result = this.scheduleInfo.formatCardScheduleForHtmlComment();
        else result = "New";
        return result;
    }
};

// src/parser.ts
var import_clozecraft = __toESM(require_dist());

// src/question.ts
var QuestionText = class _QuestionText {
    constructor(original, topicPathWithWs, actualQuestion, textDirection, blockId) {
        this.original = original;
        this.topicPathWithWs = topicPathWithWs;
        this.actualQuestion = actualQuestion;
        this.textDirection = textDirection;
        this.obsidianBlockId = blockId;
        this.textHash = cyrb53(this.formatTopicAndQuestion());
    }
    endsWithCodeBlock() {
        return this.actualQuestion.endsWith("```");
    }
    static create(original, textDirection, settings) {
        const [topicPathWithWs, actualQuestion, blockId] = this.splitText(original, settings);
        return new _QuestionText(original, topicPathWithWs, actualQuestion, textDirection, blockId);
    }
    static splitText(original, settings) {
        const originalWithoutSR = DataStore.getInstance().questionRemoveScheduleInfo(original);
        let actualQuestion = originalWithoutSR.trimEnd();
        let topicPathWithWs = null;
        let blockId = null;
        const topicPath = TopicPath.getTopicPathFromCardText(originalWithoutSR);
        if (topicPath == null ? void 0 : topicPath.hasPath) {
            const [preTopicPathWs, cardText2] = stringTrimStart(originalWithoutSR);
            const cardText3 = cardText2.replaceAll(OBSIDIAN_TAG_AT_STARTOFLINE_REGEX, "");
            let postTopicPathWs = null;
            [postTopicPathWs, actualQuestion] = stringTrimStart(cardText3);
            if (!settings.convertFoldersToDecks) {
                topicPathWithWs = new TopicPathWithWs(topicPath, preTopicPathWs, postTopicPathWs);
            }
        }
        [actualQuestion, blockId] = this.extractObsidianBlockId(actualQuestion);
        return [topicPathWithWs, actualQuestion, blockId];
    }
    static extractObsidianBlockId(text) {
        let question = text;
        let blockId = null;
        const match2 = text.match(OBSIDIAN_BLOCK_ID_ENDOFLINE_REGEX);
        if (match2) {
            blockId = match2[0].trim();
            const newLength = question.length - blockId.length;
            question = question.substring(0, newLength).trimEnd();
        }
        return [question, blockId];
    }
    formatTopicAndQuestion() {
        let result = "";
        if (this.topicPathWithWs) {
            result += this.topicPathWithWs.formatWithWs();
        }
        result += this.actualQuestion;
        return result;
    }
};
var Question = class _Question {
    get questionType() {
        return this.parsedQuestionInfo.cardType;
    }
    get lineNo() {
        return this.parsedQuestionInfo.firstLineNum;
    }
    constructor(init) {
        Object.assign(this, init);
    }
    getHtmlCommentSeparator(settings) {
        const sep2 = this.isCardCommentsOnSameLine(settings) ? " " : "\n";
        return sep2;
    }
    isCardCommentsOnSameLine(settings) {
        let result = settings.cardCommentOnSameLine;
        if (this.questionText.endsWithCodeBlock()) {
            result = false;
        }
        return result;
    }
    setCardList(cards) {
        this.cards = cards;
        this.cards.forEach((card) => (card.question = this));
    }
    formatForNote(settings) {
        let result = this.questionText.formatTopicAndQuestion();
        const blockId = this.questionText.obsidianBlockId;
        const hasSchedule = this.cards.some((card) => card.hasSchedule);
        if (hasSchedule) {
            result = result.trimEnd();
            const scheduleHtml =
                DataStoreAlgorithm.getInstance().questionFormatScheduleAsHtmlComment(this);
            if (blockId) {
                if (this.isCardCommentsOnSameLine(settings))
                    result += ` ${scheduleHtml} ${blockId}`;
                else
                    result += ` ${blockId}
${scheduleHtml}`;
            } else {
                result += this.getHtmlCommentSeparator(settings) + scheduleHtml;
            }
        } else {
            if (blockId) result += ` ${blockId}`;
        }
        return result;
    }
    updateQuestionWithinNoteText(noteText, settings) {
        const originalText = this.questionText.original;
        const replacementText = this.formatForNote(settings);
        let newText = MultiLineTextFinder.findAndReplace(noteText, originalText, replacementText);
        if (newText) {
            this.questionText = QuestionText.create(
                replacementText,
                this.questionText.textDirection,
                settings,
            );
        } else {
            console.error(
                `updateQuestionText: Text not found: ${originalText.substring(
                    0,
                    100,
                )} in note: ${noteText.substring(0, 100)}`,
            );
            newText = noteText;
        }
        return newText;
    }
    async writeQuestion(settings) {
        const fileText = await this.note.file.read();
        const newText = this.updateQuestionWithinNoteText(fileText, settings);
        await this.note.file.write(newText);
        this.hasChanged = false;
    }
    formatTopicPathList() {
        return this.topicPathList.format("|");
    }
    static Create(settings, parsedQuestionInfo, noteTopicPathList, textDirection, context) {
        const hasEditLaterTag = parsedQuestionInfo.text.includes(settings.editLaterTag);
        const questionText = QuestionText.create(parsedQuestionInfo.text, textDirection, settings);
        let topicPathList = noteTopicPathList;
        if (questionText.topicPathWithWs) {
            topicPathList = new TopicPathList([questionText.topicPathWithWs.topicPath]);
        }
        const result = new _Question({
            parsedQuestionInfo,
            topicPathList,
            questionText,
            hasEditLaterTag,
            questionContext: context,
            cards: null,
            hasChanged: false,
        });
        return result;
    }
};

// src/parser.ts
var debugParser = false;
function setDebugParser(value) {
    debugParser = value;
}
var ParsedQuestionInfo = class {
    constructor(cardType, text, firstLineNum, lastLineNum) {
        this.cardType = cardType;
        this.text = text;
        this.firstLineNum = firstLineNum;
        this.lastLineNum = lastLineNum;
    }
    isQuestionLineNum(lineNum) {
        return lineNum >= this.firstLineNum && lineNum <= this.lastLineNum;
    }
};
function markerInsideCodeBlock(text, marker, markerIndex) {
    let goingBack = markerIndex - 1,
        goingForward = markerIndex + marker.length;
    let backTicksBefore = 0,
        backTicksAfter = 0;
    while (goingBack >= 0) {
        if (text[goingBack] === "`") backTicksBefore++;
        goingBack--;
    }
    while (goingForward < text.length) {
        if (text[goingForward] === "`") backTicksAfter++;
        goingForward++;
    }
    return backTicksBefore % 2 === 1 && backTicksAfter % 2 === 1;
}
function hasInlineMarker(text, marker) {
    if (marker.length == 0) return false;
    const markerIdx = text.indexOf(marker);
    if (markerIdx === -1) return false;
    return !markerInsideCodeBlock(text, marker, markerIdx);
}
function hasLogseqFlashcardTag(line) {
    return /#flashcard\b/i.test(line);
}
function isLogseqListItem(line) {
    return /^\s*-\s+/.test(line);
}
function getLogseqIndentLevel(line) {
    const match2 = line.match(/^(\s*)/);
    return match2 ? match2[1].length : 0;
}
function parse(text, options) {
    if (debugParser) {
        console.log("Text to parse:\n<<<" + text + ">>>");
    }
    const inlineSeparators = [
        { separator: options.singleLineCardSeparator, type: 0 /* SingleLineBasic */ },
        { separator: options.singleLineReversedCardSeparator, type: 1 /* SingleLineReversed */ },
    ];
    inlineSeparators.sort((a2, b2) => b2.separator.length - a2.separator.length);
    const cards = [];
    let cardText = "";
    let cardType = null;
    let firstLineNo = 0,
        lastLineNo = 0;
    const clozecrafter = new import_clozecraft.ClozeCrafter(options.clozePatterns);
    const lines = text.replaceAll("\r\n", "\n").split("\n");
    for (let i2 = 0; i2 < lines.length; i2++) {
        const currentLine = lines[i2],
            currentTrimmed = lines[i2].trim();
        if (currentLine.startsWith("<!--") && !currentLine.startsWith("<!--SR:")) {
            while (i2 + 1 < lines.length && !currentLine.includes("-->")) i2++;
            i2++;
            continue;
        }
        const isEmptyLine = currentTrimmed.length == 0;
        const hasMultilineCardEndMarker =
            options.multilineCardEndMarker && currentTrimmed == options.multilineCardEndMarker;
        if (
            // We've probably reached the end of a card
            (isEmptyLine && !options.multilineCardEndMarker) || // Empty line & we're not picking up any card
            (isEmptyLine && cardType == null) || // We've reached the end of a multi line card &
            //  we're using custom end markers
            hasMultilineCardEndMarker
        ) {
            if (cardType) {
                lastLineNo = i2 - 1;
                cards.push(
                    new ParsedQuestionInfo(cardType, cardText.trimEnd(), firstLineNo, lastLineNo),
                );
                cardType = null;
            }
            cardText = "";
            firstLineNo = i2 + 1;
            continue;
        }
        if (cardText.length > 0) {
            cardText += "\n";
        }
        cardText += currentLine.trimEnd();
        for (const { separator, type } of inlineSeparators) {
            if (hasInlineMarker(currentLine, separator)) {
                cardType = type;
                break;
            }
        }
        if (hasLogseqFlashcardTag(currentLine) && isLogseqListItem(currentLine)) {
            const questionIndent = getLogseqIndentLevel(currentLine);
            cardText = currentLine;
            firstLineNo = i2;
            cardType = 2 /* MultiLineBasic */;
            while (i2 + 1 < lines.length) {
                const nextLine = lines[i2 + 1];
                const nextTrimmed = nextLine.trim();
                if (nextTrimmed.length === 0) break;
                if (nextLine.includes("<!--SR:")) {
                    cardText += "\n" + nextLine;
                    i2++;
                    continue;
                }
                const nextIndent = getLogseqIndentLevel(nextLine);
                if (nextIndent <= questionIndent && isLogseqListItem(nextLine)) {
                    break;
                }
                cardText += "\n" + nextLine;
                i2++;
            }
            lastLineNo = i2;
            cards.push(new ParsedQuestionInfo(cardType, cardText, firstLineNo, lastLineNo));
            cardType = null;
            cardText = "";
            firstLineNo = i2 + 1;
            continue;
        }
        if (cardType == 0 /* SingleLineBasic */ || cardType == 1 /* SingleLineReversed */) {
            cardText = currentLine;
            firstLineNo = i2;
            if (i2 + 1 < lines.length && lines[i2 + 1].startsWith("<!--SR:")) {
                cardText += "\n" + lines[i2 + 1];
                i2++;
            }
            lastLineNo = i2;
            cards.push(new ParsedQuestionInfo(cardType, cardText, firstLineNo, lastLineNo));
            cardType = null;
            cardText = "";
        } else if (currentTrimmed === options.multilineCardSeparator) {
            if (cardText.length > 1) {
                cardType = 2 /* MultiLineBasic */;
            }
        } else if (currentTrimmed === options.multilineReversedCardSeparator) {
            if (cardText.length > 1) {
                cardType = 3 /* MultiLineReversed */;
            }
        } else if (currentLine.startsWith("```") || currentLine.startsWith("~~~")) {
            const codeBlockClose = currentLine.match(/`+|~+/)[0];
            while (i2 + 1 < lines.length && !lines[i2 + 1].startsWith(codeBlockClose)) {
                i2++;
                cardText += "\n" + lines[i2];
            }
            cardText += "\n" + codeBlockClose;
            i2++;
        } else if (cardType === null && clozecrafter.isClozeNote(currentLine)) {
            cardType = 4 /* Cloze */;
        }
    }
    if (cardType && cardText) {
        lastLineNo = lines.length - 1;
        cards.push(new ParsedQuestionInfo(cardType, cardText.trimEnd(), firstLineNo, lastLineNo));
    }
    if (debugParser) {
        console.log("Parsed cards:\n", cards);
    }
    return cards;
}

// src/question-type.ts
var import_clozecraft2 = __toESM(require_dist());
var CardFrontBack = class {
    // The caller is responsible for any required trimming of leading/trailing spaces
    constructor(front, back) {
        this.front = front;
        this.back = back;
    }
};
var CardFrontBackUtil = class {
    static expand(questionType, questionText, settings) {
        const handler = QuestionTypeFactory.create(questionType);
        return handler.expand(questionText, settings);
    }
};
var QuestionTypeSingleLineBasic = class {
    expand(questionText, settings) {
        const idx = questionText.indexOf(settings.singleLineCardSeparator);
        const item = new CardFrontBack(
            questionText.substring(0, idx),
            questionText.substring(idx + settings.singleLineCardSeparator.length),
        );
        const result = [item];
        return result;
    }
};
var QuestionTypeSingleLineReversed = class {
    expand(questionText, settings) {
        const idx = questionText.indexOf(settings.singleLineReversedCardSeparator);
        const side1 = questionText.substring(0, idx),
            side2 = questionText.substring(idx + settings.singleLineReversedCardSeparator.length);
        const result = [new CardFrontBack(side1, side2), new CardFrontBack(side2, side1)];
        return result;
    }
};
var QuestionTypeMultiLineBasic = class {
    expand(questionText, settings) {
        const questionLines = questionText.split("\n");
        if (questionLines[0] && /#flashcard\b/i.test(questionLines[0])) {
            return this.expandLogseqFormat(questionLines);
        }
        const lineIdx = findLineIndexOfSearchStringIgnoringWs(
            questionLines,
            settings.multilineCardSeparator,
        );
        const side1 = questionLines.slice(0, lineIdx).join("\n");
        const side2 = questionLines.slice(lineIdx + 1).join("\n");
        const result = [new CardFrontBack(side1, side2)];
        return result;
    }
    /**
     *  Logseq 
     * : - question #flashcard
     *         answer line 1
     *         answer line 2
     *       <!--SR:!2025-12-22,4,270-->
     */
    expandLogseqFormat(questionLines) {
        const front = questionLines[0]
            .replace(/^\s*-\s+/, "")
            .replace(/#flashcard\b/gi, "")
            .replace(/<!--SR:.*?-->/g, "")
            .trim();
        const answerLines = [];
        for (let i2 = 1; i2 < questionLines.length; i2++) {
            const line = questionLines[i2];
            if (line.includes("<!--SR:")) continue;
            if (line.trim().length === 0) continue;
            const cleanedLine = line.replace(/^\s*-\s+/, "  ").trimEnd();
            answerLines.push(cleanedLine);
        }
        const back = answerLines.join("\n").trim();
        const result = [new CardFrontBack(front, back)];
        return result;
    }
};
var QuestionTypeMultiLineReversed = class {
    expand(questionText, settings) {
        const questionLines = questionText.split("\n");
        const lineIdx = findLineIndexOfSearchStringIgnoringWs(
            questionLines,
            settings.multilineReversedCardSeparator,
        );
        const side1 = questionLines.slice(0, lineIdx).join("\n");
        const side2 = questionLines.slice(lineIdx + 1).join("\n");
        const result = [new CardFrontBack(side1, side2), new CardFrontBack(side2, side1)];
        return result;
    }
};
var QuestionTypeCloze = class {
    expand(questionText, settings) {
        const clozecrafter = new import_clozecraft2.ClozeCrafter(settings.clozePatterns);
        const clozeNote = clozecrafter.createClozeNote(questionText);
        const clozeFormatter = new QuestionTypeClozeFormatter();
        let front, back;
        const result = [];
        for (let i2 = 0; i2 < clozeNote.numCards; i2++) {
            front = clozeNote.getCardFront(i2, clozeFormatter);
            back = clozeNote.getCardBack(i2, clozeFormatter);
            result.push(new CardFrontBack(front, back));
        }
        return result;
    }
};
var QuestionTypeClozeFormatter = class {
    asking(answer, hint) {
        return `<span style='color:#2196f3'>${!hint ? "[...]" : `[${hint}]`}</span>`;
    }
    showingAnswer(answer, _hint) {
        return `<span style='color:#2196f3'>${answer}</span>`;
    }
    hiding(answer, hint) {
        return `<span style='color:var(--code-comment)'>${!hint ? "[...]" : `[${hint}]`}</span>`;
    }
};
var QuestionTypeFactory = class {
    static create(questionType) {
        let handler;
        switch (questionType) {
            case 0 /* SingleLineBasic */:
                handler = new QuestionTypeSingleLineBasic();
                break;
            case 1 /* SingleLineReversed */:
                handler = new QuestionTypeSingleLineReversed();
                break;
            case 2 /* MultiLineBasic */:
                handler = new QuestionTypeMultiLineBasic();
                break;
            case 3 /* MultiLineReversed */:
                handler = new QuestionTypeMultiLineReversed();
                break;
            case 4 /* Cloze */:
                handler = new QuestionTypeCloze();
                break;
        }
        return handler;
    }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
    // flashcards
    //  Logseq  #flashcard 
    flashcardTags: ["#flashcards", "#flashcard"],
    convertFoldersToDecks: false,
    burySiblingCards: false,
    randomizeCardOrder: null,
    flashcardCardOrder: "DueFirstRandom",
    flashcardDeckOrder: "PrevDeckComplete_Sequential",
    convertHighlightsToClozes: true,
    convertBoldTextToClozes: false,
    convertCurlyBracketsToClozes: false,
    clozePatterns: ["==[123;;]answer[;;hint]=="],
    // Logseq  #flashcard  :: 
    // 
    singleLineCardSeparator: "::",
    singleLineReversedCardSeparator: ":::",
    multilineCardSeparator: "?",
    multilineReversedCardSeparator: "??",
    multilineCardEndMarker: "",
    editLaterTag: "#edit-later",
    // notes
    enableNoteReviewPaneOnStartup: true,
    tagsToReview: ["#review"],
    noteFoldersToIgnore: ["**/*.excalidraw.md"],
    openRandomNote: false,
    autoNextNote: false,
    disableFileMenuReviewOptions: false,
    maxNDaysNotesReviewQueue: 365,
    // UI settings
    showRibbonIcon: true,
    showStatusBar: true,
    initiallyExpandAllSubdecksInTree: false,
    showContextInCards: true,
    showIntervalInReviewButtons: true,
    flashcardHeightPercentage: import_obsidian3.Platform.isMobile ? 100 : 80,
    flashcardWidthPercentage: import_obsidian3.Platform.isMobile ? 100 : 40,
    flashcardEasyText: t("EASY"),
    flashcardGoodText: t("GOOD"),
    flashcardHardText: t("HARD"),
    reviewButtonDelay: 0,
    openViewInNewTab: false,
    // algorithm
    algorithm: "SM-2-OSR" /* SM_2_OSR */,
    baseEase: 250,
    lapsesIntervalChange: 0.5,
    easyBonus: 1.3,
    loadBalance: true,
    maximumInterval: 36525,
    maxLinkFactor: 1,
    // storage
    dataStore: "NOTES" /* NOTES */,
    cardCommentOnSameLine: false,
    // logging
    showSchedulingDebugMessages: false,
    showParserDebugMessages: false,
};
function upgradeSettings(settings) {
    if (
        settings.randomizeCardOrder != null &&
        settings.flashcardCardOrder == null &&
        settings.flashcardDeckOrder == null
    ) {
        settings.flashcardCardOrder = settings.randomizeCardOrder
            ? "DueFirstRandom"
            : "DueFirstSequential";
        settings.flashcardDeckOrder = "PrevDeckComplete_Sequential";
        settings.randomizeCardOrder = null;
    }
    if (settings.clozePatterns == null) {
        settings.clozePatterns = [];
        if (settings.convertHighlightsToClozes)
            settings.clozePatterns.push("==[123;;]answer[;;hint]==");
        if (settings.convertBoldTextToClozes)
            settings.clozePatterns.push("**[123;;]answer[;;hint]**");
        if (settings.convertCurlyBracketsToClozes)
            settings.clozePatterns.push("{{[123;;]answer[;;hint]}}");
    }
}
var SettingsUtil = class _SettingsUtil {
    static isFlashcardTag(settings, tag) {
        return _SettingsUtil.isTagInList(settings.flashcardTags, tag);
    }
    static isPathInNoteIgnoreFolder(settings, path3) {
        return settings.noteFoldersToIgnore.some((folder) => pathMatchesPattern(path3, folder));
    }
    static isAnyTagANoteReviewTag(settings, tags) {
        for (const tag of tags) {
            if (
                settings.tagsToReview.some(
                    (tagToReview) => tag === tagToReview || tag.startsWith(tagToReview + "/"),
                )
            ) {
                return true;
            }
        }
        return false;
    }
    // Given a list of tags, return the subset that is in settings.tagsToReview
    static filterForNoteReviewTag(settings, tags) {
        const result = [];
        for (const tagToReview of settings.tagsToReview) {
            if (tags.some((tag) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
                result.push(tagToReview);
            }
        }
        return result;
    }
    static isTagInList(tagList, tag) {
        for (const tagFromList of tagList) {
            if (tag === tagFromList || tag.startsWith(tagFromList + "/")) {
                return true;
            }
        }
        return false;
    }
};

// src/note-question-parser.ts
var NoteQuestionParser = class {
    constructor(settings) {
        this.settings = settings;
    }
    async createQuestionList(
        noteFile,
        defaultTextDirection,
        folderTopicPath,
        onlyKeepQuestionsWithTopicPath,
    ) {
        this.noteFile = noteFile;
        const tagCacheList = noteFile.getAllTagsFromCache();
        const hasTopicPaths =
            tagCacheList.some((item) => SettingsUtil.isFlashcardTag(this.settings, item)) ||
            folderTopicPath.hasPath;
        if (hasTopicPaths) {
            const noteText = await noteFile.read();
            const tagCompleteList = noteFile.getAllTagsFromText();
            [this.frontmatterText, this.contentText] = splitNoteIntoFrontmatterAndContent(noteText);
            let textDirection = noteFile.getTextDirection();
            if (textDirection == 0 /* Unspecified */) textDirection = defaultTextDirection;
            this.questionList = this.doCreateQuestionList(
                noteText,
                textDirection,
                folderTopicPath,
                this.tagCacheList,
            );
            [this.frontmatterTopicPathList, this.contentTopicPathInfo] =
                this.analyseTagCacheList(tagCompleteList);
            for (const question of this.questionList) {
                question.topicPathList = this.determineQuestionTopicPathList(question);
            }
            if (onlyKeepQuestionsWithTopicPath) {
                this.questionList = this.questionList.filter((q2) => q2.topicPathList);
            }
        } else {
            this.questionList = [];
        }
        return this.questionList;
    }
    doCreateQuestionList(noteText, textDirection, folderTopicPath, tagCacheList) {
        this.noteText = noteText;
        this.noteLines = splitTextIntoLineArray(noteText);
        this.folderTopicPath = folderTopicPath;
        this.tagCacheList = tagCacheList;
        const result = [];
        const parsedQuestionInfoList = this.parseQuestions();
        for (const parsedQuestionInfo of parsedQuestionInfoList) {
            const question = this.createQuestionObject(parsedQuestionInfo, textDirection);
            const cardFrontBackList = CardFrontBackUtil.expand(
                question.questionType,
                question.questionText.actualQuestion,
                this.settings,
            );
            let cardScheduleInfoList = DataStore.getInstance().questionCreateSchedule(
                question.questionText.original,
                null,
            );
            const correctLength = cardFrontBackList.length;
            if (cardScheduleInfoList.length > correctLength) {
                question.hasChanged = true;
                cardScheduleInfoList = cardScheduleInfoList.slice(0, correctLength);
            }
            const cardList = this.createCardList(cardFrontBackList, cardScheduleInfoList);
            question.setCardList(cardList);
            result.push(question);
        }
        return result;
    }
    parseQuestions() {
        const settings = this.settings;
        const parserOptions = {
            singleLineCardSeparator: settings.singleLineCardSeparator,
            singleLineReversedCardSeparator: settings.singleLineReversedCardSeparator,
            multilineCardSeparator: settings.multilineCardSeparator,
            multilineReversedCardSeparator: settings.multilineReversedCardSeparator,
            multilineCardEndMarker: settings.multilineCardEndMarker,
            clozePatterns: settings.clozePatterns,
        };
        return parse(this.contentText, parserOptions);
    }
    createQuestionObject(parsedQuestionInfo, textDirection) {
        const questionContext = this.noteFile.getQuestionContext(parsedQuestionInfo.firstLineNum);
        const result = Question.Create(
            this.settings,
            parsedQuestionInfo,
            null,
            // We haven't worked out the TopicPathList yet
            textDirection,
            questionContext,
        );
        return result;
    }
    createCardList(cardFrontBackList, cardScheduleInfoList) {
        const siblings = [];
        for (let i2 = 0; i2 < cardFrontBackList.length; i2++) {
            const { front, back } = cardFrontBackList[i2];
            const hasScheduleInfo = i2 < cardScheduleInfoList.length;
            const schedule = cardScheduleInfoList[i2];
            const cardObj = new Card({
                front,
                back,
                cardIdx: i2,
            });
            cardObj.scheduleInfo = hasScheduleInfo ? schedule : null;
            siblings.push(cardObj);
        }
        return siblings;
    }
    //
    // Given the complete list of tags within a note:
    // 1.   Only keep tags that are specified in the user settings as flashcardTags
    // 2.   Filter out tags that are question specific
    //      (these will be parsed separately by class QuestionText)
    // 3.   Combine all tags present logically grouped together into a single entry
    //      - All tags present on the same line grouped together
    //      - All tags within frontmatter grouped together (note that multiple tags
    //      within frontmatter appear on separate lines)
    //
    analyseTagCacheList(tagCacheList) {
        this.flashcardTagList = tagCacheList.filter((item) =>
            SettingsUtil.isFlashcardTag(this.settings, item.tag),
        );
        if (this.flashcardTagList.length > 0) {
            this.flashcardTagList.sort((a2, b2) => a2.position.start.line - b2.position.start.line);
        }
        let frontmatterLineCount = 0;
        if (this.frontmatterText) {
            frontmatterLineCount = splitTextIntoLineArray(this.frontmatterText).length;
        }
        const frontmatterTopicPathList = this.determineFrontmatterTopicPathList(
            this.flashcardTagList,
            frontmatterLineCount,
        );
        const contentTopicPathList = this.determineContentTopicPathList(
            this.flashcardTagList,
            frontmatterLineCount,
        );
        return [frontmatterTopicPathList, contentTopicPathList];
    }
    determineFrontmatterTopicPathList(flashcardTagList, frontmatterLineCount) {
        let result = null;
        const noteLevelTagList = flashcardTagList.filter(
            (item) =>
                item.position.start.line == frontmatterTagPseudoLineNum &&
                this.isNoteLevelFlashcardTag(item),
        );
        if (noteLevelTagList.length > 0) {
            if (this.frontmatterText) {
                const frontmatterTagCacheList = noteLevelTagList.filter(
                    (item) => item.position.start.line < frontmatterLineCount,
                );
                if (frontmatterTagCacheList.length > 0)
                    result = this.createTopicPathList(
                        frontmatterTagCacheList,
                        frontmatterTagPseudoLineNum,
                    );
            }
        }
        return result;
    }
    determineContentTopicPathList(flashcardTagList, frontmatterLineCount) {
        const result = [];
        const contentStartLineNum = frontmatterLineCount;
        const contentTagCacheList = flashcardTagList.filter(
            (item) =>
                item.position.start.line >= contentStartLineNum &&
                this.isNoteLevelFlashcardTag(item),
        );
        let list = [];
        for (const tag of contentTagCacheList) {
            if (list.length != 0) {
                const startLineNum = list[0].position.start.line;
                if (startLineNum != tag.position.start.line) {
                    result.push(this.createTopicPathList(list, startLineNum));
                    list = [];
                }
            }
            list.push(tag);
        }
        if (list.length > 0) {
            const startLineNum = list[0].position.start.line;
            result.push(this.createTopicPathList(list, startLineNum));
        }
        return result;
    }
    isNoteLevelFlashcardTag(tagItem) {
        const tagLineNum = tagItem.position.start.line;
        const isQuestionSpecific = this.questionList.some((q2) =>
            q2.parsedQuestionInfo.isQuestionLineNum(tagLineNum),
        );
        return !isQuestionSpecific;
    }
    createTopicPathList(tagCacheList, lineNum) {
        const list = [];
        for (const tagCache of tagCacheList) {
            list.push(TopicPath.getTopicPathFromTag(tagCache.tag));
        }
        return new TopicPathList(list, lineNum);
    }
    createTopicPathListFromSingleTag(tagCache) {
        const list = [TopicPath.getTopicPathFromTag(tagCache.tag)];
        return new TopicPathList(list, tagCache.position.start.line);
    }
    // A question can be associated with multiple topics (hence returning TopicPathList and not just TopicPath).
    //
    // If the question has an associated question specific TopicPath, then that is returned.
    //
    // Else the first TopicPathList prior to the question (in the order present in the file) is returned.
    // That could be either the tags within the note's frontmatter, or tags on lines within the note's content.
    determineQuestionTopicPathList(question) {
        let result;
        if (this.settings.convertFoldersToDecks) {
            result = new TopicPathList([this.folderTopicPath]);
        } else {
            const questionText = question.questionText;
            if (questionText.topicPathWithWs)
                result = new TopicPathList(
                    [questionText.topicPathWithWs.topicPath],
                    question.parsedQuestionInfo.firstLineNum,
                );
            else {
                result = this.frontmatterTopicPathList;
                for (let i2 = this.contentTopicPathInfo.length - 1; i2 >= 0; i2--) {
                    const topicPathList = this.contentTopicPathInfo[i2];
                    if (topicPathList.lineNum < question.parsedQuestionInfo.firstLineNum) {
                        result = topicPathList;
                        break;
                    }
                }
                if (!result && this.flashcardTagList.length > 0) {
                    result = this.createTopicPathListFromSingleTag(this.flashcardTagList[0]);
                }
            }
        }
        return result;
    }
};

// src/note-file-loader.ts
var NoteFileLoader = class {
    constructor(settings) {
        this.settings = settings;
    }
    async load(noteFile, defaultTextDirection, folderTopicPath) {
        this.noteFile = noteFile;
        const questionParser = new NoteQuestionParser(this.settings);
        const onlyKeepQuestionsWithTopicPath = true;
        const questionList = await questionParser.createQuestionList(
            noteFile,
            defaultTextDirection,
            folderTopicPath,
            onlyKeepQuestionsWithTopicPath,
        );
        const result = new Note(noteFile, questionList);
        return result;
    }
};

// src/core.ts
var OsrCore = class {
    constructor() {
        this._reviewableDeckTree = new Deck2("root", null);
    }
    get noteReviewQueue() {
        return this._noteReviewQueue;
    }
    get remainingDeckTree() {
        return this._remainingDeckTree;
    }
    get reviewableDeckTree() {
        return this._reviewableDeckTree;
    }
    get questionPostponementList() {
        return this._questionPostponementList;
    }
    get dueDateFlashcardHistogram() {
        return this._dueDateFlashcardHistogram;
    }
    get dueDateNoteHistogram() {
        return this._dueDateNoteHistogram;
    }
    get cardStats() {
        return this._cardStats;
    }
    init(
        questionPostponementList,
        osrNoteLinkInfoFinder,
        settings,
        dataChangedHandler,
        noteReviewQueue,
    ) {
        this.settings = settings;
        this.osrNoteLinkInfoFinder = osrNoteLinkInfoFinder;
        this.dataChangedHandler = dataChangedHandler;
        this._noteReviewQueue = noteReviewQueue;
        this._questionPostponementList = questionPostponementList;
        this._dueDateFlashcardHistogram = new CardDueDateHistogram();
        this._dueDateNoteHistogram = new NoteDueDateHistogram();
    }
    loadInit() {
        this.osrNoteGraph = new OsrNoteGraph(this.osrNoteLinkInfoFinder);
        this._noteReviewQueue.init();
        this.fullDeckTree = new Deck2("root", null);
    }
    async processFile(noteFile) {
        const schedule = await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
        let note = null;
        this.osrNoteGraph.processLinks(noteFile.path);
        const topicPath = this.findTopicPath(noteFile);
        if (topicPath.hasPath) {
            note = await this.loadNote(noteFile, topicPath);
            note.appendCardsToDeck(this.fullDeckTree);
        }
        SrsAlgorithm.getInstance().noteOnLoadedNote(
            noteFile.path,
            note,
            schedule == null ? void 0 : schedule.latestEase,
        );
        const tags = noteFile.getAllTagsFromCache();
        const matchedNoteTags = SettingsUtil.filterForNoteReviewTag(this.settings, tags);
        if (matchedNoteTags.length == 0) {
            return;
        }
        const noteSchedule = await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
        this._noteReviewQueue.addNoteToQueue(noteFile, noteSchedule, matchedNoteTags);
    }
    finaliseLoad() {
        this.osrNoteGraph.generatePageRanks();
        this._reviewableDeckTree = DeckTreeFilter.filterForReviewableCards(this.fullDeckTree);
        this._reviewableDeckTree.sortSubdecksList();
        this._remainingDeckTree = DeckTreeFilter.filterForRemainingCards(
            this._questionPostponementList,
            this._reviewableDeckTree,
            1 /* Review */,
        );
        const calc = new DeckTreeStatsCalculator();
        this._cardStats = calc.calculate(this._reviewableDeckTree);
        this.calculateDerivedInfo();
        this._dueDateFlashcardHistogram.calculateFromDeckTree(this._reviewableDeckTree);
        if (this.dataChangedHandler) this.dataChangedHandler();
    }
    async saveNoteReviewResponse(noteFile, response, settings) {
        const originalNoteSchedule =
            await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
        let noteSchedule;
        if (originalNoteSchedule == null) {
            noteSchedule = SrsAlgorithm.getInstance().noteCalcNewSchedule(
                noteFile.path,
                this.osrNoteGraph,
                response,
                this._dueDateNoteHistogram,
            );
        } else {
            noteSchedule = SrsAlgorithm.getInstance().noteCalcUpdatedSchedule(
                noteFile.path,
                originalNoteSchedule,
                response,
                this._dueDateNoteHistogram,
            );
        }
        await DataStoreAlgorithm.getInstance().noteSetSchedule(noteFile, noteSchedule);
        this._noteReviewQueue.updateScheduleInfo(noteFile, noteSchedule);
        this.calculateDerivedInfo();
        await this.buryAllCardsInNote(settings, noteFile);
        if (this.dataChangedHandler) this.dataChangedHandler();
    }
    calculateDerivedInfo() {
        const todayUnix = globalDateProvider.today.valueOf();
        this.noteReviewQueue.calcDueNotesCount(todayUnix);
        this._dueDateNoteHistogram.calculateFromReviewDecksAndSort(
            this.noteReviewQueue.reviewDecks,
            this.osrNoteGraph,
        );
    }
    async buryAllCardsInNote(settings, noteFile) {
        if (settings.burySiblingCards) {
            const topicPath = this.findTopicPath(noteFile);
            const noteX = await this.loadNote(noteFile, topicPath);
            if (noteX.questionList.length > 0) {
                for (const question of noteX.questionList) {
                    this._questionPostponementList.add(question);
                }
                await this._questionPostponementList.write();
            }
        }
    }
    async loadNote(noteFile, topicPath) {
        const loader = new NoteFileLoader(this.settings);
        const note = await loader.load(noteFile, this.defaultTextDirection, topicPath);
        if (note.hasChanged) {
            await note.writeNoteFile(this.settings);
        }
        return note;
    }
    findTopicPath(note) {
        return TopicPath.getTopicPathOfFile(note, this.settings);
    }
};
var OsrAppCore = class extends OsrCore {
    constructor(app) {
        super();
        this._syncLock = false;
        this.app = app;
    }
    get syncLock() {
        return this._syncLock;
    }
    async loadVault() {
        if (this._syncLock) {
            return;
        }
        this._syncLock = true;
        try {
            this.loadInit();
            const notes = this.app.vault.getMarkdownFiles();
            for (const noteFile of notes) {
                if (SettingsUtil.isPathInNoteIgnoreFolder(this.settings, noteFile.path)) {
                    continue;
                }
                const file = this.createSrTFile(noteFile);
                await this.processFile(file);
            }
            this.finaliseLoad();
        } finally {
            this._syncLock = false;
        }
    }
    createSrTFile(note) {
        return new SrTFile(this.app.vault, this.app.metadataCache, note);
    }
};

// src/data-store-algorithm/data-store-in-note-algorithm-osr.ts
var import_moment3 = __toESM(require_moment());
var DataStoreInNoteAlgorithmOsr = class {
    constructor(settings) {
        this.settings = settings;
    }
    async noteGetSchedule(note) {
        let result = null;
        const frontmatter = await note.getFrontmatter();
        if (
            frontmatter &&
            frontmatter.has("sr-due") &&
            frontmatter.has("sr-interval") &&
            frontmatter.has("sr-ease")
        ) {
            const dueDate = (0, import_moment3.default)(
                frontmatter.get("sr-due"),
                ALLOWED_DATE_FORMATS,
            );
            const interval = parseFloat(frontmatter.get("sr-interval"));
            const ease = parseFloat(frontmatter.get("sr-ease"));
            result = new RepItemScheduleInfoOsr(dueDate, interval, ease);
        }
        return result;
    }
    async noteSetSchedule(note, repItemScheduleInfo) {
        let fileText = await note.read();
        const schedInfo = repItemScheduleInfo;
        const dueString = formatDateYYYYMMDD(schedInfo.dueDate);
        const interval = schedInfo.interval;
        const ease = schedInfo.latestEase;
        if (SCHEDULING_INFO_REGEX.test(fileText)) {
            const schedulingInfo = SCHEDULING_INFO_REGEX.exec(fileText);
            fileText = fileText.replace(
                SCHEDULING_INFO_REGEX,
                `---
${schedulingInfo[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
${schedulingInfo[5]}---`,
            );
        } else if (YAML_FRONT_MATTER_REGEX.test(fileText)) {
            const existingYaml = YAML_FRONT_MATTER_REGEX.exec(fileText);
            fileText = fileText.replace(
                YAML_FRONT_MATTER_REGEX,
                `---
${existingYaml[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---`,
            );
        } else {
            fileText = `---
sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---

${fileText}`;
        }
        await note.write(fileText);
    }
    questionFormatScheduleAsHtmlComment(question) {
        let result = SR_HTML_COMMENT_BEGIN;
        for (let i2 = 0; i2 < question.cards.length; i2++) {
            const card = question.cards[i2];
            result += this.formatCardSchedule(card);
        }
        result += SR_HTML_COMMENT_END;
        return result;
    }
    formatCardSchedule(card) {
        let result;
        if (card.hasSchedule) {
            const schedule = card.scheduleInfo;
            const dateStr = schedule.dueDate
                ? formatDateYYYYMMDD(schedule.dueDate)
                : RepItemScheduleInfoOsr.dummyDueDateForNewCard;
            result = `!${dateStr},${schedule.interval},${schedule.latestEase}`;
        } else {
            result = `!${RepItemScheduleInfoOsr.dummyDueDateForNewCard},${RepItemScheduleInfoOsr.initialInterval},${this.settings.baseEase}`;
        }
        return result;
    }
};

// src/data-stores/notes/notes.ts
var StoreInNotes = class {
    constructor(settings) {
        this.settings = settings;
    }
    questionCreateSchedule(originalQuestionText, _2) {
        let scheduling = [...originalQuestionText.matchAll(MULTI_SCHEDULING_EXTRACTOR)];
        if (scheduling.length === 0)
            scheduling = [...originalQuestionText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
        const result = [];
        for (let i2 = 0; i2 < scheduling.length; i2++) {
            const match2 = scheduling[i2];
            const dueDateStr = match2[1];
            const interval = parseInt(match2[2]);
            const ease = parseInt(match2[3]);
            const dueDate = DateUtil.dateStrToMoment(dueDateStr);
            let info;
            if (
                dueDate == null ||
                formatDateYYYYMMDD(dueDate) == RepItemScheduleInfoOsr.dummyDueDateForNewCard
            ) {
                info = null;
            } else {
                const delayBeforeReviewTicks =
                    dueDate.valueOf() - globalDateProvider.today.valueOf();
                info = new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReviewTicks);
            }
            result.push(info);
        }
        return result;
    }
    questionRemoveScheduleInfo(questionText) {
        return questionText.replace(/<!--SR:.+-->/gm, "");
    }
    async questionWriteSchedule(question) {
        await this.questionWrite(question);
    }
    async questionWrite(question) {
        const fileText = await question.note.file.read();
        const newText = question.updateQuestionWithinNoteText(fileText, this.settings);
        await question.note.file.write(newText);
        question.hasChanged = false;
    }
};

// src/gui/review-queue-list-view.tsx
var import_obsidian4 = require("obsidian");
var REVIEW_QUEUE_VIEW_TYPE = "review-queue-list-view";
var ReviewQueueListView = class extends import_obsidian4.ItemView {
    get noteReviewQueue() {
        return this.nextNoteReviewHandler.noteReviewQueue;
    }
    constructor(leaf, nextNoteReviewHandler, settings) {
        super(leaf);
        this.nextNoteReviewHandler = nextNoteReviewHandler;
        this.settings = settings;
        if (this.settings.enableNoteReviewPaneOnStartup) {
            this.registerEvent(this.app.workspace.on("file-open", () => this.redraw()));
            this.registerEvent(this.app.vault.on("rename", () => this.redraw()));
        }
    }
    getViewType() {
        return REVIEW_QUEUE_VIEW_TYPE;
    }
    getDisplayText() {
        return t("NOTES_REVIEW_QUEUE");
    }
    getIcon() {
        return "SpacedRepIcon";
    }
    onHeaderMenu(menu) {
        menu.addItem((item) => {
            item.setTitle(t("CLOSE"))
                .setIcon("cross")
                .onClick(() => {
                    this.app.workspace.detachLeavesOfType(REVIEW_QUEUE_VIEW_TYPE);
                });
        });
    }
    redraw() {
        if (!this.noteReviewQueue.reviewDecks) return;
        const activeFile = this.app.workspace.getActiveFile();
        const rootEl = createDiv("tree-item nav-folder mod-root");
        const childrenEl = rootEl.createDiv("tree-item-children nav-folder-children");
        for (const [deckKey, deck] of this.noteReviewQueue.reviewDecks) {
            const deckCollapsed = !deck.activeFolders.has(deck.deckName);
            const deckFolderEl = this.createRightPaneFolder(
                childrenEl,
                deckKey,
                deckCollapsed,
                false,
                deck,
            ).getElementsByClassName("tree-item-children nav-folder-children")[0];
            if (deck.newNotes.length > 0) {
                const newNotesFolderEl = this.createRightPaneFolder(
                    deckFolderEl,
                    t("NEW"),
                    !deck.activeFolders.has(t("NEW")),
                    deckCollapsed,
                    deck,
                );
                for (const newFile of deck.newNotes) {
                    const fileIsOpen = activeFile && newFile.path === activeFile.path;
                    if (fileIsOpen) {
                        deck.activeFolders.add(deck.deckName);
                        deck.activeFolders.add(t("NEW"));
                        this.changeFolderFolding(newNotesFolderEl);
                        this.changeFolderFolding(deckFolderEl);
                    }
                    this.createRightPaneFile(
                        newNotesFolderEl,
                        newFile.tfile,
                        fileIsOpen,
                        !deck.activeFolders.has(t("NEW")),
                        deck,
                    );
                }
            }
            if (deck.scheduledNotes.length > 0) {
                const now2 = Date.now();
                let currUnix = -1;
                let schedFolderEl = null,
                    folderTitle = "";
                const maxDaysToRender = this.settings.maxNDaysNotesReviewQueue;
                for (const sNote of deck.scheduledNotes) {
                    if (sNote.dueUnix != currUnix) {
                        const nDays = Math.ceil((sNote.dueUnix - now2) / TICKS_PER_DAY);
                        if (nDays > maxDaysToRender) {
                            break;
                        }
                        if (nDays === -1) {
                            folderTitle = t("YESTERDAY");
                        } else if (nDays === 0) {
                            folderTitle = t("TODAY");
                        } else if (nDays === 1) {
                            folderTitle = t("TOMORROW");
                        } else {
                            folderTitle = new Date(sNote.dueUnix).toDateString();
                        }
                        schedFolderEl = this.createRightPaneFolder(
                            deckFolderEl,
                            folderTitle,
                            !deck.activeFolders.has(folderTitle),
                            deckCollapsed,
                            deck,
                        );
                        currUnix = sNote.dueUnix;
                    }
                    const fileIsOpen = activeFile && sNote.note.path === activeFile.path;
                    if (fileIsOpen) {
                        deck.activeFolders.add(deck.deckName);
                        deck.activeFolders.add(folderTitle);
                        this.changeFolderFolding(schedFolderEl);
                        this.changeFolderFolding(deckFolderEl);
                    }
                    this.createRightPaneFile(
                        schedFolderEl,
                        sNote.note.tfile,
                        fileIsOpen,
                        !deck.activeFolders.has(folderTitle),
                        deck,
                    );
                }
            }
        }
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
        contentEl.appendChild(rootEl);
    }
    createRightPaneFolder(parentEl, folderTitle, collapsed, hidden, deck) {
        const folderEl = parentEl.createDiv("tree-item nav-folder");
        const folderTitleEl = folderEl.createDiv("tree-item-self nav-folder-title");
        const childrenEl = folderEl.createDiv("tree-item-children nav-folder-children");
        const collapseIconEl = folderTitleEl.createDiv(
            "tree-item-icon collapse-icon nav-folder-collapse-indicator",
        );
        collapseIconEl.innerHTML = COLLAPSE_ICON;
        this.changeFolderFolding(folderEl, collapsed);
        folderTitleEl.createDiv("tree-item-inner nav-folder-title-content").setText(folderTitle);
        if (hidden) {
            folderEl.style.display = "none";
        }
        folderTitleEl.onClickEvent(() => {
            this.changeFolderFolding(folderEl, !folderEl.hasClass("is-collapsed"));
            childrenEl.style.display = !folderEl.hasClass("is-collapsed") ? "block" : "none";
            if (!folderEl.hasClass("is-collapsed")) {
                deck.activeFolders.delete(folderTitle);
            } else {
                deck.activeFolders.add(folderTitle);
            }
        });
        return folderEl;
    }
    createRightPaneFile(folderEl, file, fileElActive, hidden, deck) {
        const childrenEl = folderEl.getElementsByClassName(
            "tree-item-children nav-folder-children",
        )[0];
        const navFileEl = childrenEl.createDiv("nav-file");
        if (hidden) {
            childrenEl.style.display = "none";
        }
        const navFileTitle = navFileEl.createDiv("tree-item-self nav-file-title");
        if (fileElActive) {
            navFileTitle.addClass("is-active");
        }
        navFileTitle.createDiv("tree-item-inner nav-file-title-content").setText(file.basename);
        navFileTitle.addEventListener(
            "click",
            async (event) => {
                event.preventDefault();
                await this.nextNoteReviewHandler.openNote(deck.deckName, file);
                return false;
            },
            false,
        );
        navFileTitle.addEventListener(
            "contextmenu",
            (event) => {
                event.preventDefault();
                const fileMenu = new import_obsidian4.Menu();
                this.app.workspace.trigger("file-menu", fileMenu, file, "my-context-menu", null);
                fileMenu.showAtPosition({
                    x: event.pageX,
                    y: event.pageY,
                });
                return false;
            },
            false,
        );
    }
    changeFolderFolding(folderEl, collapsed = false) {
        if (collapsed) {
            folderEl.addClass("is-collapsed");
            const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
            collapseIconEl.addClass("is-collapsed");
        } else {
            folderEl.removeClass("is-collapsed");
            const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
            collapseIconEl.removeClass("is-collapsed");
        }
    }
};

// src/gui/settings.tsx
var import_obsidian6 = require("obsidian");

// node_modules/@kurkle/color/dist/color.esm.js
function round(v2) {
    return (v2 + 0.5) | 0;
}
var lim = (v2, l2, h6) => Math.max(Math.min(v2, h6), l2);
function p2b(v2) {
    return lim(round(v2 * 2.55), 0, 255);
}
function n2b(v2) {
    return lim(round(v2 * 255), 0, 255);
}
function b2n(v2) {
    return lim(round(v2 / 2.55) / 100, 0, 1);
}
function n2p(v2) {
    return lim(round(v2 * 100), 0, 100);
}
var map$1 = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
};
var hex = [..."0123456789ABCDEF"];
var h1 = (b2) => hex[b2 & 15];
var h2 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
var eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
var isShort = (v2) => eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a);
function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
        if (len === 4 || len === 5) {
            ret = {
                r: 255 & (map$1[str[1]] * 17),
                g: 255 & (map$1[str[2]] * 17),
                b: 255 & (map$1[str[3]] * 17),
                a: len === 5 ? map$1[str[4]] * 17 : 255,
            };
        } else if (len === 7 || len === 9) {
            ret = {
                r: (map$1[str[1]] << 4) | map$1[str[2]],
                g: (map$1[str[3]] << 4) | map$1[str[4]],
                b: (map$1[str[5]] << 4) | map$1[str[6]],
                a: len === 9 ? (map$1[str[7]] << 4) | map$1[str[8]] : 255,
            };
        }
    }
    return ret;
}
var alpha = (a2, f2) => (a2 < 255 ? f2(a2) : "");
function hexString(v2) {
    var f2 = isShort(v2) ? h1 : h2;
    return v2 ? "#" + f2(v2.r) + f2(v2.g) + f2(v2.b) + alpha(v2.a, f2) : void 0;
}
var HUE_RE =
    /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h6, s2, l2) {
    const a2 = s2 * Math.min(l2, 1 - l2);
    const f2 = (n2, k = (n2 + h6 / 30) % 12) => l2 - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f2(0), f2(8), f2(4)];
}
function hsv2rgbn(h6, s2, v2) {
    const f2 = (n2, k = (n2 + h6 / 60) % 6) => v2 - v2 * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f2(5), f2(3), f2(1)];
}
function hwb2rgbn(h6, w2, b2) {
    const rgb = hsl2rgbn(h6, 1, 0.5);
    let i2;
    if (w2 + b2 > 1) {
        i2 = 1 / (w2 + b2);
        w2 *= i2;
        b2 *= i2;
    }
    for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] *= 1 - w2 - b2;
        rgb[i2] += w2;
    }
    return rgb;
}
function hueValue(r2, g2, b2, d2, max) {
    if (r2 === max) {
        return (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
    }
    if (g2 === max) {
        return (b2 - r2) / d2 + 2;
    }
    return (r2 - g2) / d2 + 4;
}
function rgb2hsl(v2) {
    const range2 = 255;
    const r2 = v2.r / range2;
    const g2 = v2.g / range2;
    const b2 = v2.b / range2;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    const l2 = (max + min) / 2;
    let h6, s2, d2;
    if (max !== min) {
        d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        h6 = hueValue(r2, g2, b2, d2, max);
        h6 = h6 * 60 + 0.5;
    }
    return [h6 | 0, s2 || 0, l2];
}
function calln(f2, a2, b2, c2) {
    return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b2, c2)).map(n2b);
}
function hsl2rgb(h6, s2, l2) {
    return calln(hsl2rgbn, h6, s2, l2);
}
function hwb2rgb(h6, w2, b2) {
    return calln(hwb2rgbn, h6, w2, b2);
}
function hsv2rgb(h6, s2, v2) {
    return calln(hsv2rgbn, h6, s2, v2);
}
function hue(h6) {
    return ((h6 % 360) + 360) % 360;
}
function hueParse(str) {
    const m2 = HUE_RE.exec(str);
    let a2 = 255;
    let v2;
    if (!m2) {
        return;
    }
    if (m2[5] !== v2) {
        a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
    }
    const h6 = hue(+m2[2]);
    const p1 = +m2[3] / 100;
    const p2 = +m2[4] / 100;
    if (m2[1] === "hwb") {
        v2 = hwb2rgb(h6, p1, p2);
    } else if (m2[1] === "hsv") {
        v2 = hsv2rgb(h6, p1, p2);
    } else {
        v2 = hsl2rgb(h6, p1, p2);
    }
    return {
        r: v2[0],
        g: v2[1],
        b: v2[2],
        a: a2,
    };
}
function rotate(v2, deg) {
    var h6 = rgb2hsl(v2);
    h6[0] = hue(h6[0] + deg);
    h6 = hsl2rgb(h6);
    v2.r = h6[0];
    v2.g = h6[1];
    v2.b = h6[2];
}
function hslString(v2) {
    if (!v2) {
        return;
    }
    const a2 = rgb2hsl(v2);
    const h6 = a2[0];
    const s2 = n2p(a2[1]);
    const l2 = n2p(a2[2]);
    return v2.a < 255 ? `hsla(${h6}, ${s2}%, ${l2}%, ${b2n(v2.a)})` : `hsl(${h6}, ${s2}%, ${l2}%)`;
}
var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh",
};
var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32",
};
function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i2, j2, k, ok, nk;
    for (i2 = 0; i2 < keys.length; i2++) {
        ok = nk = keys[i2];
        for (j2 = 0; j2 < tkeys.length; j2++) {
            k = tkeys[j2];
            nk = nk.replace(k, map[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [(k >> 16) & 255, (k >> 8) & 255, k & 255];
    }
    return unpacked;
}
var names;
function nameParse(str) {
    if (!names) {
        names = unpack();
        names.transparent = [0, 0, 0, 0];
    }
    const a2 = names[str.toLowerCase()];
    return (
        a2 && {
            r: a2[0],
            g: a2[1],
            b: a2[2],
            a: a2.length === 4 ? a2[3] : 255,
        }
    );
}
var RGB_RE =
    /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
    const m2 = RGB_RE.exec(str);
    let a2 = 255;
    let r2, g2, b2;
    if (!m2) {
        return;
    }
    if (m2[7] !== r2) {
        const v2 = +m2[7];
        a2 = m2[8] ? p2b(v2) : lim(v2 * 255, 0, 255);
    }
    r2 = +m2[1];
    g2 = +m2[3];
    b2 = +m2[5];
    r2 = 255 & (m2[2] ? p2b(r2) : lim(r2, 0, 255));
    g2 = 255 & (m2[4] ? p2b(g2) : lim(g2, 0, 255));
    b2 = 255 & (m2[6] ? p2b(b2) : lim(b2, 0, 255));
    return {
        r: r2,
        g: g2,
        b: b2,
        a: a2,
    };
}
function rgbString(v2) {
    return (
        v2 &&
        (v2.a < 255
            ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})`
            : `rgb(${v2.r}, ${v2.g}, ${v2.b})`)
    );
}
var to = (v2) => (v2 <= 31308e-7 ? v2 * 12.92 : Math.pow(v2, 1 / 2.4) * 1.055 - 0.055);
var from = (v2) => (v2 <= 0.04045 ? v2 / 12.92 : Math.pow((v2 + 0.055) / 1.055, 2.4));
function interpolate2(rgb1, rgb2, t3) {
    const r2 = from(b2n(rgb1.r));
    const g2 = from(b2n(rgb1.g));
    const b2 = from(b2n(rgb1.b));
    return {
        r: n2b(to(r2 + t3 * (from(b2n(rgb2.r)) - r2))),
        g: n2b(to(g2 + t3 * (from(b2n(rgb2.g)) - g2))),
        b: n2b(to(b2 + t3 * (from(b2n(rgb2.b)) - b2))),
        a: rgb1.a + t3 * (rgb2.a - rgb1.a),
    };
}
function modHSL(v2, i2, ratio) {
    if (v2) {
        let tmp = rgb2hsl(v2);
        tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v2.r = tmp[0];
        v2.g = tmp[1];
        v2.b = tmp[2];
    }
}
function clone(v2, proto) {
    return v2 ? Object.assign(proto || {}, v2) : v2;
}
function fromObject(input) {
    var v2 = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
        if (input.length >= 3) {
            v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
            if (input.length > 3) {
                v2.a = n2b(input[3]);
            }
        }
    } else {
        v2 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
        v2.a = n2b(v2.a);
    }
    return v2;
}
function functionParse(str) {
    if (str.charAt(0) === "r") {
        return rgbParse(str);
    }
    return hueParse(str);
}
var Color = class _Color {
    constructor(input) {
        if (input instanceof _Color) {
            return input;
        }
        const type = typeof input;
        let v2;
        if (type === "object") {
            v2 = fromObject(input);
        } else if (type === "string") {
            v2 = hexParse(input) || nameParse(input) || functionParse(input);
        }
        this._rgb = v2;
        this._valid = !!v2;
    }
    get valid() {
        return this._valid;
    }
    get rgb() {
        var v2 = clone(this._rgb);
        if (v2) {
            v2.a = b2n(v2.a);
        }
        return v2;
    }
    set rgb(obj) {
        this._rgb = fromObject(obj);
    }
    rgbString() {
        return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
        return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
        return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
        if (color2) {
            const c1 = this.rgb;
            const c2 = color2.rgb;
            let w2;
            const p2 = weight === w2 ? 0.5 : weight;
            const w3 = 2 * p2 - 1;
            const a2 = c1.a - c2.a;
            const w1 = ((w3 * a2 === -1 ? w3 : (w3 + a2) / (1 + w3 * a2)) + 1) / 2;
            w2 = 1 - w1;
            c1.r = 255 & (w1 * c1.r + w2 * c2.r + 0.5);
            c1.g = 255 & (w1 * c1.g + w2 * c2.g + 0.5);
            c1.b = 255 & (w1 * c1.b + w2 * c2.b + 0.5);
            c1.a = p2 * c1.a + (1 - p2) * c2.a;
            this.rgb = c1;
        }
        return this;
    }
    interpolate(color2, t3) {
        if (color2) {
            this._rgb = interpolate2(this._rgb, color2._rgb, t3);
        }
        return this;
    }
    clone() {
        return new _Color(this.rgb);
    }
    alpha(a2) {
        this._rgb.a = n2b(a2);
        return this;
    }
    clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
    }
    greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
    }
    opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
    }
    negate() {
        const v2 = this._rgb;
        v2.r = 255 - v2.r;
        v2.g = 255 - v2.g;
        v2.b = 255 - v2.b;
        return this;
    }
    lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
    }
    darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
    }
    saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
    }
    desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
    }
    rotate(deg) {
        rotate(this._rgb, deg);
        return this;
    }
};

// node_modules/chart.js/dist/chunks/helpers.dataset.js
function noop() {}
var uid = /* @__PURE__ */ (() => {
    let id = 0;
    return () => id++;
})();
function isNullOrUndef(value) {
    return value === null || value === void 0;
}
function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
        return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
        return true;
    }
    return false;
}
function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) =>
    typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) =>
    typeof value === "string" && value.endsWith("%")
        ? (parseFloat(value) / 100) * dimension
        : +value;
function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
        return fn2.apply(thisArg, args);
    }
}
function each(loopable, fn2, thisArg, reverse) {
    let i2, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) {
            for (i2 = len - 1; i2 >= 0; i2--) {
                fn2.call(thisArg, loopable[i2], i2);
            }
        } else {
            for (i2 = 0; i2 < len; i2++) {
                fn2.call(thisArg, loopable[i2], i2);
            }
        }
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for (i2 = 0; i2 < len; i2++) {
            fn2.call(thisArg, loopable[keys[i2]], keys[i2]);
        }
    }
}
function _elementsEqual(a0, a1) {
    let i2, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
    }
    for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
        v0 = a0[i2];
        v1 = a1[i2];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
        }
    }
    return true;
}
function clone2(source) {
    if (isArray(source)) {
        return source.map(clone2);
    }
    if (isObject(source)) {
        const target = /* @__PURE__ */ Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for (; k < klen; ++k) {
            target[keys[k]] = clone2(source[keys[k]]);
        }
        return target;
    }
    return source;
}
function isValidKey(key) {
    return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        merge(tval, sval, options);
    } else {
        target[key] = clone2(sval);
    }
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [source];
    const ilen = sources.length;
    if (!isObject(target)) {
        return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i2 = 0; i2 < ilen; ++i2) {
        current = sources[i2];
        if (!isObject(current)) {
            continue;
        }
        const keys = Object.keys(current);
        for (let k = 0, klen = keys.length; k < klen; ++k) {
            merger(keys[k], target, current, options);
        }
    }
    return target;
}
function mergeIf(target, source) {
    return merge(target, source, {
        merger: _mergerIf,
    });
}
function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone2(sval);
    }
}
var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v2) => v2,
    // default resolvers
    x: (o2) => o2.x,
    y: (o2) => o2.y,
};
function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
        tmp += part;
        if (tmp.endsWith("\\")) {
            tmp = tmp.slice(0, -1) + ".";
        } else {
            keys.push(tmp);
            tmp = "";
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
        for (const k of keys) {
            if (k === "") {
                break;
            }
            obj = obj && obj[k];
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a2, b2) => {
    if (a2.size !== b2.size) {
        return false;
    }
    for (const item of a2) {
        if (!b2.has(item)) {
            return false;
        }
    }
    return true;
};
function _isClickEvent(e2) {
    return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = (PI * 2) / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x2, y2, epsilon) {
    return Math.abs(x2 - y2) < epsilon;
}
function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i2;
    for (i2 = 1; i2 < sqrt; i2++) {
        if (value % i2 === 0) {
            result.push(i2);
            result.push(value / i2);
        }
    }
    if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
    }
    result.sort((a2, b2) => a2 - b2).pop();
    return result;
}
function isNonPrimitive(n2) {
    return (
        typeof n2 === "symbol" ||
        (typeof n2 === "object" &&
            n2 !== null &&
            !(Symbol.toPrimitive in n2 || "toString" in n2 || "valueOf" in n2))
    );
}
function isNumber(n2) {
    return !isNonPrimitive(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x2, epsilon) {
    const rounded = Math.round(x2);
    return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property) {
    let i2, ilen, value;
    for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
        value = array[i2][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
function _decimalPlaces(x2) {
    if (!isNumberFinite(x2)) {
        return;
    }
    let e2 = 1;
    let p2 = 0;
    while (Math.round(x2 * e2) / e2 !== x2) {
        e2 *= 10;
        p2++;
    }
    return p2;
}
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(
        distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter,
    );
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
        angle += TAU;
    }
    return {
        angle,
        distance: radialDistanceFromCenter,
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _normalizeAngle(a2) {
    return ((a2 % TAU) + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a2 = _normalizeAngle(angle);
    const s2 = _normalizeAngle(start);
    const e2 = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s2 - a2);
    const angleToEnd = _normalizeAngle(e2 - a2);
    const startToAngle = _normalizeAngle(a2 - s2);
    const endToAngle = _normalizeAngle(a2 - e2);
    return (
        a2 === s2 ||
        a2 === e2 ||
        (sameAngleIsFullCircle && s2 === e2) ||
        (angleToStart > angleToEnd && startToAngle < endToAngle)
    );
}
function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
    cmp = cmp || ((index) => table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
        mid = (lo + hi) >> 1;
        if (cmp(mid)) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return {
        lo,
        hi,
    };
}
var _lookupByKey = (table, key, value, last) =>
    _lookup(
        table,
        value,
        last
            ? (index) => {
                  const ti = table[index][key];
                  return ti < value || (ti === value && table[index + 1][key] === value);
              }
            : (index) => table[index][key] < value,
    );
var _rlookupByKey = (table, key, value) =>
    _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
        start++;
    }
    while (end > start && values[end - 1] > max) {
        end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [listener],
        },
    });
    arrayEvents.forEach((key) => {
        const method = "_onData" + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                    if (typeof object[method] === "function") {
                        object[method](...args);
                    }
                });
                return res;
            },
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
        return;
    }
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) {
        listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
        return;
    }
    arrayEvents.forEach((key) => {
        delete array[key];
    });
    delete array._chartjs;
}
function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
        return items;
    }
    return Array.from(set2);
}
var requestAnimFrame = (function () {
    if (typeof window === "undefined") {
        return function (callback2) {
            return callback2();
        };
    }
    return window.requestAnimationFrame;
})();
function throttled(fn2, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function (...args) {
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, () => {
                ticking = false;
                fn2.apply(thisArg, argsToUse);
            });
        }
    };
}
function debounce(fn2, delay) {
    let timeout;
    return function (...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn2, delay, args);
        } else {
            fn2.apply(this, args);
        }
        return delay;
    };
}
var _toLeftRightCenter = (align) =>
    align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) =>
    align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
var atEdge = (t3) => t3 === 0 || t3 === 1;
var elasticIn = (t3, s2, p2) => -(Math.pow(2, 10 * (t3 -= 1)) * Math.sin(((t3 - s2) * TAU) / p2));
var elasticOut = (t3, s2, p2) => Math.pow(2, -10 * t3) * Math.sin(((t3 - s2) * TAU) / p2) + 1;
var effects = {
    linear: (t3) => t3,
    easeInQuad: (t3) => t3 * t3,
    easeOutQuad: (t3) => -t3 * (t3 - 2),
    easeInOutQuad: (t3) => ((t3 /= 0.5) < 1 ? 0.5 * t3 * t3 : -0.5 * (--t3 * (t3 - 2) - 1)),
    easeInCubic: (t3) => t3 * t3 * t3,
    easeOutCubic: (t3) => (t3 -= 1) * t3 * t3 + 1,
    easeInOutCubic: (t3) =>
        (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 + 2),
    easeInQuart: (t3) => t3 * t3 * t3 * t3,
    easeOutQuart: (t3) => -((t3 -= 1) * t3 * t3 * t3 - 1),
    easeInOutQuart: (t3) =>
        (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 : -0.5 * ((t3 -= 2) * t3 * t3 * t3 - 2),
    easeInQuint: (t3) => t3 * t3 * t3 * t3 * t3,
    easeOutQuint: (t3) => (t3 -= 1) * t3 * t3 * t3 * t3 + 1,
    easeInOutQuint: (t3) =>
        (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2),
    easeInSine: (t3) => -Math.cos(t3 * HALF_PI) + 1,
    easeOutSine: (t3) => Math.sin(t3 * HALF_PI),
    easeInOutSine: (t3) => -0.5 * (Math.cos(PI * t3) - 1),
    easeInExpo: (t3) => (t3 === 0 ? 0 : Math.pow(2, 10 * (t3 - 1))),
    easeOutExpo: (t3) => (t3 === 1 ? 1 : -Math.pow(2, -10 * t3) + 1),
    easeInOutExpo: (t3) =>
        atEdge(t3)
            ? t3
            : t3 < 0.5
              ? 0.5 * Math.pow(2, 10 * (t3 * 2 - 1))
              : 0.5 * (-Math.pow(2, -10 * (t3 * 2 - 1)) + 2),
    easeInCirc: (t3) => (t3 >= 1 ? t3 : -(Math.sqrt(1 - t3 * t3) - 1)),
    easeOutCirc: (t3) => Math.sqrt(1 - (t3 -= 1) * t3),
    easeInOutCirc: (t3) =>
        (t3 /= 0.5) < 1
            ? -0.5 * (Math.sqrt(1 - t3 * t3) - 1)
            : 0.5 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1),
    easeInElastic: (t3) => (atEdge(t3) ? t3 : elasticIn(t3, 0.075, 0.3)),
    easeOutElastic: (t3) => (atEdge(t3) ? t3 : elasticOut(t3, 0.075, 0.3)),
    easeInOutElastic(t3) {
        const s2 = 0.1125;
        const p2 = 0.45;
        return atEdge(t3)
            ? t3
            : t3 < 0.5
              ? 0.5 * elasticIn(t3 * 2, s2, p2)
              : 0.5 + 0.5 * elasticOut(t3 * 2 - 1, s2, p2);
    },
    easeInBack(t3) {
        const s2 = 1.70158;
        return t3 * t3 * ((s2 + 1) * t3 - s2);
    },
    easeOutBack(t3) {
        const s2 = 1.70158;
        return (t3 -= 1) * t3 * ((s2 + 1) * t3 + s2) + 1;
    },
    easeInOutBack(t3) {
        let s2 = 1.70158;
        if ((t3 /= 0.5) < 1) {
            return 0.5 * (t3 * t3 * (((s2 *= 1.525) + 1) * t3 - s2));
        }
        return 0.5 * ((t3 -= 2) * t3 * (((s2 *= 1.525) + 1) * t3 + s2) + 2);
    },
    easeInBounce: (t3) => 1 - effects.easeOutBounce(1 - t3),
    easeOutBounce(t3) {
        const m2 = 7.5625;
        const d2 = 2.75;
        if (t3 < 1 / d2) {
            return m2 * t3 * t3;
        }
        if (t3 < 2 / d2) {
            return m2 * (t3 -= 1.5 / d2) * t3 + 0.75;
        }
        if (t3 < 2.5 / d2) {
            return m2 * (t3 -= 2.25 / d2) * t3 + 0.9375;
        }
        return m2 * (t3 -= 2.625 / d2) * t3 + 0.984375;
    },
    easeInOutBounce: (t3) =>
        t3 < 0.5
            ? effects.easeInBounce(t3 * 2) * 0.5
            : effects.easeOutBounce(t3 * 2 - 1) * 0.5 + 0.5,
};
function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
        const type = value.toString();
        return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value)
        ? value
        : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
function applyAnimationsDefaults(defaults3) {
    defaults3.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0,
    });
    defaults3.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn",
    });
    defaults3.set("animations", {
        colors: {
            type: "color",
            properties: colors,
        },
        numbers: {
            type: "number",
            properties: numbers,
        },
    });
    defaults3.describe("animations", {
        _fallback: "animation",
    });
    defaults3.set("transitions", {
        active: {
            animation: {
                duration: 400,
            },
        },
        resize: {
            animation: {
                duration: 0,
            },
        },
        show: {
            animations: {
                colors: {
                    from: "transparent",
                },
                visible: {
                    type: "boolean",
                    duration: 0,
                },
            },
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent",
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: (v2) => v2 | 0,
                },
            },
        },
    });
}
function applyLayoutsDefaults(defaults3) {
    defaults3.set("layout", {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
        },
    });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
    options = options || {};
    const cacheKey = locale2 + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale2, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale2, options) {
    return getNumberFormat(locale2, options).format(num);
}
var formatters = {
    values(value) {
        return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index, ticks) {
        if (tickValue === 0) {
            return "0";
        }
        const locale2 = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(
                Math.abs(ticks[0].value),
                Math.abs(ticks[ticks.length - 1].value),
            );
            if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta)
            ? 1
            : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal,
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale2, options);
    },
    logarithmic(tickValue, index, ticks) {
        if (tickValue === 0) {
            return "0";
        }
        const remain =
            ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {
            return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return "";
    },
};
function calculateDelta(tickValue, ticks) {
    let delta =
        ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
    }
    return delta;
}
var Ticks = {
    formatters,
};
function applyScaleDefaults(defaults3) {
    defaults3.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        clip: true,
        grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0,
            width: 1,
        },
        title: {
            display: false,
            text: "",
            padding: {
                top: 4,
                bottom: 4,
            },
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2,
        },
    });
    defaults3.route("scale.ticks", "color", "", "color");
    defaults3.route("scale.grid", "color", "", "borderColor");
    defaults3.route("scale.border", "color", "", "borderColor");
    defaults3.route("scale.title", "color", "", "color");
    defaults3.describe("scale", {
        _fallback: false,
        _scriptable: (name) =>
            !name.startsWith("before") &&
            !name.startsWith("after") &&
            name !== "callback" &&
            name !== "parser",
        _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash",
    });
    defaults3.describe("scales", {
        _fallback: "scale",
    });
    defaults3.describe("scale.ticks", {
        _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
        _indexable: (name) => name !== "backdropPadding",
    });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
    if (!key) {
        return node;
    }
    const keys = key.split(".");
    for (let i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
        const k = keys[i2];
        node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === "string") {
        return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
    constructor(_descriptors2, _appliers) {
        this.animation = void 0;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null,
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options) => getHoverColor(options.color);
        this.indexAxis = "x";
        this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false,
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = void 0;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors2);
        this.apply(_appliers);
    }
    set(scope, values) {
        return set(this, scope, values);
    }
    get(scope) {
        return getScope$1(this, scope);
    }
    describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = "_" + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true,
            },
            [name]: {
                enumerable: true,
                get() {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) {
                        return Object.assign({}, target, local);
                    }
                    return valueOrDefault(local, target);
                },
                set(value) {
                    this[privateName] = value;
                },
            },
        });
    }
    apply(appliers) {
        appliers.forEach((apply) => apply(this));
    }
};
var defaults2 = /* @__PURE__ */ new Defaults(
    {
        _scriptable: (name) => !name.startsWith("on"),
        _indexable: (name) => name !== "events",
        hover: {
            _fallback: "interaction",
        },
        interaction: {
            _scriptable: false,
            _indexable: false,
        },
    },
    [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults],
);
function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
    }
    return (
        (font.style ? font.style + " " : "") +
        (font.weight ? font.weight + " " : "") +
        font.size +
        "px " +
        font.family
    );
}
function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) {
        longest = textWidth;
    }
    return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = (cache.data = cache.data || {});
    let gc = (cache.garbageCollect = cache.garbageCollect || []);
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i2, j2, jlen, thing, nestedThing;
    for (i2 = 0; i2 < ilen; i2++) {
        thing = arrayOfThings[i2];
        if (thing !== void 0 && thing !== null && !isArray(thing)) {
            longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray(thing)) {
            for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
                nestedThing = thing[j2];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                    longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for (i2 = 0; i2 < gcLen; i2++) {
            delete data[gc[i2]];
        }
        gc.splice(0, gcLen);
    }
    return longest;
}
function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
        return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x2, y2) {
    drawPointLegend(ctx, options, x2, y2, null);
}
function drawPointLegend(ctx, options, x2, y2, w2) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x2, y2);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) {
        return;
    }
    ctx.beginPath();
    switch (style) {
        // Default includes circle
        default:
            if (w2) {
                ctx.ellipse(x2, y2, w2 / 2, radius, 0, 0, TAU);
            } else {
                ctx.arc(x2, y2, radius, 0, TAU);
            }
            ctx.closePath();
            break;
        case "triangle":
            width = w2 ? w2 / 2 : radius;
            ctx.moveTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
            ctx.arc(x2 - xOffsetW, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x2 + yOffsetW, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x2 + xOffsetW, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x2 - yOffsetW, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case "rect":
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w2 ? w2 / 2 : size;
                ctx.rect(x2 - width, y2 - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */
        case "rectRot":
            xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
            ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
            ctx.lineTo(x2 + yOffsetW, y2 - xOffset);
            ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
            ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
            ctx.closePath();
            break;
        case "crossRot":
            rad += QUARTER_PI;
        /* falls through */
        case "cross":
            xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
            ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
            ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
            ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
            ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
            break;
        case "star":
            xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
            ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
            ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
            ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
            ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
            ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
            ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
            ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
            ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
            break;
        case "line":
            xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x2 - xOffset, y2 - yOffset);
            ctx.lineTo(x2 + xOffset, y2 + yOffset);
            break;
        case "dash":
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y2 + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
        ctx.stroke();
    }
}
function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return (
        !area ||
        (point &&
            point.x > area.left - margin &&
            point.x < area.right + margin &&
            point.y > area.top - margin &&
            point.y < area.bottom + margin)
    );
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
    }
    if (opts.color) {
        ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
    }
}
function decorateText(ctx, x2, y2, line, opts) {
    if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left = x2 - metrics.actualBoundingBoxLeft;
        const right = x2 + metrics.actualBoundingBoxRight;
        const top = y2 - metrics.actualBoundingBoxAscent;
        const bottom = y2 + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x2, y2, font, opts = {}) {
    const lines = isArray(text) ? text : [text];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i2, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i2 = 0; i2 < lines.length; ++i2) {
        line = lines[i2];
        if (opts.backdrop) {
            drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
            if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x2, y2, opts.maxWidth);
        }
        ctx.fillText(line, x2, y2, opts.maxWidth);
        decorateText(ctx, x2, y2, line, opts);
        y2 += Number(font.lineHeight);
    }
    ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
    const { x: x2, y: y2, w: w2, h: h6, radius } = rect;
    ctx.arc(x2 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x2, y2 + h6 - radius.bottomLeft);
    ctx.arc(
        x2 + radius.bottomLeft,
        y2 + h6 - radius.bottomLeft,
        radius.bottomLeft,
        PI,
        HALF_PI,
        true,
    );
    ctx.lineTo(x2 + w2 - radius.bottomRight, y2 + h6);
    ctx.arc(
        x2 + w2 - radius.bottomRight,
        y2 + h6 - radius.bottomRight,
        radius.bottomRight,
        HALF_PI,
        0,
        true,
    );
    ctx.lineTo(x2 + w2, y2 + radius.topRight);
    ctx.arc(x2 + w2 - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x2 + radius.topLeft, y2);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
        return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
        case "px":
            return value;
        case "%":
            value /= 100;
            break;
    }
    return size * value;
}
var numberOrZero = (v2) => +v2 || 0;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value)
        ? objProps
            ? (prop) => valueOrDefault(value[prop], value[props[prop]])
            : (prop) => value[prop]
        : () => value;
    for (const prop of keys) {
        ret[prop] = numberOrZero(read(prop));
    }
    return ret;
}
function toTRBL(value) {
    return _readValueToProps(value, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x",
    });
}
function toTRBLCorners(value) {
    return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults2.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
        size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = void 0;
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: "",
    };
    font.string = toFontString(font);
    return font;
}
function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i2, ilen, value;
    for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
        value = inputs[i2];
        if (value === void 0) {
            continue;
        }
        if (context !== void 0 && typeof value === "function") {
            value = value(context);
            cacheable = false;
        }
        if (index !== void 0 && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== void 0) {
            if (info && !cacheable) {
                info.cacheable = false;
            }
            return value;
        }
    }
}
function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add) => (beginAtZero && value === 0 ? 0 : value + add);
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change),
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}
function _createResolver(
    scopes,
    prefixes = [""],
    rootScopes,
    fallback,
    getTarget = () => scopes[0],
) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
        fallback = _resolve("_fallback", scopes);
    }
    const cache = {
        [Symbol.toStringTag]: "Object",
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope) =>
            _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),
    };
    return new Proxy(cache, {
        /**
         * A trap for the delete operator.
         */
        deleteProperty(target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
        },
        /**
         * A trap for getting property values.
         */
        get(target, prop) {
            return _cached(target, prop, () =>
                _resolveWithPrefixes(prop, prefixes, scopes, target),
            );
        },
        /**
         * A trap for Object.getOwnPropertyDescriptor.
         * Also used by Object.hasOwnProperty.
         */
        getOwnPropertyDescriptor(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
         * A trap for Object.getPrototypeOf.
         */
        getPrototypeOf() {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
         * A trap for the in operator.
         */
        has(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
         * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
         */
        ownKeys(target) {
            return getKeysFromAllScopes(target);
        },
        /**
         * A trap for setting property values.
         */
        set(target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value;
            delete target._keys;
            return true;
        },
    });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: /* @__PURE__ */ new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope) =>
            _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults),
    };
    return new Proxy(cache, {
        /**
         * A trap for the delete operator.
         */
        deleteProperty(target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
        },
        /**
         * A trap for getting property values.
         */
        get(target, prop, receiver) {
            return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
        },
        /**
         * A trap for Object.getOwnPropertyDescriptor.
         * Also used by Object.hasOwnProperty.
         */
        getOwnPropertyDescriptor(target, prop) {
            return target._descriptors.allKeys
                ? Reflect.has(proxy, prop)
                    ? {
                          enumerable: true,
                          configurable: true,
                      }
                    : void 0
                : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
         * A trap for Object.getPrototypeOf.
         */
        getPrototypeOf() {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
         * A trap for the in operator.
         */
        has(target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
         * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
         */
        ownKeys() {
            return Reflect.ownKeys(proxy);
        },
        /**
         * A trap for setting property values.
         */
        set(target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
        },
    });
}
function _descriptors(
    proxy,
    defaults3 = {
        scriptable: true,
        indexable: true,
    },
) {
    const {
        _scriptable = defaults3.scriptable,
        _indexable = defaults3.indexable,
        _allKeys = defaults3.allKeys,
    } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : () => _indexable,
    };
}
var readKey = (prefix, name) => (prefix ? prefix + _capitalize(name) : name);
var needsSubResolver = (prop, value) =>
    isObject(value) &&
    prop !== "adapters" &&
    (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
        return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
        throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
        return value[_context.index % value.length];
    } else if (isObject(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
        value = [];
        for (const item of arr) {
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(
                _attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2),
            );
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) =>
    key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
        const scope = getScope(key, parent);
        if (scope) {
            set2.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (
                typeof fallback !== "undefined" &&
                fallback !== key &&
                fallback !== parentFallback
            ) {
                return fallback;
            }
        } else if (
            scope === false &&
            typeof parentFallback !== "undefined" &&
            key !== parentFallback
        ) {
            return null;
        }
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [...parentScopes, ...rootScopes];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
        return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
        key = addScopesFromKey(set2, allScopes, fallback, key, value);
        if (key === null) {
            return false;
        }
    }
    return _createResolver(Array.from(set2), [""], rootScopes, fallback, () =>
        subGetTarget(resolver, prop, value),
    );
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
        key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
        parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
        return value;
    }
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== "undefined") {
            return needsSubResolver(prop, value)
                ? createSubResolver(scopes, proxy, prop, value)
                : value;
        }
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes) {
        if (!scope) {
            continue;
        }
        const value = scope[key];
        if (typeof value !== "undefined") {
            return value;
        }
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
        for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
            set2.add(key);
        }
    }
    return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
        parent = parent.host;
    }
    return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) {
            valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];
        }
    } else {
        valueInPixels = styleValue;
    }
    return valueInPixels;
}
var getComputedStyle2 = (element) =>
    element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i2 = 0; i2 < 4; i2++) {
        const pos = positions[i2];
        result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
var useOffsetPos = (x2, y2, target) => (x2 > 0 || y2 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e2, canvas) {
    const touches = e2.touches;
    const source = touches && touches.length ? touches[0] : e2;
    const { offsetX, offsetY } = source;
    let box = false;
    let x2, y2;
    if (useOffsetPos(offsetX, offsetY, e2.target)) {
        x2 = offsetX;
        y2 = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x2 = source.clientX - rect.left;
        y2 = source.clientY - rect.top;
        box = true;
    }
    return {
        x: x2,
        y: y2,
        box,
    };
}
function getRelativePosition(event, chart) {
    if ("native" in event) {
        return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x2, y: y2, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((((x2 - xOffset) / width) * canvas.width) / currentDevicePixelRatio),
        y: Math.round((((y2 - yOffset) / height) * canvas.height) / currentDevicePixelRatio),
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect();
            const containerStyle = getComputedStyle2(container);
            const containerBorder = getPositionedStyle(containerStyle, "border", "width");
            const containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY,
    };
}
var round1 = (v2) => Math.round(v2 * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
        const borders = getPositionedStyle(style, "border", "width");
        const paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
        height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width,
        height,
    };
}
function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = round1(chart.height * pixelRatio);
    const deviceWidth = round1(chart.width * pixelRatio);
    chart.height = round1(chart.height);
    chart.width = round1(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (
        chart.currentDevicePixelRatio !== pixelRatio ||
        canvas.height !== deviceHeight ||
        canvas.width !== deviceWidth
    ) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
var supportsEventListenerOptions = (function () {
    let passiveSupported = false;
    try {
        const options = {
            get passive() {
                passiveSupported = true;
                return false;
            },
        };
        if (_isDomSupported()) {
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
        }
    } catch (e2) {}
    return passiveSupported;
})();
function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
}
var getRightToLeftAdapter = function (rectX, width) {
    return {
        x(x2) {
            return rectX + rectX + width - x2;
        },
        setWidth(w2) {
            width = w2;
        },
        textAlign(align) {
            if (align === "center") {
                return align;
            }
            return align === "right" ? "left" : "right";
        },
        xPlus(x2, value) {
            return x2 - value;
        },
        leftForLtr(x2, itemWidth) {
            return x2 - itemWidth;
        },
    };
};
var getLeftToRightAdapter = function () {
    return {
        x(x2) {
            return x2;
        },
        setWidth(w2) {},
        textAlign(align) {
            return align;
        },
        xPlus(x2, value) {
            return x2 + value;
        },
        leftForLtr(x2, _itemWidth) {
            return x2;
        },
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [style.getPropertyValue("direction"), style.getPropertyPriority("direction")];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
}
function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
        return {
            left: getSizeForArea(xScale, chartArea, "left"),
            right: getSizeForArea(xScale, chartArea, "right"),
            top: getSizeForArea(yScale, chartArea, "top"),
            bottom: getSizeForArea(yScale, chartArea, "bottom"),
        };
    }
    return chartArea;
}
function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
        return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
        right:
            clip.right === false
                ? chart.width
                : area.right + (clip.right === true ? 0 : clip.right),
        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
        bottom:
            clip.bottom === false
                ? chart.height
                : area.bottom + (clip.bottom === true ? 0 : clip.bottom),
    };
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
    constructor() {
        this._request = null;
        this._charts = /* @__PURE__ */ new Map();
        this._running = false;
        this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn2) =>
            fn2({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps),
            }),
        );
    }
    _refresh() {
        if (this._request) {
            return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, () => {
            this._update();
            this._request = null;
            if (this._running) {
                this._refresh();
            }
        });
    }
    _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i2 = items.length - 1;
            let draw = false;
            let item;
            for (; i2 >= 0; --i2) {
                item = items[i2];
                if (item._active) {
                    if (item._total > anims.duration) {
                        anims.duration = item._total;
                    }
                    item.tick(date);
                    draw = true;
                } else {
                    items[i2] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw) {
                chart.draw();
                this._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, "complete");
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
            this._running = false;
        }
    }
    _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: [],
                },
            };
            charts.set(chart, anims);
        }
        return anims;
    }
    listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
        if (!items || !items.length) {
            return;
        }
        this._getAnims(chart).items.push(...items);
    }
    has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
            return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) {
            return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
            return false;
        }
        return true;
    }
    stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
            return;
        }
        const items = anims.items;
        let i2 = items.length - 1;
        for (; i2 >= 0; --i2) {
            items[i2].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
        return this._charts.delete(chart);
    }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
    boolean(from2, to2, factor) {
        return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
        const c0 = color(from2 || transparent);
        const c1 = c0.valid && color(to2 || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
        return from2 + (to2 - from2) * factor;
    },
};
var Animation = class {
    constructor(cfg, target, prop, to2) {
        const currentValue = target[prop];
        to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
        const from2 = resolve([cfg.from, currentValue, to2]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from2;
        this._to = to2;
        this._promises = void 0;
    }
    active() {
        return this._active;
    }
    update(cfg, to2, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
            this._from = resolve([cfg.from, currentValue, to2]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from2 = this._from;
        const loop = this._loop;
        const to2 = this._to;
        let factor;
        this._active = from2 !== to2 && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to2;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from2;
            return;
        }
        factor = (elapsed / duration) % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej) => {
            promises.push({
                res,
                rej,
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? "res" : "rej";
        const promises = this._promises || [];
        for (let i2 = 0; i2 < promises.length; i2++) {
            promises[i2][method]();
        }
    }
};
var Animations = class {
    constructor(chart, config) {
        this._chart = chart;
        this._properties = /* @__PURE__ */ new Map();
        this.configure(config);
    }
    configure(config) {
        if (!isObject(config)) {
            return;
        }
        const animationOptions = Object.keys(defaults2.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key) => {
            const cfg = config[key];
            if (!isObject(cfg)) {
                return;
            }
            const resolved = {};
            for (const option of animationOptions) {
                resolved[option] = cfg[option];
            }
            ((isArray(cfg.properties) && cfg.properties) || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                    animatedProps.set(prop, resolved);
                }
            });
        });
    }
    _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
            return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(
                () => {
                    target.options = newOptions;
                },
                () => {},
            );
        }
        return animations;
    }
    _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i2;
        for (i2 = props.length - 1; i2 >= 0; --i2) {
            const prop = props[i2];
            if (prop.charAt(0) === "$") {
                continue;
            }
            if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else {
                    animation.cancel();
                }
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
    update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
};
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i2 = 0; i2 < keys.length; i2++) {
        const anim = animations[keys[i2]];
        if (anim && anim.active()) {
            running.push(anim.wait());
        }
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
        return;
    }
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) {
        target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {},
        });
    }
    return options;
}
function scaleClip(scale, allowedOverflow) {
    const opts = (scale && scale.options) || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max,
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
        return false;
    }
    const x2 = scaleClip(xScale, allowedOverflow);
    const y2 = scaleClip(yScale, allowedOverflow);
    return {
        top: y2.end,
        right: x2.end,
        bottom: y2.start,
        left: x2.start,
    };
}
function toClip(value) {
    let t3, r2, b2, l2;
    if (isObject(value)) {
        t3 = value.top;
        r2 = value.right;
        b2 = value.bottom;
        l2 = value.left;
    } else {
        t3 = r2 = b2 = l2 = value;
    }
    return {
        top: t3,
        right: r2,
        bottom: b2,
        left: l2,
        disabled: value === false,
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        keys.push(metasets[i2].index);
    }
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i2, ilen, datasetIndex, otherValue;
    if (value === null) {
        return;
    }
    let found = false;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
        datasetIndex = +keys[i2];
        if (datasetIndex === dsIndex) {
            found = true;
            if (options.all) {
                continue;
            }
            break;
        }
        otherValue = stack.values[datasetIndex];
        if (
            isNumberFinite(otherValue) &&
            (singleMode || value === 0 || sign(value) === sign(otherValue))
        ) {
            value += otherValue;
        }
    }
    if (!found && !options.all) {
        return 0;
    }
    return value;
}
function convertObjectDataToArray(data, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i2, ilen, key;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
        key = keys[i2];
        adata[i2] = {
            [iAxisKey]: key,
            [vAxisKey]: data[key],
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || (stacked === void 0 && meta.stack !== void 0);
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY,
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
        const value = stack[meta.index];
        if ((positive && value > 0) || (!positive && value < 0)) {
            return meta.index;
        }
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i2 = 0; i2 < ilen; ++i2) {
        const item = parsed[i2];
        const { [iAxis]: index, [vAxis]: value } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales)
        .filter((key) => scales[key].axis === axis)
        .shift();
}
function createDatasetContext(parent, index) {
    return createContext(parent, {
        active: false,
        dataset: void 0,
        datasetIndex: index,
        index,
        mode: "default",
        type: "dataset",
    });
}
function createDataContext(parent, index, element) {
    return createContext(parent, {
        active: false,
        dataIndex: index,
        parsed: void 0,
        raw: void 0,
        element,
        index,
        mode: "default",
        type: "data",
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
        return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
            return;
        }
        delete stacks[axis][datasetIndex];
        if (
            stacks[axis]._visualValues !== void 0 &&
            stacks[axis]._visualValues[datasetIndex] !== void 0
        ) {
            delete stacks[axis]._visualValues[datasetIndex];
        }
    }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => (shared ? cached : Object.assign({}, cached));
var createStack = (canStack, meta, chart) =>
    canStack &&
    !meta.hidden &&
    meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null,
    };
var DatasetController = class {
    constructor(chart, datasetIndex) {
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = void 0;
        this._parsing = false;
        this._data = void 0;
        this._objectData = void 0;
        this._sharedOptions = void 0;
        this._drawStart = void 0;
        this._drawCount = void 0;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = void 0;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
    }
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
            console.warn(
                "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options",
            );
        }
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x2, y2, r2) => (axis === "x" ? x2 : axis === "r" ? r2 : y2);
        const xid = (meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x")));
        const yid = (meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y")));
        const rid = (meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r")));
        const indexAxis = meta.indexAxis;
        const iid = (meta.iAxisID = chooseId(indexAxis, xid, yid, rid));
        const vid = (meta.vAxisID = chooseId(indexAxis, yid, xid, rid));
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update("reset");
    }
    _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
            unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
            clearStacks(meta);
        }
    }
    _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject(data)) {
            const meta = this._cachedMeta;
            this._data = convertObjectDataToArray(data, meta);
        } else if (_data !== data) {
            if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
        }
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
            meta._stacked = isStacked(meta.vScale, meta);
        }
    }
    configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
    parse(start, count) {
        const { _cachedMeta: meta, _data: data } = this;
        const { iScale, _stacked } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i2, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
            } else if (isObject(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
            } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = () =>
                cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
            for (i2 = 0; i2 < count; ++i2) {
                meta._parsed[i2 + start] = cur = parsed[i2];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) {
                        sorted = false;
                    }
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) {
            updateStacks(this, parsed);
        }
    }
    parsePrimitiveData(meta, data, start, count) {
        const { iScale, vScale } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i2, ilen, index;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index = i2 + start;
            parsed[i2] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index),
            };
        }
        return parsed;
    }
    parseArrayData(meta, data, start, count) {
        const { xScale, yScale } = meta;
        const parsed = new Array(count);
        let i2, ilen, index, item;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index = i2 + start;
            item = data[index];
            parsed[i2] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index),
            };
        }
        return parsed;
    }
    parseObjectData(meta, data, start, count) {
        const { xScale, yScale } = meta;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const parsed = new Array(count);
        let i2, ilen, index, item;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index = i2 + start;
            item = data[index];
            parsed[i2] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index),
            };
        }
        return parsed;
    }
    getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
    getDataElement(index) {
        return this._cachedMeta.data[index];
    }
    applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues,
        };
        return applyStack(stack, value, meta.index, {
            mode,
        });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range2.min = Math.min(range2.min, value);
        range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range2 = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY,
        };
        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
        let i2, parsed;
        function _skip() {
            parsed = _parsed[i2];
            const otherValue = parsed[otherScale.axis];
            return (
                !isNumberFinite(parsed[scale.axis]) ||
                otherMin > otherValue ||
                otherMax < otherValue
            );
        }
        for (i2 = 0; i2 < ilen; ++i2) {
            if (_skip()) {
                continue;
            }
            this.updateRangeFromParsed(range2, scale, parsed, stack);
            if (sorted) {
                break;
            }
        }
        if (sorted) {
            for (i2 = ilen - 1; i2 >= 0; --i2) {
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range2, scale, parsed, stack);
                break;
            }
        }
        return range2;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i2, ilen, value;
        for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
            value = parsed[i2][scale.axis];
            if (isNumberFinite(value)) {
                values.push(value);
            }
        }
        return values;
    }
    getMaxOverflow() {
        return false;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : "",
        };
    }
    _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || "default");
        meta._clip = toClip(
            valueOrDefault(
                this.options.clip,
                defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow()),
            ),
        );
    }
    update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i2;
        if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
        }
        for (i2 = start; i2 < start + count; ++i2) {
            const element = elements[i2];
            if (element.hidden) {
                continue;
            }
            if (element.active && drawActiveElementsOnTop) {
                active.push(element);
            } else {
                element.draw(ctx, area);
            }
        }
        for (i2 = 0; i2 < active.length; ++i2) {
            active[i2].draw(ctx, area);
        }
    }
    getStyle(index, active) {
        const mode = active ? "active" : "default";
        return index === void 0 && this._cachedMeta.dataset
            ? this.resolveDatasetElementOptions(mode)
            : this.resolveDataElementOptions(index || 0, mode);
    }
    getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context =
                element.$context ||
                (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context =
                this.$context ||
                (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
    resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
    _resolveElementOptions(elementType, mode = "default", index) {
        const active = mode === "active";
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + "-" + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index);
        if (cached) {
            return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active
            ? [`${elementType}Hover`, "hover", elementType, ""]
            : [elementType, ""];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names2 = Object.keys(defaults2.elements[elementType]);
        const context = () => this.getContext(index, active, mode);
        const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
    _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
            return cached;
        }
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
    }
    getSharedOptions(options) {
        if (!options.$shared) {
            return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions =
            this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
            sharedOptions,
            includeOptions,
        };
    }
    updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
        } else {
            this._resolveAnimations(index, mode).update(element, properties);
        }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
        }
    }
    _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: (!active && this.getSharedOptions(options)) || options,
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, "active", false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, "active", true);
    }
    _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, void 0, "active", false);
        }
    }
    _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, void 0, "active", true);
        }
    }
    _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList) {
            this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
            this.parse(0, count);
        }
        if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
        }
    }
    _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i2;
        const move = (arr) => {
            arr.length += count;
            for (i2 = arr.length - 1; i2 >= end; i2--) {
                arr[i2] = arr[i2 - count];
            }
        };
        move(data);
        for (i2 = start; i2 < end; ++i2) {
            data[i2] = new this.dataElementType();
        }
        if (this._parsing) {
            move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
            this.updateElements(data, start, count, "reset");
        }
    }
    updateElements(element, start, count, mode) {}
    _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
                clearStacks(meta, removed);
            }
        }
        meta.data.splice(start, count);
    }
    _sync(args) {
        if (this._parsing) {
            this._syncList.push(args);
        } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([this.index, ...args]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - count, count]);
    }
    _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
    }
    _onDataShift() {
        this._sync(["_removeElements", 0, 1]);
    }
    _onDataSplice(start, count) {
        if (count) {
            this._sync(["_removeElements", start, count]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
            this._sync(["_insertElements", start, newCount]);
        }
    }
    _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length]);
    }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
            values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = _arrayUnique(values.sort((a2, b2) => a2 - b2));
    }
    return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i2, ilen, curr, prev;
    const updateMinAndPrev = () => {
        if (curr === 32767 || curr === -32768) {
            return;
        }
        if (defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
    };
    for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
        curr = scale.getPixelForValue(values[i2]);
        updateMinAndPrev();
    }
    prev = void 0;
    for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
        curr = scale.getPixelForTick(i2);
        updateMinAndPrev();
    }
    return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2,
    };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
        next = curr + curr - prev;
    }
    const start = curr - ((curr - Math.min(prev, next)) / 2) * percent;
    const size = (Math.abs(next - prev) / 2) * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start,
    };
}
function parseFloatBar(entry, item, vScale, i2) {
    const startValue = vScale.parse(entry[0], i2);
    const endValue = vScale.parse(entry[1], i2);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max,
    };
}
function parseValue(entry, item, vScale, i2) {
    if (isArray(entry)) {
        parseFloatBar(entry, item, vScale, i2);
    } else {
        item[vScale.axis] = vScale.parse(entry, i2);
    }
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i2, ilen, item, entry;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        entry = data[i2];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
        parsed.push(parseValue(entry, item, vScale, i2));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) {
        return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = "left";
        end = "right";
    } else {
        reverse = properties.base < properties.y;
        start = "bottom";
        end = "top";
    }
    if (reverse) {
        top = "end";
        bottom = "start";
    } else {
        top = "start";
        bottom = "end";
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom,
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true,
        };
        return;
    }
    const { start, end, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
            edge = top;
        } else if ((stack._bottom || 0) === index) {
            edge = bottom;
        } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a2, b2, reverse) {
    if (reverse) {
        edge = swap(edge, a2, b2);
        edge = startEnd(edge, b2, a2);
    } else {
        edge = startEnd(edge, a2, b2);
    }
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v2, start, end) {
    return v2 === "start" ? start : v2 === "end" ? end : v2;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? (ratio === 1 ? 0.33 : 0) : inflateAmount;
}
var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
        const { iScale, vScale } = meta;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
        const parsed = [];
        let i2, ilen, item, obj;
        for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
            obj = data[i2];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
        }
        return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
        super.updateRangeFromParsed(range2, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range2.min = Math.min(range2.min, custom.min);
            range2.max = Math.max(range2.max, custom.max);
        }
    }
    getMaxOverflow() {
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale, vScale } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom)
            ? "[" + custom.start + ", " + custom.end + "]"
            : "" + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value,
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset2 = mode === "reset";
        const {
            index,
            _cachedMeta: { vScale },
        } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        for (let i2 = start; i2 < start + count; i2++) {
            const parsed = this.getParsed(i2);
            const vpixels =
                reset2 || isNullOrUndef(parsed[vScale.axis])
                    ? {
                          base,
                          head: base,
                      }
                    : this._calculateBarValuePixels(i2);
            const ipixels = this._calculateBarIndexPixels(i2, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius:
                    !stack ||
                    isFloatBar(parsed._custom) ||
                    index === stack._top ||
                    index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size,
            };
            if (includeOptions) {
                properties.options =
                    sharedOptions ||
                    this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
            }
            const options = properties.options || bars[i2].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i2], i2, properties, mode);
        }
    }
    _getStacks(last, dataIndex) {
        const { iScale } = this._cachedMeta;
        const metasets = iScale
            .getMatchingVisibleMetas(this._type)
            .filter((meta) => meta.controller.options.grouped);
        const stacked = iScale.options.stacked;
        const stacks = [];
        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
        const iScaleValue = currentParsed && currentParsed[iScale.axis];
        const skipNull = (meta) => {
            const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
            const val = parsed && parsed[meta.vScale.axis];
            if (isNullOrUndef(val) || isNaN(val)) {
                return true;
            }
        };
        for (const meta of metasets) {
            if (dataIndex !== void 0 && skipNull(meta)) {
                continue;
            }
            if (
                stacked === false ||
                stacks.indexOf(meta.stack) === -1 ||
                (stacked === void 0 && meta.stack === void 0)
            ) {
                stacks.push(meta.stack);
            }
            if (meta.index === last) {
                break;
            }
        }
        if (!stacks.length) {
            stacks.push(void 0);
        }
        return stacks;
    }
    _getStackCount(index) {
        return this._getStacks(void 0, index).length;
    }
    _getAxisCount() {
        return this._getAxis().length;
    }
    getFirstScaleIdForIndexAxis() {
        const scales = this.chart.scales;
        const indexScaleId = this.chart.options.indexAxis;
        return Object.keys(scales)
            .filter((key) => scales[key].axis === indexScaleId)
            .shift();
    }
    _getAxis() {
        const axis = {};
        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
        for (const dataset of this.chart.data.datasets) {
            axis[
                valueOrDefault(
                    this.chart.options.indexAxis === "x" ? dataset.xAxisID : dataset.yAxisID,
                    firstScaleAxisId,
                )
            ] = true;
        }
        return Object.keys(axis);
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== void 0 ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
    _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i2, ilen;
        for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
            pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage,
        };
    }
    _calculateBarValuePixels(index) {
        const {
            _cachedMeta: { vScale, _stacked, index: datasetIndex },
            options: { base: baseValue, minBarLength },
        } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
            }
            start += value;
        }
        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
            head = vScale.getPixelForValue(start + length);
        } else {
            head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
                base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) {
                parsed._stacks[vScale.axis]._visualValues[datasetIndex] =
                    vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
            }
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = (sign(size) * vScale.getLineWidthForValue(actualBase)) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2,
        };
    }
    _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
        let center, size;
        const axisCount = this._getAxisCount();
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range2 =
                options.barThickness === "flex"
                    ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount)
                    : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);
            const axisID =
                this.chart.options.indexAxis === "x"
                    ? this.getDataset().xAxisID
                    : this.getDataset().yAxisID;
            const axisNumber = this._getAxis().indexOf(
                valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()),
            );
            const stackIndex =
                this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0) +
                axisNumber;
            center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
            size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size,
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i2 = 0;
        for (; i2 < ilen; ++i2) {
            if (this.getParsed(i2)[vScale.axis] !== null && !rects[i2].hidden) {
                rects[i2].draw(this._ctx);
            }
        }
    }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
        numbers: {
            type: "number",
            properties: ["x", "y", "base", "width", "height"],
        },
    },
});
__publicField(BarController, "overrides", {
    scales: {
        _index_: {
            type: "category",
            offset: true,
            grid: {
                offset: true,
            },
        },
        _value_: {
            type: "linear",
            beginAtZero: true,
        },
    },
});
function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a2, b2) =>
            _angleBetween(angle, startAngle, endAngle, true)
                ? 1
                : Math.max(a2, a2 * cutout, b2, b2 * cutout);
        const calcMin = (angle, a2, b2) =>
            _angleBetween(angle, startAngle, endAngle, true)
                ? -1
                : Math.min(a2, a2 * cutout, b2, b2 * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(HALF_PI, startY, endY);
        const minX = calcMin(PI, startX, endX);
        const minY = calcMin(PI + HALF_PI, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY,
    };
}
var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = void 0;
        this.outerRadius = void 0;
        this.offsetX = void 0;
        this.offsetY = void 0;
    }
    linkScales() {}
    parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
            meta._parsed = data;
        } else {
            let getter = (i3) => +data[i3];
            if (isObject(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i3) => +resolveObjectKey(data[i3], key);
            }
            let i2, ilen;
            for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
                meta._parsed[i2] = getter(i2);
            }
        }
    }
    _getRotation() {
        return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
        return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
        let min = TAU;
        let max = -TAU;
        for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
            if (
                this.chart.isDatasetVisible(i2) &&
                this.chart.getDatasetMeta(i2).type === this._type
            ) {
                const controller = this.chart.getDatasetMeta(i2).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
            }
        }
        return {
            rotation: min,
            circumference: max - min,
        };
    }
    update(mode) {
        const chart = this.chart;
        const { chartArea } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference, rotation } = this._getRotationExtents();
        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(
            rotation,
            circumference,
            cutout,
        );
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = toDimension(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i2, reset2) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (
            (reset2 && opts.animation.animateRotate) ||
            !this.chart.getDataVisibility(i2) ||
            meta._parsed[i2] === null ||
            meta.data[i2].hidden
        ) {
            return 0;
        }
        return this.calculateCircumference((meta._parsed[i2] * circumference) / TAU);
    }
    updateElements(arcs, start, count, mode) {
        const reset2 = mode === "reset";
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset2 && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        let startAngle = this._getRotation();
        let i2;
        for (i2 = 0; i2 < start; ++i2) {
            startAngle += this._circumference(i2, reset2);
        }
        for (i2 = start; i2 < start + count; ++i2) {
            const circumference = this._circumference(i2, reset2);
            const arc = arcs[i2];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius,
            };
            if (includeOptions) {
                properties.options =
                    sharedOptions ||
                    this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i2, properties, mode);
        }
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i2;
        for (i2 = 0; i2 < metaData.length; i2++) {
            const value = meta._parsed[i2];
            if (
                value !== null &&
                !isNaN(value) &&
                this.chart.getDataVisibility(i2) &&
                !metaData[i2].hidden
            ) {
                total += Math.abs(value);
            }
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
            return TAU * (Math.abs(value) / total);
        }
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || "",
            value,
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i2, ilen, meta, controller, options;
        if (!arcs) {
            for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
                if (chart.isDatasetVisible(i2)) {
                    meta = chart.getDatasetMeta(i2);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
            }
        }
        if (!arcs) {
            return 0;
        }
        for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
            options = controller.resolveDataElementOptions(i2);
            if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
            const options = this.resolveDataElementOptions(i2);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
    _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for (let i2 = 0; i2 < datasetIndex; ++i2) {
            if (this.chart.isDatasetVisible(i2)) {
                ringWeightOffset += this._getRingWeight(i2);
            }
        }
        return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
        animateRotate: true,
        animateScale: false,
    },
    animations: {
        numbers: {
            type: "number",
            properties: [
                "circumference",
                "endAngle",
                "innerRadius",
                "outerRadius",
                "startAngle",
                "x",
                "y",
                "offset",
                "borderWidth",
                "spacing",
            ],
        },
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r",
});
__publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) =>
        name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash"),
});
__publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels(chart) {
                    const data = chart.data;
                    const {
                        labels: {
                            pointStyle,
                            textAlign,
                            color: color2,
                            useBorderRadius,
                            borderRadius,
                        },
                    } = chart.legend.options;
                    if (data.labels.length && data.datasets.length) {
                        return data.labels.map((label, i2) => {
                            const meta = chart.getDatasetMeta(0);
                            const style = meta.controller.getStyle(i2);
                            return {
                                text: label,
                                fillStyle: style.backgroundColor,
                                fontColor: color2,
                                hidden: !chart.getDataVisibility(i2),
                                lineDash: style.borderDash,
                                lineDashOffset: style.borderDashOffset,
                                lineJoin: style.borderJoinStyle,
                                lineWidth: style.borderWidth,
                                strokeStyle: style.borderColor,
                                textAlign,
                                pointStyle,
                                borderRadius:
                                    useBorderRadius && (borderRadius || style.borderRadius),
                                index: i2,
                            };
                        });
                    }
                    return [];
                },
            },
            onClick(e2, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
            },
        },
    },
});
var PieController = class extends DoughnutController {};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%",
});
function abstract() {
    throw new Error(
        "This method is not implemented: Check that a complete date adapter is provided.",
    );
}
var DateAdapterBase = class _DateAdapterBase {
    constructor(options) {
        __publicField(this, "options");
        this.options = options || {};
    }
    /**
     * Override default date adapter methods.
     * Accepts type parameter to define options type.
     * @example
     * Chart._adapters._date.override<{myAdapterOption: string}>({
     *   init() {
     *     console.log(this.options.myAdapterOption);
     *   }
     * })
     */
    static override(members) {
        Object.assign(_DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {}
    formats() {
        return abstract();
    }
    parse() {
        return abstract();
    }
    format() {
        return abstract();
    }
    add() {
        return abstract();
    }
    diff() {
        return abstract();
    }
    startOf() {
        return abstract();
    }
    endOf() {
        return abstract();
    }
};
var adapters = {
    _date: DateAdapterBase,
};
function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset
        ? metaset.dataset.options
            ? metaset.dataset.options.spanGaps
            : null
        : null;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
            const result = lookupMethod(data, axis, value);
            if (spanGaps) {
                const { vScale } = controller._cachedMeta;
                const { _parsed } = metaset;
                const distanceToDefinedLo = _parsed
                    .slice(0, result.lo + 1)
                    .reverse()
                    .findIndex((point) => !isNullOrUndef(point[vScale.axis]));
                result.lo -= Math.max(0, distanceToDefinedLo);
                const distanceToDefinedHi = _parsed
                    .slice(result.hi)
                    .findIndex((point) => !isNullOrUndef(point[vScale.axis]));
                result.hi += Math.max(0, distanceToDefinedHi);
            }
            return result;
        } else if (controller._sharedOptions) {
            const el = data[0];
            const range2 = typeof el.getRange === "function" && el.getRange(axis);
            if (range2) {
                const start = lookupMethod(data, axis, value - range2);
                const end = lookupMethod(data, axis, value + range2);
                return {
                    lo: start.lo,
                    hi: end.hi,
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1,
    };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        const { index, data } = metasets[i2];
        const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
        for (let j2 = lo; j2 <= hi; ++j2) {
            const element = data[j2];
            if (!element.skip) {
                handler(element, index, j2);
            }
        }
    }
}
function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function (pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
    }
    const evaluationFunc = function (element, datasetIndex, index) {
        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
            return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index,
            });
        }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle, endAngle } = element.getProps(
            ["startAngle", "endAngle"],
            useFinalPosition,
        );
        const { angle } = getAngleFromPoint(element, {
            x: position.x,
            y: position.y,
        });
        if (_angleBetween(angle, startAngle, endAngle)) {
            items.push({
                element,
                datasetIndex,
                index,
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestCartesianItems(
    chart,
    position,
    axis,
    intersect,
    useFinalPosition,
    includeInvisible,
) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange2) {
            return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange2) {
            return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index,
                },
            ];
            minDistance = distance;
        } else if (distance === minDistance) {
            items.push({
                element,
                datasetIndex,
                index,
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
    }
    return axis === "r" && !intersect
        ? getNearestRadialItems(chart, position, axis, useFinalPosition)
        : getNearestCartesianItems(
              chart,
              position,
              axis,
              intersect,
              useFinalPosition,
              includeInvisible,
          );
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index,
            });
            intersectsItem =
                intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) {
        return [];
    }
    return items;
}
var Interaction = {
    evaluateInteractionItems,
    modes: {
        index(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            const axis = options.axis || "x";
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect
                ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)
                : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
                return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) {
                    elements.push({
                        element,
                        datasetIndex: meta.index,
                        index,
                    });
                }
            });
            return elements;
        },
        dataset(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect
                ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)
                : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i2 = 0; i2 < data.length; ++i2) {
                    items.push({
                        element: data[i2],
                        datasetIndex,
                        index: i2,
                    });
                }
            }
            return items;
        },
        point(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
        nearest(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(
                chart,
                position,
                axis,
                options.intersect,
                useFinalPosition,
                includeInvisible,
            );
        },
        x(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
        },
        y(chart, e2, options, useFinalPosition) {
            const position = getRelativePosition(e2, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
        },
    },
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
    return array.filter((v2) => v2.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
function sortByWeight(array, reverse) {
    return array.sort((a2, b2) => {
        const v0 = reverse ? b2 : a2;
        const v1 = reverse ? a2 : b2;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i2, ilen, box, pos, stack, stackWeight;
    for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
        box = boxes[i2];
        ({
            position: pos,
            options: { stack, stackWeight = 1 },
        } = box);
        layoutBoxes.push({
            index: i2,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight,
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
        const { stack, pos, stackWeight } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
        }
        const _stack =
            stacks[stack] ||
            (stacks[stack] = {
                count: 0,
                placed: 0,
                weight: 0,
                size: 0,
            });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i2, ilen, layout;
    for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
        layout = layouts2[i2];
        const { fullSize } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(
        layoutBoxes.filter((wrap) => wrap.box.fullSize),
        true,
    );
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal),
    };
}
function getCombinedMax(maxPadding, chartArea, a2, b2) {
    return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b2], chartArea[b2]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
        if (layout.size) {
            chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1,
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(
        0,
        params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"),
    );
    const newHeight = Math.max(
        0,
        params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"),
    );
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal
        ? {
              same: widthChanged,
              other: heightChanged,
          }
        : {
              same: heightChanged,
              other: widthChanged,
          };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
        };
        positions2.forEach((pos) => {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal
        ? marginForPositions(["left", "right"])
        : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i2, ilen, layout, box, refit, changed;
    for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
        layout = boxes[i2];
        box = layout.box;
        box.update(
            layout.width || chartArea.w,
            layout.height || chartArea.h,
            getMargins(layout.horizontal, chartArea),
        );
        const { same, other } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
            refitBoxes.push(layout);
        }
    }
    return (refit && fitBoxes(refitBoxes, chartArea, params, stacks)) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x2, y: y2 } = chartArea;
    for (const layout of boxes) {
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1,
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (defined(stack.start)) {
                y2 = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(
                    box,
                    userPadding.left,
                    y2,
                    params.outerWidth - userPadding.right - userPadding.left,
                    height,
                );
            } else {
                setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
            }
            stack.start = y2;
            stack.placed += width;
            y2 = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (defined(stack.start)) {
                x2 = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(
                    box,
                    x2,
                    userPadding.top,
                    width,
                    params.outerHeight - userPadding.bottom - userPadding.top,
                );
            } else {
                setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
            }
            stack.start = x2;
            stack.placed += height;
            x2 = box.right;
        }
    }
    chartArea.x = x2;
    chartArea.y = y2;
}
var layouts = {
    addBox(chart, item) {
        if (!chart.boxes) {
            chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers =
            item._layers ||
            function () {
                return [
                    {
                        z: 0,
                        draw(chartArea) {
                            item.draw(chartArea);
                        },
                    },
                ];
            };
        chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
            chart.boxes.splice(index, 1);
        }
    },
    configure(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
        if (!chart) {
            return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, (box) => {
            if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
            }
        });
        const visibleVerticalBoxCount =
            verticalBoxes.reduce(
                (total, wrap) =>
                    wrap.box.options && wrap.box.options.display === false ? total : total + 1,
                0,
            ) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2,
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea = Object.assign(
            {
                maxPadding,
                w: availableWidth,
                h: availableHeight,
                x: padding.left,
                y: padding.top,
            },
            padding,
        );
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w,
        };
        each(boxes.chartArea, (layout) => {
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
            });
        });
    },
};
var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {}
    releaseContext(context) {
        return false;
    }
    addEventListener(chart, type, listener) {}
    removeEventListener(chart, type, listener) {}
    getDevicePixelRatio() {
        return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height),
        };
    }
    isAttached(canvas) {
        return true;
    }
    updateConfig(config) {}
};
var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
        return (item && item.getContext && item.getContext("2d")) || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout",
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width,
            },
        },
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, "width");
        if (displayWidth !== void 0) {
            canvas.width = displayWidth;
        }
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") {
            canvas.height = canvas.width / (aspectRatio || 2);
        } else {
            const displayHeight = readUsedSize(canvas, "height");
            if (displayHeight !== void 0) {
                canvas.height = displayHeight;
            }
        }
    }
    return canvas;
}
var eventListenerOptions = supportsEventListenerOptions
    ? {
          passive: true,
      }
    : false;
function addListener(node, type, listener) {
    if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
    }
}
function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x: x2, y: y2 } = getRelativePosition(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x2 !== void 0 ? x2 : null,
        y: y2 !== void 0 ? y2 : null,
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
        if (node === canvas || node.contains(canvas)) {
            return true;
        }
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true,
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true,
    });
    return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
        return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
        if (chart.currentDevicePixelRatio !== dpr) {
            resize();
        }
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
        window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
        window.removeEventListener("resize", onWindowResize);
    }
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
        return;
    }
    const resize = throttled((width, height) => {
        const w2 = container.clientWidth;
        listener(width, height);
        if (w2 < container.clientWidth) {
            listener();
        }
    }, window);
    const observer = new ResizeObserver((entries) => {
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
            return;
        }
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) {
        observer.disconnect();
    }
    if (type === "resize") {
        unlistenDevicePixelRatioChanges(chart);
    }
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
        if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
        }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext("2d");
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
    releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
            return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        ["height", "width"].forEach((prop) => {
            const value = initial[prop];
            if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
            } else {
                canvas.setAttribute(prop, value);
            }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key) => {
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
    addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver,
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
            return;
        }
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver,
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = void 0;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
        const container = canvas && _getParentNode(canvas);
        return !!(container && container.isConnected);
    }
};
function _detectPlatform(canvas) {
    if (
        !_isDomSupported() ||
        (typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas)
    ) {
        return BasicPlatform;
    }
    return DomPlatform;
}
var Element = class {
    constructor() {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "active", false);
        __publicField(this, "options");
        __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
        const { x: x2, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
        return {
            x: x2,
            y: y2,
        };
    }
    hasValue() {
        return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
            return this;
        }
        const ret = {};
        props.forEach((prop) => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i2, ilen;
        const avgMajorSpacing =
            numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(
            ticks,
            newTicks,
            spacing,
            isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing,
            first,
        );
        for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
            skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
        }
        skip(
            ticks,
            newTicks,
            spacing,
            last,
            isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing,
        );
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
        const factor = factors[i2];
        if (factor > spacing) {
            return factor;
        }
    }
    return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        if (ticks[i2].major) {
            result.push(i2);
        }
    }
    return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i2;
    spacing = Math.ceil(spacing);
    for (i2 = 0; i2 < ticks.length; i2++) {
        if (i2 === next) {
            newTicks.push(ticks[i2]);
            count++;
            next = majorIndices[count * spacing];
        }
    }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i2, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while (next < 0) {
        count++;
        next = Math.round(start + count * spacing);
    }
    for (i2 = Math.max(start, 0); i2 < end; i2++) {
        if (i2 === next) {
            newTicks.push(ticks[i2]);
            count++;
            next = Math.round(start + count * spacing);
        }
    }
}
function getEvenSpacing(arr) {
    const len = arr.length;
    let i2, diff;
    if (len < 2) {
        return false;
    }
    for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
        if (arr[i2] - arr[i2 - 1] !== diff) {
            return false;
        }
    }
    return diff;
}
var reverseAlign = (align) => (align === "left" ? "right" : align === "right" ? "left" : align);
var offsetFromEdge = (scale, edge, offset) =>
    edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) =>
    Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i2 = 0;
    for (; i2 < len; i2 += increment) {
        result.push(arr[Math.floor(i2)]);
    }
    return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
        if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
            offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
        }
        lineValue += validIndex2 < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
        }
    }
    return lineValue;
}
function garbageCollect(caches, length) {
    each(caches, (cache) => {
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i2;
        if (gcLen > length) {
            for (i2 = 0; i2 < gcLen; ++i2) {
                delete cache.data[gc[i2]];
            }
            gc.splice(0, gcLen);
        }
    });
}
function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
    if (!options.display) {
        return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return createContext(parent, {
        scale,
        type: "scale",
    });
}
function createTickContext(parent, index, tick) {
    return createContext(parent, {
        tick,
        index,
        type: "tick",
    });
}
function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if ((reverse && position !== "right") || (!reverse && position === "right")) {
        ret = reverseAlign(ret);
    }
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top, left, bottom, right, chart } = scale;
    const { chartArea, scales } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === "center") {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
            titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
    } else {
        if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === "center") {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
            titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = _alignStartEnd(align, bottom, top);
        rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation,
    };
}
var Scale = class _Scale extends Element {
    constructor(cfg) {
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = void 0;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
        };
        this.maxWidth = void 0;
        this.maxHeight = void 0;
        this.paddingTop = void 0;
        this.paddingBottom = void 0;
        this.paddingLeft = void 0;
        this.paddingRight = void 0;
        this.axis = void 0;
        this.labelRotation = void 0;
        this.min = void 0;
        this.max = void 0;
        this._range = void 0;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = void 0;
        this._endPixel = void 0;
        this._reversePixels = false;
        this._userMax = void 0;
        this._userMin = void 0;
        this._suggestedMax = void 0;
        this._suggestedMin = void 0;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = void 0;
    }
    init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index) {
        return raw;
    }
    getUserBounds() {
        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax),
        };
    }
    getMinMax(canStack) {
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        let range2;
        if (minDefined && maxDefined) {
            return {
                min,
                max,
            };
        }
        const metas = this.getMatchingVisibleMetas();
        for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            range2 = metas[i2].controller.getMinMax(this, canStack);
            if (!minDefined) {
                min = Math.min(min, range2.min);
            }
            if (!maxDefined) {
                max = Math.max(max, range2.max);
            }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max)),
        };
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0,
        };
    }
    getTicks() {
        return this.ticks;
    }
    getLabels() {
        const data = this.chart.data;
        return (
            this.options.labels ||
            (this.isHorizontal() ? data.xLabels : data.yLabels) ||
            data.labels ||
            []
        );
    }
    getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        callback(this.options.beforeUpdate, [this]);
    }
    update(maxWidth, maxHeight, margins) {
        const { beginAtZero, grace, ticks: tickOpts } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign(
            {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            },
            margins,
        );
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal()
            ? this.width + margins.left + margins.right
            : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = _addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
        }
        if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
    configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        callback(this.options.afterUpdate, [this]);
    }
    beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [this]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        callback(this.options.afterSetDimensions, [this]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        callback(this.options[name], [this]);
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [this]);
    }
    generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i2, ilen, tick;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
            tick = ticks[i2];
            tick.label = callback(tickOpts.callback, [tick.value, i2, ticks], this);
        }
    }
    afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [this]);
    }
    beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [this]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (
            !this._isVisible() ||
            !tickOpts.display ||
            minRotation >= maxRotation ||
            numTicks <= 1 ||
            !this.isHorizontal()
        ) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight =
                this.maxHeight -
                getTickMarkLength(options.grid) -
                tickOpts.padding -
                getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(
                maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight,
            );
            labelRotation = toDegrees(
                Math.min(
                    Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
                    Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) -
                        Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1)),
                ),
            );
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [this]);
    }
    afterAutoSkip() {}
    beforeFit() {
        callback(this.options.beforeFit, [this]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0,
        };
        const {
            chart,
            options: { ticks: tickOpts, title: titleOpts, grid: gridOpts },
        } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror
                        ? 0
                        : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(
                        this.maxHeight,
                        minSize.height + labelHeight + tickPadding,
                    );
                } else {
                    const labelWidth = tickOpts.mirror
                        ? 0
                        : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(
                        this.maxWidth,
                        minSize.width + labelWidth + tickPadding,
                    );
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const {
            ticks: { align, padding },
            position,
        } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === "start") {
                paddingRight = last.width;
            } else if (align === "end") {
                paddingLeft = first.width;
            } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max(
                ((paddingLeft - offsetLeft + padding) * this.width) / (this.width - offsetLeft),
                0,
            );
            this.paddingRight = Math.max(
                ((paddingRight - offsetRight + padding) * this.width) / (this.width - offsetRight),
                0,
            );
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
    _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        callback(this.options.afterFit, [this]);
    }
    isHorizontal() {
        const { axis, position } = this.options;
        return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
        return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i2, ilen;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
            if (isNullOrUndef(ticks[i2].label)) {
                ticks.splice(i2, 1);
                ilen--;
                i2--;
            }
        }
        this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(
                ticks,
                ticks.length,
                this.options.ticks.maxTicksLimit,
            );
        }
        return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx, _longestTextCache: caches } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i2,
            j2,
            jlen,
            label,
            tickFont,
            fontString,
            cache,
            lineHeight,
            width,
            height,
            nestedLabel;
        for (i2 = 0; i2 < length; i2 += increment) {
            label = ticks[i2].label;
            tickFont = this._resolveTickFontOptions(i2);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: [],
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if (isArray(label)) {
                for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
                    nestedLabel = label[j2];
                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                        height += lineHeight;
                    }
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx) => ({
            width: widths[idx] || 0,
            height: heights[idx] || 0,
        });
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights,
        };
    }
    getLabelForValue(value) {
        return value;
    }
    getPixelForValue(value, index) {
        return NaN;
    }
    getValueForPixel(pixel) {}
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
    getPixelForDecimal(decimal) {
        if (this._reversePixels) {
            decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
        const { min, max } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return (
                tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick))
            );
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
        const h6 = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal()
            ? h6 * cos > w2 * sin
                ? w2 / cos
                : h6 / sin
            : h6 * sin < w2 * cos
              ? h6 / cos
              : w2 / sin;
    }
    _isVisible() {
        const display = this.options.display;
        if (display !== "auto") {
            return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid, position, border } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function (pixel) {
            return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i2, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === "top") {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === "bottom") {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === "left") {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === "right") {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === "x") {
            if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(
                    this.chart.scales[positionAxisID].getPixelForValue(value),
                );
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === "y") {
            if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(
                    this.chart.scales[positionAxisID].getPixelForValue(value),
                );
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for (i2 = 0; i2 < ticksLength; i2 += step) {
            const context = this.getContext(i2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i2, offset);
            if (lineValue === void 0) {
                continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset,
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
    _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position, ticks: optionTicks } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align, crossAlign, padding, mirror } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i2,
            ilen,
            tick,
            label,
            x2,
            y2,
            textAlign,
            pixel,
            font,
            lineHeight,
            lineCount,
            textOffset;
        let textBaseline = "middle";
        if (position === "top") {
            y2 = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === "bottom") {
            y2 = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === "left") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x2 = ret.x;
        } else if (position === "right") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x2 = ret.x;
        } else if (axis === "x") {
            if (position === "center") {
                y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === "y") {
            if (position === "center") {
                x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === "y") {
            if (align === "start") {
                textBaseline = "top";
            } else if (align === "end") {
                textBaseline = "bottom";
            }
        }
        const labelSizes = this._getLabelSizes();
        for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
            tick = ticks[i2];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i2));
            pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i2);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color2 = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
                x2 = pixel;
                if (textAlign === "inner") {
                    if (i2 === ilen - 1) {
                        tickTextAlign = !this.options.reverse ? "right" : "left";
                    } else if (i2 === 0) {
                        tickTextAlign = !this.options.reverse ? "left" : "right";
                    } else {
                        tickTextAlign = "center";
                    }
                }
                if (position === "top") {
                    if (crossAlign === "near" || rotation !== 0) {
                        textOffset = -lineCount * lineHeight + lineHeight / 2;
                    } else if (crossAlign === "center") {
                        textOffset =
                            -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    } else {
                        textOffset = -labelSizes.highest.height + lineHeight / 2;
                    }
                } else {
                    if (crossAlign === "near" || rotation !== 0) {
                        textOffset = lineHeight / 2;
                    } else if (crossAlign === "center") {
                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    } else {
                        textOffset = labelSizes.highest.height - lineCount * lineHeight;
                    }
                }
                if (mirror) {
                    textOffset *= -1;
                }
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                    x2 += (lineHeight / 2) * Math.sin(rotation);
                }
            } else {
                y2 = pixel;
                textOffset = ((1 - lineCount) * lineHeight) / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i2];
                const width = labelSizes.widths[i2];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch (textBaseline) {
                    case "middle":
                        top -= height / 2;
                        break;
                    case "bottom":
                        top -= height;
                        break;
                }
                switch (textAlign) {
                    case "center":
                        left -= width / 2;
                        break;
                    case "right":
                        left -= width;
                        break;
                    case "inner":
                        if (i2 === ilen - 1) {
                            left -= width;
                        } else if (i2 > 0) {
                            left -= width / 2;
                        }
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor,
                };
            }
            items.push({
                label,
                font,
                textOffset,
                options: {
                    rotation,
                    color: color2,
                    strokeColor,
                    strokeWidth,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [x2, y2],
                    backdrop,
                },
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position, ticks } = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
            return position === "top" ? "left" : "right";
        }
        let align = "center";
        if (ticks.align === "start") {
            align = "left";
        } else if (ticks.align === "end") {
            align = "right";
        } else if (ticks.align === "inner") {
            align = "inner";
        }
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const {
            position,
            ticks: { crossAlign, mirror, padding },
        } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x2;
        if (position === "left") {
            if (mirror) {
                x2 = this.right + padding;
                if (crossAlign === "near") {
                    textAlign = "left";
                } else if (crossAlign === "center") {
                    textAlign = "center";
                    x2 += widest / 2;
                } else {
                    textAlign = "right";
                    x2 += widest;
                }
            } else {
                x2 = this.right - tickAndPadding;
                if (crossAlign === "near") {
                    textAlign = "right";
                } else if (crossAlign === "center") {
                    textAlign = "center";
                    x2 -= widest / 2;
                } else {
                    textAlign = "left";
                    x2 = this.left;
                }
            }
        } else if (position === "right") {
            if (mirror) {
                x2 = this.left + padding;
                if (crossAlign === "near") {
                    textAlign = "right";
                } else if (crossAlign === "center") {
                    textAlign = "center";
                    x2 -= widest / 2;
                } else {
                    textAlign = "left";
                    x2 -= widest;
                }
            } else {
                x2 = this.left + tickAndPadding;
                if (crossAlign === "near") {
                    textAlign = "left";
                } else if (crossAlign === "center") {
                    textAlign = "center";
                    x2 += widest / 2;
                } else {
                    textAlign = "right";
                    x2 = this.right;
                }
            }
        } else {
            textAlign = "right";
        }
        return {
            textAlign,
            x: x2,
        };
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror) {
            return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === "left" || position === "right") {
            return {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right,
            };
        }
        if (position === "top" || position === "bottom") {
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width,
            };
        }
    }
    drawBackground() {
        const {
            ctx,
            options: { backgroundColor },
            left,
            top,
            width,
            height,
        } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
            return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex((t3) => t3.value === value);
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
    drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items =
            this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i2, ilen;
        const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
                return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) {
            for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
                const item = items[i2];
                if (grid.drawOnChartArea) {
                    drawLine(
                        {
                            x: item.x1,
                            y: item.y1,
                        },
                        {
                            x: item.x2,
                            y: item.y2,
                        },
                        item,
                    );
                }
                if (grid.drawTicks) {
                    drawLine(
                        {
                            x: item.tx1,
                            y: item.ty1,
                        },
                        {
                            x: item.tx2,
                            y: item.ty2,
                        },
                        {
                            color: item.tickColor,
                            width: item.tickWidth,
                            borderDash: item.tickBorderDash,
                            borderDashOffset: item.tickBorderDashOffset,
                        },
                    );
                }
            }
        }
    }
    drawBorder() {
        const {
            chart,
            ctx,
            options: { border, grid },
        } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
            return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
    drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
            return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
            clipArea(ctx, area);
        }
        const items = this.getLabelItems(chartArea);
        for (const item of items) {
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y2 = item.textOffset;
            renderText(ctx, label, 0, y2, tickFont, renderTextOptions);
        }
        if (area) {
            unclipArea(ctx);
        }
    }
    drawTitle() {
        const {
            ctx,
            options: { position, title, reverse },
        } = this;
        if (!title.display) {
            return;
        }
        const font = toFont(title.font);
        const padding = toPadding(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === "bottom" || position === "center" || isObject(position)) {
            offset += padding.bottom;
            if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
            }
        } else {
            offset += padding.top;
        }
        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
        renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [titleX, titleY],
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) {
            return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
    _layers() {
        const opts = this.options;
        const tz = (opts.ticks && opts.ticks.z) || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        const bz = valueOrDefault(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
            return [
                {
                    z: tz,
                    draw: (chartArea) => {
                        this.draw(chartArea);
                    },
                },
            ];
        }
        return [
            {
                z: gz,
                draw: (chartArea) => {
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                },
            },
            {
                z: bz,
                draw: () => {
                    this.drawBorder();
                },
            },
            {
                z: tz,
                draw: (chartArea) => {
                    this.drawLabels(chartArea);
                },
            },
        ];
    }
    getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + "AxisID";
        const result = [];
        let i2, ilen;
        for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            const meta = metas[i2];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
            }
        }
        return result;
    }
    _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return toFont(opts.font);
    }
    _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
};
var TypedRegistry = class {
    constructor(type, scope, override) {
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + "." + id;
        if (!id) {
            throw new Error("class does not have id: " + item);
        }
        if (id in items) {
            return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
            defaults2.override(item.id, item.overrides);
        }
        return scope;
    }
    get(id) {
        return this.items[id];
    }
    unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
            delete items[id];
        }
        if (scope && id in defaults2[scope]) {
            delete defaults2[scope][id];
            if (this.override) {
                delete overrides[id];
            }
        }
    }
};
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
        parentScope ? defaults2.get(parentScope) : {},
        defaults2.get(scope),
        item.defaults,
    ]);
    defaults2.set(scope, itemDefaults);
    if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
        defaults2.describe(scope, item.descriptors);
    }
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
        const propertyParts = property.split(".");
        const sourceName = propertyParts.pop();
        const sourceScope = [scope].concat(propertyParts).join(".");
        const parts = routes[property].split(".");
        const targetName = parts.pop();
        const targetScope = parts.join(".");
        defaults2.route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
}
var Registry = class {
    constructor() {
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [this.controllers, this.scales, this.elements];
    }
    add(...args) {
        this._each("register", args);
    }
    remove(...args) {
        this._each("unregister", args);
    }
    addControllers(...args) {
        this._each("register", args, this.controllers);
    }
    addElements(...args) {
        this._each("register", args, this.elements);
    }
    addPlugins(...args) {
        this._each("register", args, this.plugins);
    }
    addScales(...args) {
        this._each("register", args, this.scales);
    }
    getController(id) {
        return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
        return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
        return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
        return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
        this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
        this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
        this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
        this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
        [...args].forEach((arg) => {
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {
                this._exec(method, reg, arg);
            } else {
                each(arg, (item) => {
                    const itemReg = typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item);
                });
            }
        });
    }
    _exec(method, registry2, component) {
        const camelMethod = _capitalize(method);
        callback(component["before" + camelMethod], [], component);
        registry2[method](component);
        callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
        for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
            const reg = this._typedRegistries[i2];
            if (reg.isForType(type)) {
                return reg;
            }
        }
        return this.plugins;
    }
    _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === void 0) {
            throw new Error('"' + id + '" is not a registered ' + type + ".");
        }
        return item;
    }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
    constructor() {
        this._init = void 0;
    }
    notify(chart, hook, args, filter2) {
        if (hook === "beforeInit") {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, "install");
        }
        if (this._init === void 0) {
            return;
        }
        const descriptors2 = filter2
            ? this._descriptors(chart).filter(filter2)
            : this._descriptors(chart);
        const result = this._notify(descriptors2, chart, hook, args);
        if (hook === "afterDestroy") {
            this._notify(descriptors2, chart, "stop");
            this._notify(this._init, chart, "uninstall");
            this._init = void 0;
        }
        return result;
    }
    _notify(descriptors2, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors2) {
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [chart, args, descriptor.options];
            if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
            }
        }
        return true;
    }
    invalidate() {
        if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = void 0;
        }
    }
    _descriptors(chart) {
        if (this._cache) {
            return this._cache;
        }
        const descriptors2 = (this._cache = this._createDescriptors(chart));
        this._notifyStateChanges(chart);
        return descriptors2;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = valueOrDefault(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
    }
    _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors2 = this._cache;
        const diff = (a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.plugin.id === y2.plugin.id));
        this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
        this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
};
function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i2 = 0; i2 < keys.length; i2++) {
        plugins.push(registry.getPlugin(keys[i2]));
    }
    const local = config.plugins || [];
    for (let i2 = 0; i2 < local.length; i2++) {
        const plugin = local[i2];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins,
        localIds,
    };
}
function getOpts(options, all) {
    if (!all && options === false) {
        return null;
    }
    if (options === true) {
        return {};
    }
    return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins) {
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
            continue;
        }
        result.push({
            plugin,
            options: pluginOpts(
                chart.config,
                {
                    plugin,
                    local: localIds[id],
                },
                opts,
                context,
            ),
        });
    }
    return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
        scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [""], {
        scriptable: false,
        indexable: false,
        allKeys: true,
    });
}
function getIndexAxis(type, options) {
    const datasetDefaults = defaults2.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
        axis = indexAxis;
    } else if (id === "_value_") {
        axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
        return id;
    }
}
function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
        return "x";
    }
    if (position === "left" || position === "right") {
        return "y";
    }
}
function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
        return id;
    }
    for (const opts of scaleOptions) {
        const axis =
            opts.axis ||
            axisFromPosition(opts.position) ||
            (id.length > 1 && idMatchesAxis(id[0].toLowerCase()));
        if (axis) {
            return axis;
        }
    }
    throw new Error(
        `Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`,
    );
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
        return {
            axis,
        };
    }
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
        if (boundDs.length) {
            return (
                getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0])
            );
        }
    }
    return {};
}
function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
        scales: {},
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
        const scaleConf = configScales[id];
        if (!isObject(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(
            id,
            scaleConf,
            retrieveAxisFromDatasets(id, config),
            defaults2.scales[scaleConf.type],
        );
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
            {
                axis,
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId],
        ]);
    });
    config.data.datasets.forEach((dataset) => {
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID) => {
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || axis;
            scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
            mergeIf(scales[id], [
                {
                    axis,
                },
                configScales[id],
                defaultScaleOptions[defaultID],
            ]);
        });
    });
    Object.keys(scales).forEach((key) => {
        const scale = scales[key];
        mergeIf(scale, [defaults2.scales[scale.type], defaults2.scale]);
    });
    return scales;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
        set2.add(opts);
    }
};
var Config = class {
    constructor(config) {
        this._config = initConfig(config);
        this._scopeCache = /* @__PURE__ */ new Map();
        this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, ""]]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, () => [
            [`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`],
            [`datasets.${datasetType}`, ""],
        ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, () => [
            [
                `datasets.${datasetType}.elements.${elementType}`,
                `datasets.${datasetType}`,
                `elements.${elementType}`,
                "",
            ],
        ]);
    }
    pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, () => [
            [`plugins.${id}`, ...(plugin.additionalOptionScopes || [])],
        ]);
    }
    _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = /* @__PURE__ */ new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
        const { options, type } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
            return cached;
        }
        const scopes = /* @__PURE__ */ new Set();
        keyLists.forEach((keys) => {
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key) => addIfFound(scopes, options, key));
            keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach((key) => addIfFound(scopes, defaults2, key));
            keys.forEach((key) => addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
            array.push(/* @__PURE__ */ Object.create(null));
        }
        if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
        }
        return array;
    }
    chartOptionScopes() {
        const { options, type } = this;
        return [
            options,
            overrides[type] || {},
            defaults2.datasets[type] || {},
            {
                type,
            },
            defaults2,
            descriptors,
        ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
        const result = {
            $shared: true,
        };
        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names2)) {
            result.$shared = false;
            context = isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names2) {
            result[prop] = options[prop];
        }
        return result;
    }
    createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
        return isObject(context)
            ? _attachContext(resolver, context, void 0, descriptorDefaults)
            : resolver;
    }
};
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = /* @__PURE__ */ new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover")),
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
var hasFunction = (value) =>
    isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (
            (scriptable && (isFunction(value) || hasFunction(value))) ||
            (indexable && isArray(value))
        ) {
            return true;
        }
    }
    return false;
}
var version = "4.5.1";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
    return (
        position === "top" ||
        position === "bottom" ||
        (KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x")
    );
}
function compare2Level(l1, l2) {
    return function (a2, b2) {
        return a2[l1] === b2[l1] ? a2[l2] - b2[l2] : a2[l1] - b2[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
        item = document.getElementById(item);
    } else if (item && item.length) {
        item = item[0];
    }
    if (item && item.canvas) {
        item = item.canvas;
    }
    return item;
}
var instances = {};
var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances)
        .filter((c2) => c2.canvas === canvas)
        .pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
            }
        }
    }
}
function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e2.type === "mouseout") {
        return null;
    }
    if (isClick) {
        return lastEvent;
    }
    return e2;
}
var Chart = class {
    static register(...items) {
        registry.add(...items);
        invalidatePlugins();
    }
    static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
    }
    constructor(item, userConfig) {
        const config = (this.config = new Config(userConfig));
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
            throw new Error(
                "Canvas is already in use. Chart with ID '" +
                    existingChart.id +
                    "' must be destroyed before the canvas with ID '" +
                    existingChart.canvas.id +
                    "' can be reused.",
            );
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = void 0;
        this.boxes = [];
        this.currentDevicePixelRatio = void 0;
        this.chartArea = void 0;
        this._active = [];
        this._lastEvent = void 0;
        this._listeners = {};
        this._responsiveListeners = void 0;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = void 0;
        this.$context = void 0;
        this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) {
            this.update();
        }
    }
    get aspectRatio() {
        const {
            options: { aspectRatio, maintainAspectRatio },
            width,
            height,
            _aspectRatio,
        } = this;
        if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
        }
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    get registry() {
        return registry;
    }
    _initialize() {
        this.notifyPlugins("beforeInit");
        if (this.options.responsive) {
            this.resize();
        } else {
            retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins("afterInit");
        return this;
    }
    clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
    resize(width, height) {
        if (!animator.running(this)) {
            this._resize(width, height);
        } else {
            this._resizeBeforeDraw = {
                width,
                height,
            };
        }
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? "resize" : "attach";
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
            return;
        }
        this.notifyPlugins("resize", {
            size: newSize,
        });
        callback(options.onResize, [this, newSize], this);
        if (this.attached) {
            if (this._doResize(mode)) {
                this.render();
            }
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
        });
    }
    buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id) => {
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
            items = items.concat(
                Object.keys(scaleOpts).map((id) => {
                    const scaleOptions = scaleOpts[id];
                    const axis = determineAxis(id, scaleOptions);
                    const isRadial = axis === "r";
                    const isHorizontal = axis === "x";
                    return {
                        options: scaleOptions,
                        dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                        dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear",
                    };
                }),
            );
        }
        each(items, (item) => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (
                scaleOptions.position === void 0 ||
                positionIsHorizontal(scaleOptions.position, axis) !==
                    positionIsHorizontal(item.dposition)
            ) {
                scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
                scale = scales[id];
            } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this,
                });
                scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
                delete scales[id];
            }
        });
        each(scales, (scale) => {
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
    _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a2, b2) => a2.index - b2.index);
        if (numMeta > numData) {
            for (let i2 = numData; i2 < numMeta; ++i2) {
                this._destroyDatasetMeta(i2);
            }
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
        const {
            _metasets: metasets,
            data: { datasets },
        } = this;
        if (metasets.length > datasets.length) {
            delete this._stacks;
        }
        metasets.forEach((meta, index) => {
            if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index);
            }
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i2, ilen;
        this._removeUnreferencedMetasets();
        for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
            const dataset = datasets[i2];
            let meta = this.getDatasetMeta(i2);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i2);
                meta = this.getDatasetMeta(i2);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i2;
            meta.label = "" + dataset.label;
            meta.visible = this.isDatasetVisible(i2);
            if (meta.controller) {
                meta.controller.updateIndex(i2);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults2.datasets[type];
                Object.assign(ControllerClass, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType:
                        datasetElementType && registry.getElement(datasetElementType),
                });
                meta.controller = new ControllerClass(this, i2);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
    _resetElements() {
        each(
            this.data.datasets,
            (dataset, datasetIndex) => {
                this.getDatasetMeta(datasetIndex).controller.reset();
            },
            this,
        );
    }
    reset() {
        this._resetElements();
        this.notifyPlugins("reset");
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = (this._options = config.createResolver(
            config.chartOptionScopes(),
            this.getContext(),
        ));
        const animsDisabled = (this._animationsDisabled = !options.animation);
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (
            this.notifyPlugins("beforeUpdate", {
                mode,
                cancelable: true,
            }) === false
        ) {
            return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let minPadding = 0;
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
            const { controller } = this.getDatasetMeta(i2);
            const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset2);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
            each(newControllers, (controller) => {
                controller.reset();
            });
        }
        this._updateDatasets(mode);
        this.notifyPlugins("afterUpdate", {
            mode,
        });
        this._layers.sort(compare2Level("z", "_idx"));
        const { _active, _lastEvent } = this;
        if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
        }
        this.render();
    }
    _updateScales() {
        each(this.scales, (scale) => {
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
    _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (
            !setsEqual(existingEvents, newEvents) ||
            !!this._responsiveListeners !== options.responsive
        ) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
    _updateHiddenIndices() {
        const { _hiddenIndices } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method, start, count } of changes) {
            const move = method === "_removeElements" ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
    _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
            return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx) =>
            new Set(
                _dataChanges
                    .filter((c2) => c2[0] === idx)
                    .map((c2, i2) => i2 + "," + c2.splice(1).join(",")),
            );
        const changeSet = makeSet(0);
        for (let i2 = 1; i2 < datasetCount; i2++) {
            if (!setsEqual(changeSet, makeSet(i2))) {
                return;
            }
        }
        return Array.from(changeSet)
            .map((c2) => c2.split(","))
            .map((a2) => ({
                method: a2[1],
                start: +a2[2],
                count: +a2[3],
            }));
    }
    _updateLayout(minPadding) {
        if (
            this.notifyPlugins("beforeLayout", {
                cancelable: true,
            }) === false
        ) {
            return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(
            this.boxes,
            (box) => {
                if (noArea && box.position === "chartArea") {
                    return;
                }
                if (box.configure) {
                    box.configure();
                }
                this._layers.push(...box._layers());
            },
            this,
        );
        this._layers.forEach((item, index) => {
            item._idx = index;
        });
        this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
        if (
            this.notifyPlugins("beforeDatasetsUpdate", {
                mode,
                cancelable: true,
            }) === false
        ) {
            return;
        }
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this.getDatasetMeta(i2).controller.configure();
        }
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this._updateDataset(
                i2,
                isFunction(mode)
                    ? mode({
                          datasetIndex: i2,
                      })
                    : mode,
            );
        }
        this.notifyPlugins("afterDatasetsUpdate", {
            mode,
        });
    }
    _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true,
        };
        if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
        if (
            this.notifyPlugins("beforeRender", {
                cancelable: true,
            }) === false
        ) {
            return;
        }
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
                animator.start(this);
            }
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this,
            });
        }
    }
    draw() {
        let i2;
        if (this._resizeBeforeDraw) {
            const { width, height } = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null;
            this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
            return;
        }
        if (
            this.notifyPlugins("beforeDraw", {
                cancelable: true,
            }) === false
        ) {
            return;
        }
        const layers = this._layers;
        for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
            layers[i2].draw(this.chartArea);
        }
        this._drawDatasets();
        for (; i2 < layers.length; ++i2) {
            layers[i2].draw(this.chartArea);
        }
        this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i2, ilen;
        for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
            const meta = metasets[i2];
            if (!filterVisible || meta.visible) {
                result.push(meta);
            }
        }
        return result;
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
        if (
            this.notifyPlugins("beforeDatasetsDraw", {
                cancelable: true,
            }) === false
        ) {
            return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
            this._drawDataset(metasets[i2]);
        }
        this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
        const ctx = this.ctx;
        const args = {
            meta,
            index: meta.index,
            cancelable: true,
        };
        const clip = getDatasetClipArea(this, meta);
        if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
        }
        if (clip) {
            clipArea(ctx, clip);
        }
        meta.controller.draw();
        if (clip) {
            unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
        return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === "function") {
            return method(this, e2, options, useFinalPosition);
        }
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: (dataset && dataset.order) || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false,
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return (
            this.$context ||
            (this.$context = createContext(null, {
                chart: this,
                type: "chart",
            }))
        );
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
            return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? "show" : "hide";
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(void 0, mode);
        if (defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible,
            });
            this.update((ctx) => (ctx.datasetIndex === datasetIndex ? mode : void 0));
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
            meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i2, ilen;
        this.stop();
        animator.remove(this);
        for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this._destroyDatasetMeta(i2);
        }
    }
    destroy() {
        this.notifyPlugins("beforeDestroy");
        const { canvas, ctx } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
    bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
            this.bindResponsiveEvents();
        } else {
            this.attached = true;
        }
    }
    bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
        };
        const listener = (e2, x2, y2) => {
            e2.offsetX = x2;
            e2.offsetY = y2;
            this._eventHandler(e2);
        };
        each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
        if (!this._responsiveListeners) {
            this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
        };
        const _remove = (type, listener2) => {
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
            }
        };
        const listener = (width, height) => {
            if (this.canvas) {
                this.resize(width, height);
            }
        };
        let detached;
        const attached = () => {
            _remove("attach", attached);
            this.attached = true;
            this.resize();
            _add("resize", listener);
            _add("detach", detached);
        };
        detached = () => {
            this.attached = false;
            _remove("resize", listener);
            this._stop();
            this._resize(0, 0);
            _add("attach", attached);
        };
        if (platform.isAttached(this.canvas)) {
            attached();
        } else {
            detached();
        }
    }
    unbindEvents() {
        each(this._listeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? "set" : "remove";
        let meta, item, i2, ilen;
        if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix + "DatasetHoverStyle"]();
        }
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            item = items[i2];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex, index }) => {
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index,
            };
        });
        const changed = !_elementsEqual(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
    notifyPlugins(hook, args, filter2) {
        return this._plugins.notify(this, hook, args, filter2);
    }
    isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a2, b2) =>
            a2.filter(
                (x2) =>
                    !b2.some((y2) => x2.datasetIndex === y2.datasetIndex && x2.index === y2.index),
            );
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
    }
    _eventHandler(e2, replay) {
        const args = {
            event: e2,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e2),
        };
        const eventFilter = (plugin) =>
            (plugin.options.events || this.options.events).includes(e2.native.type);
        if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
        }
        const changed = this._handleEvent(e2, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins("afterEvent", args, eventFilter);
        if (changed || args.changed) {
            this.render();
        }
        return this;
    }
    _handleEvent(e2, replay, inChartArea) {
        const { _active: lastActive = [], options } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
        const isClick = _isClickEvent(e2);
        const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            callback(options.onHover, [e2, active, this], this);
            if (isClick) {
                callback(options.onClick, [e2, active, this], this);
            }
        }
        const changed = !_elementsEqual(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
    _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
        if (e2.type === "mouseout") {
            return [];
        }
        if (!inChartArea) {
            return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(
            e2,
            hoverOptions.mode,
            hoverOptions,
            useFinalPosition,
        );
    }
};
__publicField(Chart, "defaults", defaults2);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipSelf(ctx, element, endAngle) {
    const { startAngle, x: x2, y: y2, outerRadius, innerRadius, options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const outerAngleClip = Math.min(
        borderWidth / outerRadius,
        _normalizeAngle(startAngle - endAngle),
    );
    ctx.beginPath();
    ctx.arc(
        x2,
        y2,
        outerRadius - borderWidth / 2,
        startAngle + outerAngleClip / 2,
        endAngle - outerAngleClip / 2,
    );
    if (innerRadius > 0) {
        const innerAngleClip = Math.min(
            borderWidth / innerRadius,
            _normalizeAngle(startAngle - endAngle),
        );
        ctx.arc(
            x2,
            y2,
            innerRadius + borderWidth / 2,
            endAngle - innerAngleClip / 2,
            startAngle + innerAngleClip / 2,
            true,
        );
    } else {
        const clipWidth = Math.min(
            borderWidth / 2,
            outerRadius * _normalizeAngle(startAngle - endAngle),
        );
        if (borderJoinStyle === "round") {
            ctx.arc(x2, y2, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);
        } else if (borderJoinStyle === "bevel") {
            const r2 = 2 * clipWidth * clipWidth;
            const endX = -r2 * Math.cos(endAngle + PI / 2) + x2;
            const endY = -r2 * Math.sin(endAngle + PI / 2) + y2;
            const startX = r2 * Math.cos(startAngle + PI / 2) + x2;
            const startY = r2 * Math.sin(startAngle + PI / 2) + y2;
            ctx.lineTo(endX, endY);
            ctx.lineTo(startX, startY);
        }
    }
    ctx.closePath();
    ctx.moveTo(0, 0);
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clip("evenodd");
}
function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x: x2, y: y2, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x2, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x2, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
        ctx.arc(x2, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o2 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, (angleDelta * innerRadius) / 2);
    const computeOuterLimit = (val) => {
        const outerArcLimit = ((outerRadius - Math.min(halfThickness, val)) * angleDelta) / 2;
        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o2.outerStart),
        outerEnd: computeOuterLimit(o2.outerEnd),
        innerStart: _limitValue(o2.innerStart, 0, innerLimit),
        innerEnd: _limitValue(o2.innerEnd, 0, innerLimit),
    };
}
function rThetaToXY(r2, theta, x2, y2) {
    return {
        x: x2 + r2 * Math.cos(theta),
        y: y2 + r2 * Math.sin(theta),
    };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x: x2, y: y2, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle =
            avNogSpacingRadius !== 0
                ? (alpha2 * avNogSpacingRadius) / (avNogSpacingRadius + spacing)
                : alpha2;
        spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(
        element,
        innerRadius,
        outerRadius,
        endAngle - startAngle,
    );
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x2, y2, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x2, y2, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y2);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
        }
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y2);
        ctx.lineTo(p4.x, p4.y);
        if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y2);
            ctx.arc(
                pCenter.x,
                pCenter.y,
                innerEnd,
                endAngle + HALF_PI,
                innerEndAdjustedAngle + Math.PI,
            );
        }
        const innerMidAdjustedAngle =
            (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(
            x2,
            y2,
            innerRadius,
            endAngle - innerEnd / innerRadius,
            innerMidAdjustedAngle,
            true,
        );
        ctx.arc(
            x2,
            y2,
            innerRadius,
            innerMidAdjustedAngle,
            startAngle + innerStart / innerRadius,
            true,
        );
        if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y2);
            ctx.arc(
                pCenter.x,
                pCenter.y,
                innerStart,
                innerStartAdjustedAngle + Math.PI,
                startAngle - HALF_PI,
            );
        }
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y2);
        ctx.lineTo(p8.x, p8.y);
        if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y2);
            ctx.arc(
                pCenter.x,
                pCenter.y,
                outerStart,
                startAngle - HALF_PI,
                outerStartAdjustedAngle,
            );
        }
    } else {
        ctx.moveTo(x2, y2);
        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
        ctx.lineTo(outerStartX, outerStartY);
        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for (let i2 = 0; i2 < fullCircles; ++i2) {
            ctx.fill();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % TAU || TAU);
        }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
        return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || "round";
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for (let i2 = 0; i2 < fullCircles; ++i2) {
            ctx.stroke();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % TAU || TAU);
        }
    }
    if (inner) {
        clipArc(ctx, element, endAngle);
    }
    if (
        options.selfJoin &&
        endAngle - startAngle >= PI &&
        borderRadius === 0 &&
        borderJoinStyle !== "miter"
    ) {
        clipSelf(ctx, element, endAngle);
    }
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
var ArcElement = class extends Element {
    constructor(cfg) {
        super();
        __publicField(this, "circumference");
        __publicField(this, "endAngle");
        __publicField(this, "fullCircles");
        __publicField(this, "innerRadius");
        __publicField(this, "outerRadius");
        __publicField(this, "pixelMargin");
        __publicField(this, "startAngle");
        this.options = void 0;
        this.circumference = void 0;
        this.startAngle = void 0;
        this.endAngle = void 0;
        this.innerRadius = void 0;
        this.outerRadius = void 0;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps(["x", "y"], useFinalPosition);
        const { angle, distance } = getAngleFromPoint(point, {
            x: chartX,
            y: chartY,
        });
        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps(
            ["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"],
            useFinalPosition,
        );
        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
        const _circumference = valueOrDefault(circumference, endAngle - startAngle);
        const nonZeroBetween =
            _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
        const betweenAngles = _circumference >= TAU || nonZeroBetween;
        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const {
            x: x2,
            y: y2,
            startAngle,
            endAngle,
            innerRadius,
            outerRadius,
        } = this.getProps(
            ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"],
            useFinalPosition,
        );
        const { offset, spacing } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x2 + Math.cos(halfAngle) * halfRadius,
            y: y2 + Math.sin(halfAngle) * halfRadius,
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options, circumference } = this;
        const offset = (options.offset || 0) / 4;
        const spacing = (options.spacing || 0) / 2;
        const circular = options.circular;
        this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
        }
        ctx.save();
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
        const radiusOffset = offset * fix;
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        drawArc(ctx, this, radiusOffset, spacing, circular);
        drawBorder(ctx, this, radiusOffset, spacing, circular);
        ctx.restore();
    }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true,
    selfJoin: false,
});
__publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
});
__publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash",
});
function getBarBounds(bar, useFinalPosition) {
    const {
        x: x2,
        y: y2,
        base,
        width,
        height,
    } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x2, base);
        right = Math.max(x2, base);
        top = y2 - half;
        bottom = y2 + half;
    } else {
        half = width / 2;
        left = x2 - half;
        right = x2 + half;
        top = Math.min(y2, base);
        bottom = Math.max(y2, base);
    }
    return {
        left,
        top,
        right,
        bottom,
    };
}
function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o2 = toTRBL(value);
    return {
        t: skipOrLimit(skip2.top, o2.top, 0, maxH),
        r: skipOrLimit(skip2.right, o2.right, 0, maxW),
        b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
        l: skipOrLimit(skip2.left, o2.left, 0, maxW),
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
    const value = bar.options.borderRadius;
    const o2 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
        bottomLeft: skipOrLimit(
            !enableBorder || skip2.bottom || skip2.left,
            o2.bottomLeft,
            0,
            maxR,
        ),
        bottomRight: skipOrLimit(
            !enableBorder || skip2.bottom || skip2.right,
            o2.bottomRight,
            0,
            maxR,
        ),
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius,
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
            },
        },
    };
}
function inRange(bar, x2, y2, useFinalPosition) {
    const skipX = x2 === null;
    const skipY = y2 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return (
        bounds &&
        (skipX || _isBetween(x2, bounds.left, bounds.right)) &&
        (skipY || _isBetween(y2, bounds.top, bounds.bottom))
    );
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x2 = rect.x !== refRect.x ? -amount : 0;
    const y2 = rect.y !== refRect.y ? -amount : 0;
    const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
    const h6 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
    return {
        x: rect.x + x2,
        y: rect.y + y2,
        w: rect.w + w2,
        h: rect.h + h6,
        radius: rect.radius,
    };
}
var BarElement = class extends Element {
    constructor(cfg) {
        super();
        this.options = void 0;
        this.horizontal = void 0;
        this.base = void 0;
        this.width = void 0;
        this.height = void 0;
        this.inflateAmount = void 0;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    draw(ctx) {
        const {
            inflateAmount,
            options: { borderColor, backgroundColor },
        } = this;
        const { inner, outer } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill("evenodd");
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const {
            x: x2,
            y: y2,
            base,
            horizontal,
        } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
        return {
            x: horizontal ? (x2 + base) / 2 : x2,
            y: horizontal ? y2 : (y2 + base) / 2,
        };
    }
    getRange(axis) {
        return axis === "x" ? this.width / 2 : this.height / 2;
    }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0,
});
__publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor",
});
var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight),
    };
};
var itemsEqual = (a2, b2) =>
    a2 !== null && b2 !== null && a2.datasetIndex === b2.datasetIndex && a2.index === b2.index;
var Legend = class extends Element {
    constructor(config) {
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = void 0;
        this.columnSizes = void 0;
        this.lineWidths = void 0;
        this.maxHeight = void 0;
        this.maxWidth = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.height = void 0;
        this.width = void 0;
        this._margins = void 0;
        this.position = void 0;
        this.weight = void 0;
        this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
        if (labelOpts.filter) {
            legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
            legendItems = legendItems.sort((a2, b2) => labelOpts.sort(a2, b2, this.chart.data));
        }
        if (this.options.reverse) {
            legendItems.reverse();
        }
        this.legendItems = legendItems;
    }
    fit() {
        const { options, ctx } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const {
            ctx,
            maxWidth,
            options: {
                labels: { padding },
            },
        } = this;
        const hitboxes = (this.legendHitBoxes = []);
        const lineWidths = (this.lineWidths = [0]);
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i2) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (
                i2 === 0 ||
                lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth
            ) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i2] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight,
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const {
            ctx,
            maxHeight,
            options: {
                labels: { padding },
            },
        } = this;
        const hitboxes = (this.legendHitBoxes = []);
        const columnSizes = (this.columnSizes = []);
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i2) => {
            const { itemWidth, itemHeight } = calculateItemSize(
                boxWidth,
                labelFont,
                ctx,
                legendItem,
                _itemHeight,
            );
            if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight,
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i2] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight,
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight,
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) {
            return;
        }
        const titleHeight = this._computeTitleHeight();
        const {
            legendHitBoxes: hitboxes,
            options: {
                align,
                labels: { padding },
                rtl,
            },
        } = this;
        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(
                align,
                this.left + padding,
                this.right - this.lineWidths[row],
            );
            for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = _alignStartEnd(
                        align,
                        this.left + padding,
                        this.right - this.lineWidths[row],
                    );
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = _alignStartEnd(
                align,
                this.top + titleHeight + padding,
                this.bottom - this.columnSizes[col].height,
            );
            for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = _alignStartEnd(
                        align,
                        this.top + titleHeight + padding,
                        this.bottom - this.columnSizes[col].height,
                    );
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            clipArea(ctx, this);
            this._draw();
            unclipArea(ctx);
        }
    }
    _draw() {
        const { options: opts, columnSizes, lineWidths, ctx } = this;
        const { align, labels: labelOpts } = opts;
        const defaultColor = defaults2.color;
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = toFont(labelOpts.font);
        const { padding } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign("left");
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function (x2, y2, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: (boxHeight * Math.SQRT2) / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth,
                };
                const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
                const centerY = y2 + halfFontSize;
                drawPointLegend(
                    ctx,
                    drawOptions,
                    centerX,
                    centerY,
                    labelOpts.pointStyleWidth && boxWidth,
                );
            } else {
                const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
                    addRoundedRectPath(ctx, {
                        x: xBoxLeft,
                        y: yBoxTop,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius,
                    });
                } else {
                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                    ctx.stroke();
                }
            }
            ctx.restore();
        };
        const fillText = function (x2, y2, legendItem) {
            renderText(ctx, legendItem.text, x2, y2 + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign),
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
            cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0,
            };
        } else {
            cursor = {
                x: this.left + padding,
                y: _alignStartEnd(
                    align,
                    this.top + titleHeight + padding,
                    this.bottom - columnSizes[0].height,
                ),
                line: 0,
            };
        }
        overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i2) => {
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(
                legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign),
            );
            const width = boxWidth + halfFontSize + textWidth;
            let x2 = cursor.x;
            let y2 = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i2 > 0 && x2 + width + padding > this.right) {
                    y2 = cursor.y += lineHeight;
                    cursor.line++;
                    x2 = cursor.x = _alignStartEnd(
                        align,
                        this.left + padding,
                        this.right - lineWidths[cursor.line],
                    );
                }
            } else if (i2 > 0 && y2 + lineHeight > this.bottom) {
                x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y2 = cursor.y = _alignStartEnd(
                    align,
                    this.top + titleHeight + padding,
                    this.bottom - columnSizes[cursor.line].height,
                );
            }
            const realX = rtlHelper.x(x2);
            drawLegendBox(realX, y2, legendItem);
            x2 = _textX(
                textAlign,
                x2 + boxWidth + halfFontSize,
                isHorizontal ? x2 + width : this.right,
                opts.rtl,
            );
            fillText(rtlHelper.x(x2), y2, legendItem);
            if (isHorizontal) {
                cursor.x += width + padding;
            } else if (typeof legendItem.text !== "string") {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
            } else {
                cursor.y += lineHeight;
            }
        });
        restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        if (!titleOpts.display) {
            return;
        }
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y2;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y2 = this.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y2 =
                topPaddingPlusHalfFontSize +
                _alignStartEnd(
                    opts.align,
                    this.top,
                    this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight(),
                );
        }
        const x2 = _alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
        ctx.textBaseline = "middle";
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        renderText(ctx, titleOpts.text, x2, y2, titleFont);
    }
    _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x2, y2) {
        let i2, hitBox, lh;
        if (_isBetween(x2, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for (i2 = 0; i2 < lh.length; ++i2) {
                hitBox = lh[i2];
                if (
                    _isBetween(x2, hitBox.left, hitBox.left + hitBox.width) &&
                    _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)
                ) {
                    return this.legendItems[i2];
                }
            }
        }
        return null;
    }
    handleEvent(e2) {
        const opts = this.options;
        if (!isListened(e2.type, opts)) {
            return;
        }
        const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
        if (e2.type === "mousemove" || e2.type === "mouseout") {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
                callback(opts.onLeave, [e2, previous, this], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e2, hoveredItem, this], this);
            }
        } else if (hoveredItem) {
            callback(opts.onClick, [e2, hoveredItem, this], this);
        }
    }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth,
        itemHeight,
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
        legendItemText = legendItemText.reduce((a2, b2) => (a2.length > b2.length ? a2 : b2));
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
        return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
        return true;
    }
    return false;
}
var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
        const legend = (chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart,
        }));
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop(chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate(chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
        if (!args.replay) {
            chart.legend.handleEvent(args.event);
        }
    },
    defaults: {
        display: true,
        position: "top",
        align: "center",
        fullSize: true,
        reverse: false,
        weight: 1e3,
        onClick(e2, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
                const datasets = chart.data.datasets;
                const {
                    labels: {
                        usePointStyle,
                        pointStyle,
                        textAlign,
                        color: color2,
                        useBorderRadius,
                        borderRadius,
                    },
                } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta) => {
                    const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                    const borderWidth = toPadding(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color2,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index,
                    };
                }, this);
            },
        },
        title: {
            color: (ctx) => ctx.chart.options.color,
            display: false,
            position: "center",
            text: "",
        },
    },
    descriptors: {
        _scriptable: (name) => !name.startsWith("on"),
        labels: {
            _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name),
        },
    },
};
var Title = class extends Element {
    constructor(config) {
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this.position = void 0;
        this.weight = void 0;
        this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = isArray(opts.text) ? opts.text.length : 1;
        this._padding = toPadding(opts.padding);
        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
            this.height = textSize;
        } else {
            this.width = textSize;
        }
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
        const { top, left, bottom, right, options } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
            } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation,
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
            return;
        }
        const fontOpts = toFont(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
        renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [titleX, titleY],
        });
    }
};
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart,
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
        createTitle(chart, options);
    },
    stop(chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "bold",
        },
        fullSize: true,
        padding: 10,
        position: "top",
        text: "",
        weight: 2e3,
    },
    defaultRoutes: {
        color: "color",
    },
    descriptors: {
        _scriptable: true,
        _indexable: false,
    },
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart,
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map2.set(chart, title);
    },
    stop(chart) {
        layouts.removeBox(chart, map2.get(chart));
        map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
        const title = map2.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "normal",
        },
        fullSize: true,
        padding: 0,
        position: "top",
        text: "",
        weight: 1500,
    },
    defaultRoutes: {
        color: "color",
    },
    descriptors: {
        _scriptable: true,
        _indexable: false,
    },
};
var positioners = {
    average(items) {
        if (!items.length) {
            return false;
        }
        let i2, len;
        let xSet = /* @__PURE__ */ new Set();
        let y2 = 0;
        let count = 0;
        for (i2 = 0, len = items.length; i2 < len; ++i2) {
            const el = items[i2].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                xSet.add(pos.x);
                y2 += pos.y;
                ++count;
            }
        }
        if (count === 0 || xSet.size === 0) {
            return false;
        }
        const xAverage = [...xSet].reduce((a2, b2) => a2 + b2) / xSet.size;
        return {
            x: xAverage,
            y: y2 / count,
        };
    },
    nearest(items, eventPosition) {
        if (!items.length) {
            return false;
        }
        let x2 = eventPosition.x;
        let y2 = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i2, len, nearestElement;
        for (i2 = 0, len = items.length; i2 < len; ++i2) {
            const el = items[i2].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d2 = distanceBetweenPoints(eventPosition, center);
                if (d2 < minDistance) {
                    minDistance = d2;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x2 = tp.x;
            y2 = tp.y;
        }
        return {
            x: x2,
            y: y2,
        };
    },
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if (isArray(toPush)) {
            Array.prototype.push.apply(base, toPush);
        } else {
            base.push(toPush);
        }
    }
    return base;
}
function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
        return str.split("\n");
    }
    return str;
}
function createTooltipItem(chart, item) {
    const { element, datasetIndex, index } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element,
    };
}
function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce(
        (count, bodyItem) =>
            count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length,
        0,
    );
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
        height +=
            titleLineCount * titleFont.lineHeight +
            (titleLineCount - 1) * options.titleSpacing +
            options.titleMarginBottom;
    }
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors
            ? Math.max(boxHeight, bodyFont.lineHeight)
            : bodyFont.lineHeight;
        height +=
            bodyLineItemCount * bodyLineHeight +
            (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight +
            (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
        height +=
            options.footerMarginTop +
            footerLineCount * footerFont.lineHeight +
            (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height,
    };
}
function determineYAlign(chart, size) {
    const { y: y2, height } = size;
    if (y2 < height / 2) {
        return "top";
    } else if (y2 > chart.height - height / 2) {
        return "bottom";
    }
    return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x: x2, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x2 + width + caret > chart.width) {
        return true;
    }
    if (xAlign === "right" && x2 - width - caret < 0) {
        return true;
    }
}
function determineXAlign(chart, options, size, yAlign) {
    const { x: x2, width } = size;
    const {
        width: chartWidth,
        chartArea: { left, right },
    } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
        xAlign = x2 <= (left + right) / 2 ? "left" : "right";
    } else if (x2 <= width / 2) {
        xAlign = "left";
    } else if (x2 >= chartWidth - width / 2) {
        xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = "center";
    }
    return xAlign;
}
function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign,
    };
}
function alignX(size, xAlign) {
    let { x: x2, width } = size;
    if (xAlign === "right") {
        x2 -= width;
    } else if (xAlign === "center") {
        x2 -= width / 2;
    }
    return x2;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y: y2, height } = size;
    if (yAlign === "top") {
        y2 += paddingAndSize;
    } else if (yAlign === "bottom") {
        y2 -= height + paddingAndSize;
    } else {
        y2 -= height / 2;
    }
    return y2;
}
function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x2 = alignX(size, xAlign);
    const y2 = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
        if (xAlign === "left") {
            x2 += paddingAndSize;
        } else if (xAlign === "right") {
            x2 -= paddingAndSize;
        }
    } else if (xAlign === "left") {
        x2 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
        x2 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
        x: _limitValue(x2, 0, chart.width - size.width),
        y: _limitValue(y2, 0, chart.height - size.height),
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center"
        ? tooltip.x + tooltip.width / 2
        : align === "right"
          ? tooltip.x + tooltip.width - padding.right
          : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
        tooltip,
        tooltipItems,
        type: "tooltip",
    });
}
function overrideCallbacks(callbacks, context) {
    const override =
        context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
    beforeTitle: noop,
    title(tooltipItems) {
        if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") {
                return item.dataset.label || "";
            } else if (item.label) {
                return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
            }
        }
        return "";
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
            return (
                tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue
            );
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
            label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
            label += value;
        }
        return label;
    },
    labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0,
        };
    },
    labelTextColor() {
        return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation,
        };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop,
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
        return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
}
var Tooltip = class extends Element {
    constructor(config) {
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = void 0;
        this._size = void 0;
        this._cachedAnimations = void 0;
        this._tooltipItems = [];
        this.$animations = void 0;
        this.$context = void 0;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = void 0;
        this.title = void 0;
        this.beforeBody = void 0;
        this.body = void 0;
        this.afterBody = void 0;
        this.footer = void 0;
        this.xAlign = void 0;
        this.yAlign = void 0;
        this.x = void 0;
        this.y = void 0;
        this.height = void 0;
        this.width = void 0;
        this.caretX = void 0;
        this.caretY = void 0;
        this.labelColors = void 0;
        this.labelPointStyles = void 0;
        this.labelTextColors = void 0;
    }
    initialize(options) {
        this.options = options;
        this._cachedAnimations = void 0;
        this.$context = void 0;
    }
    _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
            return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
    }
    getContext() {
        return (
            this.$context ||
            (this.$context = createTooltipContext(
                this.chart.getContext(),
                this,
                this._tooltipItems,
            ))
        );
    }
    getTitle(context, options) {
        const { callbacks } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
        const title = invokeCallbackWithFallback(callbacks, "title", this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(
            invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems),
        );
    }
    getBody(tooltipItems, options) {
        const { callbacks } = options;
        const bodyItems = [];
        each(tooltipItems, (context) => {
            const bodyItem = {
                before: [],
                lines: [],
                after: [],
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(
                bodyItem.before,
                splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)),
            );
            pushOrConcat(
                bodyItem.lines,
                invokeCallbackWithFallback(scoped, "label", this, context),
            );
            pushOrConcat(
                bodyItem.after,
                splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)),
            );
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(
            invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems),
        );
    }
    getFooter(tooltipItems, options) {
        const { callbacks } = options;
        const beforeFooter = invokeCallbackWithFallback(
            callbacks,
            "beforeFooter",
            this,
            tooltipItems,
        );
        const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(
            callbacks,
            "afterFooter",
            this,
            tooltipItems,
        );
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
    _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i2, len;
        for (i2 = 0, len = active.length; i2 < len; ++i2) {
            tooltipItems.push(createTooltipItem(this.chart, active[i2]));
        }
        if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index, array) =>
                options.filter(element, index, array, data),
            );
        }
        if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a2, b2) => options.itemSort(a2, b2, data));
        }
        each(tooltipItems, (context) => {
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
            labelPointStyles.push(
                invokeCallbackWithFallback(scoped, "labelPointStyle", this, context),
            );
            labelTextColors.push(
                invokeCallbackWithFallback(scoped, "labelTextColor", this, context),
            );
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) {
                properties = {
                    opacity: 0,
                };
            }
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = (this._size = getTooltipSize(this, options));
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(
                options,
                positionAndSize,
                alignment,
                this.chart,
            );
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y,
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = void 0;
        if (properties) {
            this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
            options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay,
            });
        }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign, yAlign } = this;
        const { caretSize, cornerRadius } = options;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
        const { x: ptX, y: ptY } = tooltipPoint;
        const { width, height } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
                x2 = this.caretX;
            }
            if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3,
        };
    }
    drawTitle(pt2, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i2;
        if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt2.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for (i2 = 0; i2 < length; ++i2) {
                ctx.fillText(title[i2], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
                pt2.y += titleFont.lineHeight + titleSpacing;
                if (i2 + 1 === length) {
                    pt2.y += options.titleMarginBottom - titleSpacing;
                }
            }
        }
    }
    _drawColorBox(ctx, pt2, i2, rtlHelper, options) {
        const labelColor = this.labelColors[i2];
        const labelPointStyle = this.labelPointStyles[i2];
        const { boxHeight, boxWidth } = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, "left", options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt2.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1,
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = isObject(labelColor.borderWidth)
                ? Math.max(...Object.values(labelColor.borderWidth))
                : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = toTRBLCorners(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius,
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius,
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i2];
    }
    drawBody(pt2, ctx, options) {
        const { body } = this;
        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function (line) {
            ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
            pt2.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i2, j2, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = bodyFont.string;
        pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding =
            displayColors && bodyAlignForCalculation !== "right"
                ? bodyAlign === "center"
                    ? boxWidth / 2 + boxPadding
                    : boxWidth + 2 + boxPadding
                : 0;
        for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
            bodyItem = body[i2];
            textColor = this.labelTextColors[i2];
            ctx.fillStyle = textColor;
            each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt2, i2, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
                fillLineOfText(lines[j2]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt2.y -= bodySpacing;
    }
    drawFooter(pt2, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i2;
        if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt2.x = getAlignedX(this, options.footerAlign, options);
            pt2.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for (i2 = 0; i2 < length; ++i2) {
                ctx.fillText(footer[i2], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
                pt2.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt2, ctx, tooltipSize, options) {
        const { xAlign, yAlign } = this;
        const { x: x2, y: y2 } = pt2;
        const { width, height } = tooltipSize;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x2 + topLeft, y2);
        if (yAlign === "top") {
            this.drawCaret(pt2, ctx, tooltipSize, options);
        }
        ctx.lineTo(x2 + width - topRight, y2);
        ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + topRight);
        if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt2, ctx, tooltipSize, options);
        }
        ctx.lineTo(x2 + width, y2 + height - bottomRight);
        ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - bottomRight, y2 + height);
        if (yAlign === "bottom") {
            this.drawCaret(pt2, ctx, tooltipSize, options);
        }
        ctx.lineTo(x2 + bottomLeft, y2 + height);
        ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - bottomLeft);
        if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt2, ctx, tooltipSize, options);
        }
        ctx.lineTo(x2, y2 + topLeft);
        ctx.quadraticCurveTo(x2, y2, x2 + topLeft, y2);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
    _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(
                this,
                this._active,
                this._eventPosition,
            );
            if (!position) {
                return;
            }
            const size = (this._size = getTooltipSize(this, options));
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
    _willRender() {
        return !!this.opacity;
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
            return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height,
        };
        const pt2 = {
            x: this.x,
            y: this.y,
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent =
            this.title.length ||
            this.beforeBody.length ||
            this.body.length ||
            this.afterBody.length ||
            this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt2, ctx, tooltipSize, options);
            overrideTextDirection(ctx, options.textDirection);
            pt2.y += padding.top;
            this.drawTitle(pt2, ctx, options);
            this.drawBody(pt2, ctx, options);
            this.drawFooter(pt2, ctx, options);
            restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex, index }) => {
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index,
            };
        });
        const changed = !_elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
    handleEvent(e2, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
            return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e2);
        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e2.x,
                    y: e2.y,
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
    _getActiveElements(e2, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e2.type === "mouseout") {
            return [];
        }
        if (!inChartArea) {
            return lastActive.filter(
                (i2) =>
                    this.chart.data.datasets[i2.datasetIndex] &&
                    this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !==
                        void 0,
            );
        }
        const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
        if (options.reverse) {
            active.reverse();
        }
        return active;
    }
    _positionChanged(active, e2) {
        const { caretX, caretY, options } = this;
        const position = positioners[options.position].call(this, active, e2);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
        if (options) {
            chart.tooltip = new Tooltip({
                chart,
                options,
            });
        }
    },
    beforeUpdate(chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    reset(chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    afterDraw(chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            const args = {
                tooltip,
            };
            if (
                chart.notifyPlugins("beforeTooltipDraw", {
                    ...args,
                    cancelable: true,
                }) === false
            ) {
                return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
        }
    },
    afterEvent(chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
            }
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
            weight: "bold",
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: "bold",
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts) => opts.bodyFont.size,
        boxWidth: (ctx, opts) => opts.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: "easeOutQuart",
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"],
            },
            opacity: {
                easing: "linear",
                duration: 200,
            },
        },
        callbacks: defaultCallbacks,
    },
    defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font",
    },
    descriptors: {
        _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false,
        },
        animation: {
            _fallback: false,
        },
        animations: {
            _fallback: "animation",
        },
    },
    additionalOptionScopes: ["interaction"],
};
var addIfString = (labels, raw, index, addedLabels) => {
    if (typeof raw === "string") {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw,
        });
    } else if (isNaN(raw)) {
        index = null;
    }
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
        return addIfString(labels, raw, index, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
var validIndex = (index, max) => (index === null ? null : _limitValue(Math.round(index), 0, max));
function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
        return labels[value];
    }
    return value;
}
var CategoryScale = class extends Scale {
    constructor(cfg) {
        super(cfg);
        this._startValue = void 0;
        this._valueRange = 0;
        this._addedLabels = [];
    }
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index, label } of added) {
                if (labels[index] === label) {
                    labels.splice(index, 1);
                }
            }
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if (isNullOrUndef(raw)) {
            return null;
        }
        const labels = this.getLabels();
        index =
            isFinite(index) && labels[index] === raw
                ? index
                : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this.getMinMax(true);
        if (this.options.bounds === "ticks") {
            if (!minDefined) {
                min = 0;
            }
            if (!maxDefined) {
                max = this.getLabels().length - 1;
            }
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for (let value = min; value <= max; value++) {
            ticks.push({
                value,
            });
        }
        return ticks;
    }
    getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
    }
    configure() {
        super.configure();
        if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
        }
    }
    getPixelForValue(value) {
        if (typeof value !== "number") {
            value = this.parse(value);
        }
        return value === null
            ? NaN
            : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
    ticks: {
        callback: _getLabelForValue,
    },
});
function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } =
        generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
            {
                value: rmin,
            },
            {
                value: rmax,
            },
        ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
        spacing = niceNum((numSpaces * spacing) / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
        } else {
            numSpaces = Math.ceil(numSpaces);
        }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j2 = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min,
            });
            if (niceMin < min) {
                j2++;
            }
            if (
                almostEquals(
                    Math.round((niceMin + j2 * spacing) * factor) / factor,
                    min,
                    relativeLabelSize(min, minSpacing, generationOptions),
                )
            ) {
                j2++;
            }
        } else if (niceMin < min) {
            j2++;
        }
    }
    for (; j2 < numSpaces; ++j2) {
        const tickValue = Math.round((niceMin + j2 * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) {
            break;
        }
        ticks.push({
            value: tickValue,
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (
            ticks.length &&
            almostEquals(
                ticks[ticks.length - 1].value,
                max,
                relativeLabelSize(max, minSpacing, generationOptions),
            )
        ) {
            ticks[ticks.length - 1].value = max;
        } else {
            ticks.push({
                value: max,
            });
        }
    } else if (!maxDefined || niceMax === max) {
        ticks.push({
            value: niceMax,
        });
    }
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
    constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._endValue = void 0;
        this._valueRange = 0;
    }
    parse(raw, index) {
        if (isNullOrUndef(raw)) {
            return null;
        }
        if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
        }
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero } = this.options;
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this;
        const setMin = (v2) => (min = minDefined ? min : v2);
        const setMax = (v2) => (max = maxDefined ? max : v2);
        if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
                setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
            }
        }
        if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) {
                setMin(min - offset);
            }
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit, stepSize } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1e3) {
                console.warn(
                    `scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`,
                );
                maxTicks = 1e3;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false,
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
};
var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
        const { min, max } = this.getMinMax(true);
        this.min = isNumberFinite(min) ? min : 0;
        this.max = isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null
            ? NaN
            : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
    ticks: {
        callback: Ticks.formatters.numeric,
    },
});
var log10Floor = (v2) => Math.floor(log10(v2));
var changeExponent = (v2, m2) => Math.pow(10, log10Floor(v2) + m2);
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    const range2 = max - min;
    let rangeExp = log10Floor(range2);
    while (steps(min, max, rangeExp) > 10) {
        rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
        rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(
        generationOptions.min,
        Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision,
    );
    while (value < max) {
        ticks.push({
            value,
            major: isMajor(value),
            significand,
        });
        if (significand >= 10) {
            significand = significand < 15 ? 15 : 20;
        } else {
            significand++;
        }
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value =
            Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand,
    });
    return ticks;
}
var LogarithmicScale = class extends Scale {
    constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._valueRange = 0;
    }
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
        if (value === 0) {
            this._zero = true;
            return void 0;
        }
        return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min, max } = this.getMinMax(true);
        this.min = isNumberFinite(min) ? Math.max(0, min) : null;
        this.max = isNumberFinite(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
            this._zero = true;
        }
        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
            this.min =
                min === changeExponent(this.min, 0)
                    ? changeExponent(this.min, -1)
                    : changeExponent(this.min, 0);
        }
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined, maxDefined } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v2) => (min = minDefined ? min : v2);
        const setMax = (v2) => (max = maxDefined ? max : v2);
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, 1));
            }
        }
        if (min <= 0) {
            setMin(changeExponent(max, -1));
        }
        if (max <= 0) {
            setMax(changeExponent(min, 1));
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax,
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    getLabelForValue(value) {
        return value === void 0
            ? "0"
            : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
        const start = this.min;
        super.configure();
        this._startValue = log10(start);
        this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
        if (value === void 0 || value === 0) {
            value = this.min;
        }
        if (value === null || isNaN(value)) {
            return NaN;
        }
        return this.getPixelForDecimal(
            value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange,
        );
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
    ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
            enabled: true,
        },
    },
});
function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = toPadding(tickOpts.backdropPadding);
        return (
            valueOrDefault(tickOpts.font && tickOpts.font.size, defaults2.font.size) +
            padding.height
        );
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [label];
    return {
        w: _longestText(ctx, font.string, label),
        h: label.length * font.lineHeight,
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
        return {
            start: pos - size / 2,
            end: pos + size / 2,
        };
    } else if (angle < min || angle > max) {
        return {
            start: pos - size,
            end: pos,
        };
    }
    return {
        start: pos,
        end: pos + size,
    };
}
function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom,
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
        padding[i2] = opts.padding;
        const pointPosition = scale.getPointPosition(
            i2,
            scale.drawingArea + padding[i2],
            additionalAngle,
        );
        const plFont = toFont(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
        labelSizes[i2] = textSize;
        const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
        const angle = Math.round(toDegrees(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(
        orig.l - limits.l,
        limits.r - orig.r,
        orig.t - limits.t,
        limits.b - orig.b,
    );
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x2 = 0;
    let y2 = 0;
    if (hLimits.start < orig.l) {
        x2 = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x2);
    } else if (hLimits.end > orig.r) {
        x2 = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x2);
    }
    if (vLimits.start < orig.t) {
        y2 = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y2);
    } else if (vLimits.end > orig.b) {
        y2 = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y2);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(
        index,
        outerDistance + extra + padding,
        additionalAngle,
    );
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y: y2,
        textAlign,
        left,
        top: y2,
        right: left + size.w,
        bottom: y2 + size.h,
    };
}
function isNotOverlapped(item, area) {
    if (!area) {
        return true;
    }
    const { left, top, right, bottom } = item;
    const apexesInArea =
        _isPointInArea(
            {
                x: left,
                y: top,
            },
            area,
        ) ||
        _isPointInArea(
            {
                x: left,
                y: bottom,
            },
            area,
        ) ||
        _isPointInArea(
            {
                x: right,
                y: top,
            },
            area,
        ) ||
        _isPointInArea(
            {
                x: right,
                y: bottom,
            },
            area,
        );
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? PI / valueCount : 0,
    };
    let area;
    for (let i2 = 0; i2 < valueCount; i2++) {
        itemOpts.padding = padding[i2];
        itemOpts.size = labelSizes[i2];
        const item = createPointLabelItem(scale, i2, itemOpts);
        items.push(item);
        if (display === "auto") {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) {
                area = item;
            }
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
        return "center";
    } else if (angle < 180) {
        return "left";
    }
    return "right";
}
function leftForTextAlign(x2, w2, align) {
    if (align === "right") {
        x2 -= w2;
    } else if (align === "center") {
        x2 -= w2 / 2;
    }
    return x2;
}
function yForAngle(y2, h6, angle) {
    if (angle === 90 || angle === 270) {
        y2 -= h6 / 2;
    } else if (angle > 270 || angle < 90) {
        y2 -= h6;
    }
    return y2;
}
function drawPointLabelBox(ctx, opts, item) {
    const { left, top, right, bottom } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(opts.borderRadius);
        const padding = toPadding(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
            ctx.beginPath();
            addRoundedRectPath(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius,
            });
            ctx.fill();
        } else {
            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
    }
}
function drawPointLabels(scale, labelCount) {
    const {
        ctx,
        options: { pointLabels },
    } = scale;
    for (let i2 = labelCount - 1; i2 >= 0; i2--) {
        const item = scale._pointLabelItems[i2];
        if (!item.visible) {
            continue;
        }
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
        drawPointLabelBox(ctx, optsAtIndex, item);
        const plFont = toFont(optsAtIndex.font);
        const { x: x2, y: y2, textAlign } = item;
        renderText(ctx, scale._pointLabels[i2], x2, y2 + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign,
            textBaseline: "middle",
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for (let i2 = 1; i2 < labelCount; i2++) {
            pointPosition = scale.getPointPosition(i2, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if ((!circular && !labelCount) || !color2 || !lineWidth || radius < 0) {
        return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return createContext(parent, {
        label,
        index,
        type: "pointLabel",
    });
}
var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
        super(cfg);
        this.xCenter = void 0;
        this.yCenter = void 0;
        this.drawingArea = void 0;
        this._pointLabels = [];
        this._pointLabelItems = [];
    }
    setDimensions() {
        const padding = (this._padding = toPadding(getTickBackdropHeight(this.options) / 2));
        const w2 = (this.width = this.maxWidth - padding.width);
        const h6 = (this.height = this.maxHeight - padding.height);
        this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h6 / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w2, h6) / 2);
    }
    determineDataLimits() {
        const { min, max } = this.getMinMax(false);
        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels()
            .map((value, index) => {
                const label = callback(this.options.pointLabels.callback, [value, index], this);
                return label || label === 0 ? label : "";
            })
            .filter((v2, i2) => this.chart.getDataVisibility(i2));
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
        } else {
            this.setCenterPoint(0, 0, 0, 0);
        }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(
            this.drawingArea / 2,
            Math.max(leftMovement, rightMovement, topMovement, bottomMovement),
        );
    }
    getIndexAngle(index) {
        const angleMultiplier = TAU / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if (isNullOrUndef(value)) {
            return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if (isNullOrUndef(distance)) {
            return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle,
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left, top, right, bottom } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom,
        };
    }
    drawBackground() {
        const {
            backgroundColor,
            grid: { circular },
        } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(
                this,
                this.getDistanceFromCenterForValue(this._endValue),
                circular,
                this._pointLabels.length,
            );
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
    drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines, grid, border } = opts;
        const labelCount = this._pointLabels.length;
        let i2, offset, position;
        if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
        }
        if (grid.display) {
            this.ticks.forEach((tick, index) => {
                if (index !== 0 || (index === 0 && this.min < 0)) {
                    offset = this.getDistanceFromCenterForValue(tick.value);
                    const context = this.getContext(index);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                }
            });
        }
        if (angleLines.display) {
            ctx.save();
            for (i2 = labelCount - 1; i2 >= 0; i2--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                    continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                position = this.getPointPosition(i2, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    drawBorder() {}
    drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
            return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        this.ticks.forEach((tick, index) => {
            if (index === 0 && this.min >= 0 && !opts.reverse) {
                return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(
                    -width / 2 - padding.left,
                    -offset - tickFont.size / 2 - padding.top,
                    width + padding.width,
                    tickFont.size + padding.height,
                );
            }
            renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
                strokeColor: optsAtIndex.textStrokeColor,
                strokeWidth: optsAtIndex.textStrokeWidth,
            });
        });
        ctx.restore();
    }
    drawTitle() {}
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0,
    },
    grid: {
        circular: false,
    },
    startAngle: 0,
    ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric,
    },
    pointLabels: {
        backdropColor: void 0,
        backdropPadding: 2,
        display: true,
        font: {
            size: 10,
        },
        callback(label) {
            return label;
        },
        padding: 5,
        centerPointLabels: false,
    },
});
__publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color",
});
__publicField(RadialLinearScale, "descriptors", {
    angleLines: {
        _fallback: "grid",
    },
});
var INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1e3,
    },
    second: {
        common: true,
        size: 1e3,
        steps: 60,
    },
    minute: {
        common: true,
        size: 6e4,
        steps: 60,
    },
    hour: {
        common: true,
        size: 36e5,
        steps: 24,
    },
    day: {
        common: true,
        size: 864e5,
        steps: 30,
    },
    week: {
        common: false,
        size: 6048e5,
        steps: 4,
    },
    month: {
        common: true,
        size: 2628e6,
        steps: 12,
    },
    quarter: {
        common: false,
        size: 7884e6,
        steps: 4,
    },
    year: {
        common: true,
        size: 3154e7,
    },
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a2, b2) {
    return a2 - b2;
}
function parse2(scale, input) {
    if (isNullOrUndef(input)) {
        return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
        value = parser(value);
    }
    if (!isNumberFinite(value)) {
        value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
        return null;
    }
    if (round2) {
        value =
            round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true)
                ? adapter.startOf(value, "isoWeek", isoWeekday)
                : adapter.startOf(value, round2);
    }
    return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
        const interval = INTERVALS[UNITS[i2]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i2];
        }
    }
    return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
        const unit = UNITS[i2];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
        }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
    for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
        if (INTERVALS[UNITS[i2]].common) {
            return UNITS[i2];
        }
    }
}
function addTick(ticks, time, timestamps) {
    if (!timestamps) {
        ticks[time] = true;
    } else if (timestamps.length) {
        const { lo, hi } = _lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index = map3[major];
        if (index >= 0) {
            ticks[index].major = true;
        }
    }
    return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i2, value;
    for (i2 = 0; i2 < ilen; ++i2) {
        value = values[i2];
        map3[value] = i2;
        ticks.push({
            value,
            major: false,
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
    constructor(props) {
        super(props);
        this._cache = {
            data: [],
            labels: [],
            all: [],
        };
        this._unit = "day";
        this._majorUnit = void 0;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = (this._adapter = new adapters._date(scaleOpts.adapters.date));
        adapter.init(opts);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday,
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
    parse(raw, index) {
        if (raw === void 0) {
            return null;
        }
        return parse2(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: [],
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || "day";
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
            }
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
            }
        }
        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max,
        };
    }
    buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps =
            tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === "ticks" && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _filterBetween(timestamps, min, max);
        this._unit =
            timeOpts.unit ||
            (tickOpts.autoSkip
                ? determineUnitForAutoTicks(
                      timeOpts.minUnit,
                      this.min,
                      this.max,
                      this._getLabelCapacity(min),
                  )
                : determineUnitForFormatting(
                      this,
                      ticks.length,
                      timeOpts.minUnit,
                      this.min,
                      this.max,
                  ));
        this._majorUnit =
            !tickOpts.major.enabled || this._unit === "year"
                ? void 0
                : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
            ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick) => +tick.value));
        }
    }
    initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
                start = 1 - first;
            } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
                end = last;
            } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _limitValue(start, 0, limit);
        end = _limitValue(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end),
        };
    }
    _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor =
            timeOpts.unit ||
            determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = valueOrDefault(options.ticks.stepSize, 1);
        const weekday = minor === "week" ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? "day" : minor);
        if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw new Error(
                min +
                    " and " +
                    max +
                    " are too far apart with stepSize of " +
                    stepSize +
                    " " +
                    minor,
            );
        }
        const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
        for (
            time = first, count = 0;
            time < max;
            time = +adapter.add(time, stepSize, minor), count++
        ) {
            addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks)
            .sort(sorter)
            .map((x2) => +x2);
    }
    getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
            return callback(formatter, [time, index, ticks], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
        let i2, ilen, tick;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
            tick = ticks[i2];
            tick.label = this._tickFormatFunction(tick.value, i2, ticks);
        }
    }
    getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(
            this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation,
        );
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
        };
    }
    _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(
            exampleTime,
            0,
            ticksFromTimestamps(this, [exampleTime], this._majorUnit),
            format,
        );
        const size = this._getLabelSize(exampleLabel);
        const capacity =
            Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i2, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
            return (this._cache.data = metas[0].controller.getAllParsedValues(this));
        }
        for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
        }
        return (this._cache.data = this.normalize(timestamps));
    }
    getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i2, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const labels = this.getLabels();
        for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
            timestamps.push(parse2(this, labels[i2]));
        }
        return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
    }
    normalize(values) {
        return _arrayUnique(values.sort(sorter));
    }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {},
    },
    ticks: {
        source: "auto",
        callback: false,
        major: {
            enabled: false,
        },
    },
});
function interpolate3(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo, hi } = _lookupByKey(table, "pos", val));
        }
        ({ pos: prevSource, time: prevTarget } = table[lo]);
        ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo, hi } = _lookupByKey(table, "time", val));
        }
        ({ time: prevSource, pos: prevTarget } = table[lo]);
        ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + ((nextTarget - prevTarget) * (val - prevSource)) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
        super(props);
        this._table = [];
        this._minPos = void 0;
        this._tableRange = void 0;
    }
    initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = (this._table = this.buildLookupTable(timestamps));
        this._minPos = interpolate3(table, this.min);
        this._tableRange = interpolate3(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
        const { min, max } = this;
        const items = [];
        const table = [];
        let i2, ilen, prev, curr, next;
        for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
            curr = timestamps[i2];
            if (curr >= min && curr <= max) {
                items.push(curr);
            }
        }
        if (items.length < 2) {
            return [
                {
                    time: min,
                    pos: 0,
                },
                {
                    time: max,
                    pos: 1,
                },
            ];
        }
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            next = items[i2 + 1];
            prev = items[i2 - 1];
            curr = items[i2];
            if (Math.round((next + prev) / 2) !== curr) {
                table.push({
                    time: curr,
                    pos: i2 / (ilen - 1),
                });
            }
        }
        return table;
    }
    _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) {
            timestamps.splice(0, 0, min);
        }
        if (!timestamps.includes(max) || timestamps.length === 1) {
            timestamps.push(max);
        }
        return timestamps.sort((a2, b2) => a2 - b2);
    }
    _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
            return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
        } else {
            timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
    getDecimalForValue(value) {
        return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
    }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

// node_modules/gridjs/dist/gridjs.module.js
function t2(t3, n2) {
    for (var e2 = 0; e2 < n2.length; e2++) {
        var r2 = n2[e2];
        ((r2.enumerable = r2.enumerable || false),
            (r2.configurable = true),
            "value" in r2 && (r2.writable = true),
            Object.defineProperty(
                t3,
                "symbol" ==
                    typeof (o2 = (function (t4, n3) {
                        if ("object" != typeof t4 || null === t4) return t4;
                        var e3 = t4[Symbol.toPrimitive];
                        if (void 0 !== e3) {
                            var r3 = e3.call(t4, "string");
                            if ("object" != typeof r3) return r3;
                            throw new TypeError("@@toPrimitive must return a primitive value.");
                        }
                        return String(t4);
                    })(r2.key))
                    ? o2
                    : String(o2),
                r2,
            ));
    }
    var o2;
}
function n(n2, e2, r2) {
    return (
        e2 && t2(n2.prototype, e2),
        r2 && t2(n2, r2),
        Object.defineProperty(n2, "prototype", { writable: false }),
        n2
    );
}
function e() {
    return (
        (e = Object.assign
            ? Object.assign.bind()
            : function (t3) {
                  for (var n2 = 1; n2 < arguments.length; n2++) {
                      var e2 = arguments[n2];
                      for (var r2 in e2)
                          Object.prototype.hasOwnProperty.call(e2, r2) && (t3[r2] = e2[r2]);
                  }
                  return t3;
              }),
        e.apply(this, arguments)
    );
}
function r(t3, n2) {
    ((t3.prototype = Object.create(n2.prototype)), (t3.prototype.constructor = t3), o(t3, n2));
}
function o(t3, n2) {
    return (
        (o = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t4, n3) {
                  return ((t4.__proto__ = n3), t4);
              }),
        o(t3, n2)
    );
}
function i(t3) {
    if (void 0 === t3)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t3;
}
function u(t3, n2) {
    (null == n2 || n2 > t3.length) && (n2 = t3.length);
    for (var e2 = 0, r2 = new Array(n2); e2 < n2; e2++) r2[e2] = t3[e2];
    return r2;
}
function s(t3, n2) {
    var e2 = ("undefined" != typeof Symbol && t3[Symbol.iterator]) || t3["@@iterator"];
    if (e2) return (e2 = e2.call(t3)).next.bind(e2);
    if (
        Array.isArray(t3) ||
        (e2 = (function (t4, n3) {
            if (t4) {
                if ("string" == typeof t4) return u(t4, n3);
                var e3 = Object.prototype.toString.call(t4).slice(8, -1);
                return (
                    "Object" === e3 && t4.constructor && (e3 = t4.constructor.name),
                    "Map" === e3 || "Set" === e3
                        ? Array.from(t4)
                        : "Arguments" === e3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3)
                          ? u(t4, n3)
                          : void 0
                );
            }
        })(t3)) ||
        (n2 && t3 && "number" == typeof t3.length)
    ) {
        e2 && (t3 = e2);
        var r2 = 0;
        return function () {
            return r2 >= t3.length ? { done: true } : { done: false, value: t3[r2++] };
        };
    }
    throw new TypeError(
        "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
    );
}
var a;
!(function (t3) {
    ((t3[(t3.Init = 0)] = "Init"),
        (t3[(t3.Loading = 1)] = "Loading"),
        (t3[(t3.Loaded = 2)] = "Loaded"),
        (t3[(t3.Rendered = 3)] = "Rendered"),
        (t3[(t3.Error = 4)] = "Error"));
})(a || (a = {}));
var l;
var c;
var f;
var p;
var d;
var h;
var _;
var m = {};
var v = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function g(t3, n2) {
    for (var e2 in n2) t3[e2] = n2[e2];
    return t3;
}
function b(t3) {
    var n2 = t3.parentNode;
    n2 && n2.removeChild(t3);
}
function w(t3, n2, e2) {
    var r2,
        o2,
        i2,
        u2 = {};
    for (i2 in n2) "key" == i2 ? (r2 = n2[i2]) : "ref" == i2 ? (o2 = n2[i2]) : (u2[i2] = n2[i2]);
    if (
        (arguments.length > 2 && (u2.children = arguments.length > 3 ? l.call(arguments, 2) : e2),
        "function" == typeof t3 && null != t3.defaultProps)
    )
        for (i2 in t3.defaultProps) void 0 === u2[i2] && (u2[i2] = t3.defaultProps[i2]);
    return x(t3, u2, r2, o2, null);
}
function x(t3, n2, e2, r2, o2) {
    var i2 = {
        type: t3,
        props: n2,
        key: e2,
        ref: r2,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == o2 ? ++f : o2,
    };
    return (null == o2 && null != c.vnode && c.vnode(i2), i2);
}
function S(t3) {
    return t3.children;
}
function N(t3, n2) {
    ((this.props = t3), (this.context = n2));
}
function P(t3, n2) {
    if (null == n2) return t3.__ ? P(t3.__, t3.__.__k.indexOf(t3) + 1) : null;
    for (var e2; n2 < t3.__k.length; n2++)
        if (null != (e2 = t3.__k[n2]) && null != e2.__e) return e2.__e;
    return "function" == typeof t3.type ? P(t3) : null;
}
function C(t3) {
    var n2, e2;
    if (null != (t3 = t3.__) && null != t3.__c) {
        for (t3.__e = t3.__c.base = null, n2 = 0; n2 < t3.__k.length; n2++)
            if (null != (e2 = t3.__k[n2]) && null != e2.__e) {
                t3.__e = t3.__c.base = e2.__e;
                break;
            }
        return C(t3);
    }
}
function E(t3) {
    ((!t3.__d && (t3.__d = true) && d.push(t3) && !I.__r++) || h !== c.debounceRendering) &&
        ((h = c.debounceRendering) || setTimeout)(I);
}
function I() {
    for (var t3; (I.__r = d.length); )
        ((t3 = d.sort(function (t4, n2) {
            return t4.__v.__b - n2.__v.__b;
        })),
            (d = []),
            t3.some(function (t4) {
                var n2, e2, r2, o2, i2, u2;
                t4.__d &&
                    ((i2 = (o2 = (n2 = t4).__v).__e),
                    (u2 = n2.__P) &&
                        ((e2 = []),
                        ((r2 = g({}, o2)).__v = o2.__v + 1),
                        M(
                            u2,
                            o2,
                            r2,
                            n2.__n,
                            void 0 !== u2.ownerSVGElement,
                            null != o2.__h ? [i2] : null,
                            e2,
                            null == i2 ? P(o2) : i2,
                            o2.__h,
                        ),
                        F(e2, o2),
                        o2.__e != i2 && C(o2)));
            }));
}
function T(t3, n2, e2, r2, o2, i2, u2, s2, a2, l2) {
    var c2,
        f2,
        p2,
        d2,
        h6,
        _2,
        y2,
        g2 = (r2 && r2.__k) || v,
        b2 = g2.length;
    for (e2.__k = [], c2 = 0; c2 < n2.length; c2++)
        if (
            null !=
            (d2 = e2.__k[c2] =
                null == (d2 = n2[c2]) || "boolean" == typeof d2
                    ? null
                    : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2
                      ? x(null, d2, null, null, d2)
                      : Array.isArray(d2)
                        ? x(S, { children: d2 }, null, null, null)
                        : d2.__b > 0
                          ? x(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v)
                          : d2)
        ) {
            if (
                ((d2.__ = e2),
                (d2.__b = e2.__b + 1),
                null === (p2 = g2[c2]) || (p2 && d2.key == p2.key && d2.type === p2.type))
            )
                g2[c2] = void 0;
            else
                for (f2 = 0; f2 < b2; f2++) {
                    if ((p2 = g2[f2]) && d2.key == p2.key && d2.type === p2.type) {
                        g2[f2] = void 0;
                        break;
                    }
                    p2 = null;
                }
            (M(t3, d2, (p2 = p2 || m), o2, i2, u2, s2, a2, l2),
                (h6 = d2.__e),
                (f2 = d2.ref) &&
                    p2.ref != f2 &&
                    (y2 || (y2 = []),
                    p2.ref && y2.push(p2.ref, null, d2),
                    y2.push(f2, d2.__c || h6, d2)),
                null != h6
                    ? (null == _2 && (_2 = h6),
                      "function" == typeof d2.type && d2.__k === p2.__k
                          ? (d2.__d = a2 = L(d2, a2, t3))
                          : (a2 = A(t3, d2, p2, g2, h6, a2)),
                      "function" == typeof e2.type && (e2.__d = a2))
                    : a2 && p2.__e == a2 && a2.parentNode != t3 && (a2 = P(p2)));
        }
    for (e2.__e = _2, c2 = b2; c2--; ) null != g2[c2] && W(g2[c2], g2[c2]);
    if (y2) for (c2 = 0; c2 < y2.length; c2++) U(y2[c2], y2[++c2], y2[++c2]);
}
function L(t3, n2, e2) {
    for (var r2, o2 = t3.__k, i2 = 0; o2 && i2 < o2.length; i2++)
        (r2 = o2[i2]) &&
            ((r2.__ = t3),
            (n2 = "function" == typeof r2.type ? L(r2, n2, e2) : A(e2, r2, r2, o2, r2.__e, n2)));
    return n2;
}
function A(t3, n2, e2, r2, o2, i2) {
    var u2, s2, a2;
    if (void 0 !== n2.__d) ((u2 = n2.__d), (n2.__d = void 0));
    else if (null == e2 || o2 != i2 || null == o2.parentNode)
        t: if (null == i2 || i2.parentNode !== t3) (t3.appendChild(o2), (u2 = null));
        else {
            for (s2 = i2, a2 = 0; (s2 = s2.nextSibling) && a2 < r2.length; a2 += 1)
                if (s2 == o2) break t;
            (t3.insertBefore(o2, i2), (u2 = i2));
        }
    return void 0 !== u2 ? u2 : o2.nextSibling;
}
function O(t3, n2, e2) {
    "-" === n2[0]
        ? t3.setProperty(n2, e2)
        : (t3[n2] = null == e2 ? "" : "number" != typeof e2 || y.test(n2) ? e2 : e2 + "px");
}
function H(t3, n2, e2, r2, o2) {
    var i2;
    t: if ("style" === n2)
        if ("string" == typeof e2) t3.style.cssText = e2;
        else {
            if (("string" == typeof r2 && (t3.style.cssText = r2 = ""), r2))
                for (n2 in r2) (e2 && n2 in e2) || O(t3.style, n2, "");
            if (e2) for (n2 in e2) (r2 && e2[n2] === r2[n2]) || O(t3.style, n2, e2[n2]);
        }
    else if ("o" === n2[0] && "n" === n2[1])
        ((i2 = n2 !== (n2 = n2.replace(/Capture$/, ""))),
            (n2 = n2.toLowerCase() in t3 ? n2.toLowerCase().slice(2) : n2.slice(2)),
            t3.l || (t3.l = {}),
            (t3.l[n2 + i2] = e2),
            e2
                ? r2 || t3.addEventListener(n2, i2 ? D : j, i2)
                : t3.removeEventListener(n2, i2 ? D : j, i2));
    else if ("dangerouslySetInnerHTML" !== n2) {
        if (o2) n2 = n2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if (
            "href" !== n2 &&
            "list" !== n2 &&
            "form" !== n2 &&
            "tabIndex" !== n2 &&
            "download" !== n2 &&
            n2 in t3
        )
            try {
                t3[n2] = null == e2 ? "" : e2;
                break t;
            } catch (t4) {}
        "function" == typeof e2 ||
            (null == e2 || (false === e2 && -1 == n2.indexOf("-"))
                ? t3.removeAttribute(n2)
                : t3.setAttribute(n2, e2));
    }
}
function j(t3) {
    this.l[t3.type + false](c.event ? c.event(t3) : t3);
}
function D(t3) {
    this.l[t3.type + true](c.event ? c.event(t3) : t3);
}
function M(t3, n2, e2, r2, o2, i2, u2, s2, a2) {
    var l2,
        f2,
        p2,
        d2,
        h6,
        _2,
        m2,
        v2,
        y2,
        b2,
        w2,
        x2,
        k,
        P2,
        C2,
        E2 = n2.type;
    if (void 0 !== n2.constructor) return null;
    (null != e2.__h && ((a2 = e2.__h), (s2 = n2.__e = e2.__e), (n2.__h = null), (i2 = [s2])),
        (l2 = c.__b) && l2(n2));
    try {
        t: if ("function" == typeof E2) {
            if (
                ((v2 = n2.props),
                (y2 = (l2 = E2.contextType) && r2[l2.__c]),
                (b2 = l2 ? (y2 ? y2.props.value : l2.__) : r2),
                e2.__c
                    ? (m2 = (f2 = n2.__c = e2.__c).__ = f2.__E)
                    : ("prototype" in E2 && E2.prototype.render
                          ? (n2.__c = f2 = new E2(v2, b2))
                          : ((n2.__c = f2 = new N(v2, b2)), (f2.constructor = E2), (f2.render = B)),
                      y2 && y2.sub(f2),
                      (f2.props = v2),
                      f2.state || (f2.state = {}),
                      (f2.context = b2),
                      (f2.__n = r2),
                      (p2 = f2.__d = true),
                      (f2.__h = []),
                      (f2._sb = [])),
                null == f2.__s && (f2.__s = f2.state),
                null != E2.getDerivedStateFromProps &&
                    (f2.__s == f2.state && (f2.__s = g({}, f2.__s)),
                    g(f2.__s, E2.getDerivedStateFromProps(v2, f2.__s))),
                (d2 = f2.props),
                (h6 = f2.state),
                p2)
            )
                (null == E2.getDerivedStateFromProps &&
                    null != f2.componentWillMount &&
                    f2.componentWillMount(),
                    null != f2.componentDidMount && f2.__h.push(f2.componentDidMount));
            else {
                if (
                    (null == E2.getDerivedStateFromProps &&
                        v2 !== d2 &&
                        null != f2.componentWillReceiveProps &&
                        f2.componentWillReceiveProps(v2, b2),
                    (!f2.__e &&
                        null != f2.shouldComponentUpdate &&
                        false === f2.shouldComponentUpdate(v2, f2.__s, b2)) ||
                        n2.__v === e2.__v)
                ) {
                    for (
                        f2.props = v2,
                            f2.state = f2.__s,
                            n2.__v !== e2.__v && (f2.__d = false),
                            f2.__v = n2,
                            n2.__e = e2.__e,
                            n2.__k = e2.__k,
                            n2.__k.forEach(function (t4) {
                                t4 && (t4.__ = n2);
                            }),
                            w2 = 0;
                        w2 < f2._sb.length;
                        w2++
                    )
                        f2.__h.push(f2._sb[w2]);
                    ((f2._sb = []), f2.__h.length && u2.push(f2));
                    break t;
                }
                (null != f2.componentWillUpdate && f2.componentWillUpdate(v2, f2.__s, b2),
                    null != f2.componentDidUpdate &&
                        f2.__h.push(function () {
                            f2.componentDidUpdate(d2, h6, _2);
                        }));
            }
            if (
                ((f2.context = b2),
                (f2.props = v2),
                (f2.__v = n2),
                (f2.__P = t3),
                (x2 = c.__r),
                (k = 0),
                "prototype" in E2 && E2.prototype.render)
            ) {
                for (
                    f2.state = f2.__s,
                        f2.__d = false,
                        x2 && x2(n2),
                        l2 = f2.render(f2.props, f2.state, f2.context),
                        P2 = 0;
                    P2 < f2._sb.length;
                    P2++
                )
                    f2.__h.push(f2._sb[P2]);
                f2._sb = [];
            } else
                do {
                    ((f2.__d = false),
                        x2 && x2(n2),
                        (l2 = f2.render(f2.props, f2.state, f2.context)),
                        (f2.state = f2.__s));
                } while (f2.__d && ++k < 25);
            ((f2.state = f2.__s),
                null != f2.getChildContext && (r2 = g(g({}, r2), f2.getChildContext())),
                p2 ||
                    null == f2.getSnapshotBeforeUpdate ||
                    (_2 = f2.getSnapshotBeforeUpdate(d2, h6)),
                (C2 = null != l2 && l2.type === S && null == l2.key ? l2.props.children : l2),
                T(t3, Array.isArray(C2) ? C2 : [C2], n2, e2, r2, o2, i2, u2, s2, a2),
                (f2.base = n2.__e),
                (n2.__h = null),
                f2.__h.length && u2.push(f2),
                m2 && (f2.__E = f2.__ = null),
                (f2.__e = false));
        } else
            null == i2 && n2.__v === e2.__v
                ? ((n2.__k = e2.__k), (n2.__e = e2.__e))
                : (n2.__e = R(e2.__e, n2, e2, r2, o2, i2, u2, a2));
        (l2 = c.diffed) && l2(n2);
    } catch (t4) {
        ((n2.__v = null),
            (a2 || null != i2) && ((n2.__e = s2), (n2.__h = !!a2), (i2[i2.indexOf(s2)] = null)),
            c.__e(t4, n2, e2));
    }
}
function F(t3, n2) {
    (c.__c && c.__c(n2, t3),
        t3.some(function (n3) {
            try {
                ((t3 = n3.__h),
                    (n3.__h = []),
                    t3.some(function (t4) {
                        t4.call(n3);
                    }));
            } catch (t4) {
                c.__e(t4, n3.__v);
            }
        }));
}
function R(t3, n2, e2, r2, o2, i2, u2, s2) {
    var a2,
        c2,
        f2,
        p2 = e2.props,
        d2 = n2.props,
        h6 = n2.type,
        _2 = 0;
    if (("svg" === h6 && (o2 = true), null != i2)) {
        for (; _2 < i2.length; _2++)
            if (
                (a2 = i2[_2]) &&
                "setAttribute" in a2 == !!h6 &&
                (h6 ? a2.localName === h6 : 3 === a2.nodeType)
            ) {
                ((t3 = a2), (i2[_2] = null));
                break;
            }
    }
    if (null == t3) {
        if (null === h6) return document.createTextNode(d2);
        ((t3 = o2
            ? document.createElementNS("http://www.w3.org/2000/svg", h6)
            : document.createElement(h6, d2.is && d2)),
            (i2 = null),
            (s2 = false));
    }
    if (null === h6) p2 === d2 || (s2 && t3.data === d2) || (t3.data = d2);
    else {
        if (
            ((i2 = i2 && l.call(t3.childNodes)),
            (c2 = (p2 = e2.props || m).dangerouslySetInnerHTML),
            (f2 = d2.dangerouslySetInnerHTML),
            !s2)
        ) {
            if (null != i2)
                for (p2 = {}, _2 = 0; _2 < t3.attributes.length; _2++)
                    p2[t3.attributes[_2].name] = t3.attributes[_2].value;
            (f2 || c2) &&
                ((f2 && ((c2 && f2.__html == c2.__html) || f2.__html === t3.innerHTML)) ||
                    (t3.innerHTML = (f2 && f2.__html) || ""));
        }
        if (
            ((function (t4, n3, e3, r3, o3) {
                var i3;
                for (i3 in e3)
                    "children" === i3 || "key" === i3 || i3 in n3 || H(t4, i3, null, e3[i3], r3);
                for (i3 in n3)
                    (o3 && "function" != typeof n3[i3]) ||
                        "children" === i3 ||
                        "key" === i3 ||
                        "value" === i3 ||
                        "checked" === i3 ||
                        e3[i3] === n3[i3] ||
                        H(t4, i3, n3[i3], e3[i3], r3);
            })(t3, d2, p2, o2, s2),
            f2)
        )
            n2.__k = [];
        else if (
            ((_2 = n2.props.children),
            T(
                t3,
                Array.isArray(_2) ? _2 : [_2],
                n2,
                e2,
                r2,
                o2 && "foreignObject" !== h6,
                i2,
                u2,
                i2 ? i2[0] : e2.__k && P(e2, 0),
                s2,
            ),
            null != i2)
        )
            for (_2 = i2.length; _2--; ) null != i2[_2] && b(i2[_2]);
        s2 ||
            ("value" in d2 &&
                void 0 !== (_2 = d2.value) &&
                (_2 !== t3.value ||
                    ("progress" === h6 && !_2) ||
                    ("option" === h6 && _2 !== p2.value)) &&
                H(t3, "value", _2, p2.value, false),
            "checked" in d2 &&
                void 0 !== (_2 = d2.checked) &&
                _2 !== t3.checked &&
                H(t3, "checked", _2, p2.checked, false));
    }
    return t3;
}
function U(t3, n2, e2) {
    try {
        "function" == typeof t3 ? t3(n2) : (t3.current = n2);
    } catch (t4) {
        c.__e(t4, e2);
    }
}
function W(t3, n2, e2) {
    var r2, o2;
    if (
        (c.unmount && c.unmount(t3),
        (r2 = t3.ref) && ((r2.current && r2.current !== t3.__e) || U(r2, null, n2)),
        null != (r2 = t3.__c))
    ) {
        if (r2.componentWillUnmount)
            try {
                r2.componentWillUnmount();
            } catch (t4) {
                c.__e(t4, n2);
            }
        ((r2.base = r2.__P = null), (t3.__c = void 0));
    }
    if ((r2 = t3.__k))
        for (o2 = 0; o2 < r2.length; o2++)
            r2[o2] && W(r2[o2], n2, e2 || "function" != typeof t3.type);
    (e2 || null == t3.__e || b(t3.__e), (t3.__ = t3.__e = t3.__d = void 0));
}
function B(t3, n2, e2) {
    return this.constructor(t3, e2);
}
function q(t3, n2, e2) {
    var r2, o2, i2;
    (c.__ && c.__(t3, n2),
        (o2 = (r2 = "function" == typeof e2) ? null : (e2 && e2.__k) || n2.__k),
        (i2 = []),
        M(
            n2,
            (t3 = ((!r2 && e2) || n2).__k = w(S, null, [t3])),
            o2 || m,
            m,
            void 0 !== n2.ownerSVGElement,
            !r2 && e2 ? [e2] : o2 ? null : n2.firstChild ? l.call(n2.childNodes) : null,
            i2,
            !r2 && e2 ? e2 : o2 ? o2.__e : n2.firstChild,
            r2,
        ),
        F(i2, t3));
}
function z() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t3) {
        var n2 = (16 * Math.random()) | 0;
        return ("x" == t3 ? n2 : (3 & n2) | 8).toString(16);
    });
}
((l = v.slice),
    (c = {
        __e: function (t3, n2, e2, r2) {
            for (var o2, i2, u2; (n2 = n2.__); )
                if ((o2 = n2.__c) && !o2.__)
                    try {
                        if (
                            ((i2 = o2.constructor) &&
                                null != i2.getDerivedStateFromError &&
                                (o2.setState(i2.getDerivedStateFromError(t3)), (u2 = o2.__d)),
                            null != o2.componentDidCatch &&
                                (o2.componentDidCatch(t3, r2 || {}), (u2 = o2.__d)),
                            u2)
                        )
                            return (o2.__E = o2);
                    } catch (n3) {
                        t3 = n3;
                    }
            throw t3;
        },
    }),
    (f = 0),
    (p = function (t3) {
        return null != t3 && void 0 === t3.constructor;
    }),
    (N.prototype.setState = function (t3, n2) {
        var e2;
        ((e2 =
            null != this.__s && this.__s !== this.state
                ? this.__s
                : (this.__s = g({}, this.state))),
            "function" == typeof t3 && (t3 = t3(g({}, e2), this.props)),
            t3 && g(e2, t3),
            null != t3 && this.__v && (n2 && this._sb.push(n2), E(this)));
    }),
    (N.prototype.forceUpdate = function (t3) {
        this.__v && ((this.__e = true), t3 && this.__h.push(t3), E(this));
    }),
    (N.prototype.render = S),
    (d = []),
    (I.__r = 0),
    (_ = 0));
var V = /* @__PURE__ */ (function () {
    function t3(t4) {
        ((this._id = void 0), (this._id = t4 || z()));
    }
    return (
        n(t3, [
            {
                key: "id",
                get: function () {
                    return this._id;
                },
            },
        ]),
        t3
    );
})();
function $(t3) {
    return w(t3.parentElement || "span", { dangerouslySetInnerHTML: { __html: t3.content } });
}
function G(t3, n2) {
    return w($, { content: t3, parentElement: n2 });
}
var K;
var X = /* @__PURE__ */ (function (t3) {
    function n2(n3) {
        var e3;
        return (((e3 = t3.call(this) || this).data = void 0), e3.update(n3), e3);
    }
    r(n2, t3);
    var e2 = n2.prototype;
    return (
        (e2.cast = function (t4) {
            return t4 instanceof HTMLElement ? G(t4.outerHTML) : t4;
        }),
        (e2.update = function (t4) {
            return ((this.data = this.cast(t4)), this);
        }),
        n2
    );
})(V);
var Z = /* @__PURE__ */ (function (t3) {
    function e2(n2) {
        var e3;
        return (((e3 = t3.call(this) || this)._cells = void 0), (e3.cells = n2 || []), e3);
    }
    r(e2, t3);
    var o2 = e2.prototype;
    return (
        (o2.cell = function (t4) {
            return this._cells[t4];
        }),
        (o2.toArray = function () {
            return this.cells.map(function (t4) {
                return t4.data;
            });
        }),
        (e2.fromCells = function (t4) {
            return new e2(
                t4.map(function (t5) {
                    return new X(t5.data);
                }),
            );
        }),
        n(e2, [
            {
                key: "cells",
                get: function () {
                    return this._cells;
                },
                set: function (t4) {
                    this._cells = t4;
                },
            },
            {
                key: "length",
                get: function () {
                    return this.cells.length;
                },
            },
        ]),
        e2
    );
})(V);
var J = /* @__PURE__ */ (function (t3) {
    function e2(n2) {
        var e3;
        return (
            ((e3 = t3.call(this) || this)._rows = void 0),
            (e3._length = void 0),
            (e3.rows = n2 instanceof Array ? n2 : n2 instanceof Z ? [n2] : []),
            e3
        );
    }
    return (
        r(e2, t3),
        (e2.prototype.toArray = function () {
            return this.rows.map(function (t4) {
                return t4.toArray();
            });
        }),
        (e2.fromRows = function (t4) {
            return new e2(
                t4.map(function (t5) {
                    return Z.fromCells(t5.cells);
                }),
            );
        }),
        (e2.fromArray = function (t4) {
            return new e2(
                (t4 = (function (t5) {
                    return !t5[0] || t5[0] instanceof Array ? t5 : [t5];
                })(t4)).map(function (t5) {
                    return new Z(
                        t5.map(function (t6) {
                            return new X(t6);
                        }),
                    );
                }),
            );
        }),
        n(e2, [
            {
                key: "rows",
                get: function () {
                    return this._rows;
                },
                set: function (t4) {
                    this._rows = t4;
                },
            },
            {
                key: "length",
                get: function () {
                    return this._length || this.rows.length;
                },
                set: function (t4) {
                    this._length = t4;
                },
            },
        ]),
        e2
    );
})(V);
var Q = /* @__PURE__ */ (function () {
    function t3() {
        this.callbacks = void 0;
    }
    var n2 = t3.prototype;
    return (
        (n2.init = function (t4) {
            (this.callbacks || (this.callbacks = {}),
                t4 && !this.callbacks[t4] && (this.callbacks[t4] = []));
        }),
        (n2.listeners = function () {
            return this.callbacks;
        }),
        (n2.on = function (t4, n3) {
            return (this.init(t4), this.callbacks[t4].push(n3), this);
        }),
        (n2.off = function (t4, n3) {
            var e2 = t4;
            return (
                this.init(),
                this.callbacks[e2] && 0 !== this.callbacks[e2].length
                    ? ((this.callbacks[e2] = this.callbacks[e2].filter(function (t5) {
                          return t5 != n3;
                      })),
                      this)
                    : this
            );
        }),
        (n2.emit = function (t4) {
            var n3 = arguments,
                e2 = t4;
            return (
                this.init(e2),
                this.callbacks[e2].length > 0 &&
                    (this.callbacks[e2].forEach(function (t5) {
                        return t5.apply(void 0, [].slice.call(n3, 1));
                    }),
                    true)
            );
        }),
        t3
    );
})();
function Y(t3, n2) {
    if (typeof t3 != typeof n2) return false;
    if (null === t3 && null === n2) return true;
    if ("object" != typeof t3) return t3 === n2;
    if (Array.isArray(t3) && Array.isArray(n2)) {
        if (t3.length !== n2.length) return false;
        for (var e2 = 0; e2 < t3.length; e2++) if (!Y(t3[e2], n2[e2])) return false;
        return true;
    }
    if (
        t3.hasOwnProperty("constructor") &&
        n2.hasOwnProperty("constructor") &&
        t3.hasOwnProperty("props") &&
        n2.hasOwnProperty("props") &&
        t3.hasOwnProperty("key") &&
        n2.hasOwnProperty("key") &&
        t3.hasOwnProperty("ref") &&
        n2.hasOwnProperty("ref") &&
        t3.hasOwnProperty("type") &&
        n2.hasOwnProperty("type")
    )
        return Y(t3.props, n2.props);
    var r2 = Object.keys(t3),
        o2 = Object.keys(n2);
    if (r2.length !== o2.length) return false;
    for (var i2 = 0, u2 = r2; i2 < u2.length; i2++) {
        var s2 = u2[i2];
        if (!n2.hasOwnProperty(s2) || !Y(t3[s2], n2[s2])) return false;
    }
    return true;
}
!(function (t3) {
    ((t3[(t3.Initiator = 0)] = "Initiator"),
        (t3[(t3.ServerFilter = 1)] = "ServerFilter"),
        (t3[(t3.ServerSort = 2)] = "ServerSort"),
        (t3[(t3.ServerLimit = 3)] = "ServerLimit"),
        (t3[(t3.Extractor = 4)] = "Extractor"),
        (t3[(t3.Transformer = 5)] = "Transformer"),
        (t3[(t3.Filter = 6)] = "Filter"),
        (t3[(t3.Sort = 7)] = "Sort"),
        (t3[(t3.Limit = 8)] = "Limit"));
})(K || (K = {}));
var tt = /* @__PURE__ */ (function (t3) {
    function o2(n2) {
        var e2;
        return (
            ((e2 = t3.call(this) || this).id = void 0),
            (e2._props = void 0),
            (e2._props = {}),
            (e2.id = z()),
            n2 && e2.setProps(n2),
            e2
        );
    }
    r(o2, t3);
    var i2 = o2.prototype;
    return (
        (i2.process = function () {
            var t4 = [].slice.call(arguments);
            (this.validateProps instanceof Function && this.validateProps.apply(this, t4),
                this.emit.apply(this, ["beforeProcess"].concat(t4)));
            var n2 = this._process.apply(this, t4);
            return (this.emit.apply(this, ["afterProcess"].concat(t4)), n2);
        }),
        (i2.setProps = function (t4) {
            var n2 = e({}, this._props, t4);
            return (
                Y(n2, this._props) || ((this._props = n2), this.emit("propsUpdated", this)),
                this
            );
        }),
        n(o2, [
            {
                key: "props",
                get: function () {
                    return this._props;
                },
            },
        ]),
        o2
    );
})(Q);
var nt = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(e2, t3),
        (e2.prototype._process = function (t4) {
            return this.props.keyword
                ? ((n2 = String(this.props.keyword).trim()),
                  (e3 = this.props.columns),
                  (r2 = this.props.ignoreHiddenColumns),
                  (o2 = t4),
                  (i2 = this.props.selector),
                  (n2 = n2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")),
                  new J(
                      o2.rows.filter(function (t5, o3) {
                          return t5.cells.some(function (t6, u2) {
                              if (!t6) return false;
                              if (r2 && e3 && e3[u2] && "object" == typeof e3[u2] && e3[u2].hidden)
                                  return false;
                              var s2 = "";
                              if ("function" == typeof i2) s2 = i2(t6.data, o3, u2);
                              else if ("object" == typeof t6.data) {
                                  var a2 = t6.data;
                                  a2 && a2.props && a2.props.content && (s2 = a2.props.content);
                              } else s2 = String(t6.data);
                              return new RegExp(n2, "gi").test(s2);
                          });
                      }),
                  ))
                : t4;
            var n2, e3, r2, o2, i2;
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Filter;
                },
            },
        ]),
        e2
    );
})(tt);
function et() {
    var t3 = "gridjs";
    return (
        "" +
        t3 +
        [].slice.call(arguments).reduce(function (t4, n2) {
            return t4 + "-" + n2;
        }, "")
    );
}
function rt() {
    return [].slice
        .call(arguments)
        .map(function (t3) {
            return t3 ? t3.toString() : "";
        })
        .filter(function (t3) {
            return t3;
        })
        .reduce(function (t3, n2) {
            return (t3 || "") + " " + n2;
        }, "")
        .trim();
}
var ot;
var it;
var ut;
var st;
var at = /* @__PURE__ */ (function (t3) {
    function o2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(o2, t3),
        (o2.prototype._process = function (t4) {
            if (!this.props.keyword) return t4;
            var n2 = {};
            return (
                this.props.url && (n2.url = this.props.url(t4.url, this.props.keyword)),
                this.props.body && (n2.body = this.props.body(t4.body, this.props.keyword)),
                e({}, t4, n2)
            );
        }),
        n(o2, [
            {
                key: "type",
                get: function () {
                    return K.ServerFilter;
                },
            },
        ]),
        o2
    );
})(tt);
var lt = 0;
var ct = [];
var ft = [];
var pt = c.__b;
var dt = c.__r;
var ht = c.diffed;
var _t = c.__c;
var mt = c.unmount;
function vt(t3, n2) {
    (c.__h && c.__h(it, t3, lt || n2), (lt = 0));
    var e2 = it.__H || (it.__H = { __: [], __h: [] });
    return (t3 >= e2.__.length && e2.__.push({ __V: ft }), e2.__[t3]);
}
function yt(t3) {
    return (
        (lt = 1),
        (function (t4, n2, e2) {
            var r2 = vt(ot++, 2);
            if (
                ((r2.t = t4),
                !r2.__c &&
                    ((r2.__ = [
                        Et(void 0, n2),
                        function (t5) {
                            var n3 = r2.__N ? r2.__N[0] : r2.__[0],
                                e3 = r2.t(n3, t5);
                            n3 !== e3 && ((r2.__N = [e3, r2.__[1]]), r2.__c.setState({}));
                        },
                    ]),
                    (r2.__c = it),
                    !it.u))
            ) {
                it.u = true;
                var o2 = it.shouldComponentUpdate;
                it.shouldComponentUpdate = function (t5, n3, e3) {
                    if (!r2.__c.__H) return true;
                    var i2 = r2.__c.__H.__.filter(function (t6) {
                        return t6.__c;
                    });
                    if (
                        i2.every(function (t6) {
                            return !t6.__N;
                        })
                    )
                        return !o2 || o2.call(this, t5, n3, e3);
                    var u2 = false;
                    return (
                        i2.forEach(function (t6) {
                            if (t6.__N) {
                                var n4 = t6.__[0];
                                ((t6.__ = t6.__N),
                                    (t6.__N = void 0),
                                    n4 !== t6.__[0] && (u2 = true));
                            }
                        }),
                        !(!u2 && r2.__c.props === t5) && (!o2 || o2.call(this, t5, n3, e3))
                    );
                };
            }
            return r2.__N || r2.__;
        })(Et, t3)
    );
}
function gt(t3, n2) {
    var e2 = vt(ot++, 3);
    !c.__s && Ct(e2.__H, n2) && ((e2.__ = t3), (e2.i = n2), it.__H.__h.push(e2));
}
function bt(t3) {
    return (
        (lt = 5),
        wt(function () {
            return { current: t3 };
        }, [])
    );
}
function wt(t3, n2) {
    var e2 = vt(ot++, 7);
    return Ct(e2.__H, n2) ? ((e2.__V = t3()), (e2.i = n2), (e2.__h = t3), e2.__V) : e2.__;
}
function xt() {
    for (var t3; (t3 = ct.shift()); )
        if (t3.__P && t3.__H)
            try {
                (t3.__H.__h.forEach(Nt), t3.__H.__h.forEach(Pt), (t3.__H.__h = []));
            } catch (n2) {
                ((t3.__H.__h = []), c.__e(n2, t3.__v));
            }
}
((c.__b = function (t3) {
    ((it = null), pt && pt(t3));
}),
    (c.__r = function (t3) {
        (dt && dt(t3), (ot = 0));
        var n2 = (it = t3.__c).__H;
        (n2 &&
            (ut === it
                ? ((n2.__h = []),
                  (it.__h = []),
                  n2.__.forEach(function (t4) {
                      (t4.__N && (t4.__ = t4.__N), (t4.__V = ft), (t4.__N = t4.i = void 0));
                  }))
                : (n2.__h.forEach(Nt), n2.__h.forEach(Pt), (n2.__h = []))),
            (ut = it));
    }),
    (c.diffed = function (t3) {
        ht && ht(t3);
        var n2 = t3.__c;
        (n2 &&
            n2.__H &&
            (n2.__H.__h.length &&
                ((1 !== ct.push(n2) && st === c.requestAnimationFrame) ||
                    ((st = c.requestAnimationFrame) || St)(xt)),
            n2.__H.__.forEach(function (t4) {
                (t4.i && (t4.__H = t4.i),
                    t4.__V !== ft && (t4.__ = t4.__V),
                    (t4.i = void 0),
                    (t4.__V = ft));
            })),
            (ut = it = null));
    }),
    (c.__c = function (t3, n2) {
        (n2.some(function (t4) {
            try {
                (t4.__h.forEach(Nt),
                    (t4.__h = t4.__h.filter(function (t5) {
                        return !t5.__ || Pt(t5);
                    })));
            } catch (e2) {
                (n2.some(function (t5) {
                    t5.__h && (t5.__h = []);
                }),
                    (n2 = []),
                    c.__e(e2, t4.__v));
            }
        }),
            _t && _t(t3, n2));
    }),
    (c.unmount = function (t3) {
        mt && mt(t3);
        var n2,
            e2 = t3.__c;
        e2 &&
            e2.__H &&
            (e2.__H.__.forEach(function (t4) {
                try {
                    Nt(t4);
                } catch (t5) {
                    n2 = t5;
                }
            }),
            (e2.__H = void 0),
            n2 && c.__e(n2, e2.__v));
    }));
var kt = "function" == typeof requestAnimationFrame;
function St(t3) {
    var n2,
        e2 = function () {
            (clearTimeout(r2), kt && cancelAnimationFrame(n2), setTimeout(t3));
        },
        r2 = setTimeout(e2, 100);
    kt && (n2 = requestAnimationFrame(e2));
}
function Nt(t3) {
    var n2 = it,
        e2 = t3.__c;
    ("function" == typeof e2 && ((t3.__c = void 0), e2()), (it = n2));
}
function Pt(t3) {
    var n2 = it;
    ((t3.__c = t3.__()), (it = n2));
}
function Ct(t3, n2) {
    return (
        !t3 ||
        t3.length !== n2.length ||
        n2.some(function (n3, e2) {
            return n3 !== t3[e2];
        })
    );
}
function Et(t3, n2) {
    return "function" == typeof n2 ? n2(t3) : n2;
}
function It() {
    return (function (t3) {
        var n2 = it.context[t3.__c],
            e2 = vt(ot++, 9);
        return (
            (e2.c = t3),
            n2 ? (null == e2.__ && ((e2.__ = true), n2.sub(it)), n2.props.value) : t3.__
        );
    })(fn);
}
var Tt = {
    search: { placeholder: "Type a keyword..." },
    sort: { sortAsc: "Sort column ascending", sortDesc: "Sort column descending" },
    pagination: {
        previous: "Previous",
        next: "Next",
        navigate: function (t3, n2) {
            return "Page " + t3 + " of " + n2;
        },
        page: function (t3) {
            return "Page " + t3;
        },
        showing: "Showing",
        of: "of",
        to: "to",
        results: "results",
    },
    loading: "Loading...",
    noRecordsFound: "No matching records found",
    error: "An error happened while fetching the data",
};
var Lt = /* @__PURE__ */ (function () {
    function t3(t4) {
        ((this._language = void 0),
            (this._defaultLanguage = void 0),
            (this._language = t4),
            (this._defaultLanguage = Tt));
    }
    var n2 = t3.prototype;
    return (
        (n2.getString = function (t4, n3) {
            if (!n3 || !t4) return null;
            var e2 = t4.split("."),
                r2 = e2[0];
            if (n3[r2]) {
                var o2 = n3[r2];
                return "string" == typeof o2
                    ? function () {
                          return o2;
                      }
                    : "function" == typeof o2
                      ? o2
                      : this.getString(e2.slice(1).join("."), o2);
            }
            return null;
        }),
        (n2.translate = function (t4) {
            var n3,
                e2 = this.getString(t4, this._language);
            return (n3 = e2 || this.getString(t4, this._defaultLanguage))
                ? n3.apply(void 0, [].slice.call(arguments, 1))
                : t4;
        }),
        t3
    );
})();
function At() {
    var t3 = It();
    return function (n2) {
        var e2;
        return (e2 = t3.translator).translate.apply(e2, [n2].concat([].slice.call(arguments, 1)));
    };
}
var Ot = function (t3) {
    return function (n2) {
        return e({}, n2, { search: { keyword: t3 } });
    };
};
function Ht() {
    return It().store;
}
function jt(t3) {
    var n2 = Ht(),
        e2 = yt(t3(n2.getState())),
        r2 = e2[0],
        o2 = e2[1];
    return (
        gt(function () {
            return n2.subscribe(function () {
                var e3 = t3(n2.getState());
                r2 !== e3 && o2(e3);
            });
        }, []),
        r2
    );
}
function Dt() {
    var t3,
        n2 = yt(void 0),
        e2 = n2[0],
        r2 = n2[1],
        o2 = It(),
        i2 = o2.search,
        u2 = At(),
        s2 = Ht().dispatch,
        a2 = jt(function (t4) {
            return t4.search;
        });
    (gt(
        function () {
            e2 && e2.setProps({ keyword: null == a2 ? void 0 : a2.keyword });
        },
        [a2, e2],
    ),
        gt(
            function () {
                (r2(
                    i2.server
                        ? new at({ keyword: i2.keyword, url: i2.server.url, body: i2.server.body })
                        : new nt({
                              keyword: i2.keyword,
                              columns: o2.header && o2.header.columns,
                              ignoreHiddenColumns:
                                  i2.ignoreHiddenColumns || void 0 === i2.ignoreHiddenColumns,
                              selector: i2.selector,
                          }),
                ),
                    i2.keyword && s2(Ot(i2.keyword)));
            },
            [i2],
        ),
        gt(
            function () {
                if (e2)
                    return (
                        o2.pipeline.register(e2),
                        function () {
                            return o2.pipeline.unregister(e2);
                        }
                    );
            },
            [o2, e2],
        ));
    var l2,
        c2,
        f2,
        p2 = (function (t4, n3) {
            return (
                (lt = 8),
                wt(function () {
                    return t4;
                }, n3)
            );
        })(
            ((l2 = function (t4) {
                t4.target instanceof HTMLInputElement && s2(Ot(t4.target.value));
            }),
            (c2 = e2 instanceof at ? i2.debounceTimeout || 250 : 0),
            function () {
                var t4 = arguments;
                return new Promise(function (n3) {
                    (f2 && clearTimeout(f2),
                        (f2 = setTimeout(function () {
                            return n3(l2.apply(void 0, [].slice.call(t4)));
                        }, c2)));
                });
            }),
            [i2, e2],
        );
    return w(
        "div",
        { className: et(rt("search", null == (t3 = o2.className) ? void 0 : t3.search)) },
        w("input", {
            type: "search",
            placeholder: u2("search.placeholder"),
            "aria-label": u2("search.placeholder"),
            onInput: p2,
            className: rt(et("input"), et("search", "input")),
            defaultValue: (null == a2 ? void 0 : a2.keyword) || "",
        }),
    );
}
var Mt = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    r(e2, t3);
    var o2 = e2.prototype;
    return (
        (o2.validateProps = function () {
            if (isNaN(Number(this.props.limit)) || isNaN(Number(this.props.page)))
                throw Error("Invalid parameters passed");
        }),
        (o2._process = function (t4) {
            var n2 = this.props.page;
            return new J(t4.rows.slice(n2 * this.props.limit, (n2 + 1) * this.props.limit));
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Limit;
                },
            },
        ]),
        e2
    );
})(tt);
var Ft = /* @__PURE__ */ (function (t3) {
    function o2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(o2, t3),
        (o2.prototype._process = function (t4) {
            var n2 = {};
            return (
                this.props.url &&
                    (n2.url = this.props.url(t4.url, this.props.page, this.props.limit)),
                this.props.body &&
                    (n2.body = this.props.body(t4.body, this.props.page, this.props.limit)),
                e({}, t4, n2)
            );
        }),
        n(o2, [
            {
                key: "type",
                get: function () {
                    return K.ServerLimit;
                },
            },
        ]),
        o2
    );
})(tt);
function Rt() {
    var t3 = It(),
        n2 = t3.pagination,
        e2 = n2.server,
        r2 = n2.summary,
        o2 = void 0 === r2 || r2,
        i2 = n2.nextButton,
        u2 = void 0 === i2 || i2,
        s2 = n2.prevButton,
        a2 = void 0 === s2 || s2,
        l2 = n2.buttonsCount,
        c2 = void 0 === l2 ? 3 : l2,
        f2 = n2.limit,
        p2 = void 0 === f2 ? 10 : f2,
        d2 = n2.page,
        h6 = void 0 === d2 ? 0 : d2,
        _2 = n2.resetPageOnUpdate,
        m2 = void 0 === _2 || _2,
        v2 = bt(null),
        y2 = yt(h6),
        g2 = y2[0],
        b2 = y2[1],
        x2 = yt(0),
        k = x2[0],
        N2 = x2[1],
        P2 = At();
    gt(function () {
        return (
            e2
                ? ((v2.current = new Ft({ limit: p2, page: g2, url: e2.url, body: e2.body })),
                  t3.pipeline.register(v2.current))
                : ((v2.current = new Mt({ limit: p2, page: g2 })),
                  t3.pipeline.register(v2.current)),
            v2.current instanceof Ft
                ? t3.pipeline.on("afterProcess", function (t4) {
                      return N2(t4.length);
                  })
                : v2.current instanceof Mt &&
                  v2.current.on("beforeProcess", function (t4) {
                      return N2(t4.length);
                  }),
            t3.pipeline.on("updated", C2),
            t3.pipeline.on("error", function () {
                (N2(0), b2(0));
            }),
            function () {
                (t3.pipeline.unregister(v2.current), t3.pipeline.off("updated", C2));
            }
        );
    }, []);
    var C2 = function (t4) {
            m2 &&
                t4 !== v2.current &&
                (b2(0), 0 !== v2.current.props.page && v2.current.setProps({ page: 0 }));
        },
        E2 = function () {
            return Math.ceil(k / p2);
        },
        I2 = function (t4) {
            if (t4 >= E2() || t4 < 0 || t4 === g2) return null;
            (b2(t4), v2.current.setProps({ page: t4 }));
        };
    return w(
        "div",
        { className: rt(et("pagination"), t3.className.pagination) },
        w(
            S,
            null,
            o2 &&
                k > 0 &&
                w(
                    "div",
                    {
                        role: "status",
                        "aria-live": "polite",
                        className: rt(et("summary"), t3.className.paginationSummary),
                        title: P2("pagination.navigate", g2 + 1, E2()),
                    },
                    P2("pagination.showing"),
                    " ",
                    w("b", null, P2("" + (g2 * p2 + 1))),
                    " ",
                    P2("pagination.to"),
                    " ",
                    w("b", null, P2("" + Math.min((g2 + 1) * p2, k))),
                    " ",
                    P2("pagination.of"),
                    " ",
                    w("b", null, P2("" + k)),
                    " ",
                    P2("pagination.results"),
                ),
        ),
        w(
            "div",
            { className: et("pages") },
            a2 &&
                w(
                    "button",
                    {
                        tabIndex: 0,
                        role: "button",
                        disabled: 0 === g2,
                        onClick: function () {
                            return I2(g2 - 1);
                        },
                        title: P2("pagination.previous"),
                        "aria-label": P2("pagination.previous"),
                        className: rt(
                            t3.className.paginationButton,
                            t3.className.paginationButtonPrev,
                        ),
                    },
                    P2("pagination.previous"),
                ),
            (function () {
                if (c2 <= 0) return null;
                var n3 = Math.min(E2(), c2),
                    e3 = Math.min(g2, Math.floor(n3 / 2));
                return (
                    g2 + Math.floor(n3 / 2) >= E2() && (e3 = n3 - (E2() - g2)),
                    w(
                        S,
                        null,
                        E2() > n3 &&
                            g2 - e3 > 0 &&
                            w(
                                S,
                                null,
                                w(
                                    "button",
                                    {
                                        tabIndex: 0,
                                        role: "button",
                                        onClick: function () {
                                            return I2(0);
                                        },
                                        title: P2("pagination.firstPage"),
                                        "aria-label": P2("pagination.firstPage"),
                                        className: t3.className.paginationButton,
                                    },
                                    P2("1"),
                                ),
                                w(
                                    "button",
                                    {
                                        tabIndex: -1,
                                        className: rt(et("spread"), t3.className.paginationButton),
                                    },
                                    "...",
                                ),
                            ),
                        Array.from(Array(n3).keys())
                            .map(function (t4) {
                                return g2 + (t4 - e3);
                            })
                            .map(function (n4) {
                                return w(
                                    "button",
                                    {
                                        tabIndex: 0,
                                        role: "button",
                                        onClick: function () {
                                            return I2(n4);
                                        },
                                        className: rt(
                                            g2 === n4
                                                ? rt(
                                                      et("currentPage"),
                                                      t3.className.paginationButtonCurrent,
                                                  )
                                                : null,
                                            t3.className.paginationButton,
                                        ),
                                        title: P2("pagination.page", n4 + 1),
                                        "aria-label": P2("pagination.page", n4 + 1),
                                    },
                                    P2("" + (n4 + 1)),
                                );
                            }),
                        E2() > n3 &&
                            E2() > g2 + e3 + 1 &&
                            w(
                                S,
                                null,
                                w(
                                    "button",
                                    {
                                        tabIndex: -1,
                                        className: rt(et("spread"), t3.className.paginationButton),
                                    },
                                    "...",
                                ),
                                w(
                                    "button",
                                    {
                                        tabIndex: 0,
                                        role: "button",
                                        onClick: function () {
                                            return I2(E2() - 1);
                                        },
                                        title: P2("pagination.page", E2()),
                                        "aria-label": P2("pagination.page", E2()),
                                        className: t3.className.paginationButton,
                                    },
                                    P2("" + E2()),
                                ),
                            ),
                    )
                );
            })(),
            u2 &&
                w(
                    "button",
                    {
                        tabIndex: 0,
                        role: "button",
                        disabled: E2() === g2 + 1 || 0 === E2(),
                        onClick: function () {
                            return I2(g2 + 1);
                        },
                        title: P2("pagination.next"),
                        "aria-label": P2("pagination.next"),
                        className: rt(
                            t3.className.paginationButton,
                            t3.className.paginationButtonNext,
                        ),
                    },
                    P2("pagination.next"),
                ),
        ),
    );
}
function Ut(t3, n2) {
    return "string" == typeof t3
        ? t3.indexOf("%") > -1
            ? (n2 / 100) * parseInt(t3, 10)
            : parseInt(t3, 10)
        : t3;
}
function Wt(t3) {
    return t3 ? Math.floor(t3) + "px" : "";
}
function Bt(t3) {
    var n2 = t3.tableRef.cloneNode(true);
    return (
        (n2.style.position = "absolute"),
        (n2.style.width = "100%"),
        (n2.style.zIndex = "-2147483640"),
        (n2.style.visibility = "hidden"),
        w("div", {
            ref: function (t4) {
                t4 && t4.appendChild(n2);
            },
        })
    );
}
function qt(t3) {
    if (!t3) return "";
    var n2 = t3.split(" ");
    return 1 === n2.length && /([a-z][A-Z])+/g.test(t3)
        ? t3
        : n2
              .map(function (t4, n3) {
                  return 0 == n3
                      ? t4.toLowerCase()
                      : t4.charAt(0).toUpperCase() + t4.slice(1).toLowerCase();
              })
              .join("");
}
var zt;
var Vt = new /* @__PURE__ */ ((function () {
    function t3() {}
    var n2 = t3.prototype;
    return (
        (n2.format = function (t4, n3) {
            return "[Grid.js] [" + n3.toUpperCase() + "]: " + t4;
        }),
        (n2.error = function (t4, n3) {
            void 0 === n3 && (n3 = false);
            var e2 = this.format(t4, "error");
            if (n3) throw Error(e2);
            console.error(e2);
        }),
        (n2.warn = function (t4) {
            console.warn(this.format(t4, "warn"));
        }),
        (n2.info = function (t4) {
            console.info(this.format(t4, "info"));
        }),
        t3
    );
})())();
!(function (t3) {
    ((t3[(t3.Header = 0)] = "Header"),
        (t3[(t3.Footer = 1)] = "Footer"),
        (t3[(t3.Cell = 2)] = "Cell"));
})(zt || (zt = {}));
var $t = /* @__PURE__ */ (function () {
    function t3() {
        ((this.plugins = void 0), (this.plugins = []));
    }
    var n2 = t3.prototype;
    return (
        (n2.get = function (t4) {
            return this.plugins.find(function (n3) {
                return n3.id === t4;
            });
        }),
        (n2.add = function (t4) {
            return t4.id
                ? this.get(t4.id)
                    ? (Vt.error("Duplicate plugin ID: " + t4.id), this)
                    : (this.plugins.push(t4), this)
                : (Vt.error("Plugin ID cannot be empty"), this);
        }),
        (n2.remove = function (t4) {
            var n3 = this.get(t4);
            return (n3 && this.plugins.splice(this.plugins.indexOf(n3), 1), this);
        }),
        (n2.list = function (t4) {
            var n3;
            return (
                (n3 =
                    null != t4 || null != t4
                        ? this.plugins.filter(function (n4) {
                              return n4.position === t4;
                          })
                        : this.plugins),
                n3.sort(function (t5, n4) {
                    return t5.order && n4.order ? t5.order - n4.order : 1;
                })
            );
        }),
        t3
    );
})();
function Gt(t3) {
    var n2 = this,
        r2 = It();
    if (t3.pluginId) {
        var o2 = r2.plugin.get(t3.pluginId);
        return o2 ? w(S, {}, w(o2.component, e({ plugin: o2 }, t3.props))) : null;
    }
    return void 0 !== t3.position
        ? w(
              S,
              {},
              r2.plugin.list(t3.position).map(function (t4) {
                  return w(t4.component, e({ plugin: t4 }, n2.props.props));
              }),
          )
        : null;
}
var Kt = /* @__PURE__ */ (function (t3) {
    function o2() {
        var n2;
        return (((n2 = t3.call(this) || this)._columns = void 0), (n2._columns = []), n2);
    }
    r(o2, t3);
    var i2 = o2.prototype;
    return (
        (i2.adjustWidth = function (t4, n2, r2) {
            var i3 = t4.container,
                u2 = t4.autoWidth;
            if (!i3) return this;
            var a2 = i3.clientWidth,
                l2 = {};
            n2.current &&
                u2 &&
                (q(w(Bt, { tableRef: n2.current }), r2.current),
                (l2 = (function (t5) {
                    var n3 = t5.querySelector("table");
                    if (!n3) return {};
                    var r3 = n3.className,
                        o3 = n3.style.cssText;
                    ((n3.className = r3 + " " + et("shadowTable")),
                        (n3.style.tableLayout = "auto"),
                        (n3.style.width = "auto"),
                        (n3.style.padding = "0"),
                        (n3.style.margin = "0"),
                        (n3.style.border = "none"),
                        (n3.style.outline = "none"));
                    var i4 = Array.from(n3.parentNode.querySelectorAll("thead th")).reduce(
                        function (t6, n4) {
                            var r4;
                            return (
                                (n4.style.width = n4.clientWidth + "px"),
                                e(
                                    (((r4 = {})[n4.getAttribute("data-column-id")] = {
                                        minWidth: n4.clientWidth,
                                    }),
                                    r4),
                                    t6,
                                )
                            );
                        },
                        {},
                    );
                    return (
                        (n3.className = r3),
                        (n3.style.cssText = o3),
                        (n3.style.tableLayout = "auto"),
                        Array.from(n3.parentNode.querySelectorAll("thead th")).reduce(function (
                            t6,
                            n4,
                        ) {
                            return (
                                (t6[n4.getAttribute("data-column-id")].width = n4.clientWidth),
                                t6
                            );
                        }, i4)
                    );
                })(r2.current)));
            for (
                var c2,
                    f2 = s(
                        o2.tabularFormat(this.columns).reduce(function (t5, n3) {
                            return t5.concat(n3);
                        }, []),
                    );
                !(c2 = f2()).done;
            ) {
                var p2 = c2.value;
                (p2.columns && p2.columns.length > 0) ||
                    (!p2.width && u2
                        ? p2.id in l2 &&
                          ((p2.width = Wt(l2[p2.id].width)), (p2.minWidth = Wt(l2[p2.id].minWidth)))
                        : (p2.width = Wt(Ut(p2.width, a2))));
            }
            return (n2.current && u2 && q(null, r2.current), this);
        }),
        (i2.setSort = function (t4, n2) {
            for (var r2, o3 = s(n2 || this.columns || []); !(r2 = o3()).done; ) {
                var i3 = r2.value;
                (i3.columns && i3.columns.length > 0
                    ? (i3.sort = void 0)
                    : void 0 === i3.sort && t4
                      ? (i3.sort = {})
                      : i3.sort
                        ? "object" == typeof i3.sort && (i3.sort = e({}, i3.sort))
                        : (i3.sort = void 0),
                    i3.columns && this.setSort(t4, i3.columns));
            }
        }),
        (i2.setResizable = function (t4, n2) {
            for (var e2, r2 = s(n2 || this.columns || []); !(e2 = r2()).done; ) {
                var o3 = e2.value;
                (void 0 === o3.resizable && (o3.resizable = t4),
                    o3.columns && this.setResizable(t4, o3.columns));
            }
        }),
        (i2.setID = function (t4) {
            for (var n2, e2 = s(t4 || this.columns || []); !(n2 = e2()).done; ) {
                var r2 = n2.value;
                (r2.id || "string" != typeof r2.name || (r2.id = qt(r2.name)),
                    r2.id ||
                        Vt.error(
                            'Could not find a valid ID for one of the columns. Make sure a valid "id" is set for all columns.',
                        ),
                    r2.columns && this.setID(r2.columns));
            }
        }),
        (i2.populatePlugins = function (t4, n2) {
            for (var r2, o3 = s(n2); !(r2 = o3()).done; ) {
                var i3 = r2.value;
                void 0 !== i3.plugin && t4.add(e({ id: i3.id }, i3.plugin, { position: zt.Cell }));
            }
        }),
        (o2.fromColumns = function (t4) {
            for (var n2, e2 = new o2(), r2 = s(t4); !(n2 = r2()).done; ) {
                var i3 = n2.value;
                if ("string" == typeof i3 || p(i3)) e2.columns.push({ name: i3 });
                else if ("object" == typeof i3) {
                    var u2 = i3;
                    (u2.columns && (u2.columns = o2.fromColumns(u2.columns).columns),
                        "object" == typeof u2.plugin && void 0 === u2.data && (u2.data = null),
                        e2.columns.push(i3));
                }
            }
            return e2;
        }),
        (o2.createFromConfig = function (t4) {
            var n2 = new o2();
            return (
                t4.from
                    ? (n2.columns = o2.fromHTMLTable(t4.from).columns)
                    : t4.columns
                      ? (n2.columns = o2.fromColumns(t4.columns).columns)
                      : !t4.data ||
                        "object" != typeof t4.data[0] ||
                        t4.data[0] instanceof Array ||
                        (n2.columns = Object.keys(t4.data[0]).map(function (t5) {
                            return { name: t5 };
                        })),
                n2.columns.length
                    ? (n2.setID(),
                      n2.setSort(t4.sort),
                      n2.setResizable(t4.resizable),
                      n2.populatePlugins(t4.plugin, n2.columns),
                      n2)
                    : null
            );
        }),
        (o2.fromHTMLTable = function (t4) {
            for (
                var n2, e2 = new o2(), r2 = s(t4.querySelector("thead").querySelectorAll("th"));
                !(n2 = r2()).done;
            ) {
                var i3 = n2.value;
                e2.columns.push({ name: i3.innerHTML, width: i3.width });
            }
            return e2;
        }),
        (o2.tabularFormat = function (t4) {
            var n2 = [],
                e2 = t4 || [],
                r2 = [];
            if (e2 && e2.length) {
                n2.push(e2);
                for (var o3, i3 = s(e2); !(o3 = i3()).done; ) {
                    var u2 = o3.value;
                    u2.columns && u2.columns.length && (r2 = r2.concat(u2.columns));
                }
                r2.length && (n2 = n2.concat(this.tabularFormat(r2)));
            }
            return n2;
        }),
        (o2.leafColumns = function (t4) {
            var n2 = [],
                e2 = t4 || [];
            if (e2 && e2.length)
                for (var r2, o3 = s(e2); !(r2 = o3()).done; ) {
                    var i3 = r2.value;
                    ((i3.columns && 0 !== i3.columns.length) || n2.push(i3),
                        i3.columns && (n2 = n2.concat(this.leafColumns(i3.columns))));
                }
            return n2;
        }),
        (o2.maximumDepth = function (t4) {
            return this.tabularFormat([t4]).length - 1;
        }),
        n(o2, [
            {
                key: "columns",
                get: function () {
                    return this._columns;
                },
                set: function (t4) {
                    this._columns = t4;
                },
            },
            {
                key: "visibleColumns",
                get: function () {
                    return this._columns.filter(function (t4) {
                        return !t4.hidden;
                    });
                },
            },
        ]),
        o2
    );
})(V);
var Xt = function () {};
var Zt = /* @__PURE__ */ (function (t3) {
    function n2(n3) {
        var e3;
        return (((e3 = t3.call(this) || this).data = void 0), e3.set(n3), e3);
    }
    r(n2, t3);
    var e2 = n2.prototype;
    return (
        (e2.get = function () {
            try {
                return Promise.resolve(this.data()).then(function (t4) {
                    return { data: t4, total: t4.length };
                });
            } catch (t4) {
                return Promise.reject(t4);
            }
        }),
        (e2.set = function (t4) {
            return (
                t4 instanceof Array
                    ? (this.data = function () {
                          return t4;
                      })
                    : t4 instanceof Function && (this.data = t4),
                this
            );
        }),
        n2
    );
})(Xt);
var Jt = /* @__PURE__ */ (function (t3) {
    function n2(n3) {
        var e2;
        return (((e2 = t3.call(this) || this).options = void 0), (e2.options = n3), e2);
    }
    r(n2, t3);
    var o2 = n2.prototype;
    return (
        (o2.handler = function (t4) {
            return "function" == typeof this.options.handle
                ? this.options.handle(t4)
                : t4.ok
                  ? t4.json()
                  : (Vt.error("Could not fetch data: " + t4.status + " - " + t4.statusText, true),
                    null);
        }),
        (o2.get = function (t4) {
            var n3 = e({}, this.options, t4);
            return "function" == typeof n3.data
                ? n3.data(n3)
                : fetch(n3.url, n3)
                      .then(this.handler.bind(this))
                      .then(function (t5) {
                          return {
                              data: n3.then(t5),
                              total: "function" == typeof n3.total ? n3.total(t5) : void 0,
                          };
                      });
        }),
        n2
    );
})(Xt);
var Qt = /* @__PURE__ */ (function () {
    function t3() {}
    return (
        (t3.createFromConfig = function (t4) {
            var n2 = null;
            return (
                t4.data && (n2 = new Zt(t4.data)),
                t4.from &&
                    ((n2 = new Zt(this.tableElementToArray(t4.from))),
                    (t4.from.style.display = "none")),
                t4.server && (n2 = new Jt(t4.server)),
                n2 || Vt.error("Could not determine the storage type", true),
                n2
            );
        }),
        (t3.tableElementToArray = function (t4) {
            for (
                var n2, e2, r2 = [], o2 = s(t4.querySelector("tbody").querySelectorAll("tr"));
                !(n2 = o2()).done;
            ) {
                for (
                    var i2, u2 = [], a2 = s(n2.value.querySelectorAll("td"));
                    !(i2 = a2()).done;
                ) {
                    var l2 = i2.value;
                    1 === l2.childNodes.length && l2.childNodes[0].nodeType === Node.TEXT_NODE
                        ? u2.push(
                              ((e2 = l2.innerHTML),
                              new DOMParser().parseFromString(e2, "text/html").documentElement
                                  .textContent),
                          )
                        : u2.push(G(l2.innerHTML));
                }
                r2.push(u2);
            }
            return r2;
        }),
        t3
    );
})();
var Yt =
    "undefined" != typeof Symbol
        ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))
        : "@@iterator";
function tn(t3, n2, e2) {
    if (!t3.s) {
        if (e2 instanceof nn) {
            if (!e2.s) return void (e2.o = tn.bind(null, t3, n2));
            (1 & n2 && (n2 = e2.s), (e2 = e2.v));
        }
        if (e2 && e2.then) return void e2.then(tn.bind(null, t3, n2), tn.bind(null, t3, 2));
        ((t3.s = n2), (t3.v = e2));
        var r2 = t3.o;
        r2 && r2(t3);
    }
}
var nn = /* @__PURE__ */ (function () {
    function t3() {}
    return (
        (t3.prototype.then = function (n2, e2) {
            var r2 = new t3(),
                o2 = this.s;
            if (o2) {
                var i2 = 1 & o2 ? n2 : e2;
                if (i2) {
                    try {
                        tn(r2, 1, i2(this.v));
                    } catch (t4) {
                        tn(r2, 2, t4);
                    }
                    return r2;
                }
                return this;
            }
            return (
                (this.o = function (t4) {
                    try {
                        var o3 = t4.v;
                        1 & t4.s
                            ? tn(r2, 1, n2 ? n2(o3) : o3)
                            : e2
                              ? tn(r2, 1, e2(o3))
                              : tn(r2, 2, o3);
                    } catch (t5) {
                        tn(r2, 2, t5);
                    }
                }),
                r2
            );
        }),
        t3
    );
})();
function en(t3) {
    return t3 instanceof nn && 1 & t3.s;
}
var rn = /* @__PURE__ */ (function (t3) {
    function e2(n2) {
        var e3;
        return (
            ((e3 = t3.call(this) || this)._steps = /* @__PURE__ */ new Map()),
            (e3.cache = /* @__PURE__ */ new Map()),
            (e3.lastProcessorIndexUpdated = -1),
            n2 &&
                n2.forEach(function (t4) {
                    return e3.register(t4);
                }),
            e3
        );
    }
    r(e2, t3);
    var o2 = e2.prototype;
    return (
        (o2.clearCache = function () {
            ((this.cache = /* @__PURE__ */ new Map()), (this.lastProcessorIndexUpdated = -1));
        }),
        (o2.register = function (t4, n2) {
            if ((void 0 === n2 && (n2 = null), !t4)) throw Error("Processor is not defined");
            if (null === t4.type) throw Error("Processor type is not defined");
            if (this.findProcessorIndexByID(t4.id) > -1)
                throw Error("Processor ID " + t4.id + " is already defined");
            return (
                t4.on("propsUpdated", this.processorPropsUpdated.bind(this)),
                this.addProcessorByPriority(t4, n2),
                this.afterRegistered(t4),
                t4
            );
        }),
        (o2.tryRegister = function (t4, n2) {
            void 0 === n2 && (n2 = null);
            try {
                return this.register(t4, n2);
            } catch (t5) {}
        }),
        (o2.unregister = function (t4) {
            if (t4 && -1 !== this.findProcessorIndexByID(t4.id)) {
                var n2 = this._steps.get(t4.type);
                n2 &&
                    n2.length &&
                    (this._steps.set(
                        t4.type,
                        n2.filter(function (n3) {
                            return n3 != t4;
                        }),
                    ),
                    this.emit("updated", t4));
            }
        }),
        (o2.addProcessorByPriority = function (t4, n2) {
            var e3 = this._steps.get(t4.type);
            if (!e3) {
                var r2 = [];
                (this._steps.set(t4.type, r2), (e3 = r2));
            }
            if (null === n2 || n2 < 0) e3.push(t4);
            else if (e3[n2]) {
                var o3 = e3.slice(0, n2 - 1),
                    i2 = e3.slice(n2 + 1);
                this._steps.set(t4.type, o3.concat(t4).concat(i2));
            } else e3[n2] = t4;
        }),
        (o2.getStepsByType = function (t4) {
            return this.steps.filter(function (n2) {
                return n2.type === t4;
            });
        }),
        (o2.getSortedProcessorTypes = function () {
            return Object.keys(K)
                .filter(function (t4) {
                    return !isNaN(Number(t4));
                })
                .map(function (t4) {
                    return Number(t4);
                });
        }),
        (o2.process = function (t4) {
            try {
                var n2 = function (t5) {
                        return (
                            (e3.lastProcessorIndexUpdated = o3.length),
                            e3.emit("afterProcess", i2),
                            i2
                        );
                    },
                    e3 = this,
                    r2 = e3.lastProcessorIndexUpdated,
                    o3 = e3.steps,
                    i2 = t4,
                    u2 = (function (t5, n3) {
                        try {
                            var u3 = (function (t6, n4, e4) {
                                if ("function" == typeof t6[Yt]) {
                                    var r3,
                                        o4,
                                        i3,
                                        u4 = t6[Yt]();
                                    if (
                                        ((function t7(e5) {
                                            try {
                                                for (; !(r3 = u4.next()).done; )
                                                    if ((e5 = n4(r3.value)) && e5.then) {
                                                        if (!en(e5))
                                                            return void e5.then(
                                                                t7,
                                                                i3 ||
                                                                    (i3 = tn.bind(
                                                                        null,
                                                                        (o4 = new nn()),
                                                                        2,
                                                                    )),
                                                            );
                                                        e5 = e5.v;
                                                    }
                                                o4 ? tn(o4, 1, e5) : (o4 = e5);
                                            } catch (t8) {
                                                tn(o4 || (o4 = new nn()), 2, t8);
                                            }
                                        })(),
                                        u4.return)
                                    ) {
                                        var s2 = function (t7) {
                                            try {
                                                r3.done || u4.return();
                                            } catch (t8) {}
                                            return t7;
                                        };
                                        if (o4 && o4.then)
                                            return o4.then(s2, function (t7) {
                                                throw s2(t7);
                                            });
                                        s2();
                                    }
                                    return o4;
                                }
                                if (!("length" in t6))
                                    throw new TypeError("Object is not iterable");
                                for (var a2 = [], l2 = 0; l2 < t6.length; l2++) a2.push(t6[l2]);
                                return (function (t7, n5, e5) {
                                    var r4,
                                        o5,
                                        i4 = -1;
                                    return (
                                        (function e6(u5) {
                                            try {
                                                for (; ++i4 < t7.length; )
                                                    if ((u5 = n5(i4)) && u5.then) {
                                                        if (!en(u5))
                                                            return void u5.then(
                                                                e6,
                                                                o5 ||
                                                                    (o5 = tn.bind(
                                                                        null,
                                                                        (r4 = new nn()),
                                                                        2,
                                                                    )),
                                                            );
                                                        u5 = u5.v;
                                                    }
                                                r4 ? tn(r4, 1, u5) : (r4 = u5);
                                            } catch (t8) {
                                                tn(r4 || (r4 = new nn()), 2, t8);
                                            }
                                        })(),
                                        r4
                                    );
                                })(a2, function (t7) {
                                    return n4(a2[t7]);
                                });
                            })(o3, function (t6) {
                                var n4 = e3.findProcessorIndexByID(t6.id),
                                    o4 = (function () {
                                        if (n4 >= r2)
                                            return Promise.resolve(t6.process(i2)).then(
                                                function (n5) {
                                                    e3.cache.set(t6.id, (i2 = n5));
                                                },
                                            );
                                        i2 = e3.cache.get(t6.id);
                                    })();
                                if (o4 && o4.then) return o4.then(function () {});
                            });
                        } catch (t6) {
                            return n3(t6);
                        }
                        return u3 && u3.then ? u3.then(void 0, n3) : u3;
                    })(0, function (t5) {
                        throw (Vt.error(t5), e3.emit("error", i2), t5);
                    });
                return Promise.resolve(u2 && u2.then ? u2.then(n2) : n2());
            } catch (t5) {
                return Promise.reject(t5);
            }
        }),
        (o2.findProcessorIndexByID = function (t4) {
            return this.steps.findIndex(function (n2) {
                return n2.id == t4;
            });
        }),
        (o2.setLastProcessorIndex = function (t4) {
            var n2 = this.findProcessorIndexByID(t4.id);
            this.lastProcessorIndexUpdated > n2 && (this.lastProcessorIndexUpdated = n2);
        }),
        (o2.processorPropsUpdated = function (t4) {
            (this.setLastProcessorIndex(t4), this.emit("propsUpdated"), this.emit("updated", t4));
        }),
        (o2.afterRegistered = function (t4) {
            (this.setLastProcessorIndex(t4), this.emit("afterRegister"), this.emit("updated", t4));
        }),
        n(e2, [
            {
                key: "steps",
                get: function () {
                    for (
                        var t4, n2 = [], e3 = s(this.getSortedProcessorTypes());
                        !(t4 = e3()).done;
                    ) {
                        var r2 = this._steps.get(t4.value);
                        r2 && r2.length && (n2 = n2.concat(r2));
                    }
                    return n2.filter(function (t5) {
                        return t5;
                    });
                },
            },
        ]),
        e2
    );
})(Q);
var on = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(e2, t3),
        (e2.prototype._process = function (t4) {
            try {
                return Promise.resolve(this.props.storage.get(t4));
            } catch (t5) {
                return Promise.reject(t5);
            }
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Extractor;
                },
            },
        ]),
        e2
    );
})(tt);
var un = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(e2, t3),
        (e2.prototype._process = function (t4) {
            var n2 = J.fromArray(t4.data);
            return ((n2.length = t4.total), n2);
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Transformer;
                },
            },
        ]),
        e2
    );
})(tt);
var sn = /* @__PURE__ */ (function (t3) {
    function o2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(o2, t3),
        (o2.prototype._process = function () {
            return Object.entries(this.props.serverStorageOptions)
                .filter(function (t4) {
                    return "function" != typeof t4[1];
                })
                .reduce(function (t4, n2) {
                    var r2;
                    return e({}, t4, (((r2 = {})[n2[0]] = n2[1]), r2));
                }, {});
        }),
        n(o2, [
            {
                key: "type",
                get: function () {
                    return K.Initiator;
                },
            },
        ]),
        o2
    );
})(tt);
var an = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    r(e2, t3);
    var o2 = e2.prototype;
    return (
        (o2.castData = function (t4) {
            if (!t4 || !t4.length) return [];
            if (!this.props.header || !this.props.header.columns) return t4;
            var n2 = Kt.leafColumns(this.props.header.columns);
            return t4[0] instanceof Array
                ? t4.map(function (t5) {
                      var e3 = 0;
                      return n2.map(function (n3, r2) {
                          return void 0 !== n3.data
                              ? (e3++, "function" == typeof n3.data ? n3.data(t5) : n3.data)
                              : t5[r2 - e3];
                      });
                  })
                : "object" != typeof t4[0] || t4[0] instanceof Array
                  ? []
                  : t4.map(function (t5) {
                        return n2.map(function (n3, e3) {
                            return void 0 !== n3.data
                                ? "function" == typeof n3.data
                                    ? n3.data(t5)
                                    : n3.data
                                : n3.id
                                  ? t5[n3.id]
                                  : (Vt.error(
                                        "Could not find the correct cell for column at position " +
                                            e3 +
                                            ".\n                          Make sure either 'id' or 'selector' is defined for all columns.",
                                    ),
                                    null);
                        });
                    });
        }),
        (o2._process = function (t4) {
            return { data: this.castData(t4.data), total: t4.total };
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Transformer;
                },
            },
        ]),
        e2
    );
})(tt);
var ln = /* @__PURE__ */ (function () {
    function t3() {}
    return (
        (t3.createFromConfig = function (t4) {
            var n2 = new rn();
            return (
                t4.storage instanceof Jt &&
                    n2.register(new sn({ serverStorageOptions: t4.server })),
                n2.register(new on({ storage: t4.storage })),
                n2.register(new an({ header: t4.header })),
                n2.register(new un()),
                n2
            );
        }),
        t3
    );
})();
var cn = function (t3) {
    var n2 = this;
    ((this.state = void 0),
        (this.listeners = []),
        (this.isDispatching = false),
        (this.getState = function () {
            return n2.state;
        }),
        (this.getListeners = function () {
            return n2.listeners;
        }),
        (this.dispatch = function (t4) {
            if ("function" != typeof t4) throw new Error("Reducer is not a function");
            if (n2.isDispatching) throw new Error("Reducers may not dispatch actions");
            n2.isDispatching = true;
            var e2 = n2.state;
            try {
                n2.state = t4(n2.state);
            } finally {
                n2.isDispatching = false;
            }
            for (var r2, o2 = s(n2.listeners); !(r2 = o2()).done; ) (0, r2.value)(n2.state, e2);
            return n2.state;
        }),
        (this.subscribe = function (t4) {
            if ("function" != typeof t4) throw new Error("Listener is not a function");
            return (
                (n2.listeners = [].concat(n2.listeners, [t4])),
                function () {
                    return (n2.listeners = n2.listeners.filter(function (n3) {
                        return n3 !== t4;
                    }));
                }
            );
        }),
        (this.state = t3));
};
var fn = (function (t3, n2) {
    var e2 = {
        __c: (n2 = "__cC" + _++),
        __: null,
        Consumer: function (t4, n3) {
            return t4.children(n3);
        },
        Provider: function (t4) {
            var e3, r2;
            return (
                this.getChildContext ||
                    ((e3 = []),
                    ((r2 = {})[n2] = this),
                    (this.getChildContext = function () {
                        return r2;
                    }),
                    (this.shouldComponentUpdate = function (t5) {
                        this.props.value !== t5.value && e3.some(E);
                    }),
                    (this.sub = function (t5) {
                        e3.push(t5);
                        var n3 = t5.componentWillUnmount;
                        t5.componentWillUnmount = function () {
                            (e3.splice(e3.indexOf(t5), 1), n3 && n3.call(t5));
                        };
                    })),
                t4.children
            );
        },
    };
    return (e2.Provider.__ = e2.Consumer.contextType = e2);
})();
var pn = /* @__PURE__ */ (function () {
    function t3() {
        Object.assign(this, t3.defaultConfig());
    }
    var n2 = t3.prototype;
    return (
        (n2.assign = function (t4) {
            return Object.assign(this, t4);
        }),
        (n2.update = function (n3) {
            return n3 ? (this.assign(t3.fromPartialConfig(e({}, this, n3))), this) : this;
        }),
        (t3.defaultConfig = function () {
            return {
                store: new cn({ status: a.Init, header: void 0, data: null }),
                plugin: new $t(),
                tableRef: { current: null },
                width: "100%",
                height: "auto",
                processingThrottleMs: 100,
                autoWidth: true,
                style: {},
                className: {},
            };
        }),
        (t3.fromPartialConfig = function (n3) {
            var e2 = new t3().assign(n3);
            return (
                "boolean" == typeof n3.sort &&
                    n3.sort &&
                    e2.assign({ sort: { multiColumn: true } }),
                e2.assign({ header: Kt.createFromConfig(e2) }),
                e2.assign({ storage: Qt.createFromConfig(e2) }),
                e2.assign({ pipeline: ln.createFromConfig(e2) }),
                e2.assign({ translator: new Lt(e2.language) }),
                (e2.plugin = new $t()),
                e2.search && e2.plugin.add({ id: "search", position: zt.Header, component: Dt }),
                e2.pagination &&
                    e2.plugin.add({ id: "pagination", position: zt.Footer, component: Rt }),
                e2.plugins &&
                    e2.plugins.forEach(function (t4) {
                        return e2.plugin.add(t4);
                    }),
                e2
            );
        }),
        t3
    );
})();
function dn(t3) {
    var n2,
        r2 = It();
    return w(
        "td",
        e(
            {
                role: t3.role,
                colSpan: t3.colSpan,
                "data-column-id": t3.column && t3.column.id,
                className: rt(et("td"), t3.className, r2.className.td),
                style: e({}, t3.style, r2.style.td),
                onClick: function (n3) {
                    t3.messageCell ||
                        r2.eventEmitter.emit("cellClick", n3, t3.cell, t3.column, t3.row);
                },
            },
            (n2 = t3.column)
                ? "function" == typeof n2.attributes
                    ? n2.attributes(t3.cell.data, t3.row, t3.column)
                    : n2.attributes
                : {},
        ),
        t3.column && "function" == typeof t3.column.formatter
            ? t3.column.formatter(t3.cell.data, t3.row, t3.column)
            : t3.column && t3.column.plugin
              ? w(Gt, {
                    pluginId: t3.column.id,
                    props: { column: t3.column, cell: t3.cell, row: t3.row },
                })
              : t3.cell.data,
    );
}
function hn(t3) {
    var n2 = It(),
        e2 = jt(function (t4) {
            return t4.header;
        });
    return w(
        "tr",
        {
            className: rt(et("tr"), n2.className.tr),
            onClick: function (e3) {
                t3.messageRow || n2.eventEmitter.emit("rowClick", e3, t3.row);
            },
        },
        t3.children
            ? t3.children
            : t3.row.cells.map(function (n3, r2) {
                  var o2 = (function (t4) {
                      if (e2) {
                          var n4 = Kt.leafColumns(e2.columns);
                          if (n4) return n4[t4];
                      }
                      return null;
                  })(r2);
                  return o2 && o2.hidden
                      ? null
                      : w(dn, { key: n3.id, cell: n3, row: t3.row, column: o2 });
              }),
    );
}
function _n(t3) {
    return w(
        hn,
        { messageRow: true },
        w(dn, {
            role: "alert",
            colSpan: t3.colSpan,
            messageCell: true,
            cell: new X(t3.message),
            className: rt(et("message"), t3.className ? t3.className : null),
        }),
    );
}
function mn() {
    var t3 = It(),
        n2 = jt(function (t4) {
            return t4.data;
        }),
        e2 = jt(function (t4) {
            return t4.status;
        }),
        r2 = jt(function (t4) {
            return t4.header;
        }),
        o2 = At(),
        i2 = function () {
            return r2 ? r2.visibleColumns.length : 0;
        };
    return w(
        "tbody",
        { className: rt(et("tbody"), t3.className.tbody) },
        n2 &&
            n2.rows.map(function (t4) {
                return w(hn, { key: t4.id, row: t4 });
            }),
        e2 === a.Loading &&
            (!n2 || 0 === n2.length) &&
            w(_n, {
                message: o2("loading"),
                colSpan: i2(),
                className: rt(et("loading"), t3.className.loading),
            }),
        e2 === a.Rendered &&
            n2 &&
            0 === n2.length &&
            w(_n, {
                message: o2("noRecordsFound"),
                colSpan: i2(),
                className: rt(et("notfound"), t3.className.notfound),
            }),
        e2 === a.Error &&
            w(_n, {
                message: o2("error"),
                colSpan: i2(),
                className: rt(et("error"), t3.className.error),
            }),
    );
}
var vn = /* @__PURE__ */ (function (t3) {
    function e2() {
        return t3.apply(this, arguments) || this;
    }
    r(e2, t3);
    var o2 = e2.prototype;
    return (
        (o2.validateProps = function () {
            for (var t4, n2 = s(this.props.columns); !(t4 = n2()).done; ) {
                var e3 = t4.value;
                (void 0 === e3.direction && (e3.direction = 1),
                    1 !== e3.direction &&
                        -1 !== e3.direction &&
                        Vt.error("Invalid sort direction " + e3.direction));
            }
        }),
        (o2.compare = function (t4, n2) {
            return t4 > n2 ? 1 : t4 < n2 ? -1 : 0;
        }),
        (o2.compareWrapper = function (t4, n2) {
            for (var e3, r2 = 0, o3 = s(this.props.columns); !(e3 = o3()).done; ) {
                var i2 = e3.value;
                if (0 !== r2) break;
                var u2 = t4.cells[i2.index].data,
                    a2 = n2.cells[i2.index].data;
                r2 |=
                    "function" == typeof i2.compare
                        ? i2.compare(u2, a2) * i2.direction
                        : this.compare(u2, a2) * i2.direction;
            }
            return r2;
        }),
        (o2._process = function (t4) {
            var n2 = [].concat(t4.rows);
            n2.sort(this.compareWrapper.bind(this));
            var e3 = new J(n2);
            return ((e3.length = t4.length), e3);
        }),
        n(e2, [
            {
                key: "type",
                get: function () {
                    return K.Sort;
                },
            },
        ]),
        e2
    );
})(tt);
var yn = function (t3, n2, r2, o2) {
    return function (i2) {
        var u2,
            s2 =
                null != (u2 = i2.sort) && u2.columns
                    ? i2.sort.columns.map(function (t4) {
                          return e({}, t4);
                      })
                    : [],
            a2 = s2.length,
            l2 = s2.find(function (n3) {
                return n3.index === t3;
            }),
            c2 = false,
            f2 = false,
            p2 = false,
            d2 = false;
        if (
            (void 0 !== l2
                ? r2
                    ? -1 === l2.direction
                        ? (p2 = true)
                        : (d2 = true)
                    : 1 === a2
                      ? (d2 = true)
                      : a2 > 1 && ((f2 = true), (c2 = true))
                : 0 === a2
                  ? (c2 = true)
                  : a2 > 0 && !r2
                    ? ((c2 = true), (f2 = true))
                    : a2 > 0 && r2 && (c2 = true),
            f2 && (s2 = []),
            c2)
        )
            s2.push({ index: t3, direction: n2, compare: o2 });
        else if (d2) {
            var h6 = s2.indexOf(l2);
            s2[h6].direction = n2;
        } else if (p2) {
            var _2 = s2.indexOf(l2);
            s2.splice(_2, 1);
        }
        return e({}, i2, { sort: { columns: s2 } });
    };
};
var gn = function (t3, n2, r2) {
    return function (o2) {
        var i2 = (o2.sort ? [].concat(o2.sort.columns) : []).find(function (n3) {
            return n3.index === t3;
        });
        return e(
            {},
            o2,
            i2 ? yn(t3, 1 === i2.direction ? -1 : 1, n2, r2)(o2) : yn(t3, 1, n2, r2)(o2),
        );
    };
};
var bn = /* @__PURE__ */ (function (t3) {
    function o2() {
        return t3.apply(this, arguments) || this;
    }
    return (
        r(o2, t3),
        (o2.prototype._process = function (t4) {
            var n2 = {};
            return (
                this.props.url && (n2.url = this.props.url(t4.url, this.props.columns)),
                this.props.body && (n2.body = this.props.body(t4.body, this.props.columns)),
                e({}, t4, n2)
            );
        }),
        n(o2, [
            {
                key: "type",
                get: function () {
                    return K.ServerSort;
                },
            },
        ]),
        o2
    );
})(tt);
function wn(t3) {
    var n2 = It(),
        r2 = Ht().dispatch,
        o2 = At(),
        i2 = yt(0),
        u2 = i2[0],
        s2 = i2[1],
        a2 = n2.sort,
        l2 = jt(function (t4) {
            return t4.sort;
        }),
        c2 = "object" == typeof (null == a2 ? void 0 : a2.server) ? K.ServerSort : K.Sort,
        f2 = function () {
            var t4 = n2.pipeline.getStepsByType(c2);
            if (t4.length) return t4[0];
        };
    return (
        gt(
            function () {
                var t4 =
                    f2() ||
                    (c2 === K.ServerSort
                        ? new bn(e({ columns: l2 ? l2.columns : [] }, a2.server))
                        : new vn({ columns: l2 ? l2.columns : [] }));
                return (
                    n2.pipeline.tryRegister(t4),
                    function () {
                        return n2.pipeline.unregister(t4);
                    }
                );
            },
            [n2],
        ),
        gt(
            function () {
                if (l2) {
                    var n3,
                        e2 = l2.columns.find(function (n4) {
                            return n4.index === t3.index;
                        });
                    e2
                        ? (0 === u2 && (e2.direction = null != (n3 = t3.direction) ? n3 : 1),
                          s2(e2.direction))
                        : s2(0);
                }
            },
            [l2],
        ),
        gt(
            function () {
                var t4 = f2();
                t4 && l2 && t4.setProps({ columns: l2.columns });
            },
            [l2],
        ),
        w("button", {
            tabIndex: -1,
            "aria-label": o2("sort.sort" + (1 === u2 ? "Desc" : "Asc")),
            title: o2("sort.sort" + (1 === u2 ? "Desc" : "Asc")),
            className: rt(
                et("sort"),
                et(
                    "sort",
                    /* @__PURE__ */ (function (t4) {
                        return 1 === t4 ? "asc" : -1 === t4 ? "desc" : "neutral";
                    })(u2),
                ),
                n2.className.sort,
            ),
            onClick: function (n3) {
                (n3.preventDefault(),
                    n3.stopPropagation(),
                    r2(gn(t3.index, true === n3.shiftKey && a2.multiColumn, t3.compare)));
            },
        })
    );
}
var xn = function (t3, n2) {
    var e2;
    void 0 === n2 && (n2 = 100);
    var r2 = Date.now(),
        o2 = function () {
            ((r2 = Date.now()), t3.apply(void 0, [].slice.call(arguments)));
        };
    return function () {
        var t4 = [].slice.call(arguments),
            i2 = Date.now(),
            u2 = i2 - r2;
        u2 >= n2
            ? o2.apply(void 0, t4)
            : (e2 && clearTimeout(e2),
              (e2 = setTimeout(function () {
                  (o2.apply(void 0, t4), (e2 = null));
              }, n2 - u2)));
    };
};
function kn(t3) {
    var n2,
        e2 = function (t4) {
            return t4 instanceof MouseEvent
                ? Math.floor(t4.pageX)
                : Math.floor(t4.changedTouches[0].pageX);
        },
        r2 = function (r3) {
            r3.stopPropagation();
            var u2 = parseInt(t3.thRef.current.style.width, 10) - e2(r3);
            ((n2 = xn(function (t4) {
                return o2(t4, u2);
            }, 10)),
                document.addEventListener("mouseup", i2),
                document.addEventListener("touchend", i2),
                document.addEventListener("mousemove", n2),
                document.addEventListener("touchmove", n2));
        },
        o2 = function (n3, r3) {
            n3.stopPropagation();
            var o3 = t3.thRef.current;
            r3 + e2(n3) >= parseInt(o3.style.minWidth, 10) && (o3.style.width = r3 + e2(n3) + "px");
        },
        i2 = function t4(e3) {
            (e3.stopPropagation(),
                document.removeEventListener("mouseup", t4),
                document.removeEventListener("mousemove", n2),
                document.removeEventListener("touchmove", n2),
                document.removeEventListener("touchend", t4));
        };
    return w("div", {
        className: rt(et("th"), et("resizable")),
        onMouseDown: r2,
        onTouchStart: r2,
        onClick: function (t4) {
            return t4.stopPropagation();
        },
    });
}
function Sn(t3) {
    var n2 = It(),
        r2 = bt(null),
        o2 = yt({}),
        i2 = o2[0],
        u2 = o2[1],
        s2 = Ht().dispatch;
    gt(
        function () {
            if (n2.fixedHeader && r2.current) {
                var t4 = r2.current.offsetTop;
                "number" == typeof t4 && u2({ top: t4 });
            }
        },
        [r2],
    );
    var a2,
        l2 = function () {
            return null != t3.column.sort;
        },
        c2 = function (e2) {
            (e2.stopPropagation(),
                l2() &&
                    s2(
                        gn(
                            t3.index,
                            true === e2.shiftKey && n2.sort.multiColumn,
                            t3.column.sort.compare,
                        ),
                    ));
        };
    return w(
        "th",
        e(
            {
                ref: r2,
                "data-column-id": t3.column && t3.column.id,
                className: rt(
                    et("th"),
                    l2() ? et("th", "sort") : null,
                    n2.fixedHeader ? et("th", "fixed") : null,
                    n2.className.th,
                ),
                onClick: c2,
                style: e(
                    {},
                    n2.style.th,
                    { minWidth: t3.column.minWidth, width: t3.column.width },
                    i2,
                    t3.style,
                ),
                onKeyDown: function (t4) {
                    l2() && 13 === t4.which && c2(t4);
                },
                rowSpan: t3.rowSpan > 1 ? t3.rowSpan : void 0,
                colSpan: t3.colSpan > 1 ? t3.colSpan : void 0,
            },
            (a2 = t3.column)
                ? "function" == typeof a2.attributes
                    ? a2.attributes(null, null, t3.column)
                    : a2.attributes
                : {},
            l2() ? { tabIndex: 0 } : {},
        ),
        w(
            "div",
            { className: et("th", "content") },
            void 0 !== t3.column.name
                ? t3.column.name
                : void 0 !== t3.column.plugin
                  ? w(Gt, { pluginId: t3.column.plugin.id, props: { column: t3.column } })
                  : null,
        ),
        l2() && w(wn, e({ index: t3.index }, t3.column.sort)),
        t3.column.resizable &&
            t3.index < n2.header.visibleColumns.length - 1 &&
            w(kn, { column: t3.column, thRef: r2 }),
    );
}
function Nn() {
    var t3,
        n2 = It(),
        e2 = jt(function (t4) {
            return t4.header;
        });
    return e2
        ? w(
              "thead",
              { key: e2.id, className: rt(et("thead"), n2.className.thead) },
              (t3 = Kt.tabularFormat(e2.columns)).map(function (n3, r2) {
                  return (function (t4, n4, r3) {
                      var o2 = Kt.leafColumns(e2.columns);
                      return w(
                          hn,
                          null,
                          t4.map(function (t5) {
                              return t5.hidden
                                  ? null
                                  : (function (t6, n5, e3, r4) {
                                        var o3 = (function (t7, n6, e4) {
                                            var r5 = Kt.maximumDepth(t7),
                                                o4 = e4 - n6;
                                            return {
                                                rowSpan: Math.floor(o4 - r5 - r5 / o4),
                                                colSpan: (t7.columns && t7.columns.length) || 1,
                                            };
                                        })(t6, n5, r4);
                                        return w(Sn, {
                                            column: t6,
                                            index: e3,
                                            colSpan: o3.colSpan,
                                            rowSpan: o3.rowSpan,
                                        });
                                    })(t5, n4, o2.indexOf(t5), r3);
                          }),
                      );
                  })(n3, r2, t3.length);
              }),
          )
        : null;
}
var Pn = function (t3) {
    return function (n2) {
        return e({}, n2, { header: t3 });
    };
};
function Cn() {
    var t3 = It(),
        n2 = bt(null),
        r2 = Ht().dispatch;
    return (
        gt(
            function () {
                n2 &&
                    r2(
                        /* @__PURE__ */ (function (t4) {
                            return function (n3) {
                                return e({}, n3, { tableRef: t4 });
                            };
                        })(n2),
                    );
            },
            [n2],
        ),
        w(
            "table",
            {
                ref: n2,
                role: "grid",
                className: rt(et("table"), t3.className.table),
                style: e({}, t3.style.table, { height: t3.height }),
            },
            w(Nn, null),
            w(mn, null),
        )
    );
}
function En() {
    var t3 = yt(true),
        n2 = t3[0],
        r2 = t3[1],
        o2 = bt(null),
        i2 = It();
    return (
        gt(
            function () {
                0 === o2.current.children.length && r2(false);
            },
            [o2],
        ),
        n2
            ? w(
                  "div",
                  {
                      ref: o2,
                      className: rt(et("head"), i2.className.header),
                      style: e({}, i2.style.header),
                  },
                  w(Gt, { position: zt.Header }),
              )
            : null
    );
}
function In() {
    var t3 = bt(null),
        n2 = yt(true),
        r2 = n2[0],
        o2 = n2[1],
        i2 = It();
    return (
        gt(
            function () {
                0 === t3.current.children.length && o2(false);
            },
            [t3],
        ),
        r2
            ? w(
                  "div",
                  {
                      ref: t3,
                      className: rt(et("footer"), i2.className.footer),
                      style: e({}, i2.style.footer),
                  },
                  w(Gt, { position: zt.Footer }),
              )
            : null
    );
}
function Tn() {
    var t3 = It(),
        n2 = Ht().dispatch,
        r2 = jt(function (t4) {
            return t4.status;
        }),
        o2 = jt(function (t4) {
            return t4.data;
        }),
        i2 = jt(function (t4) {
            return t4.tableRef;
        }),
        u2 = { current: null },
        s2 = xn(function () {
            try {
                n2(function (t4) {
                    return e({}, t4, { status: a.Loading });
                });
                var r3 = (function (r4, o3) {
                    try {
                        var i3 = Promise.resolve(t3.pipeline.process()).then(function (t4) {
                            (n2(
                                /* @__PURE__ */ (function (t5) {
                                    return function (n3) {
                                        return t5 ? e({}, n3, { data: t5, status: a.Loaded }) : n3;
                                    };
                                })(t4),
                            ),
                                setTimeout(function () {
                                    n2(function (t5) {
                                        return t5.status === a.Loaded
                                            ? e({}, t5, { status: a.Rendered })
                                            : t5;
                                    });
                                }, 0));
                        });
                    } catch (t4) {
                        return o3(t4);
                    }
                    return i3 && i3.then ? i3.then(void 0, o3) : i3;
                })(0, function (t4) {
                    (Vt.error(t4),
                        n2(function (t5) {
                            return e({}, t5, { data: null, status: a.Error });
                        }));
                });
                return Promise.resolve(r3 && r3.then ? r3.then(function () {}) : void 0);
            } catch (t4) {
                return Promise.reject(t4);
            }
        }, t3.processingThrottleMs);
    return (
        gt(function () {
            return (
                n2(Pn(t3.header)),
                s2(),
                t3.pipeline.on("updated", s2),
                function () {
                    return t3.pipeline.off("updated", s2);
                }
            );
        }, []),
        gt(
            function () {
                t3.header &&
                    r2 === a.Loaded &&
                    null != o2 &&
                    o2.length &&
                    n2(Pn(t3.header.adjustWidth(t3, i2, u2)));
            },
            [o2, t3, u2],
        ),
        w(
            "div",
            {
                role: "complementary",
                className: rt(
                    "gridjs",
                    et("container"),
                    r2 === a.Loading ? et("loading") : null,
                    t3.className.container,
                ),
                style: e({}, t3.style.container, { width: t3.width }),
            },
            r2 === a.Loading && w("div", { className: et("loading-bar") }),
            w(En, null),
            w("div", { className: et("wrapper"), style: { height: t3.height } }, w(Cn, null)),
            w(In, null),
            w("div", { ref: u2, id: "gridjs-temp", className: et("temp") }),
        )
    );
}
var Ln = /* @__PURE__ */ (function (t3) {
    function n2(n3) {
        var e3;
        return (
            ((e3 = t3.call(this) || this).config = void 0),
            (e3.plugin = void 0),
            (e3.config = new pn().assign({ instance: i(e3), eventEmitter: i(e3) }).update(n3)),
            (e3.plugin = e3.config.plugin),
            e3
        );
    }
    r(n2, t3);
    var e2 = n2.prototype;
    return (
        (e2.updateConfig = function (t4) {
            return (this.config.update(t4), this);
        }),
        (e2.createElement = function () {
            return w(fn.Provider, { value: this.config, children: w(Tn, {}) });
        }),
        (e2.forceRender = function () {
            return (
                (this.config && this.config.container) ||
                    Vt.error(
                        "Container is empty. Make sure you call render() before forceRender()",
                        true,
                    ),
                this.destroy(),
                q(this.createElement(), this.config.container),
                this
            );
        }),
        (e2.destroy = function () {
            (this.config.pipeline.clearCache(), q(null, this.config.container));
        }),
        (e2.render = function (t4) {
            return (
                t4 || Vt.error("Container element cannot be null", true),
                t4.childNodes.length > 0
                    ? (Vt.error(
                          "The container element " +
                              t4 +
                              " is not empty. Make sure the container is empty and call render() again",
                      ),
                      this)
                    : ((this.config.container = t4), q(this.createElement(), t4), this)
            );
        }),
        n2
    );
})(Q);

// src/gui/statistics.tsx
var import_path = __toESM(require("path"));
var import_vhtml = __toESM(require_vhtml());
Chart.register(
    BarElement,
    BarController,
    plugin_legend,
    plugin_title,
    plugin_tooltip,
    plugin_subtitle,
    CategoryScale,
    LinearScale,
    PieController,
    ArcElement,
);
var StatisticsView = class {
    constructor(containerEl, osrCore) {
        this.containerEl = containerEl;
        this.osrCore = osrCore;
    }
    render() {
        this.containerEl.style.textAlign = "center";
        this.containerEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)(
            "select",
            { id: "sr-chart-period" },
            /* @__PURE__ */ (0, import_vhtml.default)(
                "option",
                { value: "month", selected: true },
                t("MONTH"),
            ),
            /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "quarter" }, t("QUARTER")),
            /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "year" }, t("YEAR")),
            /* @__PURE__ */ (0, import_vhtml.default)(
                "option",
                { value: "lifetime" },
                t("LIFETIME"),
            ),
        );
        const cardStats = this.osrCore.cardStats;
        let maxN = cardStats.delayedDays.getMaxValue();
        for (let dueOffset = 0; dueOffset <= maxN; dueOffset++) {
            cardStats.delayedDays.clearCountIfMissing(dueOffset);
        }
        const dueDatesFlashcardsCopy = { 0: 0 };
        for (const [dueOffset, dueCount] of getTypedObjectEntries(cardStats.delayedDays.dict)) {
            if (dueOffset <= 0) {
                dueDatesFlashcardsCopy[0] += dueCount;
            } else {
                dueDatesFlashcardsCopy[dueOffset] = dueCount;
            }
        }
        const scheduledCount = cardStats.youngCount + cardStats.matureCount;
        maxN = Math.max(maxN, 1);
        this.containerEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)(
            "div",
            null,
            /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "forecastChart" }),
            /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "forecastChartSummary" }),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "intervalsChart" }),
            /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "intervalsChartSummary" }),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "easesChart" }),
            /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "easesChartSummary" }),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "cardTypesChart" }),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "cardTypesChartSummary" }),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("br", null),
            /* @__PURE__ */ (0, import_vhtml.default)("h1", null, "Notes"),
            /* @__PURE__ */ (0, import_vhtml.default)("div", { id: "noteStats" }),
        );
        this.forecastChart = createStatsChart(
            "bar",
            "forecastChart",
            t("FORECAST"),
            t("FORECAST_DESC"),
            Object.keys(dueDatesFlashcardsCopy),
            Object.values(dueDatesFlashcardsCopy),
            t("REVIEWS_PER_DAY", { avg: (scheduledCount / maxN).toFixed(1) }),
            t("SCHEDULED"),
            t("DAYS"),
            t("NUMBER_OF_CARDS"),
        );
        maxN = cardStats.intervals.getMaxValue();
        for (let interval = 0; interval <= maxN; interval++) {
            cardStats.intervals.clearCountIfMissing(interval);
        }
        const averageInterval = textInterval(
                Math.round(
                    (cardStats.intervals.getTotalOfValueMultiplyCount() / scheduledCount) * 10,
                ) / 10 || 0,
                false,
            ),
            longestInterval = textInterval(cardStats.intervals.getMaxValue(), false);
        this.intervalsChart = createStatsChart(
            "bar",
            "intervalsChart",
            t("INTERVALS"),
            t("INTERVALS_DESC"),
            Object.keys(cardStats.intervals.dict),
            Object.values(cardStats.intervals.dict),
            t("INTERVALS_SUMMARY", { avg: averageInterval, longest: longestInterval }),
            t("COUNT"),
            t("DAYS"),
            t("NUMBER_OF_CARDS"),
        );
        const eases = getKeysPreserveType(cardStats.eases.dict);
        for (let ease = Math.min(...eases); ease <= Math.max(...eases); ease++) {
            cardStats.eases.clearCountIfMissing(ease);
        }
        const averageEase =
            Math.round(cardStats.eases.getTotalOfValueMultiplyCount() / scheduledCount) || 0;
        this.easesChart = createStatsChart(
            "bar",
            "easesChart",
            t("EASES"),
            "",
            Object.keys(cardStats.eases.dict),
            Object.values(cardStats.eases.dict),
            t("EASES_SUMMARY", { avgEase: averageEase }),
            t("COUNT"),
            t("EASES"),
            t("NUMBER_OF_CARDS"),
        );
        const totalCardsCount = this.osrCore.reviewableDeckTree.getDistinctCardCount(
            2 /* All */,
            true,
        );
        this.cardTypesChart = createStatsChart(
            "pie",
            "cardTypesChart",
            t("CARD_TYPES"),
            t("CARD_TYPES_DESC"),
            [
                `${t("CARD_TYPE_NEW")} - ${Math.round((cardStats.newCount / totalCardsCount) * 100)}%`,
                `${t("CARD_TYPE_YOUNG")} - ${Math.round(
                    (cardStats.youngCount / totalCardsCount) * 100,
                )}%`,
                `${t("CARD_TYPE_MATURE")} - ${Math.round(
                    (cardStats.matureCount / totalCardsCount) * 100,
                )}%`,
            ],
            [cardStats.newCount, cardStats.youngCount, cardStats.matureCount],
            t("CARD_TYPES_SUMMARY", { totalCardsCount }),
        );
        const noteEases = mapRecord(SrsAlgorithm.getInstance().noteStats().dict, (key, value) => [
            import_path.default.parse(key).name,
            Math.round(value),
        ]);
        this.noteStatsGrid = new Ln({
            columns: [
                {
                    name: t("NOTE"),
                },
                {
                    name: t("EASE"),
                    sort: true,
                    width: "200px",
                },
            ],
            search: true,
            autoWidth: false,
            data: Object.entries(noteEases).sort((a2, b2) => b2[1] - a2[1]),
            pagination: {
                limit: 10,
                summary: false,
            },
            language: {
                search: {
                    placeholder: t("SEARCH"),
                },
                pagination: {
                    previous: t("PREVIOUS"),
                    next: t("NEXT"),
                },
            },
        });
        this.noteStatsGrid.render(document.getElementById("noteStats"));
    }
    destroy() {
        this.forecastChart.destroy();
        this.intervalsChart.destroy();
        this.easesChart.destroy();
        this.cardTypesChart.destroy();
        this.noteStatsGrid.destroy();
    }
};
function createStatsChart(
    type,
    canvasId,
    title,
    subtitle,
    labels,
    data,
    summary,
    seriesTitle = "",
    xAxisTitle = "",
    yAxisTitle = "",
) {
    const style = getComputedStyle(document.body);
    const textColor = style.getPropertyValue("--text-normal");
    let scales = {},
        backgroundColor = ["#2196f3"];
    if (type !== "pie") {
        scales = {
            x: {
                title: {
                    display: true,
                    text: xAxisTitle,
                    color: textColor,
                },
            },
            y: {
                title: {
                    display: true,
                    text: yAxisTitle,
                    color: textColor,
                },
            },
        };
    } else {
        backgroundColor = ["#2196f3", "#4caf50", "green"];
    }
    const shouldFilter = canvasId === "forecastChart" || canvasId === "intervalsChart";
    const statsChart = new Chart(document.getElementById(canvasId), {
        type,
        data: {
            labels: shouldFilter ? labels.slice(0, 31) : labels,
            datasets: [
                {
                    label: seriesTitle,
                    backgroundColor,
                    data: shouldFilter ? data.slice(0, 31) : data,
                },
            ],
        },
        options: {
            scales,
            plugins: {
                title: {
                    display: true,
                    text: title,
                    font: {
                        size: 22,
                    },
                    color: textColor,
                },
                subtitle: {
                    display: true,
                    text: subtitle,
                    font: {
                        size: 16,
                        style: "italic",
                    },
                    color: textColor,
                },
                legend: {
                    display: false,
                },
            },
            aspectRatio: 2,
        },
    });
    if (shouldFilter) {
        const chartPeriodEl = document.getElementById("sr-chart-period");
        chartPeriodEl.addEventListener("click", () => {
            let filteredLabels, filteredData;
            const chartPeriod = chartPeriodEl.value;
            if (chartPeriod === "month") {
                filteredLabels = labels.slice(0, 31);
                filteredData = data.slice(0, 31);
            } else if (chartPeriod === "quarter") {
                filteredLabels = labels.slice(0, 91);
                filteredData = data.slice(0, 91);
            } else if (chartPeriod === "year") {
                filteredLabels = labels.slice(0, 366);
                filteredData = data.slice(0, 366);
            } else {
                filteredLabels = labels;
                filteredData = data;
            }
            statsChart.data.labels = filteredLabels;
            statsChart.data.datasets[0] = {
                label: seriesTitle,
                backgroundColor,
                data: filteredData,
            };
            statsChart.update();
        });
    }
    document.getElementById(`${canvasId}Summary`).innerText = summary;
    return statsChart;
}

// src/gui/tabs.tsx
var import_obsidian5 = require("obsidian");
var import_vhtml2 = __toESM(require_vhtml());
function createTabs(containerElement, tabs, activateTabId) {
    const tabHeader = containerElement.createEl("div", {
        attr: { class: "sr-tab-header" },
    });
    const tabContentContainers = {};
    const tabButtons = {};
    const tabStructure = {
        header: tabHeader,
        // Indicate that the first tab is active.
        // This does not affect what tab is active in practice, it just reports the active tab.
        activeTabId: Object.keys(tabs)[0],
        buttons: tabButtons,
        contentContainers: tabContentContainers,
        contentGeneratorPromises: {},
    };
    let firstButton;
    for (const tabId in tabs) {
        const tab = tabs[tabId];
        const button = tabHeader.createEl("button", {
            attr: {
                class: "sr-tab-header-button",
                activateTab: "sr-tab-" + tabId,
            },
        });
        button.onclick = function (event) {
            var _a;
            const tabButton = this;
            let maxWidth = 0;
            let maxHeight = 0;
            const tabHeader2 = tabButton.parentElement;
            if (null === tabHeader2) {
                throw new Error("Tab header is missing. Did not get a parent from tab button.");
            }
            const containerElement2 = tabHeader2.parentElement;
            if (null === containerElement2) {
                throw new Error(
                    "Container element is missing. Did not get a parent from tab header.",
                );
            }
            const tabContents = containerElement2.findAll("div.sr-tab-content");
            const isMainSettingsModal = containerElement2.hasClass("vertical-tab-content");
            for (const index in tabContents) {
                const tabContent2 = tabContents[index];
                if (!isMainSettingsModal) {
                    tabContent2.addClass("sr-tab-active");
                    if (tabContent2.offsetHeight > maxHeight) {
                        maxHeight = tabContent2.offsetHeight;
                    }
                    if (tabContent2.offsetWidth > maxWidth) {
                        maxWidth = tabContent2.offsetWidth;
                    }
                }
                tabContent2.removeClass("sr-tab-active");
            }
            const adjacentTabButtons = tabHeader2.findAll(".sr-tab-header-button");
            for (const index in adjacentTabButtons) {
                const tabButton2 = adjacentTabButtons[index];
                tabButton2.removeClass("sr-tab-active");
            }
            tabButton.addClass("sr-tab-active");
            const activateTabAttribute = tabButton.attributes.getNamedItem("activateTab");
            if (null === activateTabAttribute) {
                throw new Error("Tab button has no 'activateTab' HTML attribute! Murr!");
            }
            const activateTabId2 = activateTabAttribute.value;
            const tabContent = document.getElementById(activateTabId2);
            if (null === tabContent) {
                throw new Error(
                    "No tab content was found with activate_tab_id '" + activateTabId2 + "'! Hmph!",
                );
            }
            tabContent.addClass("sr-tab-active");
            tabStructure.activeTabId = activateTabId2.replace(/^sr-tab-/, "");
            (_a = tabContent.find(".sr-focus-element-on-tab-opening")) == null
                ? void 0
                : _a.focus();
            if (!isMainSettingsModal) {
                tabContent.style.width = maxWidth + "px";
                tabContent.style.height = maxHeight + "px";
            }
            event.preventDefault();
        };
        if (tab.icon) (0, import_obsidian5.setIcon)(button, tab.icon);
        button.insertAdjacentHTML(
            "beforeend",
            /* @__PURE__ */ (0, import_vhtml2.default)(
                "span",
                { style: "padding-left: 5px;" },
                tab.title,
            ),
        );
        tabButtons[tabId] = button;
        tabContentContainers[tabId] = containerElement.createEl("div", {
            attr: { class: "sr-tab-content", id: "sr-tab-" + tabId },
        });
        tabStructure.contentGeneratorPromises[tabId] = tab.contentGenerator(
            tabContentContainers[tabId],
        );
        if (void 0 === firstButton) {
            firstButton = button;
        }
    }
    tabButtons[activateTabId].click();
    return tabStructure;
}

// src/gui/settings.tsx
var applyDebounceTimer = 0;
function applySettingsUpdate(callback2) {
    clearTimeout(applyDebounceTimer);
    applyDebounceTimer = window.setTimeout(callback2, 512);
}
var SRSettingTab = class extends import_obsidian6.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.lastPosition = {
            scrollPosition: 0,
            tabName: "main-flashcards",
        };
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        const header = containerEl.createEl("h4", {
            text: `${t("SETTINGS_HEADER")}`,
        });
        header.addClass("sr-centered");
        this.tabStructure = createTabs(
            containerEl,
            {
                "main-flashcards": {
                    title: t("FLASHCARDS"),
                    icon: "SpacedRepIcon",
                    contentGenerator: (containerElement) => this.tabFlashcards(containerElement),
                },
                "main-notes": {
                    title: t("NOTES"),
                    icon: "book-text",
                    contentGenerator: (containerElement) => this.tabNotes(containerElement),
                },
                "main-algorithm": {
                    title: t("SCHEDULING"),
                    icon: "calendar",
                    contentGenerator: (containerElement) => this.tabScheduling(containerElement),
                },
                "main-ui-preferences": {
                    title: t("UI"),
                    icon: "presentation",
                    contentGenerator: (containerElement) => this.tabUiPreferences(containerElement),
                },
                "main-statistics": {
                    title: t("STATS_TITLE"),
                    icon: "bar-chart-3",
                    contentGenerator: async (containerElement) => {
                        if (this.plugin.osrAppCore.cardStats == null) {
                            await this.plugin.sync();
                        }
                        this.statistics = new StatisticsView(
                            containerElement,
                            this.plugin.osrAppCore,
                        );
                        this.statistics.render();
                    },
                },
                "main-help": {
                    title: t("HELP"),
                    icon: "badge-help",
                    contentGenerator: (containerElement) => this.tabHelp(containerElement),
                },
            },
            this.lastPosition.tabName,
        );
        this.tabStructure.contentGeneratorPromises[this.tabStructure.activeTabId].then(() => {
            this.rememberLastPosition(containerEl);
        });
    }
    hide() {
        this.statistics.destroy();
        this.containerEl.empty();
    }
    async tabFlashcards(containerEl) {
        containerEl.createEl("h3", { text: t("GROUP_TAGS_FOLDERS") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("FLASHCARD_TAGS"))
            .setDesc(t("FLASHCARD_TAGS_DESC"))
            .addTextArea((text) =>
                text
                    .setValue(this.plugin.data.settings.flashcardTags.join(" "))
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.flashcardTags = value.split(/\s+/);
                            await this.plugin.savePluginData();
                        });
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("CONVERT_FOLDERS_TO_DECKS"))
            .setDesc(t("CONVERT_FOLDERS_TO_DECKS_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.convertFoldersToDecks)
                    .onChange(async (value) => {
                        this.plugin.data.settings.convertFoldersToDecks = value;
                        await this.plugin.savePluginData();
                    }),
            );
        this.createSettingFoldersToIgnore(containerEl);
        containerEl.createEl("h3", { text: t("GROUP_FLASHCARD_REVIEW") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("BURY_SIBLINGS_TILL_NEXT_DAY"))
            .setDesc(t("BURY_SIBLINGS_TILL_NEXT_DAY_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.burySiblingCards)
                    .onChange(async (value) => {
                        this.plugin.data.settings.burySiblingCards = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("REVIEW_CARD_ORDER_WITHIN_DECK"))
            .addDropdown((dropdown) =>
                dropdown
                    .addOptions({
                        NewFirstSequential: t("REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL"),
                        DueFirstSequential: t("REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL"),
                        NewFirstRandom: t("REVIEW_CARD_ORDER_NEW_FIRST_RANDOM"),
                        DueFirstRandom: t("REVIEW_CARD_ORDER_DUE_FIRST_RANDOM"),
                        EveryCardRandomDeckAndCard: t("REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD"),
                    })
                    .setValue(this.plugin.data.settings.flashcardCardOrder)
                    .onChange(async (value) => {
                        this.plugin.data.settings.flashcardCardOrder = value;
                        await this.plugin.savePluginData();
                        this.display();
                    }),
            );
        const deckOrderEnabled =
            this.plugin.data.settings.flashcardCardOrder != "EveryCardRandomDeckAndCard";
        new import_obsidian6.Setting(containerEl)
            .setName(t("REVIEW_DECK_ORDER"))
            .addDropdown((dropdown) =>
                dropdown
                    .addOptions(
                        deckOrderEnabled
                            ? {
                                  // eslint-disable-next-line camelcase
                                  PrevDeckComplete_Sequential: t(
                                      "REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL",
                                  ),
                                  // eslint-disable-next-line camelcase
                                  PrevDeckComplete_Random: t(
                                      "REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM",
                                  ),
                              }
                            : {
                                  EveryCardRandomDeckAndCard: t(
                                      "REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD",
                                  ),
                              },
                    )
                    .setValue(
                        deckOrderEnabled
                            ? this.plugin.data.settings.flashcardDeckOrder
                            : "EveryCardRandomDeckAndCard",
                    )
                    .setDisabled(!deckOrderEnabled)
                    .onChange(async (value) => {
                        this.plugin.data.settings.flashcardDeckOrder = value;
                        await this.plugin.savePluginData();
                    }),
            );
        containerEl.createEl("h3", { text: t("GROUP_FLASHCARD_SEPARATORS") });
        const convertHighlightsToClozesEl = new import_obsidian6.Setting(containerEl).setName(
            t("CONVERT_HIGHLIGHTS_TO_CLOZES"),
        );
        convertHighlightsToClozesEl.descEl.insertAdjacentHTML(
            "beforeend",
            t("CONVERT_HIGHLIGHTS_TO_CLOZES_DESC", { defaultPattern: "==[123;;]answer[;;hint]==" }),
        );
        convertHighlightsToClozesEl.addToggle((toggle) =>
            toggle
                .setValue(this.plugin.data.settings.convertHighlightsToClozes)
                .onChange(async (value) => {
                    const defaultHightlightPattern = "==[123;;]answer[;;hint]==";
                    const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
                    if (value) {
                        clozePatternSet.add(defaultHightlightPattern);
                    } else {
                        clozePatternSet.delete(defaultHightlightPattern);
                    }
                    this.plugin.data.settings.clozePatterns = [...clozePatternSet];
                    this.plugin.data.settings.convertHighlightsToClozes = value;
                    await this.plugin.savePluginData();
                    this.display();
                }),
        );
        const convertBoldTextToClozesEl = new import_obsidian6.Setting(containerEl).setName(
            t("CONVERT_BOLD_TEXT_TO_CLOZES"),
        );
        convertBoldTextToClozesEl.descEl.insertAdjacentHTML(
            "beforeend",
            t("CONVERT_BOLD_TEXT_TO_CLOZES_DESC", { defaultPattern: "**[123;;]answer[;;hint]**" }),
        );
        convertBoldTextToClozesEl.addToggle((toggle) =>
            toggle
                .setValue(this.plugin.data.settings.convertBoldTextToClozes)
                .onChange(async (value) => {
                    const defaultBoldPattern = "**[123;;]answer[;;hint]**";
                    const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
                    if (value) {
                        clozePatternSet.add(defaultBoldPattern);
                    } else {
                        clozePatternSet.delete(defaultBoldPattern);
                    }
                    this.plugin.data.settings.clozePatterns = [...clozePatternSet];
                    this.plugin.data.settings.convertBoldTextToClozes = value;
                    await this.plugin.savePluginData();
                    this.display();
                }),
        );
        const convertCurlyBracketsToClozesEl = new import_obsidian6.Setting(containerEl).setName(
            t("CONVERT_CURLY_BRACKETS_TO_CLOZES"),
        );
        convertCurlyBracketsToClozesEl.descEl.insertAdjacentHTML(
            "beforeend",
            t("CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC", {
                defaultPattern: "{{[123;;]answer[;;hint]}}",
            }),
        );
        convertCurlyBracketsToClozesEl.addToggle((toggle) =>
            toggle
                .setValue(this.plugin.data.settings.convertCurlyBracketsToClozes)
                .onChange(async (value) => {
                    const defaultCurlyBracketsPattern = "{{[123;;]answer[;;hint]}}";
                    const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
                    if (value) {
                        clozePatternSet.add(defaultCurlyBracketsPattern);
                    } else {
                        clozePatternSet.delete(defaultCurlyBracketsPattern);
                    }
                    this.plugin.data.settings.clozePatterns = [...clozePatternSet];
                    this.plugin.data.settings.convertCurlyBracketsToClozes = value;
                    await this.plugin.savePluginData();
                    this.display();
                }),
        );
        const clozePatternsEl = new import_obsidian6.Setting(containerEl).setName(
            t("CLOZE_PATTERNS"),
        );
        clozePatternsEl.descEl.insertAdjacentHTML(
            "beforeend",
            t("CLOZE_PATTERNS_DESC", {
                docsUrl:
                    "https://www.stephenmwangi.com/obsidian-spaced-repetition/flashcards/cloze-cards/#cloze-types",
            }),
        );
        clozePatternsEl.addTextArea((text) =>
            text
                .setPlaceholder(
                    "Example:\n==[123;;]answer[;;hint]==\n**[123;;]answer[;;hint]**\n{{[123;;]answer[;;hint]}}",
                )
                .setValue(this.plugin.data.settings.clozePatterns.join("\n"))
                .onChange((value) => {
                    applySettingsUpdate(async () => {
                        const defaultHightlightPattern = "==[123;;]answer[;;hint]==";
                        const defaultBoldPattern = "**[123;;]answer[;;hint]**";
                        const defaultCurlyBracketsPattern = "{{[123;;]answer[;;hint]}}";
                        const clozePatternSet = new Set(
                            value
                                .split(/\n+/)
                                .map((v2) => v2.trim())
                                .filter((v2) => v2),
                        );
                        if (clozePatternSet.has(defaultHightlightPattern)) {
                            this.plugin.data.settings.convertHighlightsToClozes = true;
                        } else {
                            this.plugin.data.settings.convertHighlightsToClozes = false;
                        }
                        if (clozePatternSet.has(defaultBoldPattern)) {
                            this.plugin.data.settings.convertBoldTextToClozes = true;
                        } else {
                            this.plugin.data.settings.convertBoldTextToClozes = false;
                        }
                        if (clozePatternSet.has(defaultCurlyBracketsPattern)) {
                            this.plugin.data.settings.convertCurlyBracketsToClozes = true;
                        } else {
                            this.plugin.data.settings.convertCurlyBracketsToClozes = false;
                        }
                        this.plugin.data.settings.clozePatterns = [...clozePatternSet];
                        await this.plugin.savePluginData();
                    });
                }),
        );
        new import_obsidian6.Setting(containerEl)
            .setName(t("INLINE_CARDS_SEPARATOR"))
            .setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.singleLineCardSeparator)
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.singleLineCardSeparator = value;
                            await this.plugin.savePluginData();
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.singleLineCardSeparator =
                            DEFAULT_SETTINGS.singleLineCardSeparator;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("INLINE_REVERSED_CARDS_SEPARATOR"))
            .setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.singleLineReversedCardSeparator)
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.singleLineReversedCardSeparator = value;
                            await this.plugin.savePluginData();
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.singleLineReversedCardSeparator =
                            DEFAULT_SETTINGS.singleLineReversedCardSeparator;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("MULTILINE_CARDS_SEPARATOR"))
            .setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.multilineCardSeparator)
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.multilineCardSeparator = value;
                            await this.plugin.savePluginData();
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.multilineCardSeparator =
                            DEFAULT_SETTINGS.multilineCardSeparator;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("MULTILINE_REVERSED_CARDS_SEPARATOR"))
            .setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.multilineReversedCardSeparator)
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.multilineReversedCardSeparator = value;
                            await this.plugin.savePluginData();
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.multilineReversedCardSeparator =
                            DEFAULT_SETTINGS.multilineReversedCardSeparator;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("MULTILINE_CARDS_END_MARKER"))
            .setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.multilineCardEndMarker)
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.multilineCardEndMarker = value;
                            await this.plugin.savePluginData();
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.multilineCardEndMarker =
                            DEFAULT_SETTINGS.multilineCardEndMarker;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
    }
    async tabNotes(containerEl) {
        containerEl.createEl("h3", { text: t("GROUP_TAGS_FOLDERS") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("TAGS_TO_REVIEW"))
            .setDesc(t("TAGS_TO_REVIEW_DESC"))
            .addTextArea((text) =>
                text
                    .setValue(this.plugin.data.settings.tagsToReview.join(" "))
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.tagsToReview = value.split(/\s+/);
                            await this.plugin.savePluginData();
                        });
                    }),
            );
        this.createSettingFoldersToIgnore(containerEl);
        containerEl.createEl("h3", { text: t("NOTES_REVIEW_QUEUE") });
        new import_obsidian6.Setting(containerEl).setName(t("AUTO_NEXT_NOTE")).addToggle((toggle) =>
            toggle.setValue(this.plugin.data.settings.autoNextNote).onChange(async (value) => {
                this.plugin.data.settings.autoNextNote = value;
                await this.plugin.savePluginData();
            }),
        );
        new import_obsidian6.Setting(containerEl)
            .setName(t("OPEN_RANDOM_NOTE"))
            .setDesc(t("OPEN_RANDOM_NOTE_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.openRandomNote)
                    .onChange(async (value) => {
                        this.plugin.data.settings.openRandomNote = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("REVIEW_PANE_ON_STARTUP"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.enableNoteReviewPaneOnStartup)
                    .onChange(async (value) => {
                        this.plugin.data.settings.enableNoteReviewPaneOnStartup = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("MAX_N_DAYS_REVIEW_QUEUE"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString())
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            const numValue = Number.parseInt(value);
                            if (!isNaN(numValue)) {
                                if (numValue < 1) {
                                    new import_obsidian6.Notice(t("MIN_ONE_DAY"));
                                    text.setValue(
                                        this.plugin.data.settings.maxNDaysNotesReviewQueue.toString(),
                                    );
                                    return;
                                }
                                this.plugin.data.settings.maxNDaysNotesReviewQueue = numValue;
                                await this.plugin.savePluginData();
                            } else {
                                new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
                            }
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.maxNDaysNotesReviewQueue =
                            DEFAULT_SETTINGS.maxNDaysNotesReviewQueue;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
    }
    async createSettingFoldersToIgnore(containerEl) {
        new import_obsidian6.Setting(containerEl)
            .setName(t("FOLDERS_TO_IGNORE"))
            .setDesc(t("FOLDERS_TO_IGNORE_DESC"))
            .addTextArea((text) =>
                text
                    .setValue(this.plugin.data.settings.noteFoldersToIgnore.join("\n"))
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            this.plugin.data.settings.noteFoldersToIgnore = value
                                .split(/\n+/)
                                .map((v2) => v2.trim())
                                .filter((v2) => v2);
                            await this.plugin.savePluginData();
                            this.display();
                        });
                    }),
            );
    }
    async tabUiPreferences(containerEl) {
        containerEl.createEl("h3", { text: t("OBSIDIAN_INTEGRATION") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("OPEN_IN_TAB"))
            .setDesc(t("OPEN_IN_TAB_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.openViewInNewTab)
                    .onChange(async (value) => {
                        if (value) {
                            this.plugin.registerSRFocusListener();
                        } else {
                            this.plugin.tabViewManager.closeAllTabViews();
                            this.plugin.removeSRFocusListener();
                        }
                        this.plugin.data.settings.openViewInNewTab = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("SHOW_RIBBON_ICON"))
            .setDesc(t("SHOW_RIBBON_ICON_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.showRibbonIcon)
                    .onChange(async (value) => {
                        this.plugin.data.settings.showRibbonIcon = value;
                        await this.plugin.savePluginData();
                        this.plugin.showRibbonIcon(value);
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("SHOW_STATUS_BAR"))
            .setDesc(t("SHOW_STATUS_BAR_DESC"))
            .addToggle((toggle) =>
                toggle.setValue(this.plugin.data.settings.showStatusBar).onChange(async (value) => {
                    this.plugin.data.settings.showStatusBar = value;
                    await this.plugin.savePluginData();
                    this.plugin.showStatusBar(value);
                }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("ENABLE_FILE_MENU_REVIEW_OPTIONS"))
            .setDesc(t("ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(!this.plugin.data.settings.disableFileMenuReviewOptions)
                    .onChange(async (value) => {
                        this.plugin.data.settings.disableFileMenuReviewOptions = !value;
                        await this.plugin.savePluginData();
                        this.plugin.showFileMenuItems(value);
                    }),
            );
        containerEl.createEl("h3", { text: t("FLASHCARDS") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE"))
            .setDesc(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.initiallyExpandAllSubdecksInTree)
                    .onChange(async (value) => {
                        this.plugin.data.settings.initiallyExpandAllSubdecksInTree = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("SHOW_CARD_CONTEXT"))
            .setDesc(t("SHOW_CARD_CONTEXT_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.showContextInCards)
                    .onChange(async (value) => {
                        this.plugin.data.settings.showContextInCards = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("SHOW_INTERVAL_IN_REVIEW_BUTTONS"))
            .setDesc(t("SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.showIntervalInReviewButtons)
                    .onChange(async (value) => {
                        this.plugin.data.settings.showIntervalInReviewButtons = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("CARD_MODAL_HEIGHT_PERCENT"))
            .setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC"))
            .addSlider((slider) =>
                slider
                    .setLimits(10, 100, 5)
                    .setValue(this.plugin.data.settings.flashcardHeightPercentage)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.data.settings.flashcardHeightPercentage = value;
                        await this.plugin.savePluginData();
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.flashcardHeightPercentage =
                            DEFAULT_SETTINGS.flashcardHeightPercentage;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("CARD_MODAL_WIDTH_PERCENT"))
            .setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC"))
            .addSlider((slider) =>
                slider
                    .setLimits(10, 100, 5)
                    .setValue(this.plugin.data.settings.flashcardWidthPercentage)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.data.settings.flashcardWidthPercentage = value;
                        await this.plugin.savePluginData();
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.flashcardWidthPercentage =
                            DEFAULT_SETTINGS.flashcardWidthPercentage;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        containerEl.createEl("h3", { text: t("GROUP_FLASHCARDS_NOTES") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("FLASHCARD_EASY_LABEL"))
            .setDesc(t("FLASHCARD_EASY_DESC"))
            .addText((text) =>
                text.setValue(this.plugin.data.settings.flashcardEasyText).onChange((value) => {
                    applySettingsUpdate(async () => {
                        this.plugin.data.settings.flashcardEasyText = value;
                        await this.plugin.savePluginData();
                    });
                }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.flashcardEasyText =
                            DEFAULT_SETTINGS.flashcardEasyText;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("FLASHCARD_GOOD_LABEL"))
            .setDesc(t("FLASHCARD_GOOD_DESC"))
            .addText((text) =>
                text.setValue(this.plugin.data.settings.flashcardGoodText).onChange((value) => {
                    applySettingsUpdate(async () => {
                        this.plugin.data.settings.flashcardGoodText = value;
                        await this.plugin.savePluginData();
                    });
                }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.flashcardGoodText =
                            DEFAULT_SETTINGS.flashcardGoodText;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("FLASHCARD_HARD_LABEL"))
            .setDesc(t("FLASHCARD_HARD_DESC"))
            .addText((text) =>
                text.setValue(this.plugin.data.settings.flashcardHardText).onChange((value) => {
                    applySettingsUpdate(async () => {
                        this.plugin.data.settings.flashcardHardText = value;
                        await this.plugin.savePluginData();
                    });
                }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.flashcardHardText =
                            DEFAULT_SETTINGS.flashcardHardText;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("REVIEW_BUTTON_DELAY"))
            .setDesc(t("REVIEW_BUTTON_DELAY_DESC"))
            .addSlider((slider) =>
                slider
                    .setLimits(0, 5e3, 100)
                    .setValue(this.plugin.data.settings.reviewButtonDelay)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.data.settings.reviewButtonDelay = value;
                        await this.plugin.savePluginData();
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.reviewButtonDelay =
                            DEFAULT_SETTINGS.reviewButtonDelay;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
    }
    async tabScheduling(containerEl) {
        containerEl.createEl("h3", { text: t("ALGORITHM") });
        const algoSettingEl = new import_obsidian6.Setting(containerEl).setName(t("ALGORITHM"));
        algoSettingEl.descEl.insertAdjacentHTML(
            "beforeend",
            t("CHECK_ALGORITHM_WIKI", {
                algoUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/algorithms/",
            }),
        );
        algoSettingEl.addDropdown((dropdown) =>
            dropdown
                .addOptions({
                    "SM-2-OSR": t("SM2_OSR_VARIANT"),
                })
                .setValue(this.plugin.data.settings.algorithm)
                .onChange(async (value) => {
                    this.plugin.data.settings.algorithm = value;
                    await this.plugin.savePluginData();
                }),
        );
        new import_obsidian6.Setting(containerEl)
            .setName(t("BASE_EASE"))
            .setDesc(t("BASE_EASE_DESC"))
            .addText((text) =>
                text.setValue(this.plugin.data.settings.baseEase.toString()).onChange((value) => {
                    applySettingsUpdate(async () => {
                        const numValue = Number.parseInt(value);
                        if (!isNaN(numValue)) {
                            if (numValue < 130) {
                                new import_obsidian6.Notice(t("BASE_EASE_MIN_WARNING"));
                                text.setValue(this.plugin.data.settings.baseEase.toString());
                                return;
                            }
                            this.plugin.data.settings.baseEase = numValue;
                            await this.plugin.savePluginData();
                        } else {
                            new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
                        }
                    });
                }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.baseEase = DEFAULT_SETTINGS.baseEase;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("LAPSE_INTERVAL_CHANGE"))
            .setDesc(t("LAPSE_INTERVAL_CHANGE_DESC"))
            .addSlider((slider) =>
                slider
                    .setLimits(1, 99, 1)
                    .setValue(this.plugin.data.settings.lapsesIntervalChange * 100)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.data.settings.lapsesIntervalChange = value / 100;
                        await this.plugin.savePluginData();
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.lapsesIntervalChange =
                            DEFAULT_SETTINGS.lapsesIntervalChange;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("EASY_BONUS"))
            .setDesc(t("EASY_BONUS_DESC"))
            .addText((text) =>
                text
                    .setValue((this.plugin.data.settings.easyBonus * 100).toString())
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            const numValue = Number.parseInt(value) / 100;
                            if (!isNaN(numValue)) {
                                if (numValue < 1) {
                                    new import_obsidian6.Notice(t("EASY_BONUS_MIN_WARNING"));
                                    text.setValue(
                                        (this.plugin.data.settings.easyBonus * 100).toString(),
                                    );
                                    return;
                                }
                                this.plugin.data.settings.easyBonus = numValue;
                                await this.plugin.savePluginData();
                            } else {
                                new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
                            }
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.easyBonus = DEFAULT_SETTINGS.easyBonus;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("LOAD_BALANCE"))
            .setDesc(t("LOAD_BALANCE_DESC"))
            .addToggle((toggle) =>
                toggle.setValue(this.plugin.data.settings.loadBalance).onChange(async (value) => {
                    this.plugin.data.settings.loadBalance = value;
                    await this.plugin.savePluginData();
                }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("MAX_INTERVAL"))
            .setDesc(t("MAX_INTERVAL_DESC"))
            .addText((text) =>
                text
                    .setValue(this.plugin.data.settings.maximumInterval.toString())
                    .onChange((value) => {
                        applySettingsUpdate(async () => {
                            const numValue = Number.parseInt(value);
                            if (!isNaN(numValue)) {
                                if (numValue < 1) {
                                    new import_obsidian6.Notice(t("MAX_INTERVAL_MIN_WARNING"));
                                    text.setValue(
                                        this.plugin.data.settings.maximumInterval.toString(),
                                    );
                                    return;
                                }
                                this.plugin.data.settings.maximumInterval = numValue;
                                await this.plugin.savePluginData();
                            } else {
                                new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
                            }
                        });
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.maximumInterval =
                            DEFAULT_SETTINGS.maximumInterval;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        new import_obsidian6.Setting(containerEl)
            .setName(t("MAX_LINK_CONTRIB"))
            .setDesc(t("MAX_LINK_CONTRIB_DESC"))
            .addSlider((slider) =>
                slider
                    .setLimits(0, 100, 1)
                    .setValue(this.plugin.data.settings.maxLinkFactor * 100)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.data.settings.maxLinkFactor = value / 100;
                        await this.plugin.savePluginData();
                    }),
            )
            .addExtraButton((button) => {
                button
                    .setIcon("reset")
                    .setTooltip(t("RESET_DEFAULT"))
                    .onClick(async () => {
                        this.plugin.data.settings.maxLinkFactor = DEFAULT_SETTINGS.maxLinkFactor;
                        await this.plugin.savePluginData();
                        this.display();
                    });
            });
        containerEl.createEl("h3", { text: t("GROUP_DATA_STORAGE") });
        new import_obsidian6.Setting(containerEl)
            .setName(t("GROUP_DATA_STORAGE"))
            .setDesc(t("GROUP_DATA_STORAGE_DESC"))
            .addDropdown((dropdown) =>
                dropdown
                    .addOptions({
                        NOTES: t("STORE_IN_NOTES"),
                    })
                    .setValue(this.plugin.data.settings.dataStore)
                    .onChange(async (value) => {
                        this.plugin.data.settings.dataStore = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("INLINE_SCHEDULING_COMMENTS"))
            .setDesc(t("INLINE_SCHEDULING_COMMENTS_DESC"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.cardCommentOnSameLine)
                    .onChange(async (value) => {
                        this.plugin.data.settings.cardCommentOnSameLine = value;
                        await this.plugin.savePluginData();
                    }),
            );
    }
    async tabHelp(containerEl) {
        containerEl.createEl("h3", { text: `${t("HELP")}` });
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("CHECK_WIKI", {
                wikiUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/",
            }),
        );
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("GITHUB_DISCUSSIONS", {
                discussionsUrl:
                    "https://github.com/st3v3nmw/obsidian-spaced-repetition/discussions/",
            }),
        );
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("GITHUB_ISSUES", {
                issuesUrl: "https://github.com/st3v3nmw/obsidian-spaced-repetition/issues/",
            }),
        );
        containerEl.createEl("h3", { text: `${t("LOGGING")}` });
        new import_obsidian6.Setting(containerEl)
            .setName(t("DISPLAY_SCHEDULING_DEBUG_INFO"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.showSchedulingDebugMessages)
                    .onChange(async (value) => {
                        this.plugin.data.settings.showSchedulingDebugMessages = value;
                        await this.plugin.savePluginData();
                    }),
            );
        new import_obsidian6.Setting(containerEl)
            .setName(t("DISPLAY_PARSER_DEBUG_INFO"))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.data.settings.showParserDebugMessages)
                    .onChange(async (value) => {
                        this.plugin.data.settings.showParserDebugMessages = value;
                        setDebugParser(this.plugin.data.settings.showParserDebugMessages);
                        await this.plugin.savePluginData();
                    }),
            );
        containerEl.createEl("h3", { text: t("GROUP_CONTRIBUTING") });
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("GITHUB_SOURCE_CODE", {
                githubProjectUrl: "https://github.com/st3v3nmw/obsidian-spaced-repetition",
            }),
        );
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("CODE_CONTRIBUTION_INFO", {
                codeContributionUrl:
                    "https://www.stephenmwangi.com/obsidian-spaced-repetition/contributing/#code",
            }),
        );
        containerEl.createEl("p").insertAdjacentHTML(
            "beforeend",
            t("TRANSLATION_CONTRIBUTION_INFO", {
                translationContributionUrl:
                    "https://www.stephenmwangi.com/obsidian-spaced-repetition/contributing/#translating",
            }),
        );
    }
    rememberLastPosition(containerElement) {
        const lastPosition = this.lastPosition;
        this.tabStructure.buttons[lastPosition.tabName].click();
        containerElement.scrollTo({
            top: this.lastPosition.scrollPosition,
            behavior: "auto",
        });
        containerElement.addEventListener("scroll", (_2) => {
            this.lastPosition.scrollPosition = containerElement.scrollTop;
        });
        for (const tabName in this.tabStructure.buttons) {
            const button = this.tabStructure.buttons[tabName];
            button.onClickEvent((_2) => {
                lastPosition.tabName = tabName;
            });
        }
    }
};

// src/gui/sidebar.tsx
var OsrSidebar = class {
    get app() {
        return this.plugin.app;
    }
    constructor(plugin, settings, nextNoteReviewHandler) {
        this.plugin = plugin;
        this.settings = settings;
        this.nextNoteReviewHandler = nextNoteReviewHandler;
    }
    redraw() {
        this.reviewQueueListView.redraw();
    }
    getActiveLeaf(type) {
        const leaves = this.app.workspace.getLeavesOfType(type);
        if (leaves.length == 0) {
            return this.app.workspace.getRightLeaf(false);
        }
        return leaves[0];
    }
    init() {
        this.plugin.registerView(REVIEW_QUEUE_VIEW_TYPE, (leaf) => {
            return (this.reviewQueueListView = new ReviewQueueListView(
                leaf,
                this.nextNoteReviewHandler,
                this.settings,
            ));
        });
    }
    async activateReviewQueueViewPanel() {
        if (this.settings.enableNoteReviewPaneOnStartup) {
            await this.getActiveLeaf(REVIEW_QUEUE_VIEW_TYPE).setViewState({
                type: REVIEW_QUEUE_VIEW_TYPE,
                active: true,
            });
        }
    }
    async openReviewQueueView() {
        const reviewQueueLeaf = this.getActiveLeaf(REVIEW_QUEUE_VIEW_TYPE);
        this.app.workspace.revealLeaf(reviewQueueLeaf);
    }
};

// src/gui/sr-modal.tsx
var import_obsidian10 = require("obsidian");

// src/gui/card-ui.tsx
var import_moment4 = __toESM(require_moment());
var import_obsidian8 = require("obsidian");

// src/utils/renderers.ts
var import_obsidian7 = require("obsidian");
var RenderMarkdownWrapper = class {
    constructor(app, plugin, notePath) {
        this.app = app;
        this.notePath = notePath;
        this.plugin = plugin;
    }
    // slightly modified version of the renderMarkdown function in
    // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/KanbanView.tsx
    async renderMarkdownWrapper(markdownString, containerEl, textDirection, recursiveDepth = 0) {
        if (recursiveDepth > 4) return;
        let el;
        if (textDirection == 2 /* Rtl */) {
            el = containerEl.createDiv();
            el.setAttribute("dir", "rtl");
        } else el = containerEl;
        import_obsidian7.MarkdownRenderer.render(
            this.app,
            markdownString,
            el,
            this.notePath,
            this.plugin,
        );
        el.findAll(".internal-embed").forEach((el2) => {
            const link2 = this.parseLink(el2.getAttribute("src"));
            if (!link2.target) {
                el2.innerText = link2.text;
            } else if (link2.target instanceof import_obsidian7.TFile) {
                if (link2.target.extension !== "md") {
                    this.embedMediaFile(el2, link2.target);
                } else {
                }
            }
        });
    }
    parseLink(src) {
        const linkComponentsRegex =
            /^(?<file>[^#^]+)?(?:#(?!\^)(?<heading>.+)|#\^(?<blockId>.+)|#)?$/;
        const matched = typeof src === "string" && src.match(linkComponentsRegex);
        const file = matched.groups.file || this.notePath;
        const target = this.plugin.app.metadataCache.getFirstLinkpathDest(file, this.notePath);
        return {
            text: matched[0],
            file: matched.groups.file,
            heading: matched.groups.heading,
            blockId: matched.groups.blockId,
            target,
        };
    }
    embedMediaFile(el, target) {
        el.innerText = "";
        if (IMAGE_FORMATS.includes(target.extension)) {
            el.createEl(
                "img",
                {
                    attr: {
                        src: this.plugin.app.vault.getResourcePath(target),
                    },
                },
                (img) => {
                    if (el.hasAttribute("width"))
                        img.setAttribute("width", el.getAttribute("width"));
                    else img.setAttribute("width", "100%");
                    if (el.hasAttribute("alt")) img.setAttribute("alt", el.getAttribute("alt"));
                    el.addEventListener(
                        "click",
                        (ev) =>
                            (ev.target.style.minWidth =
                                ev.target.style.minWidth === "100%" ? null : "100%"),
                    );
                },
            );
            el.addClasses(["image-embed", "is-loaded"]);
        } else if (
            AUDIO_FORMATS.includes(target.extension) ||
            VIDEO_FORMATS.includes(target.extension)
        ) {
            el.createEl(
                AUDIO_FORMATS.includes(target.extension) ? "audio" : "video",
                {
                    attr: {
                        controls: "",
                        src: this.plugin.app.vault.getResourcePath(target),
                    },
                },
                (audio) => {
                    if (el.hasAttribute("alt")) audio.setAttribute("alt", el.getAttribute("alt"));
                },
            );
            el.addClasses(["media-embed", "is-loaded"]);
        } else {
            el.innerText = target.path;
        }
    }
};

// src/gui/card-ui.tsx
var CardUI = class {
    constructor(
        app,
        plugin,
        settings,
        reviewSequencer,
        reviewMode,
        view,
        backToDeck,
        editClickHandler,
    ) {
        this.totalCardsInSession = 0;
        this.totalDecksInSession = 0;
        this.currentDeckTotalCardsInQueue = 0;
        this._keydownHandler = (e2) => {
            if (
                document.activeElement.nodeName === "TEXTAREA" ||
                this.mode === 3 /* Closed */ ||
                !this.plugin.getSRInFocusState()
            ) {
                return;
            }
            const consumeKeyEvent = () => {
                e2.preventDefault();
                e2.stopPropagation();
            };
            switch (e2.code) {
                case "KeyS":
                    this._skipCurrentCard();
                    consumeKeyEvent();
                    break;
                case "Space":
                    if (this.mode === 1 /* Front */) {
                        this._showAnswer();
                        consumeKeyEvent();
                    } else if (this.mode === 2 /* Back */) {
                        this._processReview(1 /* Good */);
                        consumeKeyEvent();
                    }
                    break;
                case "Enter":
                case "NumpadEnter":
                    if (this.mode !== 1 /* Front */) {
                        break;
                    }
                    this._showAnswer();
                    consumeKeyEvent();
                    break;
                case "Numpad1":
                case "Digit1":
                    if (this.mode !== 2 /* Back */) {
                        break;
                    }
                    this._processReview(2 /* Hard */);
                    consumeKeyEvent();
                    break;
                case "Numpad2":
                case "Digit2":
                    if (this.mode !== 2 /* Back */) {
                        break;
                    }
                    this._processReview(1 /* Good */);
                    consumeKeyEvent();
                    break;
                case "Numpad3":
                case "Digit3":
                    if (this.mode !== 2 /* Back */) {
                        break;
                    }
                    this._processReview(0 /* Easy */);
                    consumeKeyEvent();
                    break;
                case "Numpad0":
                case "Digit0":
                    if (this.mode !== 2 /* Back */) {
                        break;
                    }
                    this._processReview(3 /* Reset */);
                    consumeKeyEvent();
                    break;
                default:
                    break;
            }
        };
        this.app = app;
        this.plugin = plugin;
        this.settings = settings;
        this.reviewSequencer = reviewSequencer;
        this.reviewMode = reviewMode;
        this.backToDeck = backToDeck;
        this.editClickHandler = editClickHandler;
        this.view = view;
        this.chosenDeck = null;
        this.init();
    }
    // #region -> public methods
    /**
     * Initializes all static elements in the FlashcardView
     */
    init() {
        this.view.addClasses(["sr-flashcard", "sr-is-hidden"]);
        this.controls = this.view.createDiv();
        this.controls.addClass("sr-controls");
        this._createCardControls();
        this._createInfoSection();
        this.content = this.view.createDiv();
        this.content.addClass("sr-content");
        this.response = this.view.createDiv();
        this.response.addClass("sr-response");
        this._createResponseButtons();
    }
    /**
     * Shows the FlashcardView if it is hidden
     */
    async show(chosenDeck) {
        if (!this.view.hasClass("sr-is-hidden")) {
            return;
        }
        this.chosenDeck = chosenDeck;
        const deckStats = this.reviewSequencer.getDeckStats(chosenDeck.getTopicPath());
        this.totalCardsInSession = deckStats.cardsInQueueCount;
        this.totalDecksInSession = deckStats.decksInQueueOfThisDeckCount;
        await this._drawContent();
        this.view.removeClass("sr-is-hidden");
        document.addEventListener("keydown", this._keydownHandler);
    }
    /**
     * Refreshes all dynamic elements
     */
    async refresh() {
        await this._drawContent();
    }
    /**
     * Hides the FlashcardView if it is visible
     */
    hide() {
        if (this.view.hasClass("sr-is-hidden")) {
            return;
        }
        document.removeEventListener("keydown", this._keydownHandler);
        this.view.addClass("sr-is-hidden");
    }
    /**
     * Closes the FlashcardView
     */
    close() {
        this.hide();
        document.removeEventListener("keydown", this._keydownHandler);
    }
    // #region -> Functions & helpers
    async _drawContent() {
        this.resetButton.disabled = true;
        this.mode = 1 /* Front */;
        this.previousDeck = this.currentDeck;
        this.currentDeck = this.reviewSequencer.currentDeck;
        if (this.previousDeck !== this.currentDeck) {
            const currentDeckStats = this.reviewSequencer.getDeckStats(
                this.currentDeck.getTopicPath(),
            );
            this.currentDeckTotalCardsInQueue = currentDeckStats.cardsInQueueOfThisDeckCount;
        }
        this._updateInfoBar(this.chosenDeck, this.currentDeck);
        this.content.empty();
        const wrapper = new RenderMarkdownWrapper(
            this.app,
            this.plugin,
            this._currentNote.filePath,
        );
        await wrapper.renderMarkdownWrapper(
            this._currentCard.front.trimStart(),
            this.content,
            this._currentQuestion.questionText.textDirection,
        );
        this.content.scrollTop = 0;
        this._resetResponseButtons();
    }
    get _currentCard() {
        return this.reviewSequencer.currentCard;
    }
    get _currentQuestion() {
        return this.reviewSequencer.currentQuestion;
    }
    get _currentNote() {
        return this.reviewSequencer.currentNote;
    }
    async _processReview(response) {
        const timeNow = (0, import_moment4.now)();
        if (
            this.lastPressed &&
            timeNow - this.lastPressed < this.plugin.data.settings.reviewButtonDelay
        ) {
            return;
        }
        this.lastPressed = timeNow;
        await this.reviewSequencer.processReview(response);
        await this._showNextCard();
    }
    async _showNextCard() {
        if (this._currentCard != null) await this.refresh();
        else this.backToDeck();
    }
    // #region -> Controls
    _createCardControls() {
        this._createEditButton();
        this._createResetButton();
        this._createCardInfoButton();
        this._createSkipButton();
    }
    _createEditButton() {
        this.editButton = this.controls.createEl("button");
        this.editButton.addClasses(["sr-button", "sr-edit-button"]);
        (0, import_obsidian8.setIcon)(this.editButton, "edit");
        this.editButton.setAttribute("aria-label", t("EDIT_CARD"));
        this.editButton.addEventListener("click", async () => {
            this.editClickHandler();
        });
    }
    _createResetButton() {
        this.resetButton = this.controls.createEl("button");
        this.resetButton.addClasses(["sr-button", "sr-reset-button"]);
        (0, import_obsidian8.setIcon)(this.resetButton, "refresh-cw");
        this.resetButton.setAttribute("aria-label", t("RESET_CARD_PROGRESS"));
        this.resetButton.addEventListener("click", () => {
            this._processReview(3 /* Reset */);
        });
    }
    _createCardInfoButton() {
        this.infoButton = this.controls.createEl("button");
        this.infoButton.addClasses(["sr-button", "sr-info-button"]);
        (0, import_obsidian8.setIcon)(this.infoButton, "info");
        this.infoButton.setAttribute("aria-label", "View Card Info");
        this.infoButton.addEventListener("click", async () => {
            this._displayCurrentCardInfoNotice();
        });
    }
    _createSkipButton() {
        this.skipButton = this.controls.createEl("button");
        this.skipButton.addClasses(["sr-button", "sr-skip-button"]);
        (0, import_obsidian8.setIcon)(this.skipButton, "chevrons-right");
        this.skipButton.setAttribute("aria-label", t("SKIP"));
        this.skipButton.addEventListener("click", () => {
            this._skipCurrentCard();
        });
    }
    async _skipCurrentCard() {
        this.reviewSequencer.skipCurrentCard();
        await this._showNextCard();
    }
    _displayCurrentCardInfoNotice() {
        var _a;
        const schedule = this._currentCard.scheduleInfo;
        const currentEaseStr =
            t("CURRENT_EASE_HELP_TEXT") +
            ((_a = schedule == null ? void 0 : schedule.latestEase) != null ? _a : t("NEW"));
        const currentIntervalStr =
            t("CURRENT_INTERVAL_HELP_TEXT") +
            textInterval(schedule == null ? void 0 : schedule.interval, false);
        const generatedFromStr = t("CARD_GENERATED_FROM", {
            notePath: this._currentQuestion.note.filePath,
        });
        new import_obsidian8.Notice(
            currentEaseStr + "\n" + currentIntervalStr + "\n" + generatedFromStr,
        );
    }
    // #region -> Deck Info
    _createInfoSection() {
        this.infoSection = this.view.createDiv();
        this.infoSection.addClass("sr-info-section");
        this.deckProgressInfo = this.infoSection.createDiv();
        this.deckProgressInfo.addClass("sr-deck-progress-info");
        this.chosenDeckInfo = this.deckProgressInfo.createDiv();
        this.chosenDeckInfo.addClass("sr-chosen-deck-info");
        this.chosenDeckName = this.chosenDeckInfo.createDiv();
        this.chosenDeckName.addClass("sr-chosen-deck-name");
        this.chosenDeckCounterWrapper = this.chosenDeckInfo.createDiv();
        this.chosenDeckCounterWrapper.addClass("sr-chosen-deck-counter-wrapper");
        this.chosenDeckCounterDivider = this.chosenDeckCounterWrapper.createDiv();
        this.chosenDeckCounterDivider.addClass("sr-chosen-deck-counter-divider");
        this.chosenDeckCardCounterWrapper = this.chosenDeckCounterWrapper.createDiv();
        this.chosenDeckCardCounterWrapper.addClass("sr-chosen-deck-card-counter-wrapper");
        this.chosenDeckCardCounter = this.chosenDeckCardCounterWrapper.createDiv();
        this.chosenDeckCardCounter.addClass("sr-chosen-deck-card-counter");
        this.chosenDeckCardCounterIcon = this.chosenDeckCardCounterWrapper.createDiv();
        this.chosenDeckCardCounterIcon.addClass("sr-chosen-deck-card-counter-icon");
        (0, import_obsidian8.setIcon)(this.chosenDeckCardCounterIcon, "credit-card");
        this.chosenDeckSubDeckCounterWrapper = this.chosenDeckCounterWrapper.createDiv();
        this.chosenDeckSubDeckCounterWrapper.addClass("sr-is-hidden");
        this.chosenDeckSubDeckCounterWrapper.addClass("sr-chosen-deck-subdeck-counter-wrapper");
        this.chosenDeckSubDeckCounter = this.chosenDeckSubDeckCounterWrapper.createDiv();
        this.chosenDeckSubDeckCounter.addClass("sr-chosen-deck-subdeck-counter");
        this.chosenDeckSubDeckCounterIcon = this.chosenDeckSubDeckCounterWrapper.createDiv();
        this.chosenDeckSubDeckCounterIcon.addClass("sr-chosen-deck-subdeck-counter-icon");
        (0, import_obsidian8.setIcon)(this.chosenDeckSubDeckCounterIcon, "layers");
        this.currentDeckInfo = this.deckProgressInfo.createDiv();
        this.currentDeckInfo.addClass("sr-is-hidden");
        this.currentDeckInfo.addClass("sr-current-deck-info");
        this.currentDeckName = this.currentDeckInfo.createDiv();
        this.currentDeckName.addClass("sr-current-deck-name");
        this.currentDeckCounterWrapper = this.currentDeckInfo.createDiv();
        this.currentDeckCounterWrapper.addClass("sr-current-deck-counter-wrapper");
        this.currentDeckCounterDivider = this.currentDeckCounterWrapper.createDiv();
        this.currentDeckCounterDivider.addClass("sr-current-deck-counter-divider");
        this.currentDeckCardCounterWrapper = this.currentDeckCounterWrapper.createDiv();
        this.currentDeckCardCounterWrapper.addClass("sr-current-deck-card-counter-wrapper");
        this.currentDeckCardCounter = this.currentDeckCardCounterWrapper.createDiv();
        this.currentDeckCardCounter.addClass("sr-current-deck-card-counter");
        this.currentDeckCardCounterIcon = this.currentDeckCardCounterWrapper.createDiv();
        this.currentDeckCardCounterIcon.addClass("sr-current-deck-card-counter-icon");
        (0, import_obsidian8.setIcon)(this.currentDeckCardCounterIcon, "credit-card");
        if (this.settings.showContextInCards) {
            this.cardContext = this.infoSection.createDiv();
            this.cardContext.addClass("sr-context");
        }
    }
    _updateInfoBar(chosenDeck, currentDeck) {
        this._updateChosenDeckInfo(chosenDeck);
        this._updateCurrentDeckInfo(chosenDeck, currentDeck);
        this._updateCardContext();
    }
    _updateChosenDeckInfo(chosenDeck) {
        const chosenDeckStats = this.reviewSequencer.getDeckStats(chosenDeck.getTopicPath());
        this.chosenDeckName.setText(`${chosenDeck.deckName}`);
        this.chosenDeckCardCounter.setText(
            `${this.totalCardsInSession - chosenDeckStats.cardsInQueueCount}/${this.totalCardsInSession}`,
        );
        if (chosenDeck.subdecks.length === 0) {
            if (!this.chosenDeckSubDeckCounterWrapper.hasClass("sr-is-hidden")) {
                this.chosenDeckSubDeckCounterWrapper.addClass("sr-is-hidden");
            }
            return;
        }
        if (this.chosenDeckSubDeckCounterWrapper.hasClass("sr-is-hidden")) {
            this.chosenDeckSubDeckCounterWrapper.removeClass("sr-is-hidden");
        }
        this.chosenDeckSubDeckCounter.setText(
            `${this.totalDecksInSession - chosenDeckStats.decksInQueueOfThisDeckCount}/${this.totalDecksInSession}`,
        );
    }
    _updateCurrentDeckInfo(chosenDeck, currentDeck) {
        if (chosenDeck.subdecks.length === 0) {
            if (!this.currentDeckInfo.hasClass("sr-is-hidden")) {
                this.currentDeckInfo.addClass("sr-is-hidden");
            }
            return;
        }
        if (this.currentDeckInfo.hasClass("sr-is-hidden")) {
            this.currentDeckInfo.removeClass("sr-is-hidden");
        }
        this.currentDeckName.setText(`${currentDeck.deckName}`);
        const isRandomMode = this.settings.flashcardCardOrder === "EveryCardRandomDeckAndCard";
        if (!isRandomMode) {
            const currentDeckStats = this.reviewSequencer.getDeckStats(currentDeck.getTopicPath());
            this.currentDeckCardCounter.setText(
                `${this.currentDeckTotalCardsInQueue - currentDeckStats.cardsInQueueOfThisDeckCount}/${this.currentDeckTotalCardsInQueue}`,
            );
        }
    }
    _updateCardContext() {
        if (!this.cardContext) return;
        if (!this.settings.showContextInCards) {
            this.cardContext.setText("");
            return;
        }
        this.cardContext.setText(
            ` ${this._formatQuestionContextText(this._currentQuestion.questionContext)}`,
        );
    }
    _formatQuestionContextText(questionContext) {
        const separator = " > ";
        let result = this._currentNote.file.basename;
        questionContext.forEach((context) => {
            if (context.startsWith("[[") && context.endsWith("]]")) {
                context = context.replace("[[", "").replace("]]", "");
                if (context.contains("|")) {
                    context = context.split("|")[1];
                }
            }
            result += separator + context;
        });
        return result;
    }
    // #region -> Response
    _createResponseButtons() {
        this._createShowAnswerButton();
        this._createHardButton();
        this._createGoodButton();
        this._createEasyButton();
    }
    _resetResponseButtons() {
        this.answerButton.removeClass("sr-is-hidden");
        this.hardButton.addClass("sr-is-hidden");
        this.goodButton.addClass("sr-is-hidden");
        this.easyButton.addClass("sr-is-hidden");
    }
    _createShowAnswerButton() {
        this.answerButton = this.response.createEl("button");
        this.answerButton.addClasses(["sr-response-button", "sr-show-answer-button", "sr-bg-blue"]);
        this.answerButton.setText(t("SHOW_ANSWER"));
        this.answerButton.addEventListener("click", () => {
            this._showAnswer();
        });
    }
    _createHardButton() {
        this.hardButton = this.response.createEl("button");
        this.hardButton.addClasses([
            "sr-response-button",
            "sr-hard-button",
            "sr-bg-red",
            "sr-is-hidden",
        ]);
        this.hardButton.setText(this.settings.flashcardHardText);
        this.hardButton.addEventListener("click", () => {
            this._processReview(2 /* Hard */);
        });
    }
    _createGoodButton() {
        this.goodButton = this.response.createEl("button");
        this.goodButton.addClasses([
            "sr-response-button",
            "sr-good-button",
            "sr-bg-blue",
            "sr-is-hidden",
        ]);
        this.goodButton.setText(this.settings.flashcardGoodText);
        this.goodButton.addEventListener("click", () => {
            this._processReview(1 /* Good */);
        });
    }
    _createEasyButton() {
        this.easyButton = this.response.createEl("button");
        this.easyButton.addClasses([
            "sr-response-button",
            "sr-hard-button",
            "sr-bg-green",
            "sr-is-hidden",
        ]);
        this.easyButton.setText(this.settings.flashcardEasyText);
        this.easyButton.addEventListener("click", () => {
            this._processReview(0 /* Easy */);
        });
    }
    _setupEaseButton(button, buttonName, reviewResponse) {
        const schedule = this.reviewSequencer.determineCardSchedule(
            reviewResponse,
            this._currentCard,
        );
        const interval = schedule.interval;
        if (this.settings.showIntervalInReviewButtons) {
            if (import_obsidian8.Platform.isMobile) {
                button.setText(textInterval(interval, true));
            } else {
                button.setText(`${buttonName} - ${textInterval(interval, false)}`);
            }
        } else {
            button.setText(buttonName);
        }
    }
    _showAnswer() {
        const timeNow = (0, import_moment4.now)();
        if (
            this.lastPressed &&
            timeNow - this.lastPressed < this.plugin.data.settings.reviewButtonDelay
        ) {
            return;
        }
        this.lastPressed = timeNow;
        this.mode = 2 /* Back */;
        this.resetButton.disabled = false;
        if (this._currentQuestion.questionType !== 4 /* Cloze */) {
            const hr = document.createElement("hr");
            this.content.appendChild(hr);
        } else {
            this.content.empty();
        }
        const wrapper = new RenderMarkdownWrapper(
            this.app,
            this.plugin,
            this._currentNote.filePath,
        );
        wrapper.renderMarkdownWrapper(
            this._currentCard.back,
            this.content,
            this._currentQuestion.questionText.textDirection,
        );
        this.answerButton.addClass("sr-is-hidden");
        this.hardButton.removeClass("sr-is-hidden");
        this.easyButton.removeClass("sr-is-hidden");
        if (this.reviewMode === 0 /* Cram */) {
            this.response.addClass("is-cram");
            this.hardButton.setText(`${this.settings.flashcardHardText}`);
            this.easyButton.setText(`${this.settings.flashcardEasyText}`);
        } else {
            this.goodButton.removeClass("sr-is-hidden");
            this._setupEaseButton(this.hardButton, this.settings.flashcardHardText, 2 /* Hard */);
            this._setupEaseButton(this.goodButton, this.settings.flashcardGoodText, 1 /* Good */);
            this._setupEaseButton(this.easyButton, this.settings.flashcardEasyText, 0 /* Easy */);
        }
    }
};

// src/gui/deck-ui.tsx
var import_vhtml3 = __toESM(require_vhtml());
var DeckUI = class {
    constructor(plugin, settings, reviewSequencer, view, startReviewOfDeck) {
        this.plugin = plugin;
        this.settings = settings;
        this.reviewSequencer = reviewSequencer;
        this.view = view;
        this.startReviewOfDeck = startReviewOfDeck;
        this.init();
    }
    /**
     * Initializes all static elements in the DeckListView
     */
    init() {
        this.view.addClasses(["sr-deck-list", "sr-is-hidden"]);
        this.header = this.view.createDiv();
        this.header.addClass("sr-header");
        this.title = this.header.createDiv();
        this.title.addClass("sr-title");
        this.title.setText(t("DECKS"));
        this.stats = this.header.createDiv();
        this.stats.addClass("sr-header-stats-container");
        this._createHeaderStats();
        this.headerDivider = this.view.createEl("hr");
        this.content = this.view.createDiv();
        this.content.addClass("sr-content");
    }
    /**
     * Shows the DeckListView & rerenders dynamic elements
     */
    show() {
        this.mode = 0 /* Deck */;
        this._createHeaderStats();
        this.content.empty();
        for (const deck of this.reviewSequencer.originalDeckTree.subdecks) {
            this._createTree(deck, this.content);
        }
        if (this.view.hasClass("sr-is-hidden")) {
            this.view.removeClass("sr-is-hidden");
        }
    }
    /**
     * Hides the DeckListView
     */
    hide() {
        if (!this.view.hasClass("sr-is-hidden")) {
            this.view.addClass("sr-is-hidden");
        }
    }
    /**
     * Closes the DeckListView
     */
    close() {
        this.hide();
    }
    // -> Header
    _createHeaderStats() {
        const statistics = this.reviewSequencer.getDeckStats(TopicPath.emptyPath);
        this.stats.empty();
        this._createHeaderStatsContainer(t("DUE_CARDS"), statistics.dueCount, "sr-bg-green");
        this._createHeaderStatsContainer(t("NEW_CARDS"), statistics.newCount, "sr-bg-blue");
        this._createHeaderStatsContainer(t("TOTAL_CARDS"), statistics.totalCount, "sr-bg-red");
    }
    _createHeaderStatsContainer(statsLable, statsNumber, statsClass) {
        const statsContainer = this.stats.createDiv();
        statsContainer.ariaLabel = statsLable;
        statsContainer.addClasses([
            "tag-pane-tag-count",
            "tree-item-flair",
            "sr-header-stats-count",
            statsClass,
        ]);
        const lable = statsContainer.createDiv();
        lable.setText(statsLable + ":");
        const number = statsContainer.createDiv();
        number.setText(statsNumber.toString());
    }
    // -> Tree content
    _createTree(deck, container) {
        const deckTree = container.createDiv("tree-item sr-tree-item-container");
        const deckTreeSelf = deckTree.createDiv(
            "tree-item-self tag-pane-tag is-clickable sr-tree-item-row",
        );
        const shouldBeInitiallyExpanded = this.settings.initiallyExpandAllSubdecksInTree;
        let collapsed = !shouldBeInitiallyExpanded;
        let collapseIconEl = null;
        if (deck.subdecks.length > 0) {
            collapseIconEl = deckTreeSelf.createDiv("tree-item-icon collapse-icon");
            collapseIconEl.innerHTML = COLLAPSE_ICON;
            collapseIconEl.childNodes[0].style.transform = collapsed ? "rotate(-90deg)" : "";
        }
        const deckTreeInner = deckTreeSelf.createDiv("tree-item-inner");
        const deckTreeInnerText = deckTreeInner.createDiv("tag-pane-tag-text");
        deckTreeInnerText.innerHTML += /* @__PURE__ */ (0, import_vhtml3.default)(
            "span",
            { class: "tag-pane-tag-self" },
            deck.deckName,
        );
        const deckTreeOuter = deckTreeSelf.createDiv();
        deckTreeOuter.addClasses(["tree-item-flair-outer", "sr-tree-stats-container"]);
        const deckStats = this.reviewSequencer.getDeckStats(deck.getTopicPath());
        this._createStats(deckStats, deckTreeOuter);
        const deckTreeChildren = deckTree.createDiv("tree-item-children");
        deckTreeChildren.style.display = collapsed ? "none" : "block";
        if (deck.subdecks.length > 0) {
            collapseIconEl.addEventListener("click", (e2) => {
                if (collapsed) {
                    collapseIconEl.childNodes[0].style.transform = "";
                    deckTreeChildren.style.display = "block";
                } else {
                    collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
                    deckTreeChildren.style.display = "none";
                }
                e2.stopPropagation();
                collapsed = !collapsed;
            });
        }
        deckTreeSelf.addEventListener("click", () => {
            this.startReviewOfDeck(deck);
        });
        for (const subdeck of deck.subdecks) {
            this._createTree(subdeck, deckTreeChildren);
        }
    }
    _createStats(statistics, statsWrapper) {
        statsWrapper.empty();
        this._createStatsContainer(
            t("DUE_CARDS"),
            statistics.dueCount,
            "sr-bg-green",
            statsWrapper,
        );
        this._createStatsContainer(t("NEW_CARDS"), statistics.newCount, "sr-bg-blue", statsWrapper);
        this._createStatsContainer(
            t("TOTAL_CARDS"),
            statistics.totalCount,
            "sr-bg-red",
            statsWrapper,
        );
    }
    _createStatsContainer(statsLable, statsNumber, statsClass, statsWrapper) {
        const statsContainer = statsWrapper.createDiv();
        statsContainer.ariaLabel = statsLable;
        statsContainer.addClasses([
            "tag-pane-tag-count",
            "tree-item-flair",
            "sr-tree-stats-count",
            statsClass,
        ]);
        statsContainer.setText(statsNumber.toString());
    }
};

// src/gui/edit-modal.tsx
var import_obsidian9 = require("obsidian");
var FlashcardEditModal = class _FlashcardEditModal extends import_obsidian9.Modal {
    constructor(app, existingText, textDirection) {
        super(app);
        this.didSaveChanges = false;
        // -> Functions & helpers
        this.saveClickCallback = (_2) => this.save();
        this.cancelClickCallback = (_2) => this.cancel();
        this.saveOnEnterCallback = (evt) => {
            if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
                evt.preventDefault();
                this.save();
            }
        };
        this.modalText = existingText;
        this.changedText = existingText;
        this.textDirection = textDirection;
        this.waitForClose = new Promise((resolve2, reject) => {
            this.resolvePromise = resolve2;
            this.rejectPromise = reject;
        });
        this.modalEl.addClasses(["sr-modal", "sr-edit-modal"]);
        this.init();
        this.open();
    }
    static Prompt(app, placeholder, textDirection) {
        const newPromptModal = new _FlashcardEditModal(app, placeholder, textDirection);
        return newPromptModal.waitForClose;
    }
    /**
     * Initializes all components of the EditModal
     */
    init() {
        var _a;
        this.contentEl.empty();
        this.contentEl.addClass("sr-edit-view");
        this.title = this.contentEl.createDiv();
        this.title.setText(t("EDIT_CARD"));
        this.title.addClass("sr-title");
        this.textArea = this.contentEl.createEl("textarea");
        this.textArea.addClass("sr-input");
        this.textArea.setText((_a = this.modalText) != null ? _a : "");
        this.textArea.addEventListener("keydown", this.saveOnEnterCallback);
        if (this.textDirection == 2 /* Rtl */) {
            this.textArea.setAttribute("dir", "rtl");
        }
        this._createResponse(this.contentEl);
    }
    /**
     * Opens the EditModal
     */
    onOpen() {
        super.onOpen();
        this.textArea.focus();
    }
    /**
     * Closes the EditModal
     */
    onClose() {
        super.onClose();
        this.resolveInput();
        this.removeInputListener();
    }
    save() {
        this.didSaveChanges = true;
        this.changedText = this.textArea.value;
        this.close();
    }
    cancel() {
        this.close();
    }
    resolveInput() {
        if (!this.didSaveChanges) this.rejectPromise(t("NO_INPUT"));
        else this.resolvePromise(this.changedText);
    }
    removeInputListener() {
        this.textArea.removeEventListener("keydown", this.saveOnEnterCallback);
    }
    // -> Response section
    _createResponseButton(container, text, colorClass, callback2) {
        const button = container.createEl("button");
        button.addClasses(["sr-response-button", colorClass]);
        button.setText(text);
        button.addEventListener("click", callback2);
    }
    _createResponse(mainContentContainer) {
        const response = mainContentContainer.createDiv();
        response.addClass("sr-response");
        this._createResponseButton(response, t("CANCEL"), "sr-bg-red", this.cancelClickCallback);
        this._createResponseButton(response, "", "sr-spacer", () => {});
        this._createResponseButton(response, t("SAVE"), "sr-bg-green", this.saveClickCallback);
    }
};

// src/gui/sr-modal.tsx
var FlashcardModal = class extends import_obsidian10.Modal {
    constructor(app, plugin, settings, reviewSequencer, reviewMode) {
        super(app);
        this.plugin = plugin;
        this.settings = settings;
        this.reviewSequencer = reviewSequencer;
        this.reviewMode = reviewMode;
        this.modalEl.style.height = this.settings.flashcardHeightPercentage + "%";
        this.modalEl.style.maxHeight = this.settings.flashcardHeightPercentage + "%";
        this.modalEl.style.width = this.settings.flashcardWidthPercentage + "%";
        this.modalEl.style.maxWidth = this.settings.flashcardWidthPercentage + "%";
        this.modalEl.setAttribute("id", "sr-modal");
        if (
            this.settings.flashcardHeightPercentage >= 100 ||
            this.settings.flashcardWidthPercentage >= 100
        ) {
            this.modalEl.style.borderRadius = "0";
        }
        this.contentEl.addClass("sr-modal-content");
        this.deckView = new DeckUI(
            this.plugin,
            this.settings,
            this.reviewSequencer,
            this.contentEl.createDiv(),
            this._startReviewOfDeck.bind(this),
        );
        this.flashcardView = new CardUI(
            this.app,
            this.plugin,
            this.settings,
            this.reviewSequencer,
            this.reviewMode,
            this.contentEl.createDiv(),
            this._showDecksList.bind(this),
            this._doEditQuestionText.bind(this),
        );
    }
    onOpen() {
        this._createBackButton();
        this._showDecksList();
    }
    onClose() {
        this.plugin.setSRViewInFocus(false);
        this.mode = 3 /* Closed */;
        this.deckView.close();
        this.flashcardView.close();
    }
    _showDecksList() {
        this._hideFlashcard();
        this.deckView.show();
    }
    _hideDecksList() {
        this.deckView.hide();
    }
    _showFlashcard(deck) {
        this._hideDecksList();
        this.flashcardView.show(deck);
    }
    _hideFlashcard() {
        this.flashcardView.hide();
    }
    _startReviewOfDeck(deck) {
        this.reviewSequencer.setCurrentDeck(deck.getTopicPath());
        if (this.reviewSequencer.hasCurrentCard) {
            this._showFlashcard(deck);
            this.backButton.removeClass("sr-is-hidden");
        } else {
            this._showDecksList();
        }
    }
    async _doEditQuestionText() {
        const currentQ = this.reviewSequencer.currentQuestion;
        const textPrompt = currentQ.questionText.actualQuestion;
        const editModal = FlashcardEditModal.Prompt(
            this.app,
            textPrompt,
            currentQ.questionText.textDirection,
        );
        editModal
            .then(async (modifiedCardText) => {
                this.reviewSequencer.updateCurrentQuestionText(modifiedCardText);
            })
            .catch((reason) => console.log(reason));
    }
    _createBackButton() {
        this.backButton = this.modalEl.createDiv();
        this.backButton.addClasses(["sr-back-button", "sr-is-hidden"]);
        (0, import_obsidian10.setIcon)(this.backButton, "arrow-left");
        this.backButton.setAttribute("aria-label", t("BACK"));
        this.backButton.addEventListener("click", () => {
            this.backButton.addClass("sr-is-hidden");
            this._showDecksList();
        });
    }
};

// src/gui/sr-tab-view.tsx
var import_obsidian11 = require("obsidian");
var SRTabView = class extends import_obsidian11.ItemView {
    constructor(leaf, plugin, loadReviewSequencerData) {
        super(leaf);
        this.openErrorCount = 0;
        this.plugin = plugin;
        this.settings = plugin.data.settings;
        this.loadReviewSequencerData = loadReviewSequencerData;
        const viewContent = this.containerEl.getElementsByClassName("view-content");
        if (viewContent.length > 0) {
            this.viewContainerEl = viewContent[0];
            this.viewContainerEl.addClass("sr-tab-view");
            this.viewContentEl = this.viewContainerEl.createDiv("sr-tab-view-content");
            this.viewContentEl.style.height = this.settings.flashcardHeightPercentage + "%";
            this.viewContentEl.style.maxHeight = this.settings.flashcardHeightPercentage + "%";
            this.viewContentEl.style.width = this.settings.flashcardWidthPercentage + "%";
            this.viewContentEl.style.maxWidth = this.settings.flashcardWidthPercentage + "%";
            this.viewContainerEl.appendChild(this.viewContentEl);
        }
    }
    /**
     * Returns the view type identifier for the SRTabView.
     *
     * @returns {string} The view type identifier.
     */
    getViewType() {
        return SR_TAB_VIEW;
    }
    /**
     * Retrieves the icon identifier for the SRTabView.
     *
     * @returns {string} The tab icon identifier.
     */
    getIcon() {
        return "SpacedRepIcon";
    }
    /**
     * Returns the display text for the SRTabView.
     *
     * @returns {string} The display text for the SRTabView.
     */
    getDisplayText() {
        return "Spaced Repetition";
    }
    /**
     * Initializes the SRTabView when opened by loading the review sequencer data
     * and setting up the deck and flashcard views if they are not already initialized.
     * Catches and logs errors that occur during the initial loading process.
     */
    async onOpen() {
        try {
            this._createBackButton();
            const loadedData = await this.loadReviewSequencerData();
            this.reviewSequencer = loadedData.reviewSequencer;
            this.reviewMode = loadedData.mode;
            if (this.deckView === void 0) {
                this.deckView = new DeckUI(
                    this.plugin,
                    this.settings,
                    this.reviewSequencer,
                    this.viewContentEl.createDiv(),
                    this._startReviewOfDeck.bind(this),
                );
            }
            if (this.flashcardView === void 0) {
                this.flashcardView = new CardUI(
                    this.app,
                    this.plugin,
                    this.settings,
                    this.reviewSequencer,
                    this.reviewMode,
                    this.viewContentEl.createDiv(),
                    this._showDecksList.bind(this),
                    this._doEditQuestionText.bind(this),
                );
            }
            this._showDecksList();
        } catch (e2) {
            if (this.openErrorCount > 0) {
                console.error(e2);
            }
            this.openErrorCount++;
        }
    }
    /**
     * Closes the SRTabView by shutting down any active deck or flashcard views.
     * Ensures that resources associated with these views are properly released.
     */
    async onClose() {
        if (this.deckView) this.deckView.close();
        if (this.flashcardView) this.flashcardView.close();
    }
    _showDecksList() {
        this._hideFlashcard();
        this.deckView.show();
    }
    _hideDecksList() {
        this.deckView.hide();
    }
    _showFlashcard(deck) {
        this._hideDecksList();
        this.flashcardView.show(deck);
    }
    _hideFlashcard() {
        this.flashcardView.hide();
    }
    _startReviewOfDeck(deck) {
        this.reviewSequencer.setCurrentDeck(deck.getTopicPath());
        if (this.reviewSequencer.hasCurrentCard) {
            this.backButton.removeClass("sr-is-hidden");
            this._showFlashcard(deck);
        } else {
            this._showDecksList();
        }
    }
    async _doEditQuestionText() {
        const currentQ = this.reviewSequencer.currentQuestion;
        const textPrompt = currentQ.questionText.actualQuestion;
        const editModal = FlashcardEditModal.Prompt(
            this.app,
            textPrompt,
            currentQ.questionText.textDirection,
        );
        editModal
            .then(async (modifiedCardText) => {
                this.reviewSequencer.updateCurrentQuestionText(modifiedCardText);
            })
            .catch((reason) => console.log(reason));
    }
    _createBackButton() {
        this.backButton = this.viewContentEl.createDiv();
        this.backButton.addClasses(["sr-back-button", "sr-is-hidden"]);
        (0, import_obsidian11.setIcon)(this.backButton, "arrow-left");
        this.backButton.setAttribute("aria-label", t("BACK"));
        this.backButton.addEventListener("click", () => {
            this.backButton.addClass("sr-is-hidden");
            this._showDecksList();
        });
    }
};

// src/gui/tab-view-manager.tsx
var TabViewManager = class {
    // Add any needed resourced
    constructor(plugin) {
        // Add any new other tab view types to this, then they'll be automatically registered
        this.tabViewTypes = [
            {
                type: SR_TAB_VIEW,
                viewCreator: (leaf) =>
                    new SRTabView(leaf, this.plugin, async () => {
                        if (this.shouldOpenSingeNoteTabView) {
                            const singleNoteDeckData =
                                await this.plugin.getPreparedDecksForSingleNoteReview(
                                    this.chosenSingleNoteForTabbedView,
                                    this.chosenReviewModeForTabbedView,
                                );
                            return this.plugin.getPreparedReviewSequencer(
                                singleNoteDeckData.deckTree,
                                singleNoteDeckData.remainingDeckTree,
                                singleNoteDeckData.mode,
                            );
                        }
                        const fullDeckTree = this.osrAppCore.reviewableDeckTree;
                        const remainingDeckTree =
                            this.chosenReviewModeForTabbedView === 0 /* Cram */
                                ? this.osrAppCore.reviewableDeckTree
                                : this.osrAppCore.remainingDeckTree;
                        return this.plugin.getPreparedReviewSequencer(
                            fullDeckTree,
                            remainingDeckTree,
                            this.chosenReviewModeForTabbedView,
                        );
                    }),
            },
        ];
        this.plugin = plugin;
        this.shouldOpenSingeNoteTabView = false;
        this.registerAllTabViews();
    }
    /**
     * Opens the Spaced Repetition tab view in the application.
     *
     * This method sets up the necessary state for the tab view and invokes the
     * internal method to open the tab view with the specified parameters.
     *
     * @param osrAppCore - The core application instance used for managing reviewable decks.
     * @param reviewMode - The mode of flashcard review.
     * @param singleNote - Optional parameter specifying a single note to review.
     *                     If provided, the tab view will focus on this note.
     *
     * @returns {Promise<void>} - A promise that resolves when the tab view is opened.
     */
    async openSRTabView(osrAppCore, reviewMode, singleNote) {
        this.osrAppCore = osrAppCore;
        this.chosenReviewModeForTabbedView = reviewMode;
        this.shouldOpenSingeNoteTabView = singleNote !== void 0;
        if (singleNote) this.chosenSingleNoteForTabbedView = singleNote;
        await this.openTabView(SR_TAB_VIEW, true);
    }
    /**
     * Closes all open tab views in the application.
     *
     * This method iterates over all registered tab view types and detaches
     * their corresponding leaves from the workspace, effectively closing them.
     */
    closeAllTabViews() {
        this.forEachTabViewType((viewType) => {
            this.plugin.app.workspace.detachLeavesOfType(viewType.type);
        });
    }
    forEachTabViewType(callback2) {
        this.tabViewTypes.forEach((type) => callback2(type));
    }
    registerAllTabViews() {
        this.forEachTabViewType((viewType) =>
            this.plugin.registerView(viewType.type, viewType.viewCreator),
        );
    }
    async openTabView(type, newLeaf) {
        const { workspace } = this.plugin.app;
        let leaf = null;
        const leaves = workspace.getLeavesOfType(type);
        if (leaves.length > 0) {
            leaf = leaves[0];
        } else {
            leaf = workspace.getLeaf(newLeaf);
            if (leaf !== null) {
                await leaf.setViewState({ type, active: true });
            }
        }
        if (leaf !== null) {
            workspace.revealLeaf(leaf);
        }
    }
};

// src/icons/app-icon.ts
var import_obsidian12 = require("obsidian");
function appIcon() {
    (0, import_obsidian12.addIcon)(
        "SpacedRepIcon",
        `<path fill="currentColor" stroke="currentColor" d="M 88.960938 17.257812 L 47.457031 17.257812 C 45.679688 17.257812 44.230469 18.703125 44.230469 20.484375 L 44.230469 86.558594 C 44.230469 88.335938 45.679688 89.785156 47.457031 89.785156 L 88.960938 89.785156 C 90.738281 89.785156 92.1875 88.335938 92.1875 86.558594 L 92.1875 20.484375 C 92.1875 18.703125 90.738281 17.257812 88.960938 17.257812 Z M 88.28125 85.878906 L 48.136719 85.878906 L 48.136719 21.164062 L 88.28125 21.164062 Z M 88.28125 85.878906 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 88.960938 9.445312 L 61.667969 9.445312 C 59.925781 3.816406 54.011719 0.515625 48.269531 2.054688 L 8.183594 12.796875 C 2.304688 14.371094 -1.199219 20.4375 0.378906 26.316406 L 17.476562 90.140625 C 18.796875 95.066406 23.269531 98.324219 28.144531 98.324219 C 29.085938 98.324219 30.046875 98.199219 31 97.945312 L 40.765625 95.328125 C 42.625 96.75 44.941406 97.597656 47.457031 97.597656 L 88.960938 97.597656 C 95.046875 97.597656 100 92.644531 100 86.558594 L 100 20.484375 C 100 14.398438 95.046875 9.445312 88.960938 9.445312 Z M 29.988281 94.171875 C 26.1875 95.191406 22.269531 92.925781 21.25 89.128906 L 4.152344 25.304688 C 3.132812 21.507812 5.394531 17.585938 9.195312 16.570312 L 49.28125 5.828125 C 52.578125 4.945312 55.960938 6.53125 57.464844 9.445312 L 47.457031 9.445312 C 41.371094 9.445312 36.417969 14.398438 36.417969 20.484375 L 36.417969 86.558594 C 36.417969 88.558594 36.957031 90.433594 37.890625 92.054688 Z M 96.09375 86.558594 C 96.09375 90.492188 92.894531 93.691406 88.960938 93.691406 L 47.457031 93.691406 C 43.523438 93.691406 40.324219 90.492188 40.324219 86.558594 L 40.324219 20.484375 C 40.324219 16.550781 43.523438 13.351562 47.457031 13.351562 L 88.960938 13.351562 C 92.894531 13.351562 96.09375 16.550781 96.09375 20.484375 Z M 96.09375 86.558594 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 54.101562 53.09375 L 60.070312 57.410156 L 57.789062 64.378906 C 56.90625 67.074219 59.996094 69.320312 62.285156 67.648438 L 68.210938 63.324219 L 74.132812 67.648438 C 76.421875 69.320312 79.511719 67.074219 78.628906 64.378906 L 76.347656 57.410156 L 82.320312 53.09375 C 84.613281 51.433594 83.441406 47.804688 80.605469 47.804688 L 73.242188 47.804688 L 70.988281 40.839844 C 70.117188 38.144531 66.300781 38.144531 65.429688 40.839844 L 63.179688 47.804688 L 55.8125 47.804688 C 52.980469 47.804688 51.804688 51.433594 54.101562 53.09375 Z M 54.101562 53.09375 "/>
        `,
    );
}

// src/next-note-review-handler.ts
var import_obsidian14 = require("obsidian");

// src/gui/review-deck-selection-modal.tsx
var import_obsidian13 = require("obsidian");
var ReviewDeckSelectionModal = class extends import_obsidian13.FuzzySuggestModal {
    constructor(app, deckKeys) {
        super(app);
        this.deckKeys = [];
        this.deckKeys = deckKeys;
    }
    getItems() {
        return this.deckKeys;
    }
    getItemText(item) {
        return item;
    }
    onChooseItem(deckKey, _2) {
        this.close();
        this.submitCallback(deckKey);
    }
};

// src/next-note-review-handler.ts
var NextNoteReviewHandler = class {
    get lastSelectedReviewDeck() {
        return this._lastSelectedReviewDeck;
    }
    get noteReviewQueue() {
        return this._noteReviewQueue;
    }
    constructor(app, settings, noteReviewQueue) {
        this.app = app;
        this.settings = settings;
        this._noteReviewQueue = noteReviewQueue;
    }
    async autoReviewNextNote() {
        if (this.settings.autoNextNote) {
            if (!this._lastSelectedReviewDeck) {
                const reviewDeckKeys = this._noteReviewQueue.reviewDeckNameList;
                if (reviewDeckKeys.length > 0) this._lastSelectedReviewDeck = reviewDeckKeys[0];
                else {
                    new import_obsidian14.Notice(t("ALL_CAUGHT_UP"));
                    return;
                }
            }
            this.reviewNextNote(this._lastSelectedReviewDeck);
        }
    }
    async reviewNextNoteModal() {
        const reviewDeckNames = this._noteReviewQueue.reviewDeckNameList;
        if (reviewDeckNames.length === 1) {
            this.reviewNextNote(reviewDeckNames[0]);
        } else {
            const deckSelectionModal = new ReviewDeckSelectionModal(this.app, reviewDeckNames);
            deckSelectionModal.submitCallback = (deckKey) => this.reviewNextNote(deckKey);
            deckSelectionModal.open();
        }
    }
    async reviewNextNote(deckKey) {
        if (!this._noteReviewQueue.reviewDeckNameList.contains(deckKey)) {
            new import_obsidian14.Notice(t("NO_DECK_EXISTS", { deckName: deckKey }));
            return;
        }
        this._lastSelectedReviewDeck = deckKey;
        const deck = this._noteReviewQueue.reviewDecks.get(deckKey);
        const notefile = deck.determineNextNote(this.settings.openRandomNote);
        if (notefile) {
            await this.openNote(deckKey, notefile.tfile);
        } else {
            new import_obsidian14.Notice(t("ALL_CAUGHT_UP"));
        }
    }
    async openNote(deckName, file) {
        this._lastSelectedReviewDeck = deckName;
        await this.app.workspace.getLeaf().openFile(file);
    }
};

// src/note-review-deck.ts
var SchedNote = class {
    constructor(note, dueUnix) {
        this.note = note;
        this.dueUnix = dueUnix;
    }
    isDue(todayUnix) {
        return this.dueUnix <= todayUnix;
    }
};
var NoteReviewDeck = class {
    constructor(name) {
        this._newNotes = [];
        this._scheduledNotes = [];
        this._dueNotesCount = 0;
        this._deckName = name;
        this._activeFolders = /* @__PURE__ */ new Set([this._deckName, t("TODAY")]);
    }
    get deckName() {
        return this._deckName;
    }
    get newNotes() {
        return this._newNotes;
    }
    get scheduledNotes() {
        return this._scheduledNotes;
    }
    get dueNotesCount() {
        return this._dueNotesCount;
    }
    get activeFolders() {
        return this._activeFolders;
    }
    calcDueNotesCount(todayUnix) {
        this._dueNotesCount = 0;
        this.scheduledNotes.forEach((scheduledNote) => {
            if (scheduledNote.isDue(todayUnix)) {
                this._dueNotesCount++;
            }
        });
    }
    sortNotesByDateAndImportance(pageranks) {
        this._newNotes = this.newNotes.sort(
            (a2, b2) => (pageranks[b2.path] || 0) - (pageranks[a2.path] || 0),
        );
        this._scheduledNotes = this.scheduledNotes.sort((a2, b2) => {
            const result = a2.dueUnix - b2.dueUnix;
            if (result != 0) {
                return result;
            }
            return (pageranks[b2.note.path] || 0) - (pageranks[a2.note.path] || 0);
        });
    }
    determineNextNote(openRandomNote) {
        const todayUnix = globalDateProvider.today.valueOf();
        const dueNotes = this.scheduledNotes.filter((note) => note.isDue(todayUnix));
        if (dueNotes.length > 0) {
            const index = openRandomNote
                ? globalRandomNumberProvider.getInteger(0, dueNotes.length - 1)
                : 0;
            return dueNotes[index].note;
        }
        if (this.newNotes.length > 0) {
            const index = openRandomNote
                ? globalRandomNumberProvider.getInteger(0, this.newNotes.length - 1)
                : 0;
            return this.newNotes[index];
        }
        return null;
    }
};

// src/note-review-queue.ts
var NoteReviewQueue = class {
    get reviewDecks() {
        return this._reviewDecks;
    }
    get dueNotesCount() {
        return this._dueNotesCount;
    }
    get reviewDeckNameList() {
        return [...this._reviewDecks.keys()];
    }
    init() {
        this._reviewDecks = /* @__PURE__ */ new Map();
    }
    calcDueNotesCount(todayUnix) {
        this._dueNotesCount = 0;
        this._reviewDecks.forEach((reviewDeck) => {
            reviewDeck.calcDueNotesCount(todayUnix);
            this._dueNotesCount += reviewDeck.dueNotesCount;
        });
    }
    addNoteToQueue(noteFile, noteSchedule, matchedNoteTags) {
        for (const matchedNoteTag of matchedNoteTags) {
            if (!this.reviewDecks.has(matchedNoteTag)) {
                this.reviewDecks.set(matchedNoteTag, new NoteReviewDeck(matchedNoteTag));
            }
        }
        if (noteSchedule == null) {
            for (const matchedNoteTag of matchedNoteTags) {
                this.reviewDecks.get(matchedNoteTag).newNotes.push(noteFile);
            }
        } else {
            for (const matchedNoteTag of matchedNoteTags) {
                this.reviewDecks
                    .get(matchedNoteTag)
                    .scheduledNotes.push(new SchedNote(noteFile, noteSchedule.dueDateAsUnix));
            }
        }
    }
    updateScheduleInfo(note, scheduleInfo) {
        this.reviewDecks.forEach((reviewDeck) => {
            let wasDueInDeck = false;
            for (const scheduledNote of reviewDeck.scheduledNotes) {
                if (scheduledNote.note.path === note.path) {
                    scheduledNote.dueUnix = scheduleInfo.dueDate.valueOf();
                    wasDueInDeck = true;
                    break;
                }
            }
            if (!wasDueInDeck) {
                reviewDeck.newNotes.splice(
                    reviewDeck.newNotes.findIndex((newNote) => newNote.path === note.path),
                    1,
                );
                reviewDeck.scheduledNotes.push(new SchedNote(note, scheduleInfo.dueDate.valueOf()));
            }
        });
    }
};

// src/plugin-data.ts
var DEFAULT_DATA = {
    settings: DEFAULT_SETTINGS,
    buryDate: "",
    buryList: [],
    historyDeck: null,
};

// src/question-postponement-list.ts
var QuestionPostponementList = class {
    constructor(plugin, settings, list) {
        this.plugin = plugin;
        this.settings = settings;
        this.list = list;
    }
    async clearIfNewDay(data) {
        const now2 = window.moment(Date.now());
        const todayDate = now2.format("YYYY-MM-DD");
        const isNewDay = todayDate !== data.buryDate;
        if (isNewDay) {
            data.buryDate = todayDate;
            this.clear();
            await this.write();
        }
    }
    clear() {
        this.list.splice(0);
    }
    add(question) {
        if (!this.includes(question)) this.list.push(question.questionText.textHash);
    }
    includes(question) {
        return this.list.includes(question.questionText.textHash);
    }
    async write() {
        if (this.plugin == null) return;
        await this.plugin.savePluginData();
    }
};

// src/main.ts
var SRPlugin = class _SRPlugin extends import_obsidian15.Plugin {
    constructor() {
        super(...arguments);
        this.ribbonIcon = null;
        this.statusBar = null;
        this.isSRInFocus = false;
    }
    async onload() {
        this.tabViewManager = new TabViewManager(this);
        this.app.workspace.onLayoutReady(async () => {
            this.tabViewManager.closeAllTabViews();
        });
        await this.loadPluginData();
        const noteReviewQueue = new NoteReviewQueue();
        this.nextNoteReviewHandler = new NextNoteReviewHandler(
            this.app,
            this.data.settings,
            noteReviewQueue,
        );
        this.osrSidebar = new OsrSidebar(this, this.data.settings, this.nextNoteReviewHandler);
        this.osrSidebar.init();
        this.app.workspace.onLayoutReady(async () => {
            await this.osrSidebar.activateReviewQueueViewPanel();
            setTimeout(async () => {
                if (!this.osrAppCore.syncLock) {
                    await this.sync();
                }
            }, 2e3);
        });
        const questionPostponementList = new QuestionPostponementList(
            this,
            this.data.settings,
            this.data.buryList,
        );
        const osrNoteLinkInfoFinder = new ObsidianVaultNoteLinkInfoFinder(this.app.metadataCache);
        this.osrAppCore = new OsrAppCore(this.app);
        this.osrAppCore.init(
            questionPostponementList,
            osrNoteLinkInfoFinder,
            this.data.settings,
            this.onOsrVaultDataChanged.bind(this),
            noteReviewQueue,
        );
        appIcon();
        this.showStatusBar(this.data.settings.showStatusBar);
        this.showRibbonIcon(this.data.settings.showRibbonIcon);
        this.showFileMenuItems(!this.data.settings.disableFileMenuReviewOptions);
        this.addPluginCommands();
        this.addSettingTab(new SRSettingTab(this.app, this));
        this.registerSRFocusListener();
    }
    showFileMenuItems(status) {
        if (this.fileMenuHandler === void 0) {
            this.fileMenuHandler = (menu, fileish) => {
                if (fileish instanceof import_obsidian15.TFile && fileish.extension === "md") {
                    menu.addItem((item) => {
                        item.setTitle(
                            t("REVIEW_DIFFICULTY_FILE_MENU", {
                                difficulty: this.data.settings.flashcardEasyText,
                            }),
                        )
                            .setIcon("SpacedRepIcon")
                            .onClick(() => {
                                this.saveNoteReviewResponse(fileish, 0 /* Easy */);
                            });
                    });
                    menu.addItem((item) => {
                        item.setTitle(
                            t("REVIEW_DIFFICULTY_FILE_MENU", {
                                difficulty: this.data.settings.flashcardGoodText,
                            }),
                        )
                            .setIcon("SpacedRepIcon")
                            .onClick(() => {
                                this.saveNoteReviewResponse(fileish, 1 /* Good */);
                            });
                    });
                    menu.addItem((item) => {
                        item.setTitle(
                            t("REVIEW_DIFFICULTY_FILE_MENU", {
                                difficulty: this.data.settings.flashcardHardText,
                            }),
                        )
                            .setIcon("SpacedRepIcon")
                            .onClick(() => {
                                this.saveNoteReviewResponse(fileish, 2 /* Hard */);
                            });
                    });
                }
            };
        }
        if (status) {
            this.registerEvent(this.app.workspace.on("file-menu", this.fileMenuHandler));
        } else {
            this.app.workspace.off("file-menu", this.fileMenuHandler);
        }
    }
    addPluginCommands() {
        this.addCommand({
            id: "srs-note-review-open-note",
            name: t("OPEN_NOTE_FOR_REVIEW"),
            callback: async () => {
                if (!this.osrAppCore.syncLock) {
                    await this.sync();
                    this.nextNoteReviewHandler.reviewNextNoteModal();
                }
            },
        });
        this.addCommand({
            id: "srs-note-review-easy",
            name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
                difficulty: this.data.settings.flashcardEasyText,
            }),
            callback: () => {
                const openFile = this.app.workspace.getActiveFile();
                if (openFile && openFile.extension === "md") {
                    this.saveNoteReviewResponse(openFile, 0 /* Easy */);
                }
            },
        });
        this.addCommand({
            id: "srs-note-review-good",
            name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
                difficulty: this.data.settings.flashcardGoodText,
            }),
            callback: () => {
                const openFile = this.app.workspace.getActiveFile();
                if (openFile && openFile.extension === "md") {
                    this.saveNoteReviewResponse(openFile, 1 /* Good */);
                }
            },
        });
        this.addCommand({
            id: "srs-note-review-hard",
            name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
                difficulty: this.data.settings.flashcardHardText,
            }),
            callback: () => {
                const openFile = this.app.workspace.getActiveFile();
                if (openFile && openFile.extension === "md") {
                    this.saveNoteReviewResponse(openFile, 2 /* Hard */);
                }
            },
        });
        this.addCommand({
            id: "srs-review-flashcards",
            name: t("REVIEW_ALL_CARDS"),
            callback: async () => {
                if (this.osrAppCore.syncLock) {
                    return;
                }
                await this.sync();
                if (this.data.settings.openViewInNewTab) {
                    this.tabViewManager.openSRTabView(this.osrAppCore, 1 /* Review */);
                } else {
                    this.openFlashcardModal(
                        this.osrAppCore.reviewableDeckTree,
                        this.osrAppCore.remainingDeckTree,
                        1 /* Review */,
                    );
                }
            },
        });
        this.addCommand({
            id: "srs-cram-flashcards",
            name: t("CRAM_ALL_CARDS"),
            callback: async () => {
                await this.sync();
                if (this.data.settings.openViewInNewTab) {
                    this.tabViewManager.openSRTabView(this.osrAppCore, 0 /* Cram */);
                } else {
                    this.openFlashcardModal(
                        this.osrAppCore.reviewableDeckTree,
                        this.osrAppCore.reviewableDeckTree,
                        0 /* Cram */,
                    );
                }
            },
        });
        this.addCommand({
            id: "srs-review-flashcards-in-note",
            name: t("REVIEW_CARDS_IN_NOTE"),
            callback: async () => {
                const openFile = this.app.workspace.getActiveFile();
                if (!openFile || openFile.extension !== "md") {
                    return;
                }
                if (this.data.settings.openViewInNewTab) {
                    this.tabViewManager.openSRTabView(this.osrAppCore, 1 /* Review */, openFile);
                } else {
                    this.openFlashcardModalForSingleNote(openFile, 1 /* Review */);
                }
            },
        });
        this.addCommand({
            id: "srs-cram-flashcards-in-note",
            name: t("CRAM_CARDS_IN_NOTE"),
            callback: async () => {
                const openFile = this.app.workspace.getActiveFile();
                if (!openFile || openFile.extension !== "md") {
                    return;
                }
                if (this.data.settings.openViewInNewTab) {
                    this.tabViewManager.openSRTabView(this.osrAppCore, 0 /* Cram */, openFile);
                } else {
                    this.openFlashcardModalForSingleNote(openFile, 0 /* Cram */);
                }
            },
        });
        this.addCommand({
            id: "srs-open-review-queue-view",
            name: t("OPEN_REVIEW_QUEUE_VIEW"),
            callback: async () => {
                await this.osrSidebar.openReviewQueueView();
            },
        });
    }
    onunload() {
        this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).forEach((leaf) => leaf.detach());
        this.tabViewManager.closeAllTabViews();
    }
    getPreparedReviewSequencer(fullDeckTree, remainingDeckTree, reviewMode) {
        const deckIterator = _SRPlugin.createDeckTreeIterator(this.data.settings);
        const reviewSequencer = new FlashcardReviewSequencer(
            reviewMode,
            deckIterator,
            this.data.settings,
            SrsAlgorithm.getInstance(),
            this.osrAppCore.questionPostponementList,
            this.osrAppCore.dueDateFlashcardHistogram,
        );
        reviewSequencer.setDeckTree(fullDeckTree, remainingDeckTree);
        return { reviewSequencer, mode: reviewMode };
    }
    async getPreparedDecksForSingleNoteReview(file, mode) {
        const note = await this.loadNote(file);
        const deckTree = new Deck2("root", null);
        note.appendCardsToDeck(deckTree);
        const remainingDeckTree = DeckTreeFilter.filterForRemainingCards(
            this.osrAppCore.questionPostponementList,
            deckTree,
            mode,
        );
        return { deckTree, remainingDeckTree, mode };
    }
    registerSRFocusListener() {
        this.registerEvent(
            this.app.workspace.on("active-leaf-change", this.handleFocusChange.bind(this)),
        );
    }
    removeSRFocusListener() {
        this.setSRViewInFocus(false);
        this.app.workspace.off("active-leaf-change", this.handleFocusChange.bind(this));
    }
    handleFocusChange(leaf) {
        this.setSRViewInFocus(leaf !== null && leaf.view instanceof SRTabView);
    }
    setSRViewInFocus(value) {
        this.isSRInFocus = value;
    }
    getSRInFocusState() {
        return this.isSRInFocus;
    }
    async openFlashcardModalForSingleNote(noteFile, reviewMode) {
        const singleNoteDeckData = await this.getPreparedDecksForSingleNoteReview(
            noteFile,
            reviewMode,
        );
        this.openFlashcardModal(
            singleNoteDeckData.deckTree,
            singleNoteDeckData.remainingDeckTree,
            reviewMode,
        );
    }
    openFlashcardModal(fullDeckTree, remainingDeckTree, reviewMode) {
        const reviewSequencerData = this.getPreparedReviewSequencer(
            fullDeckTree,
            remainingDeckTree,
            reviewMode,
        );
        this.setSRViewInFocus(true);
        new FlashcardModal(
            this.app,
            this,
            this.data.settings,
            reviewSequencerData.reviewSequencer,
            reviewSequencerData.mode,
        ).open();
    }
    static createDeckTreeIterator(settings) {
        let cardOrder = CardOrder[settings.flashcardCardOrder];
        if (cardOrder === void 0) cardOrder = 2 /* DueFirstSequential */;
        let deckOrder = DeckOrder[settings.flashcardDeckOrder];
        if (deckOrder === void 0) deckOrder = 0 /* PrevDeckComplete_Sequential */;
        const iteratorOrder = {
            deckOrder,
            cardOrder,
        };
        return new DeckTreeIterator(iteratorOrder, null);
    }
    async sync() {
        if (this.osrAppCore.syncLock) {
            return;
        }
        const now2 = window.moment(Date.now());
        this.osrAppCore.defaultTextDirection = this.getObsidianRtlSetting();
        await this.osrAppCore.loadVault();
        if (this.data.settings.showSchedulingDebugMessages) {
            console.log(`SR: ${t("DECKS")}`, this.osrAppCore.reviewableDeckTree);
            console.log(
                "SR: " +
                    t("SYNC_TIME_TAKEN", {
                        t: Date.now() - now2.valueOf(),
                    }),
            );
        }
    }
    onOsrVaultDataChanged() {
        this.statusBar.setText(
            t("STATUS_BAR", {
                dueNotesCount: this.osrAppCore.noteReviewQueue.dueNotesCount,
                dueFlashcardsCount: this.osrAppCore.remainingDeckTree.getCardCount(
                    2 /* All */,
                    true,
                ),
            }),
        );
        if (this.data.settings.enableNoteReviewPaneOnStartup) this.osrSidebar.redraw();
    }
    async loadNote(noteFile) {
        const loader = new NoteFileLoader(this.data.settings);
        const srFile = this.createSrTFile(noteFile);
        const folderTopicPath = TopicPath.getFolderPathFromFilename(srFile, this.data.settings);
        const note = await loader.load(
            this.createSrTFile(noteFile),
            this.getObsidianRtlSetting(),
            folderTopicPath,
        );
        if (note.hasChanged) {
            note.writeNoteFile(this.data.settings);
        }
        return note;
    }
    getObsidianRtlSetting() {
        const v2 = this.app.vault.getConfig("rightToLeft");
        return convertToStringOrEmpty(v2) == "true" ? 2 /* Rtl */ : 1 /* Ltr */;
    }
    async saveNoteReviewResponse(note, response) {
        const noteSrTFile = this.createSrTFile(note);
        if (SettingsUtil.isPathInNoteIgnoreFolder(this.data.settings, note.path)) {
            new import_obsidian15.Notice(t("NOTE_IN_IGNORED_FOLDER"));
            return;
        }
        const tags = noteSrTFile.getAllTagsFromCache();
        if (!SettingsUtil.isAnyTagANoteReviewTag(this.data.settings, tags)) {
            new import_obsidian15.Notice(t("PLEASE_TAG_NOTE"));
            return;
        }
        await this.osrAppCore.saveNoteReviewResponse(noteSrTFile, response, this.data.settings);
        new import_obsidian15.Notice(t("RESPONSE_RECEIVED"));
        if (this.data.settings.autoNextNote) {
            this.nextNoteReviewHandler.autoReviewNextNote();
        }
    }
    createSrTFile(note) {
        return new SrTFile(this.app.vault, this.app.metadataCache, note);
    }
    async loadPluginData() {
        const loadedData = await this.loadData();
        if (loadedData == null ? void 0 : loadedData.settings) upgradeSettings(loadedData.settings);
        this.data = Object.assign({}, DEFAULT_DATA, loadedData);
        this.data.settings = Object.assign({}, DEFAULT_SETTINGS, this.data.settings);
        setDebugParser(this.data.settings.showParserDebugMessages);
        this.setupDataStoreAndAlgorithmInstances(this.data.settings);
    }
    setupDataStoreAndAlgorithmInstances(settings) {
        DataStore.instance = new StoreInNotes(settings);
        SrsAlgorithm.instance = new SrsAlgorithmOsr(settings);
        DataStoreAlgorithm.instance = new DataStoreInNoteAlgorithmOsr(settings);
    }
    async savePluginData() {
        await this.saveData(this.data);
    }
    showRibbonIcon(status) {
        if (!this.ribbonIcon) {
            this.ribbonIcon = this.addRibbonIcon("SpacedRepIcon", t("REVIEW_CARDS"), async () => {
                if (!this.osrAppCore.syncLock) {
                    await this.sync();
                    this.openFlashcardModal(
                        this.osrAppCore.reviewableDeckTree,
                        this.osrAppCore.remainingDeckTree,
                        1 /* Review */,
                    );
                }
            });
        }
        if (status) {
            this.ribbonIcon.style.display = "";
        } else {
            this.ribbonIcon.style.display = "none";
        }
    }
    showStatusBar(status) {
        if (!this.statusBar) {
            this.statusBar = this.addStatusBarItem();
            this.statusBar.classList.add("mod-clickable");
            this.statusBar.setAttribute("aria-label", t("OPEN_NOTE_FOR_REVIEW"));
            this.statusBar.setAttribute("aria-label-position", "top");
            this.statusBar.addEventListener("click", async () => {
                if (!this.osrAppCore.syncLock) {
                    await this.sync();
                    this.nextNoteReviewHandler.reviewNextNoteModal();
                }
            });
        }
        if (status) {
            this.statusBar.style.display = "";
        } else {
            this.statusBar.style.display = "none";
        }
    }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.dataset.js:
chart.js/dist/chart.js:
  (*!
   * Chart.js v4.5.1
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BhZ2VyYW5rLmpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL3V0aWxzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW1wbGVtZW50YXRpb24vQ2xvemVGaWVsZEVudW0uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZVJlZ0V4cC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL0Nsb3plTm90ZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL0Nsb3plTm90ZUNsYXNzaWMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZU5vdGVPTC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL0Nsb3plTm90ZVNpbXBsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL0Nsb3plVHlwZUVudW0uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZVBhdHRlcm4uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZUNyYWZ0ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvdmh0bWwvc3JjL2VtcHR5LXRhZ3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ZodG1sL3NyYy92aHRtbC5qcyIsICIuLi9zcmMvbWFpbi50cyIsICIuLi9zcmMvYWxnb3JpdGhtcy9iYXNlL3JlcGV0aXRpb24taXRlbS50cyIsICIuLi9zcmMvYWxnb3JpdGhtcy9iYXNlL3Nycy1hbGdvcml0aG0udHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL29ic2lkaWFuLXZhdWx0LW5vdGVsaW5rLWluZm8tZmluZGVyLnRzIiwgIi4uL3NyYy9hbGdvcml0aG1zL29zci9zcnMtYWxnb3JpdGhtLW9zci50cyIsICIuLi9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL3NyYy9sYW5nL2hlbHBlcnMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2FmLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9hci50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvYm4udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2N6LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9kYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZGUudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2VuLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9lbi1nYi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZXMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2ZyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9oaS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvaWQudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2l0LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9qYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUva28udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL21yLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ubC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvbm8udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3BsLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9wdC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcHQtYnIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3JvLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ydS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvc3cudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3RhLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS90ZS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdGgudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3RyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS91ay50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdXIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3ZpLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS96aC1jbi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvemgtdHcudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL25vdGUtc2NoZWR1bGluZy50cyIsICIuLi9zcmMvdXRpbHMvZGF0ZXMudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvYmFzZS9yZXAtaXRlbS1zY2hlZHVsZS1pbmZvLnRzIiwgIi4uL3NyYy9hbGdvcml0aG1zL29zci9yZXAtaXRlbS1zY2hlZHVsZS1pbmZvLW9zci50cyIsICIuLi9zcmMvbm90ZS1lYXNlLWxpc3QudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL29zci1ub3RlLWdyYXBoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AaXNhYWNzL2JhbGFuY2VkLW1hdGNoL3NyYy9pbmRleC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9icmFjZS1leHBhbnNpb24vc3JjL2luZGV4LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2Fzc2VydC12YWxpZC1wYXR0ZXJuLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2JyYWNlLWV4cHJlc3Npb25zLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL3VuZXNjYXBlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2FzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL3NyYy9lc2NhcGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9zcmMvaW5kZXgudHMiLCAiLi4vc3JjL3V0aWxzL2ZzLnRzIiwgIi4uL3NyYy9kYXRhLXN0b3JlLWFsZ29yaXRobS9kYXRhLXN0b3JlLWFsZ29yaXRobS50cyIsICIuLi9zcmMvZGF0YS1zdG9yZXMvYmFzZS9kYXRhLXN0b3JlLnRzIiwgIi4uL3NyYy90b3BpYy1wYXRoLnRzIiwgIi4uL3NyYy9mbGFzaGNhcmQtcmV2aWV3LXNlcXVlbmNlci50cyIsICIuLi9zcmMvZGVjay50cyIsICIuLi9zcmMvdXRpbHMvdHlwZXMudHMiLCAiLi4vc3JjL3V0aWxzL251bWJlcnMudHMiLCAiLi4vc3JjL2RlY2stdHJlZS1pdGVyYXRvci50cyIsICIuLi9zcmMvc3RhdHMudHMiLCAiLi4vc3JjL2RlY2stdHJlZS1zdGF0cy1jYWxjdWxhdG9yLnRzIiwgIi4uL3NyYy9kdWUtZGF0ZS1oaXN0b2dyYW0udHMiLCAiLi4vc3JjL2ZpbGUudHMiLCAiLi4vc3JjL3V0aWxzL3N0cmluZ3MudHMiLCAiLi4vc3JjL25vdGUudHMiLCAiLi4vc3JjL2NhcmQudHMiLCAiLi4vc3JjL3BhcnNlci50cyIsICIuLi9zcmMvcXVlc3Rpb24udHMiLCAiLi4vc3JjL3F1ZXN0aW9uLXR5cGUudHMiLCAiLi4vc3JjL3NldHRpbmdzLnRzIiwgIi4uL3NyYy9ub3RlLXF1ZXN0aW9uLXBhcnNlci50cyIsICIuLi9zcmMvbm90ZS1maWxlLWxvYWRlci50cyIsICIuLi9zcmMvY29yZS50cyIsICIuLi9zcmMvZGF0YS1zdG9yZS1hbGdvcml0aG0vZGF0YS1zdG9yZS1pbi1ub3RlLWFsZ29yaXRobS1vc3IudHMiLCAiLi4vc3JjL2RhdGEtc3RvcmVzL25vdGVzL25vdGVzLnRzIiwgIi4uL3NyYy9ndWkvcmV2aWV3LXF1ZXVlLWxpc3Qtdmlldy50c3giLCAiLi4vc3JjL2d1aS9zZXR0aW5ncy50c3giLCAiLi4vbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZGF0YXNldC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYmFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5saW5lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucmFkYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnNjYXR0ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNpYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmRvbS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmVsZW1lbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuYXV0b3NraXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudHlwZWRSZWdpc3RyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5yZWdpc3RyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbmZpZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb250cm9sbGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5jb2xvcnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5kZWNpbWF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5oZWxwZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLm9wdGlvbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9zaW1wbGVBcmMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uc3VidGl0bGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhcmJhc2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnJhZGlhbExpbmVhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9pbmRleC50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy90eXBlcy50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QubW9kdWxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvaWQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvYmFzZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2h0bWxFbGVtZW50LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL2h0bWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvY2VsbC50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9wcm9jZXNzb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcm93LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3RhYnVsYXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9hcnJheS50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL2V2ZW50RW1pdHRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL2RlZXBFcXVhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9maWx0ZXIvZ2xvYmFsU2VhcmNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL29wZXJhdG9yL3NlYXJjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL2NsYXNzTmFtZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9maWx0ZXIvc2VydmVyR2xvYmFsU2VhcmNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9kaXN0L2hvb2tzLm1vZHVsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9ob29rcy91c2VDb25maWcudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvaTE4bi9lbl9VUy50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9pMThuL2xhbmd1YWdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3NlYXJjaC9hY3Rpb25zLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2hvb2tzL3VzZVN0b3JlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3NlYXJjaC9zZWFyY2gudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvZGVib3VuY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGlwZWxpbmUvbGltaXQvcGFnaW5hdGlvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9saW1pdC9zZXJ2ZXJQYWdpbmF0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3BhZ2luYXRpb24udHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvd2lkdGgudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS9zaGFkb3cudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvc3RyaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BsdWdpbi50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL2xvZy50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9oZWFkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvc3RvcmFnZS9zdG9yYWdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3N0b3JhZ2UvbWVtb3J5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3N0b3JhZ2Uvc2VydmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3N0b3JhZ2Uvc3RvcmFnZVV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL3BpcGVsaW5lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL2V4dHJhY3Rvci9zdG9yYWdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL3RyYW5zZm9ybWVyL2FycmF5VG9UYWJ1bGFyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL2luaXRpYXRvci9zZXJ2ZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGlwZWxpbmUvdHJhbnNmb3JtZXIvc3RvcmFnZVJlc3BvbnNlVG9BcnJheS50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9waXBlbGluZVV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3N0YXRlL3N0b3JlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2NvbmZpZy50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3RhYmxlL3RkLnRzeCIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3RhYmxlL3RyLnRzeCIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3RhYmxlL21lc3NhZ2VSb3cudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvdGFibGUvdGJvZHkudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL3NvcnQvbmF0aXZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3NvcnQvYWN0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9zb3J0L3NlcnZlci50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3BsdWdpbi9zb3J0L3NvcnQudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvdGhyb3R0bGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy9wbHVnaW4vcmVzaXplL3Jlc2l6ZS50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90aC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90aGVhZC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC90YWJsZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2FjdGlvbnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90YWJsZS50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy9oZWFkZXJDb250YWluZXIudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvZm9vdGVyQ29udGFpbmVyLnRzeCIsICIuLi9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2NvbnRhaW5lci50c3giLCAiLi4vbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvZ3JpZC50cyIsICIuLi9zcmMvZ3VpL3N0YXRpc3RpY3MudHN4IiwgIi4uL3NyYy9ndWkvdGFicy50c3giLCAiLi4vc3JjL2d1aS9zaWRlYmFyLnRzeCIsICIuLi9zcmMvZ3VpL3NyLW1vZGFsLnRzeCIsICIuLi9zcmMvZ3VpL2NhcmQtdWkudHN4IiwgIi4uL3NyYy91dGlscy9yZW5kZXJlcnMudHMiLCAiLi4vc3JjL2d1aS9kZWNrLXVpLnRzeCIsICIuLi9zcmMvZ3VpL2VkaXQtbW9kYWwudHN4IiwgIi4uL3NyYy9ndWkvc3ItdGFiLXZpZXcudHN4IiwgIi4uL3NyYy9ndWkvdGFiLXZpZXctbWFuYWdlci50c3giLCAiLi4vc3JjL2ljb25zL2FwcC1pY29uLnRzIiwgIi4uL3NyYy9uZXh0LW5vdGUtcmV2aWV3LWhhbmRsZXIudHMiLCAiLi4vc3JjL2d1aS9yZXZpZXctZGVjay1zZWxlY3Rpb24tbW9kYWwudHN4IiwgIi4uL3NyYy9ub3RlLXJldmlldy1kZWNrLnRzIiwgIi4uL3NyYy9ub3RlLXJldmlldy1xdWV1ZS50cyIsICIuLi9zcmMvcGx1Z2luLWRhdGEudHMiLCAiLi4vc3JjL3F1ZXN0aW9uLXBvc3Rwb25lbWVudC1saXN0LnRzIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSwyQ0FBQUEsU0FBQTtBQU1DLEtBQUMsU0FBVSxRQUFRLFNBQVM7QUFDekIsYUFBTyxZQUFZLFlBQVksT0FBT0EsWUFBVyxjQUFjQSxRQUFPLFVBQVUsUUFBUSxJQUN4RixPQUFPLFdBQVcsY0FBYyxPQUFPLE1BQU0sT0FBTyxPQUFPLElBQzNELE9BQU8sU0FBUyxRQUFRO0FBQUEsSUFDNUIsR0FBRSxVQUFPLFdBQVk7QUFBRTtBQUVuQixVQUFJO0FBRUosZUFBUyxRQUFRO0FBQ2IsZUFBTyxhQUFhLE1BQU0sTUFBTSxTQUFTO0FBQUEsTUFDN0M7QUFJQSxlQUFTLGdCQUFnQkMsV0FBVTtBQUMvQix1QkFBZUE7QUFBQSxNQUNuQjtBQUVBLGVBQVNDLFNBQVEsT0FBTztBQUNwQixlQUNJLGlCQUFpQixTQUNqQixPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUFBLE1BRWxEO0FBRUEsZUFBU0MsVUFBUyxPQUFPO0FBR3JCLGVBQ0ksU0FBUyxRQUNULE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFFbEQ7QUFFQSxlQUFTLFdBQVdDLElBQUdDLElBQUc7QUFDdEIsZUFBTyxPQUFPLFVBQVUsZUFBZSxLQUFLRCxJQUFHQyxFQUFDO0FBQUEsTUFDcEQ7QUFFQSxlQUFTLGNBQWMsS0FBSztBQUN4QixZQUFJLE9BQU8scUJBQXFCO0FBQzVCLGlCQUFPLE9BQU8sb0JBQW9CLEdBQUcsRUFBRSxXQUFXO0FBQUEsUUFDdEQsT0FBTztBQUNILGNBQUk7QUFDSixlQUFLLEtBQUssS0FBSztBQUNYLGdCQUFJ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RUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQ0o7QUFDQSxJQUFNLFVBQVU7QUFBQSxFQUNmLFFBQVE7QUFBQSxFQUNSLGFBQWE7QUFBQSxFQUNiLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLGNBQWM7QUFBQSxFQUNkLElBQUk7QUFBQSxFQUNKLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLGFBQWE7QUFBQSxFQUNiLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLElBQUk7QUFBQSxFQUNKLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLElBQUk7QUFBQSxFQUNKLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLElBQUk7QUFBQSxFQUNKLE9BQU87QUFDUjtBQUNBLFNBQVMsU0FBUztBQUNoQixRQUFNLFdBQVcsQ0FBQztBQUNsQixRQUFNLE9BQU8sT0FBTyxLQUFLLE9BQU87QUFDaEMsUUFBTSxRQUFRLE9BQU8sS0FBSyxHQUFHO0FBQzdCLE1BQUlHLElBQUdPLElBQUcsR0FBRyxJQUFJO0FBQ2pCLE9BQUtQLEtBQUksR0FBR0EsS0FBSSxLQUFLLFFBQVFBLE1BQUs7QUFDaEMsU0FBSyxLQUFLLEtBQUtBLEVBQUM7QUFDaEIsU0FBS08sS0FBSSxHQUFHQSxLQUFJLE1BQU0sUUFBUUEsTUFBSztBQUNqQyxVQUFJLE1BQU1BLEVBQUM7QUFDWCxXQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQUEsSUFDM0I7QUFDQSxRQUFJLFNBQVMsUUFBUSxFQUFFLEdBQUcsRUFBRTtBQUM1QixhQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFNLEtBQUssSUFBSSxLQUFNLElBQUksR0FBSTtBQUFBLEVBQ3pEO0FBQ0EsU0FBTztBQUNUO0FBRUEsSUFBSTtBQUNKLFNBQVMsVUFBVSxLQUFLO0FBQ3RCLE1BQUksQ0FBQyxPQUFPO0FBQ1YsWUFBUSxPQUFPO0FBQ2YsVUFBTSxjQUFjLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ2pDO0FBQ0EsUUFBTWQsS0FBSSxNQUFNLElBQUksWUFBWSxDQUFDO0FBQ2pDLFNBQU9BLE1BQUs7QUFBQSxJQUNWLEdBQUdBLEdBQUUsQ0FBQztBQUFBLElBQ04sR0FBR0EsR0FBRSxDQUFDO0FBQUEsSUFDTixHQUFHQSxHQUFFLENBQUM7QUFBQSxJQUNOLEdBQUdBLEdBQUUsV0FBVyxJQUFJQSxHQUFFLENBQUMsSUFBSTtBQUFBLEVBQzdCO0FBQ0Y7QUFFQSxJQUFNLFNBQVM7QUFDZixTQUFTLFNBQVMsS0FBSztBQUNyQixRQUFNYSxLQUFJLE9BQU8sS0FBSyxHQUFHO0FBQ3pCLE1BQUliLEtBQUk7QUFDUixNQUFJUSxJQUFHQyxJQUFHVjtBQUNWLE1BQUksQ0FBQ2MsSUFBRztBQUNOO0FBQUEsRUFDRjtBQUNBLE1BQUlBLEdBQUUsQ0FBQyxNQUFNTCxJQUFHO0FBQ2QsVUFBTVYsS0FBSSxDQUFDZSxHQUFFLENBQUM7QUFDZCxJQUFBYixLQUFJYSxHQUFFLENBQUMsSUFBSSxJQUFJZixFQUFDLElBQUksSUFBSUEsS0FBSSxLQUFLLEdBQUcsR0FBRztBQUFBLEVBQ3pDO0FBQ0EsRUFBQVUsS0FBSSxDQUFDSyxHQUFFLENBQUM7QUFDUixFQUFBSixLQUFJLENBQUNJLEdBQUUsQ0FBQztBQUNSLEVBQUFkLEtBQUksQ0FBQ2MsR0FBRSxDQUFDO0FBQ1IsRUFBQUwsS0FBSSxPQUFPSyxHQUFFLENBQUMsSUFBSSxJQUFJTCxFQUFDLElBQUksSUFBSUEsSUFBRyxHQUFHLEdBQUc7QUFDeEMsRUFBQUMsS0FBSSxPQUFPSSxHQUFFLENBQUMsSUFBSSxJQUFJSixFQUFDLElBQUksSUFBSUEsSUFBRyxHQUFHLEdBQUc7QUFDeEMsRUFBQVYsS0FBSSxPQUFPYyxHQUFFLENBQUMsSUFBSSxJQUFJZCxFQUFDLElBQUksSUFBSUEsSUFBRyxHQUFHLEdBQUc7QUFDeEMsU0FBTztBQUFBLElBQ0wsR0FBR1M7QUFBQSxJQUNILEdBQUdDO0FBQUEsSUFDSCxHQUFHVjtBQUFBLElBQ0gsR0FBR0M7QUFBQSxFQUNMO0FBQ0Y7QUFDQSxTQUFTLFVBQVVGLElBQUc7QUFDcEIsU0FBT0EsT0FDTEEsR0FBRSxJQUFJLE1BQ0YsUUFBUUEsR0FBRSxDQUFDLEtBQUtBLEdBQUUsQ0FBQyxLQUFLQSxHQUFFLENBQUMsS0FBSyxJQUFJQSxHQUFFLENBQUMsQ0FBQyxNQUN4QyxPQUFPQSxHQUFFLENBQUMsS0FBS0EsR0FBRSxDQUFDLEtBQUtBLEdBQUUsQ0FBQztBQUVsQztBQUVBLElBQU0sS0FBSyxDQUFBQSxPQUFLQSxNQUFLLFdBQVlBLEtBQUksUUFBUSxLQUFLLElBQUlBLElBQUcsSUFBTSxHQUFHLElBQUksUUFBUTtBQUM5RSxJQUFNLE9BQU8sQ0FBQUEsT0FBS0EsTUFBSyxVQUFVQSxLQUFJLFFBQVEsS0FBSyxLQUFLQSxLQUFJLFNBQVMsT0FBTyxHQUFHO0FBQzlFLFNBQVNpQixhQUFZLE1BQU0sTUFBTUMsSUFBRztBQUNsQyxRQUFNUixLQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMxQixRQUFNQyxLQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMxQixRQUFNVixLQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMxQixTQUFPO0FBQUEsSUFDTCxHQUFHLElBQUksR0FBR1MsS0FBSVEsTUFBSyxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSVIsR0FBRSxDQUFDO0FBQUEsSUFDMUMsR0FBRyxJQUFJLEdBQUdDLEtBQUlPLE1BQUssS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUlQLEdBQUUsQ0FBQztBQUFBLElBQzFDLEdBQUcsSUFBSSxHQUFHVixLQUFJaUIsTUFBSyxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSWpCLEdBQUUsQ0FBQztBQUFBLElBQzFDLEdBQUcsS0FBSyxJQUFJaUIsTUFBSyxLQUFLLElBQUksS0FBSztBQUFBLEVBQ2pDO0FBQ0Y7QUFFQSxTQUFTLE9BQU9sQixJQUFHUyxJQUFHLE9BQU87QUFDM0IsTUFBSVQsSUFBRztBQUNMLFFBQUksTUFBTSxRQUFRQSxFQUFDO0FBQ25CLFFBQUlTLEVBQUMsSUFBSSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUksSUFBSUEsRUFBQyxJQUFJLElBQUlBLEVBQUMsSUFBSSxPQUFPQSxPQUFNLElBQUksTUFBTSxDQUFDLENBQUM7QUFDekUsVUFBTSxRQUFRLEdBQUc7QUFDakIsSUFBQVQsR0FBRSxJQUFJLElBQUksQ0FBQztBQUNYLElBQUFBLEdBQUUsSUFBSSxJQUFJLENBQUM7QUFDWCxJQUFBQSxHQUFFLElBQUksSUFBSSxDQUFDO0FBQUEsRUFDYjtBQUNGO0FBQ0EsU0FBUyxNQUFNQSxJQUFHLE9BQU87QUFDdkIsU0FBT0EsS0FBSSxPQUFPLE9BQU8sU0FBUyxDQUFDLEdBQUdBLEVBQUMsSUFBSUE7QUFDN0M7QUFDQSxTQUFTLFdBQVcsT0FBTztBQUN6QixNQUFJQSxLQUFJLEVBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ2pDLE1BQUksTUFBTSxRQUFRLEtBQUssR0FBRztBQUN4QixRQUFJLE1BQU0sVUFBVSxHQUFHO0FBQ3JCLE1BQUFBLEtBQUksRUFBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUc7QUFDbEQsVUFBSSxNQUFNLFNBQVMsR0FBRztBQUNwQixRQUFBQSxHQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQztBQUFBLE1BQ3BCO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLElBQUFBLEtBQUksTUFBTSxPQUFPLEVBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFDLENBQUM7QUFDekMsSUFBQUEsR0FBRSxJQUFJLElBQUlBLEdBQUUsQ0FBQztBQUFBLEVBQ2Y7QUFDQSxTQUFPQTtBQUNUO0FBQ0EsU0FBUyxjQUFjLEtBQUs7QUFDMUIsTUFBSSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDekIsV0FBTyxTQUFTLEdBQUc7QUFBQSxFQUNyQjtBQUNBLFNBQU8sU0FBUyxHQUFHO0FBQ3JCO0FBQ0EsSUFBTSxRQUFOLE1BQU0sT0FBTTtBQUFBLEVBQ1YsWUFBWSxPQUFPO0FBQ2pCLFFBQUksaUJBQWlCLFFBQU87QUFDMUIsYUFBTztBQUFBLElBQ1Q7QUFDQSxVQUFNLE9BQU8sT0FBTztBQUNwQixRQUFJQTtBQUNKLFFBQUksU0FBUyxVQUFVO0FBQ3JCLE1BQUFBLEtBQUksV0FBVyxLQUFLO0FBQUEsSUFDdEIsV0FBVyxTQUFTLFVBQVU7QUFDNUIsTUFBQUEsS0FBSSxTQUFTLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxjQUFjLEtBQUs7QUFBQSxJQUNoRTtBQUNBLFNBQUssT0FBT0E7QUFDWixTQUFLLFNBQVMsQ0FBQyxDQUFDQTtBQUFBLEVBQ2xCO0FBQUEsRUFDQSxJQUFJLFFBQVE7QUFDVixXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFDQSxJQUFJLE1BQU07QUFDUixRQUFJQSxLQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ3ZCLFFBQUlBLElBQUc7QUFDTCxNQUFBQSxHQUFFLElBQUksSUFBSUEsR0FBRSxDQUFDO0FBQUEsSUFDZjtBQUNBLFdBQU9BO0FBQUEsRUFDVDtBQUFBLEVBQ0EsSUFBSSxJQUFJLEtBQUs7QUFDWCxTQUFLLE9BQU8sV0FBVyxHQUFHO0FBQUEsRUFDNUI7QUFBQSxFQUNBLFlBQVk7QUFDVixXQUFPLEtBQUssU0FBUyxVQUFVLEtBQUssSUFBSSxJQUFJO0FBQUEsRUFDOUM7QUFBQSxFQUNBLFlBQVk7QUFDVixXQUFPLEtBQUssU0FBUyxVQUFVLEtBQUssSUFBSSxJQUFJO0FBQUEsRUFDOUM7QUFBQSxFQUNBLFlBQVk7QUFDVixXQUFPLEtBQUssU0FBUyxVQUFVLEtBQUssSUFBSSxJQUFJO0FBQUEsRUFDOUM7QUFBQSxFQUNBLElBQUltQixRQUFPLFFBQVE7QUFDakIsUUFBSUEsUUFBTztBQUNULFlBQU0sS0FBSyxLQUFLO0FBQ2hCLFlBQU0sS0FBS0EsT0FBTTtBQUNqQixVQUFJO0FBQ0osWUFBTUMsS0FBSSxXQUFXLEtBQUssTUFBTTtBQUNoQyxZQUFNWixLQUFJLElBQUlZLEtBQUk7QUFDbEIsWUFBTWxCLEtBQUksR0FBRyxJQUFJLEdBQUc7QUFDcEIsWUFBTSxPQUFPTSxLQUFJTixPQUFNLEtBQUtNLE1BQUtBLEtBQUlOLE9BQU0sSUFBSU0sS0FBSU4sT0FBTSxLQUFLO0FBQzlELFdBQUssSUFBSTtBQUNULFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSWtCLEtBQUksR0FBRyxLQUFLLElBQUlBLE1BQUssR0FBRztBQUMvQixXQUFLLE1BQU07QUFBQSxJQUNiO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFlBQVlELFFBQU9ELElBQUc7QUFDcEIsUUFBSUMsUUFBTztBQUNULFdBQUssT0FBT0YsYUFBWSxLQUFLLE1BQU1FLE9BQU0sTUFBTUQsRUFBQztBQUFBLElBQ2xEO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFFBQVE7QUFDTixXQUFPLElBQUksT0FBTSxLQUFLLEdBQUc7QUFBQSxFQUMzQjtBQUFBLEVBQ0EsTUFBTWhCLElBQUc7QUFDUCxTQUFLLEtBQUssSUFBSSxJQUFJQSxFQUFDO0FBQ25CLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxRQUFRLE9BQU87QUFDYixVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJLEtBQUssSUFBSTtBQUNiLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxZQUFZO0FBQ1YsVUFBTSxNQUFNLEtBQUs7QUFDakIsVUFBTSxNQUFNLE1BQU0sSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUk7QUFDM0QsUUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFFBQVEsT0FBTztBQUNiLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFFBQUksS0FBSyxJQUFJO0FBQ2IsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFNBQVM7QUFDUCxVQUFNRixLQUFJLEtBQUs7QUFDZixJQUFBQSxHQUFFLElBQUksTUFBTUEsR0FBRTtBQUNkLElBQUFBLEdBQUUsSUFBSSxNQUFNQSxHQUFFO0FBQ2QsSUFBQUEsR0FBRSxJQUFJLE1BQU1BLEdBQUU7QUFDZCxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsUUFBUSxPQUFPO0FBQ2IsV0FBTyxLQUFLLE1BQU0sR0FBRyxLQUFLO0FBQzFCLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxPQUFPLE9BQU87QUFDWixXQUFPLEtBQUssTUFBTSxHQUFHLENBQUMsS0FBSztBQUMzQixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsU0FBUyxPQUFPO0FBQ2QsV0FBTyxLQUFLLE1BQU0sR0FBRyxLQUFLO0FBQzFCLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxXQUFXLE9BQU87QUFDaEIsV0FBTyxLQUFLLE1BQU0sR0FBRyxDQUFDLEtBQUs7QUFDM0IsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE9BQU8sS0FBSztBQUNWLFdBQU8sS0FBSyxNQUFNLEdBQUc7QUFDckIsV0FBTztBQUFBLEVBQ1Q7QUFDRjs7O0FDNWpCTyxTQUFTcUIsT0FBTztBQUNyQjtBQU1LLElBQU1DLE1BQU8sdUJBQU07QUFDeEIsTUFBSUMsS0FBSztBQUNULFNBQU8sTUFBTUE7QUFDZixHQUFBO0FBT08sU0FBU0MsY0FBY0MsT0FBMkM7QUFDdkUsU0FBT0EsVUFBVSxRQUFRQSxVQUFVQztBQUNyQztBQU9PLFNBQVNDLFFBQXFCRixPQUE4QjtBQUNqRSxNQUFJRyxNQUFNRCxXQUFXQyxNQUFNRCxRQUFRRixLQUFRLEdBQUE7QUFDekMsV0FBTzs7QUFFVCxRQUFNSSxPQUFPQyxPQUFPQyxVQUFVQyxTQUFTQyxLQUFLUixLQUFBQTtBQUM1QyxNQUFJSSxLQUFLSyxNQUFNLEdBQUcsQ0FBQSxNQUFPLGFBQWFMLEtBQUtLLE1BQU0sRUFBQyxNQUFPLFVBQVU7QUFDakUsV0FBTzs7QUFFVCxTQUFPO0FBQ1Q7QUFPTyxTQUFTQyxTQUFTVixPQUFvQztBQUMzRCxTQUFPQSxVQUFVLFFBQVFLLE9BQU9DLFVBQVVDLFNBQVNDLEtBQUtSLEtBQVcsTUFBQTtBQUNyRTtBQU1BLFNBQVNXLGVBQWVYLE9BQWlDO0FBQ3ZELFVBQVEsT0FBT0EsVUFBVSxZQUFZQSxpQkFBaUJZLFdBQVdDLFNBQVMsQ0FBQ2IsS0FBQUE7QUFDN0U7QUFVTyxTQUFTYyxnQkFBZ0JkLE9BQWdCZSxjQUFzQjtBQUNwRSxTQUFPSixlQUFlWCxLQUFTQSxJQUFBQSxRQUFRZTtBQUN6QztBQU9PLFNBQVNDLGVBQWtCaEIsT0FBc0JlLGNBQWlCO0FBQ3ZFLFNBQU8sT0FBT2YsVUFBVSxjQUFjZSxlQUFlZjtBQUN2RDtJQUVhaUIsZUFBZSxDQUFDakIsT0FBd0JrQixjQUNuRCxPQUFPbEIsVUFBVSxZQUFZQSxNQUFNbUIsU0FBUyxHQUFBLElBQzFDQyxXQUFXcEIsS0FBQUEsSUFBUyxNQUNsQixDQUFDQSxRQUFRa0I7SUFFRkcsY0FBYyxDQUFDckIsT0FBd0JrQixjQUNsRCxPQUFPbEIsVUFBVSxZQUFZQSxNQUFNbUIsU0FBUyxHQUFBLElBQzFDQyxXQUFXcEIsS0FBQUEsSUFBUyxNQUFNa0IsWUFDeEIsQ0FBQ2xCO0FBU0EsU0FBU3NCLFNBQ2RDLEtBQ0FDLE1BQ0FDLFNBQ2U7QUFDZixNQUFJRixPQUFNLE9BQU9BLElBQUdmLFNBQVMsWUFBWTtBQUN2QyxXQUFPZSxJQUFHRyxNQUFNRCxTQUFTRCxJQUFBQTs7QUFFN0I7QUF1Qk8sU0FBU0csS0FDZEMsVUFDQUwsS0FDQUUsU0FDQUksU0FDQTtBQUNBLE1BQUlDLElBQVdDLEtBQWFDO0FBQzVCLE1BQUk5QixRQUFRMEIsUUFBVyxHQUFBO0FBQ3JCRyxVQUFNSCxTQUFTSztBQUNmLFFBQUlKLFNBQVM7QUFDWCxXQUFLQyxLQUFJQyxNQUFNLEdBQUdELE1BQUssR0FBR0EsTUFBSztBQUM3QlAsUUFBQUEsSUFBR2YsS0FBS2lCLFNBQVNHLFNBQVNFLEVBQUFBLEdBQUlBLEVBQUFBO01BQ2hDO1dBQ0s7QUFDTCxXQUFLQSxLQUFJLEdBQUdBLEtBQUlDLEtBQUtELE1BQUs7QUFDeEJQLFFBQUFBLElBQUdmLEtBQUtpQixTQUFTRyxTQUFTRSxFQUFBQSxHQUFJQSxFQUFBQTtNQUNoQzs7YUFFT3BCLFNBQVNrQixRQUFXLEdBQUE7QUFDN0JJLFdBQU8zQixPQUFPMkIsS0FBS0osUUFBQUE7QUFDbkJHLFVBQU1DLEtBQUtDO0FBQ1gsU0FBS0gsS0FBSSxHQUFHQSxLQUFJQyxLQUFLRCxNQUFLO0FBQ3hCUCxNQUFBQSxJQUFHZixLQUFLaUIsU0FBU0csU0FBU0ksS0FBS0YsRUFBQUEsQ0FBRSxHQUFHRSxLQUFLRixFQUFFLENBQUE7SUFDN0M7O0FBRUo7QUFRTyxTQUFTSSxlQUFlQyxJQUF1QkMsSUFBdUI7QUFDM0UsTUFBSU4sSUFBV08sTUFBY0MsSUFBcUJDO0FBRWxELE1BQUksQ0FBQ0osTUFBTSxDQUFDQyxNQUFNRCxHQUFHRixXQUFXRyxHQUFHSCxRQUFRO0FBQ3pDLFdBQU87O0FBR1QsT0FBS0gsS0FBSSxHQUFHTyxPQUFPRixHQUFHRixRQUFRSCxLQUFJTyxNQUFNLEVBQUVQLElBQUc7QUFDM0NRLFNBQUtILEdBQUdMLEVBQUU7QUFDVlMsU0FBS0gsR0FBR04sRUFBRTtBQUVWLFFBQUlRLEdBQUdFLGlCQUFpQkQsR0FBR0MsZ0JBQWdCRixHQUFHRyxVQUFVRixHQUFHRSxPQUFPO0FBQ2hFLGFBQU87O0VBRVg7QUFFQSxTQUFPO0FBQ1Q7QUFNTyxTQUFTQyxPQUFTQyxRQUFjO0FBQ3JDLE1BQUl6QyxRQUFReUMsTUFBUyxHQUFBO0FBQ25CLFdBQU9BLE9BQU9DLElBQUlGLE1BQUFBOztBQUdwQixNQUFJaEMsU0FBU2lDLE1BQVMsR0FBQTtBQUNwQixVQUFNRSxTQUFTeEMsdUJBQU95QyxPQUFPLElBQUk7QUFDakMsVUFBTWQsT0FBTzNCLE9BQU8yQixLQUFLVyxNQUFBQTtBQUN6QixVQUFNSSxPQUFPZixLQUFLQztBQUNsQixRQUFJZSxJQUFJO0FBRVIsV0FBT0EsSUFBSUQsTUFBTSxFQUFFQyxHQUFHO0FBQ3BCSCxhQUFPYixLQUFLZ0IsQ0FBQUEsQ0FBRSxJQUFJTixPQUFNQyxPQUFPWCxLQUFLZ0IsQ0FBQUEsQ0FBRSxDQUFDO0lBQ3pDO0FBRUEsV0FBT0g7O0FBR1QsU0FBT0Y7QUFDVDtBQUVBLFNBQVNNLFdBQVdDLEtBQWE7QUFDL0IsU0FBTztJQUFDO0lBQWE7SUFBYTtJQUFlQyxRQUFRRCxHQUFBQSxNQUFTO0FBQ3BFO0FBT08sU0FBU0UsUUFBUUYsS0FBYUwsUUFBbUJGLFFBQW1CVSxTQUFvQjtBQUM3RixNQUFJLENBQUNKLFdBQVdDLEdBQU0sR0FBQTtBQUNwQjs7QUFHRixRQUFNSSxPQUFPVCxPQUFPSyxHQUFJO0FBQ3hCLFFBQU1LLE9BQU9aLE9BQU9PLEdBQUk7QUFFeEIsTUFBSXhDLFNBQVM0QyxJQUFTNUMsS0FBQUEsU0FBUzZDLElBQU8sR0FBQTtBQUVwQ0MsVUFBTUYsTUFBTUMsTUFBTUYsT0FBQUE7U0FDYjtBQUNMUixXQUFPSyxHQUFJLElBQUdSLE9BQU1hLElBQUFBOztBQUV4QjtBQTBCTyxTQUFTQyxNQUFTWCxRQUFXRixRQUFxQlUsU0FBbUM7QUFDMUYsUUFBTUksVUFBVXZELFFBQVF5QyxNQUFBQSxJQUFVQSxTQUFTO0lBQUNBO0VBQU87QUFDbkQsUUFBTU4sT0FBT29CLFFBQVF4QjtBQUVyQixNQUFJLENBQUN2QixTQUFTbUMsTUFBUyxHQUFBO0FBQ3JCLFdBQU9BOztBQUdUUSxZQUFVQSxXQUFXLENBQUE7QUFDckIsUUFBTUssU0FBU0wsUUFBUUssVUFBVU47QUFDakMsTUFBSU87QUFFSixXQUFTN0IsS0FBSSxHQUFHQSxLQUFJTyxNQUFNLEVBQUVQLElBQUc7QUFDN0I2QixjQUFVRixRQUFRM0IsRUFBRTtBQUNwQixRQUFJLENBQUNwQixTQUFTaUQsT0FBVSxHQUFBO0FBQ3RCOztBQUdGLFVBQU0zQixPQUFPM0IsT0FBTzJCLEtBQUsyQixPQUFBQTtBQUN6QixhQUFTWCxJQUFJLEdBQUdELE9BQU9mLEtBQUtDLFFBQVFlLElBQUlELE1BQU0sRUFBRUMsR0FBRztBQUNqRFUsYUFBTzFCLEtBQUtnQixDQUFFLEdBQUVILFFBQVFjLFNBQVNOLE9BQUFBO0lBQ25DO0VBQ0Y7QUFFQSxTQUFPUjtBQUNUO0FBZ0JPLFNBQVNlLFFBQVdmLFFBQVdGLFFBQWdDO0FBRXBFLFNBQU9hLE1BQVNYLFFBQVFGLFFBQVE7SUFBQ2UsUUFBUUc7RUFBUyxDQUFBO0FBQ3BEO0FBTU8sU0FBU0EsVUFBVVgsS0FBYUwsUUFBbUJGLFFBQW1CO0FBQzNFLE1BQUksQ0FBQ00sV0FBV0MsR0FBTSxHQUFBO0FBQ3BCOztBQUdGLFFBQU1JLE9BQU9ULE9BQU9LLEdBQUk7QUFDeEIsUUFBTUssT0FBT1osT0FBT08sR0FBSTtBQUV4QixNQUFJeEMsU0FBUzRDLElBQVM1QyxLQUFBQSxTQUFTNkMsSUFBTyxHQUFBO0FBQ3BDSyxZQUFRTixNQUFNQyxJQUFBQTthQUNMLENBQUNsRCxPQUFPQyxVQUFVd0QsZUFBZXRELEtBQUtxQyxRQUFRSyxHQUFNLEdBQUE7QUFDN0RMLFdBQU9LLEdBQUksSUFBR1IsT0FBTWEsSUFBQUE7O0FBRXhCO0FBYUEsSUFBTVEsZUFBZTs7RUFFbkIsSUFBSUMsQ0FBQUEsT0FBS0E7O0VBRVRDLEdBQUdDLENBQUFBLE9BQUtBLEdBQUVEO0VBQ1ZFLEdBQUdELENBQUFBLE9BQUtBLEdBQUVDO0FBQ1o7QUFLTyxTQUFTQyxVQUFVQyxLQUFhO0FBQ3JDLFFBQU1DLFFBQVFELElBQUlFLE1BQU0sR0FBQTtBQUN4QixRQUFNQyxPQUFpQixDQUFBO0FBQ3ZCLE1BQUlDLE1BQU07QUFDVixhQUFXQyxRQUFRSixPQUFPO0FBQ3hCRyxXQUFPQztBQUNQLFFBQUlELElBQUlFLFNBQVMsSUFBTyxHQUFBO0FBQ3RCRixZQUFNQSxJQUFJRyxNQUFNLEdBQUcsRUFBTSxJQUFBO1dBQ3BCO0FBQ0xKLFdBQUtLLEtBQUtKLEdBQUFBO0FBQ1ZBLFlBQU07O0VBRVY7QUFDQSxTQUFPRDtBQUNUO0FBRUEsU0FBU00sZ0JBQWdCVCxLQUFhO0FBQ3BDLFFBQU1HLE9BQU9KLFVBQVVDLEdBQUFBO0FBQ3ZCLFNBQU9VLENBQUFBLFFBQU87QUFDWixlQUFXQyxLQUFLUixNQUFNO0FBQ3BCLFVBQUlRLE1BQU0sSUFBSTtBQUdaOztBQUVGRCxZQUFNQSxPQUFPQSxJQUFJQyxDQUFFO0lBQ3JCO0FBQ0EsV0FBT0Q7RUFDVDtBQUNGO0FBRU8sU0FBU0UsaUJBQWlCRixLQUFnQlYsS0FBa0I7QUFDakUsUUFBTWEsV0FBV25CLGFBQWFNLEdBQUksTUFBS04sYUFBYU0sR0FBQUEsSUFBT1MsZ0JBQWdCVCxHQUFHO0FBQzlFLFNBQU9hLFNBQVNILEdBQUFBO0FBQ2xCO0FBS08sU0FBU0ksWUFBWUMsS0FBYTtBQUN2QyxTQUFPQSxJQUFJQyxPQUFPLENBQUEsRUFBR0MsWUFBVyxJQUFLRixJQUFJUixNQUFNLENBQUE7QUFDakQ7SUFHYVcsVUFBVSxDQUFDQyxVQUFtQixPQUFPQSxVQUFVO0lBRS9DQyxhQUFhLENBQUNELFVBQXFELE9BQU9BLFVBQVU7QUFHcEZFLElBQUFBLFlBQVksQ0FBSUMsSUFBV0MsT0FBYztBQUNwRCxNQUFJRCxHQUFFRSxTQUFTRCxHQUFFQyxNQUFNO0FBQ3JCLFdBQU87O0FBR1QsYUFBV0MsUUFBUUgsSUFBRztBQUNwQixRQUFJLENBQUNDLEdBQUVHLElBQUlELElBQU8sR0FBQTtBQUNoQixhQUFPOztFQUVYO0FBRUEsU0FBTztBQUNUO0FBTU8sU0FBU0UsY0FBY0MsSUFBZTtBQUMzQyxTQUFPQSxHQUFFQyxTQUFTLGFBQWFELEdBQUVDLFNBQVMsV0FBV0QsR0FBRUMsU0FBUztBQUNsRTtBQ3ZaTyxJQUFNQyxLQUFLQyxLQUFLRDtBQUNoQixJQUFNRSxNQUFNLElBQUlGO0FBQ2hCLElBQU1HLFFBQVFELE1BQU1GO0FBQ2RJLElBQUFBLFdBQVdDLE9BQU9DO0FBQ3hCLElBQU1DLGNBQWNQLEtBQUs7QUFDekIsSUFBTVEsVUFBVVIsS0FBSztBQUNyQixJQUFNUyxhQUFhVCxLQUFLO0FBQ2xCVSxJQUFBQSxnQkFBZ0JWLEtBQUssSUFBSTtBQUV6QlcsSUFBQUEsUUFBUVYsS0FBS1U7QUFDYkMsSUFBQUEsT0FBT1gsS0FBS1c7QUFFbEIsU0FBU0MsYUFBYS9DLElBQVdFLElBQVc4QyxTQUFpQjtBQUNsRSxTQUFPYixLQUFLYyxJQUFJakQsS0FBSUUsRUFBSzhDLElBQUFBO0FBQzNCO0FBS08sU0FBU0UsUUFBUUMsUUFBZTtBQUNyQyxRQUFNQyxlQUFlakIsS0FBS2tCLE1BQU1GLE1BQUFBO0FBQ2hDQSxFQUFBQSxTQUFRSixhQUFhSSxRQUFPQyxjQUFjRCxTQUFRLEdBQUEsSUFBUUMsZUFBZUQ7QUFDekUsUUFBTUcsWUFBWW5CLEtBQUtvQixJQUFJLElBQUlwQixLQUFLcUIsTUFBTVgsTUFBTU0sTUFBQUEsQ0FBQUEsQ0FBQUE7QUFDaEQsUUFBTU0sV0FBV04sU0FBUUc7QUFDekIsUUFBTUksZUFBZUQsWUFBWSxJQUFJLElBQUlBLFlBQVksSUFBSSxJQUFJQSxZQUFZLElBQUksSUFBSTtBQUNqRixTQUFPQyxlQUFlSjtBQUN4QjtBQU1PLFNBQVNLLFdBQVdwQyxPQUFlO0FBQ3hDLFFBQU1xQyxTQUFtQixDQUFBO0FBQ3pCLFFBQU1DLE9BQU8xQixLQUFLMEIsS0FBS3RDLEtBQUFBO0FBQ3ZCLE1BQUl1QztBQUVKLE9BQUtBLEtBQUksR0FBR0EsS0FBSUQsTUFBTUMsTUFBSztBQUN6QixRQUFJdkMsUUFBUXVDLE9BQU0sR0FBRztBQUNuQkYsYUFBT2hELEtBQUtrRCxFQUFBQTtBQUNaRixhQUFPaEQsS0FBS1csUUFBUXVDLEVBQUFBOztFQUV4QjtBQUNBLE1BQUlELFVBQVVBLE9BQU8sSUFBSTtBQUN2QkQsV0FBT2hELEtBQUtpRCxJQUFBQTs7QUFHZEQsU0FBT0csS0FBSyxDQUFDckMsSUFBR0MsT0FBTUQsS0FBSUMsRUFBQUEsRUFBR3FDLElBQUc7QUFDaEMsU0FBT0o7QUFDVDtBQUtBLFNBQVNLLGVBQWVDLElBQVk7QUFDbEMsU0FBTyxPQUFPQSxPQUFNLFlBQWEsT0FBT0EsT0FBTSxZQUFZQSxPQUFNLFFBQVEsRUFBRUMsT0FBT0MsZUFBZUYsTUFBSyxjQUFjQSxNQUFLLGFBQWFBO0FBQ3ZJO0FBRU8sU0FBU0csU0FBU0gsSUFBeUI7QUFDaEQsU0FBTyxDQUFDRCxlQUFlQyxFQUFBQSxLQUFNLENBQUNJLE1BQU1DLFdBQVdMLEVBQUFBLENBQUFBLEtBQWlCTSxTQUFTTixFQUFBQTtBQUMzRTtBQUVPLFNBQVNPLFlBQVl6RSxJQUFXZ0QsU0FBaUI7QUFDdEQsUUFBTTBCLFVBQVV2QyxLQUFLa0IsTUFBTXJELEVBQUFBO0FBQzNCLFNBQU8sVUFBWWdELFdBQVloRCxNQUFRMEUsVUFBVTFCLFdBQVloRDtBQUMvRDtBQUtPLFNBQVMyRSxtQkFDZEMsT0FDQUMsUUFDQUMsVUFDQTtBQUNBLE1BQUloQixJQUFXaUIsTUFBY3hEO0FBRTdCLE9BQUt1QyxLQUFJLEdBQUdpQixPQUFPSCxNQUFNSSxRQUFRbEIsS0FBSWlCLE1BQU1qQixNQUFLO0FBQzlDdkMsWUFBUXFELE1BQU1kLEVBQUUsRUFBQ2dCLFFBQVM7QUFDMUIsUUFBSSxDQUFDUixNQUFNL0MsS0FBUSxHQUFBO0FBQ2pCc0QsYUFBT0ksTUFBTTlDLEtBQUs4QyxJQUFJSixPQUFPSSxLQUFLMUQsS0FBQUE7QUFDbENzRCxhQUFPSyxNQUFNL0MsS0FBSytDLElBQUlMLE9BQU9LLEtBQUszRCxLQUFBQTs7RUFFdEM7QUFDRjtBQUVPLFNBQVM0RCxVQUFVQyxTQUFpQjtBQUN6QyxTQUFPQSxXQUFXbEQsS0FBSztBQUN6QjtBQUVPLFNBQVNtRCxVQUFVQyxTQUFpQjtBQUN6QyxTQUFPQSxXQUFXLE1BQU1wRDtBQUMxQjtBQVNPLFNBQVNxRCxlQUFldkYsSUFBVztBQUN4QyxNQUFJLENBQUN3RixlQUFleEYsRUFBSSxHQUFBO0FBQ3RCOztBQUVGLE1BQUlnQyxLQUFJO0FBQ1IsTUFBSXlELEtBQUk7QUFDUixTQUFPdEQsS0FBS2tCLE1BQU1yRCxLQUFJZ0MsRUFBQUEsSUFBS0EsT0FBTWhDLElBQUc7QUFDbENnQyxJQUFBQSxNQUFLO0FBQ0x5RCxJQUFBQTtFQUNGO0FBQ0EsU0FBT0E7QUFDVDtBQUdPLFNBQVNDLGtCQUNkQyxhQUNBQyxZQUNBO0FBQ0EsUUFBTUMsc0JBQXNCRCxXQUFXNUYsSUFBSTJGLFlBQVkzRjtBQUN2RCxRQUFNOEYsc0JBQXNCRixXQUFXMUYsSUFBSXlGLFlBQVl6RjtBQUN2RCxRQUFNNkYsMkJBQTJCNUQsS0FBSzBCLEtBQUtnQyxzQkFBc0JBLHNCQUFzQkMsc0JBQXNCQSxtQkFBQUE7QUFFN0csTUFBSUUsUUFBUTdELEtBQUs4RCxNQUFNSCxxQkFBcUJELG1CQUFBQTtBQUU1QyxNQUFJRyxRQUFTLE9BQU85RCxJQUFLO0FBQ3ZCOEQsYUFBUzVEOztBQUdYLFNBQU87SUFDTDREO0lBQ0FFLFVBQVVIO0VBQ1o7QUFDRjtBQUVPLFNBQVNJLHNCQUFzQkMsS0FBWUMsS0FBWTtBQUM1RCxTQUFPbEUsS0FBSzBCLEtBQUsxQixLQUFLb0IsSUFBSThDLElBQUlyRyxJQUFJb0csSUFBSXBHLEdBQUcsQ0FBQSxJQUFLbUMsS0FBS29CLElBQUk4QyxJQUFJbkcsSUFBSWtHLElBQUlsRyxHQUFHLENBQUEsQ0FBQTtBQUN4RTtBQWNPLFNBQVNvRyxnQkFBZ0JDLElBQVc7QUFDekMsVUFBUUEsS0FBSUMsTUFBTUEsT0FBT0E7QUFDM0I7QUFLTyxTQUFTQyxjQUFjQyxPQUFlQyxPQUFlQyxLQUFhQyx1QkFBaUM7QUFDeEcsUUFBTU4sS0FBSUQsZ0JBQWdCSSxLQUFBQTtBQUMxQixRQUFNSSxLQUFJUixnQkFBZ0JLLEtBQUFBO0FBQzFCLFFBQU1JLEtBQUlULGdCQUFnQk0sR0FBQUE7QUFDMUIsUUFBTUksZUFBZVYsZ0JBQWdCUSxLQUFJUCxFQUFBQTtBQUN6QyxRQUFNVSxhQUFhWCxnQkFBZ0JTLEtBQUlSLEVBQUFBO0FBQ3ZDLFFBQU1XLGVBQWVaLGdCQUFnQkMsS0FBSU8sRUFBQUE7QUFDekMsUUFBTUssYUFBYWIsZ0JBQWdCQyxLQUFJUSxFQUFBQTtBQUN2QyxTQUFPUixPQUFNTyxNQUFLUCxPQUFNUSxNQUFNRix5QkFBeUJDLE9BQU1DLE1BQ3ZEQyxlQUFlQyxjQUFjQyxlQUFlQztBQUNwRDtBQVNPLFNBQVNDLFlBQVlDLE9BQWVDLEtBQWFDLEtBQWE7QUFDbkUsU0FBT0MsS0FBS0QsSUFBSUQsS0FBS0UsS0FBS0YsSUFBSUMsS0FBS0YsS0FBQUEsQ0FBQUE7QUFDckM7QUFNTyxTQUFTSSxZQUFZSixPQUFlO0FBQ3pDLFNBQU9ELFlBQVlDLE9BQU8sUUFBUSxLQUFBO0FBQ3BDO0FBU08sU0FBU0ssV0FBV0wsT0FBZVYsT0FBZUMsS0FBYWUsVUFBVSxNQUFNO0FBQ3BGLFNBQU9OLFNBQVNHLEtBQUtGLElBQUlYLE9BQU9DLEdBQUFBLElBQU9lLFdBQVdOLFNBQVNHLEtBQUtELElBQUlaLE9BQU9DLEdBQU9lLElBQUFBO0FBQ3BGO0FDM0xPLFNBQVNDLFFBQ2RDLE9BQ0FSLE9BQ0FTLEtBQ0E7QUFDQUEsUUFBTUEsUUFBUSxDQUFDQyxVQUFVRixNQUFNRSxLQUFBQSxJQUFTVjtBQUN4QyxNQUFJVyxLQUFLSCxNQUFNSSxTQUFTO0FBQ3hCLE1BQUlDLEtBQUs7QUFDVCxNQUFJQztBQUVKLFNBQU9ILEtBQUtFLEtBQUssR0FBRztBQUNsQkMsVUFBT0QsS0FBS0YsTUFBTztBQUNuQixRQUFJRixJQUFJSyxHQUFNLEdBQUE7QUFDWkQsV0FBS0M7V0FDQTtBQUNMSCxXQUFLRzs7RUFFVDtBQUVBLFNBQU87SUFBQ0Q7SUFBSUY7RUFBRTtBQUNoQjtBQVVPLElBQU1JLGVBQWUsQ0FDMUJQLE9BQ0FRLEtBQ0FoQixPQUNBaUIsU0FFQVYsUUFBUUMsT0FBT1IsT0FBT2lCLE9BQ2xCUCxDQUFBQSxVQUFTO0FBQ1QsUUFBTVEsS0FBS1YsTUFBTUUsS0FBQUEsRUFBT00sR0FBSTtBQUM1QixTQUFPRSxLQUFLbEIsU0FBU2tCLE9BQU9sQixTQUFTUSxNQUFNRSxRQUFRLENBQUEsRUFBR00sR0FBQUEsTUFBU2hCO0lBRS9EVSxDQUFBQSxVQUFTRixNQUFNRSxLQUFBQSxFQUFPTSxHQUFBQSxJQUFPaEIsS0FBSztBQVMzQm1CLElBQUFBLGdCQUFnQixDQUMzQlgsT0FDQVEsS0FDQWhCLFVBRUFPLFFBQVFDLE9BQU9SLE9BQU9VLENBQUFBLFVBQVNGLE1BQU1FLEtBQUFBLEVBQU9NLEdBQUFBLEtBQVFoQixLQUFPO0FBU3RELFNBQVNvQixlQUFlQyxRQUFrQnBCLEtBQWFDLEtBQWE7QUFDekUsTUFBSVosUUFBUTtBQUNaLE1BQUlDLE1BQU04QixPQUFPVDtBQUVqQixTQUFPdEIsUUFBUUMsT0FBTzhCLE9BQU8vQixLQUFBQSxJQUFTVyxLQUFLO0FBQ3pDWDtFQUNGO0FBQ0EsU0FBT0MsTUFBTUQsU0FBUytCLE9BQU85QixNQUFNLENBQUEsSUFBS1csS0FBSztBQUMzQ1g7RUFDRjtBQUVBLFNBQU9ELFFBQVEsS0FBS0MsTUFBTThCLE9BQU9ULFNBQzdCUyxPQUFPQyxNQUFNaEMsT0FBT0MsR0FBQUEsSUFDcEI4QjtBQUNOO0FBRUEsSUFBTUUsY0FBYztFQUFDO0VBQVE7RUFBTztFQUFTO0VBQVU7QUFBVTtBQWdCMUQsU0FBU0Msa0JBQWtCQyxPQUFPQyxVQUFVO0FBQ2pELE1BQUlELE1BQU1FLFVBQVU7QUFDbEJGLFVBQU1FLFNBQVNDLFVBQVVDLEtBQUtILFFBQUFBO0FBQzlCOztBQUdGSSxTQUFPQyxlQUFlTixPQUFPLFlBQVk7SUFDdkNPLGNBQWM7SUFDZEMsWUFBWTtJQUNaakMsT0FBTztNQUNMNEIsV0FBVztRQUFDRjtNQUFTO0lBQ3ZCO0VBQ0YsQ0FBQTtBQUVBSCxjQUFZVyxRQUFRLENBQUNsQixRQUFRO0FBQzNCLFVBQU1tQixTQUFTLFlBQVlDLFlBQVlwQixHQUFBQTtBQUN2QyxVQUFNcUIsT0FBT1osTUFBTVQsR0FBSTtBQUV2QmMsV0FBT0MsZUFBZU4sT0FBT1QsS0FBSztNQUNoQ2dCLGNBQWM7TUFDZEMsWUFBWTtNQUNaakMsU0FBU3NDLE1BQU07QUFDYixjQUFNQyxNQUFNRixLQUFLRyxNQUFNLE1BQU1GLElBQUFBO0FBRTdCYixjQUFNRSxTQUFTQyxVQUFVTSxRQUFRLENBQUNPLFdBQVc7QUFDM0MsY0FBSSxPQUFPQSxPQUFPTixNQUFBQSxNQUFZLFlBQVk7QUFDeENNLG1CQUFPTixNQUFBQSxFQUFXRyxHQUFBQSxJQUFBQTs7UUFFdEIsQ0FBQTtBQUVBLGVBQU9DO01BQ1Q7SUFDRixDQUFBO0VBQ0YsQ0FBQTtBQUNGO0FBUU8sU0FBU0csb0JBQW9CakIsT0FBT0MsVUFBVTtBQUNuRCxRQUFNaUIsT0FBT2xCLE1BQU1FO0FBQ25CLE1BQUksQ0FBQ2dCLE1BQU07QUFDVDs7QUFHRixRQUFNZixZQUFZZSxLQUFLZjtBQUN2QixRQUFNbEIsUUFBUWtCLFVBQVVnQixRQUFRbEIsUUFBQUE7QUFDaEMsTUFBSWhCLFVBQVUsSUFBSTtBQUNoQmtCLGNBQVVpQixPQUFPbkMsT0FBTyxDQUFBOztBQUcxQixNQUFJa0IsVUFBVWhCLFNBQVMsR0FBRztBQUN4Qjs7QUFHRlcsY0FBWVcsUUFBUSxDQUFDbEIsUUFBUTtBQUMzQixXQUFPUyxNQUFNVCxHQUFJO0VBQ25CLENBQUE7QUFFQSxTQUFPUyxNQUFNRTtBQUNmO0FBS08sU0FBU21CLGFBQWdCQyxPQUFZO0FBQzFDLFFBQU1DLE9BQU0sSUFBSUMsSUFBT0YsS0FBQUE7QUFFdkIsTUFBSUMsS0FBSUUsU0FBU0gsTUFBTW5DLFFBQVE7QUFDN0IsV0FBT21DOztBQUdULFNBQU9JLE1BQU1DLEtBQUtKLElBQUFBO0FBQ3BCO0FDbExhSyxJQUFBQSxvQkFBb0IsV0FBVztBQUMxQyxNQUFJLE9BQU9DLFdBQVcsYUFBYTtBQUNqQyxXQUFPLFNBQVNDLFdBQVU7QUFDeEIsYUFBT0EsVUFBQUE7SUFDVDs7QUFFRixTQUFPRCxPQUFPRTtBQUNoQixHQUFLO0FBTUUsU0FBU0MsVUFDZEMsS0FDQUMsU0FDQTtBQUNBLE1BQUlDLFlBQVksQ0FBQTtBQUNoQixNQUFJQyxVQUFVO0FBRWQsU0FBTyxZQUFZQyxNQUFhO0FBRTlCRixnQkFBWUU7QUFDWixRQUFJLENBQUNELFNBQVM7QUFDWkEsZ0JBQVU7QUFDVlIsdUJBQWlCVSxLQUFLVCxRQUFRLE1BQU07QUFDbENPLGtCQUFVO0FBQ1ZILFFBQUFBLElBQUdNLE1BQU1MLFNBQVNDLFNBQUFBO01BQ3BCLENBQUE7O0VBRUo7QUFDRjtBQUtPLFNBQVNLLFNBQW1DUCxLQUE4QlEsT0FBZTtBQUM5RixNQUFJQztBQUNKLFNBQU8sWUFBWUwsTUFBYTtBQUM5QixRQUFJSSxPQUFPO0FBQ1RFLG1CQUFhRCxPQUFBQTtBQUNiQSxnQkFBVUUsV0FBV1gsS0FBSVEsT0FBT0osSUFBQUE7V0FDM0I7QUFDTEosTUFBQUEsSUFBR00sTUFBTSxNQUFNRixJQUFBQTs7QUFFakIsV0FBT0k7RUFDVDtBQUNGO0FBTU8sSUFBTUkscUJBQXFCLENBQUNDLFVBQXNDQSxVQUFVLFVBQVUsU0FBU0EsVUFBVSxRQUFRLFVBQVU7QUFNckhDLElBQUFBLGlCQUFpQixDQUFDRCxPQUFtQ0UsT0FBZUMsUUFBZ0JILFVBQVUsVUFBVUUsUUFBUUYsVUFBVSxRQUFRRyxPQUFPRCxRQUFRQyxPQUFPO0FBTXhKQyxJQUFBQSxTQUFTLENBQUNKLE9BQW9DSyxNQUFjQyxPQUFlQyxRQUFpQjtBQUN2RyxRQUFNQyxRQUFRRCxNQUFNLFNBQVM7QUFDN0IsU0FBT1AsVUFBVVEsUUFBUUYsUUFBUU4sVUFBVSxZQUFZSyxPQUFPQyxTQUFTLElBQUlEO0FBQzdFO0FDL0VBLElBQU1JLFNBQVMsQ0FBQ0MsT0FBY0EsT0FBTSxLQUFLQSxPQUFNO0FBQy9DLElBQU1DLFlBQVksQ0FBQ0QsSUFBV0UsSUFBV0MsT0FBYyxFQUFFQyxLQUFLQyxJQUFJLEdBQUcsTUFBTUwsTUFBSyxFQUFNSSxJQUFBQSxLQUFLRSxLQUFLTixLQUFJRSxNQUFLSyxNQUFNSixFQUFDO0FBQ2hILElBQU1LLGFBQWEsQ0FBQ1IsSUFBV0UsSUFBV0MsT0FBY0MsS0FBS0MsSUFBSSxHQUFHLE1BQU1MLEVBQUtJLElBQUFBLEtBQUtFLEtBQUtOLEtBQUlFLE1BQUtLLE1BQU1KLEVBQUssSUFBQTtBQU01RyxJQUNLTSxVQUFVO0VBQ2RDLFFBQVEsQ0FBQ1YsT0FBY0E7RUFFdkJXLFlBQVksQ0FBQ1gsT0FBY0EsS0FBSUE7RUFFL0JZLGFBQWEsQ0FBQ1osT0FBYyxDQUFDQSxNQUFLQSxLQUFJO0VBRXRDYSxlQUFlLENBQUNiLFFBQWdCQSxNQUFLLE9BQU8sSUFDeEMsTUFBTUEsS0FBSUEsS0FDVixRQUFTLEVBQUVBLE1BQU1BLEtBQUksS0FBSztFQUU5QmMsYUFBYSxDQUFDZCxPQUFjQSxLQUFJQSxLQUFJQTtFQUVwQ2UsY0FBYyxDQUFDZixRQUFlQSxNQUFLLEtBQUtBLEtBQUlBLEtBQUk7RUFFaERnQixnQkFBZ0IsQ0FBQ2hCLFFBQWdCQSxNQUFLLE9BQU8sSUFDekMsTUFBTUEsS0FBSUEsS0FBSUEsS0FDZCxRQUFRQSxNQUFLLEtBQUtBLEtBQUlBLEtBQUk7RUFFOUJpQixhQUFhLENBQUNqQixPQUFjQSxLQUFJQSxLQUFJQSxLQUFJQTtFQUV4Q2tCLGNBQWMsQ0FBQ2xCLE9BQWMsR0FBR0EsTUFBSyxLQUFLQSxLQUFJQSxLQUFJQSxLQUFJO0VBRXREbUIsZ0JBQWdCLENBQUNuQixRQUFnQkEsTUFBSyxPQUFPLElBQ3pDLE1BQU1BLEtBQUlBLEtBQUlBLEtBQUlBLEtBQ2xCLFNBQVNBLE1BQUssS0FBS0EsS0FBSUEsS0FBSUEsS0FBSTtFQUVuQ29CLGFBQWEsQ0FBQ3BCLE9BQWNBLEtBQUlBLEtBQUlBLEtBQUlBLEtBQUlBO0VBRTVDcUIsY0FBYyxDQUFDckIsUUFBZUEsTUFBSyxLQUFLQSxLQUFJQSxLQUFJQSxLQUFJQSxLQUFJO0VBRXhEc0IsZ0JBQWdCLENBQUN0QixRQUFnQkEsTUFBSyxPQUFPLElBQ3pDLE1BQU1BLEtBQUlBLEtBQUlBLEtBQUlBLEtBQUlBLEtBQ3RCLFFBQVFBLE1BQUssS0FBS0EsS0FBSUEsS0FBSUEsS0FBSUEsS0FBSTtFQUV0Q3VCLFlBQVksQ0FBQ3ZCLE9BQWMsQ0FBQ0ksS0FBS29CLElBQUl4QixLQUFJeUIsT0FBVyxJQUFBO0VBRXBEQyxhQUFhLENBQUMxQixPQUFjSSxLQUFLRSxJQUFJTixLQUFJeUIsT0FBQUE7RUFFekNFLGVBQWUsQ0FBQzNCLE9BQWMsUUFBUUksS0FBS29CLElBQUlJLEtBQUs1QixFQUFBQSxJQUFLO0VBRXpENkIsWUFBWSxDQUFDN0IsT0FBY0EsT0FBTyxJQUFLLElBQUlJLEtBQUtDLElBQUksR0FBRyxNQUFNTCxLQUFJLEVBQUc7RUFFcEU4QixhQUFhLENBQUM5QixPQUFjQSxPQUFPLElBQUssSUFBSSxDQUFDSSxLQUFLQyxJQUFJLEdBQUcsTUFBTUwsRUFBQUEsSUFBSztFQUVwRStCLGVBQWUsQ0FBQy9CLE9BQWNELE9BQU9DLEVBQUFBLElBQUtBLEtBQUlBLEtBQUksTUFDOUMsTUFBTUksS0FBS0MsSUFBSSxHQUFHLE1BQU1MLEtBQUksSUFBSSxFQUFBLElBQ2hDLE9BQU8sQ0FBQ0ksS0FBS0MsSUFBSSxHQUFHLE9BQU9MLEtBQUksSUFBSSxFQUFBLElBQU07RUFFN0NnQyxZQUFZLENBQUNoQyxPQUFjQSxNQUFNLElBQUtBLEtBQUksRUFBRUksS0FBSzZCLEtBQUssSUFBSWpDLEtBQUlBLEVBQUFBLElBQUs7RUFFbkVrQyxhQUFhLENBQUNsQyxPQUFjSSxLQUFLNkIsS0FBSyxLQUFLakMsTUFBSyxLQUFLQSxFQUFBQTtFQUVyRG1DLGVBQWUsQ0FBQ25DLFFBQWdCQSxNQUFLLE9BQU8sSUFDeEMsUUFBUUksS0FBSzZCLEtBQUssSUFBSWpDLEtBQUlBLEVBQUFBLElBQUssS0FDL0IsT0FBT0ksS0FBSzZCLEtBQUssS0FBS2pDLE1BQUssS0FBS0EsRUFBQUEsSUFBSztFQUV6Q29DLGVBQWUsQ0FBQ3BDLE9BQWNELE9BQU9DLEVBQUFBLElBQUtBLEtBQUlDLFVBQVVELElBQUcsT0FBTyxHQUFJO0VBRXRFcUMsZ0JBQWdCLENBQUNyQyxPQUFjRCxPQUFPQyxFQUFBQSxJQUFLQSxLQUFJUSxXQUFXUixJQUFHLE9BQU8sR0FBSTtFQUV4RXNDLGlCQUFpQnRDLElBQVc7QUFDMUIsVUFBTUUsS0FBSTtBQUNWLFVBQU1DLEtBQUk7QUFDVixXQUFPSixPQUFPQyxFQUFLQSxJQUFBQSxLQUNqQkEsS0FBSSxNQUNBLE1BQU1DLFVBQVVELEtBQUksR0FBR0UsSUFBR0MsRUFBQUEsSUFDMUIsTUFBTSxNQUFNSyxXQUFXUixLQUFJLElBQUksR0FBR0UsSUFBR0MsRUFBRTtFQUMvQztFQUVBb0MsV0FBV3ZDLElBQVc7QUFDcEIsVUFBTUUsS0FBSTtBQUNWLFdBQU9GLEtBQUlBLE9BQU1FLEtBQUksS0FBS0YsS0FBSUU7RUFDaEM7RUFFQXNDLFlBQVl4QyxJQUFXO0FBQ3JCLFVBQU1FLEtBQUk7QUFDVixZQUFRRixNQUFLLEtBQUtBLE9BQU1FLEtBQUksS0FBS0YsS0FBSUUsTUFBSztFQUM1QztFQUVBdUMsY0FBY3pDLElBQVc7QUFDdkIsUUFBSUUsS0FBSTtBQUNSLFNBQUtGLE1BQUssT0FBTyxHQUFHO0FBQ2xCLGFBQU8sT0FBT0EsS0FBSUEsUUFBT0UsTUFBTSxTQUFVLEtBQUtGLEtBQUlFOztBQUVwRCxXQUFPLFFBQVFGLE1BQUssS0FBS0EsUUFBT0UsTUFBTSxTQUFVLEtBQUtGLEtBQUlFLE1BQUs7RUFDaEU7RUFFQXdDLGNBQWMsQ0FBQzFDLE9BQWMsSUFBSVMsUUFBUWtDLGNBQWMsSUFBSTNDLEVBQUFBO0VBRTNEMkMsY0FBYzNDLElBQVc7QUFDdkIsVUFBTTRDLEtBQUk7QUFDVixVQUFNQyxLQUFJO0FBQ1YsUUFBSTdDLEtBQUssSUFBSTZDLElBQUk7QUFDZixhQUFPRCxLQUFJNUMsS0FBSUE7O0FBRWpCLFFBQUlBLEtBQUssSUFBSTZDLElBQUk7QUFDZixhQUFPRCxNQUFLNUMsTUFBTSxNQUFNNkMsTUFBTTdDLEtBQUk7O0FBRXBDLFFBQUlBLEtBQUssTUFBTTZDLElBQUk7QUFDakIsYUFBT0QsTUFBSzVDLE1BQU0sT0FBTzZDLE1BQU03QyxLQUFJOztBQUVyQyxXQUFPNEMsTUFBSzVDLE1BQU0sUUFBUTZDLE1BQU03QyxLQUFJO0VBQ3RDO0VBRUE4QyxpQkFBaUIsQ0FBQzlDLE9BQWVBLEtBQUksTUFDakNTLFFBQVFpQyxhQUFhMUMsS0FBSSxDQUFLLElBQUEsTUFDOUJTLFFBQVFrQyxjQUFjM0MsS0FBSSxJQUFJLENBQUEsSUFBSyxNQUFNO0FBQy9DO0FDckhPLFNBQVMrQyxvQkFBb0JDLE9BQXlEO0FBQzNGLE1BQUlBLFNBQVMsT0FBT0EsVUFBVSxVQUFVO0FBQ3RDLFVBQU1DLE9BQU9ELE1BQU1FLFNBQVE7QUFDM0IsV0FBT0QsU0FBUyw0QkFBNEJBLFNBQVM7O0FBR3ZELFNBQU87QUFDVDtBQVdPLFNBQVNFLE1BQU1ILE9BQU87QUFDM0IsU0FBT0Qsb0JBQW9CQyxLQUFBQSxJQUFTQSxRQUFRLElBQUlJLE1BQU1KLEtBQU07QUFDOUQ7QUFLTyxTQUFTSyxjQUFjTCxPQUFPO0FBQ25DLFNBQU9ELG9CQUFvQkMsS0FBQUEsSUFDdkJBLFFBQ0EsSUFBSUksTUFBTUosS0FBQUEsRUFBT00sU0FBUyxHQUFLQyxFQUFBQSxPQUFPLEdBQUEsRUFBS0MsVUFBUztBQUMxRDtBQy9CQSxJQUFNQyxVQUFVO0VBQUM7RUFBSztFQUFLO0VBQWU7RUFBVTtBQUFVO0FBQzlELElBQU1DLFNBQVM7RUFBQztFQUFTO0VBQWU7QUFBa0I7QUFFbkQsU0FBU0Msd0JBQXdCQyxXQUFVO0FBQ2hEQSxFQUFBQSxVQUFTQyxJQUFJLGFBQWE7SUFDeEJDLE9BQU9DO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxJQUFJSDtJQUNKSSxNQUFNSjtJQUNOSyxNQUFNTDtJQUNOTSxJQUFJTjtJQUNKZCxNQUFNYztFQUNSLENBQUE7QUFFQUgsRUFBQUEsVUFBU1UsU0FBUyxhQUFhO0lBQzdCQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsYUFBYSxDQUFDQyxTQUFTQSxTQUFTLGdCQUFnQkEsU0FBUyxnQkFBZ0JBLFNBQVM7RUFDcEYsQ0FBQTtBQUVBZCxFQUFBQSxVQUFTQyxJQUFJLGNBQWM7SUFDekJILFFBQVE7TUFDTlQsTUFBTTtNQUNOMEIsWUFBWWpCO0lBQ2Q7SUFDQUQsU0FBUztNQUNQUixNQUFNO01BQ04wQixZQUFZbEI7SUFDZDtFQUNGLENBQUE7QUFFQUcsRUFBQUEsVUFBU1UsU0FBUyxjQUFjO0lBQzlCQyxXQUFXO0VBQ2IsQ0FBQTtBQUVBWCxFQUFBQSxVQUFTQyxJQUFJLGVBQWU7SUFDMUJlLFFBQVE7TUFDTkMsV0FBVztRQUNUYixVQUFVO01BQ1o7SUFDRjtJQUNBYyxRQUFRO01BQ05ELFdBQVc7UUFDVGIsVUFBVTtNQUNaO0lBQ0Y7SUFDQWUsTUFBTTtNQUNKQyxZQUFZO1FBQ1Z0QixRQUFRO1VBQ05TLE1BQU07UUFDUjtRQUNBYyxTQUFTO1VBQ1BoQyxNQUFNO1VBQ05lLFVBQVU7UUFDWjtNQUNGO0lBQ0Y7SUFDQWtCLE1BQU07TUFDSkYsWUFBWTtRQUNWdEIsUUFBUTtVQUNOVyxJQUFJO1FBQ047UUFDQVksU0FBUztVQUNQaEMsTUFBTTtVQUNOZ0IsUUFBUTtVQUNSQyxJQUFJaUIsQ0FBQUEsT0FBS0EsS0FBSTtRQUNmO01BQ0Y7SUFDRjtFQUNGLENBQUE7QUFDRjtBQ3ZFTyxTQUFTQyxxQkFBcUJ4QixXQUFVO0FBQzdDQSxFQUFBQSxVQUFTQyxJQUFJLFVBQVU7SUFDckJ3QixhQUFhO0lBQ2JDLFNBQVM7TUFDUEMsS0FBSztNQUNMQyxPQUFPO01BQ1BDLFFBQVE7TUFDUkMsTUFBTTtJQUNSO0VBQ0YsQ0FBQTtBQUNGO0FDVEEsSUFBTUMsWUFBWSxvQkFBSUMsSUFBQUE7QUFFdEIsU0FBU0MsZ0JBQWdCQyxTQUFnQkMsU0FBb0M7QUFDM0VBLFlBQVVBLFdBQVcsQ0FBQTtBQUNyQixRQUFNQyxXQUFXRixVQUFTRyxLQUFLQyxVQUFVSCxPQUFBQTtBQUN6QyxNQUFJSSxZQUFZUixVQUFVUyxJQUFJSixRQUFBQTtBQUM5QixNQUFJLENBQUNHLFdBQVc7QUFDZEEsZ0JBQVksSUFBSUUsS0FBS0MsYUFBYVIsU0FBUUMsT0FBQUE7QUFDMUNKLGNBQVU5QixJQUFJbUMsVUFBVUcsU0FBQUE7O0FBRTFCLFNBQU9BO0FBQ1Q7QUFFTyxTQUFTSSxhQUFhQyxLQUFhVixTQUFnQkMsU0FBb0M7QUFDNUYsU0FBT0YsZ0JBQWdCQyxTQUFRQyxPQUFTVSxFQUFBQSxPQUFPRCxHQUFBQTtBQUNqRDtBQ1JBLElBQU1FLGFBQWE7RUFPakJDLE9BQU8zRCxPQUFPO0FBQ1osV0FBTzRELFFBQVE1RCxLQUFTLElBQXlCQSxRQUFTLEtBQUtBO0VBQ2pFO0VBVUE2RCxRQUFRQyxXQUFXQyxPQUFPQyxPQUFPO0FBQy9CLFFBQUlGLGNBQWMsR0FBRztBQUNuQixhQUFPOztBQUdULFVBQU1oQixVQUFTLEtBQUttQixNQUFNbEIsUUFBUUQ7QUFDbEMsUUFBSW9CO0FBQ0osUUFBSUMsUUFBUUw7QUFFWixRQUFJRSxNQUFNSSxTQUFTLEdBQUc7QUFFcEIsWUFBTUMsVUFBVWpILEtBQUtrSCxJQUFJbEgsS0FBS21ILElBQUlQLE1BQU0sQ0FBRSxFQUFDaEUsS0FBSyxHQUFHNUMsS0FBS21ILElBQUlQLE1BQU1BLE1BQU1JLFNBQVMsQ0FBRSxFQUFDcEUsS0FBSyxDQUFBO0FBQ3pGLFVBQUlxRSxVQUFVLFFBQVFBLFVBQVUsTUFBTztBQUNyQ0gsbUJBQVc7O0FBR2JDLGNBQVFLLGVBQWVWLFdBQVdFLEtBQUFBOztBQUdwQyxVQUFNUyxXQUFXQyxNQUFNdEgsS0FBS21ILElBQUlKLEtBQUFBLENBQUFBO0FBT2hDLFVBQU1RLGFBQWFDLE1BQU1ILFFBQUFBLElBQVksSUFBSXJILEtBQUtrSCxJQUFJbEgsS0FBS3lILElBQUksS0FBS3pILEtBQUswSCxNQUFNTCxRQUFBQSxHQUFXLEVBQUEsR0FBSyxDQUFFO0FBRTdGLFVBQU0xQixVQUFVO01BQUNtQjtNQUFVYSx1QkFBdUJKO01BQVlLLHVCQUF1Qkw7SUFBVTtBQUMvRk0sV0FBT0MsT0FBT25DLFNBQVMsS0FBS0EsUUFBUWlCLE1BQU1QLE1BQU07QUFFaEQsV0FBT0YsYUFBYU8sV0FBV2hCLFNBQVFDLE9BQUFBO0VBQ3pDO0VBV0FvQyxZQUFZckIsV0FBV0MsT0FBT0MsT0FBTztBQUNuQyxRQUFJRixjQUFjLEdBQUc7QUFDbkIsYUFBTzs7QUFFVCxVQUFNc0IsU0FBU3BCLE1BQU1ELEtBQUFBLEVBQU9zQixlQUFnQnZCLFlBQWExRyxLQUFLQyxJQUFJLElBQUlELEtBQUswSCxNQUFNSixNQUFNWixTQUFBQSxDQUFBQSxDQUFBQTtBQUN2RixRQUFJO01BQUM7TUFBRztNQUFHO01BQUc7TUFBRztNQUFJO0lBQUcsRUFBQ3dCLFNBQVNGLE1BQUFBLEtBQVdyQixRQUFRLE1BQU1DLE1BQU1JLFFBQVE7QUFDdkUsYUFBT1YsV0FBV0csUUFBUTBCLEtBQUssTUFBTXpCLFdBQVdDLE9BQU9DLEtBQUFBOztBQUV6RCxXQUFPO0VBQ1Q7QUFFRjtBQUdBLFNBQVNRLGVBQWVWLFdBQVdFLE9BQU87QUFHeEMsTUFBSUcsUUFBUUgsTUFBTUksU0FBUyxJQUFJSixNQUFNLENBQUUsRUFBQ2hFLFFBQVFnRSxNQUFNLENBQUUsRUFBQ2hFLFFBQVFnRSxNQUFNLENBQUUsRUFBQ2hFLFFBQVFnRSxNQUFNLENBQUUsRUFBQ2hFO0FBRzNGLE1BQUk1QyxLQUFLbUgsSUFBSUosS0FBQUEsS0FBVSxLQUFLTCxjQUFjMUcsS0FBSzBILE1BQU1oQixTQUFZLEdBQUE7QUFFL0RLLFlBQVFMLFlBQVkxRyxLQUFLMEgsTUFBTWhCLFNBQUFBOztBQUVqQyxTQUFPSztBQUNUO0FBTUEsSUFBQSxRQUFlO0VBQUNUO0FBQVU7QUNuR25CLFNBQVM4QixtQkFBbUI1RSxXQUFVO0FBQzNDQSxFQUFBQSxVQUFTQyxJQUFJLFNBQVM7SUFDcEI0RSxTQUFTO0lBQ1RDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxhQUFhO0lBU2JDLFFBQVE7SUFFUkMsTUFBTTtJQU1OQyxPQUFPO0lBR1BDLE1BQU07TUFDSlAsU0FBUztNQUNUUSxXQUFXO01BQ1hDLGlCQUFpQjtNQUNqQkMsV0FBVztNQUNYQyxZQUFZO01BQ1pDLFdBQVcsQ0FBQ0MsTUFBTXZELFlBQVlBLFFBQVFrRDtNQUN0Q00sV0FBVyxDQUFDRCxNQUFNdkQsWUFBWUEsUUFBUTVDO01BQ3RDdUYsUUFBUTtJQUNWO0lBRUFjLFFBQVE7TUFDTmYsU0FBUztNQUNUZ0IsTUFBTSxDQUFBO01BQ05DLFlBQVk7TUFDWkMsT0FBTztJQUNUO0lBR0FDLE9BQU87TUFFTG5CLFNBQVM7TUFHVG9CLE1BQU07TUFHTnZFLFNBQVM7UUFDUEMsS0FBSztRQUNMRSxRQUFRO01BQ1Y7SUFDRjtJQUdBdUIsT0FBTztNQUNMOEMsYUFBYTtNQUNiQyxhQUFhO01BQ2JDLFFBQVE7TUFDUkMsaUJBQWlCO01BQ2pCQyxpQkFBaUI7TUFDakI1RSxTQUFTO01BQ1RtRCxTQUFTO01BQ1QwQixVQUFVO01BQ1ZDLGlCQUFpQjtNQUNqQkMsYUFBYTtNQUViQyxVQUFVQyxNQUFNN0QsV0FBV0M7TUFDM0I2RCxPQUFPLENBQUE7TUFDUEMsT0FBTyxDQUFBO01BQ1BDLE9BQU87TUFDUEMsWUFBWTtNQUVaQyxtQkFBbUI7TUFDbkJDLGVBQWU7TUFDZkMsaUJBQWlCO0lBQ25CO0VBQ0YsQ0FBQTtBQUVBbEgsRUFBQUEsVUFBU21ILE1BQU0sZUFBZSxTQUFTLElBQUksT0FBQTtBQUMzQ25ILEVBQUFBLFVBQVNtSCxNQUFNLGNBQWMsU0FBUyxJQUFJLGFBQUE7QUFDMUNuSCxFQUFBQSxVQUFTbUgsTUFBTSxnQkFBZ0IsU0FBUyxJQUFJLGFBQUE7QUFDNUNuSCxFQUFBQSxVQUFTbUgsTUFBTSxlQUFlLFNBQVMsSUFBSSxPQUFBO0FBRTNDbkgsRUFBQUEsVUFBU1UsU0FBUyxTQUFTO0lBQ3pCQyxXQUFXO0lBQ1hFLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDQSxLQUFLc0csV0FBVyxRQUFBLEtBQWEsQ0FBQ3RHLEtBQUtzRyxXQUFXLE9BQVl0RyxLQUFBQSxTQUFTLGNBQWNBLFNBQVM7SUFDbEhGLFlBQVksQ0FBQ0UsU0FBU0EsU0FBUyxnQkFBZ0JBLFNBQVMsb0JBQW9CQSxTQUFTO0VBQ3ZGLENBQUE7QUFFQWQsRUFBQUEsVUFBU1UsU0FBUyxVQUFVO0lBQzFCQyxXQUFXO0VBQ2IsQ0FBQTtBQUVBWCxFQUFBQSxVQUFTVSxTQUFTLGVBQWU7SUFDL0JHLGFBQWEsQ0FBQ0MsU0FBU0EsU0FBUyxxQkFBcUJBLFNBQVM7SUFDOURGLFlBQVksQ0FBQ0UsU0FBU0EsU0FBUztFQUNqQyxDQUFBO0FBQ0Y7SUNsR2F1RyxZQUFZaEQsdUJBQU9pRCxPQUFPLElBQUk7SUFDOUJDLGNBQWNsRCx1QkFBT2lELE9BQU8sSUFBSTtBQU83QyxTQUFTRSxXQUFTQyxNQUFNQyxLQUFLO0FBQzNCLE1BQUksQ0FBQ0EsS0FBSztBQUNSLFdBQU9EOztBQUVULFFBQU1FLE9BQU9ELElBQUlFLE1BQU0sR0FBQTtBQUN2QixXQUFTQyxLQUFJLEdBQUdDLEtBQUlILEtBQUtuRSxRQUFRcUUsS0FBSUMsSUFBRyxFQUFFRCxJQUFHO0FBQzNDLFVBQU1FLElBQUlKLEtBQUtFLEVBQUU7QUFDakJKLFdBQU9BLEtBQUtNLENBQUUsTUFBS04sS0FBS00sQ0FBQUEsSUFBSzFELHVCQUFPaUQsT0FBTyxJQUFJO0VBQ2pEO0FBQ0EsU0FBT0c7QUFDVDtBQUVBLFNBQVN4SCxJQUFJK0gsTUFBTUMsT0FBT2xGLFFBQVE7QUFDaEMsTUFBSSxPQUFPa0YsVUFBVSxVQUFVO0FBQzdCLFdBQU9DLE1BQU1WLFdBQVNRLE1BQU1DLEtBQVFsRixHQUFBQSxNQUFBQTs7QUFFdEMsU0FBT21GLE1BQU1WLFdBQVNRLE1BQU0sRUFBS0MsR0FBQUEsS0FBQUE7QUFDbkM7QUFNTyxJQUFNRSxXQUFOLE1BQU1BO0VBQ1hDLFlBQVlDLGVBQWNDLFdBQVc7QUFDbkMsU0FBS3JILFlBQVlkO0FBQ2pCLFNBQUtvSSxrQkFBa0I7QUFDdkIsU0FBS0MsY0FBYztBQUNuQixTQUFLakosUUFBUTtBQUNiLFNBQUtrSixXQUFXLENBQUE7QUFDaEIsU0FBS0MsbUJBQW1CLENBQUNDLFlBQVlBLFFBQVF0RixNQUFNdUYsU0FBU0Msb0JBQW1CO0FBQy9FLFNBQUtDLFdBQVcsQ0FBQTtBQUNoQixTQUFLQyxTQUFTO01BQ1o7TUFDQTtNQUNBO01BQ0E7TUFDQTtJQUNEO0FBQ0QsU0FBS0MsT0FBTztNQUNWQyxRQUFRO01BQ1JDLE1BQU07TUFDTkMsT0FBTztNQUNQQyxZQUFZO01BQ1pDLFFBQVE7SUFDVjtBQUNBLFNBQUtDLFFBQVEsQ0FBQTtBQUNiLFNBQUtDLHVCQUF1QixDQUFDQyxLQUFLckgsWUFBWTFDLGNBQWMwQyxRQUFRb0csZUFBZTtBQUNuRixTQUFLa0IsbUJBQW1CLENBQUNELEtBQUtySCxZQUFZMUMsY0FBYzBDLFFBQVFxRyxXQUFXO0FBQzNFLFNBQUtrQixhQUFhLENBQUNGLEtBQUtySCxZQUFZMUMsY0FBYzBDLFFBQVE1QyxLQUFLO0FBQy9ELFNBQUtvSyxZQUFZO0FBQ2pCLFNBQUtDLGNBQWM7TUFDakJDLE1BQU07TUFDTkMsV0FBVztNQUNYQyxrQkFBa0I7SUFDcEI7QUFDQSxTQUFLQyxzQkFBc0I7QUFDM0IsU0FBS0MsVUFBVTtBQUNmLFNBQUtDLFVBQVU7QUFDZixTQUFLQyxVQUFVO0FBQ2YsU0FBS0MsVUFBVSxDQUFBO0FBQ2YsU0FBS0MsYUFBYTtBQUNsQixTQUFLQyxRQUFRbks7QUFDYixTQUFLb0ssU0FBUyxDQUFBO0FBQ2QsU0FBS0MsV0FBVztBQUNoQixTQUFLQywwQkFBMEI7QUFFL0IsU0FBSy9KLFNBQVMySCxhQUFBQTtBQUNkLFNBQUtxQyxNQUFNcEMsU0FBQUE7RUFDYjtFQU1BckksSUFBSWdJLE9BQU9sRixRQUFRO0FBQ2pCLFdBQU85QyxJQUFJLE1BQU1nSSxPQUFPbEYsTUFBQUE7RUFDMUI7RUFLQVAsSUFBSXlGLE9BQU87QUFDVCxXQUFPVCxXQUFTLE1BQU1TLEtBQUFBO0VBQ3hCO0VBTUF2SCxTQUFTdUgsT0FBT2xGLFFBQVE7QUFDdEIsV0FBTzlDLElBQUlzSCxhQUFhVSxPQUFPbEYsTUFBQUE7RUFDakM7RUFFQTRILFNBQVMxQyxPQUFPbEYsUUFBUTtBQUN0QixXQUFPOUMsSUFBSW9ILFdBQVdZLE9BQU9sRixNQUFBQTtFQUMvQjtFQW1CQW9FLE1BQU1jLE9BQU9uSCxNQUFNOEosYUFBYUMsWUFBWTtBQUMxQyxVQUFNQyxjQUFjdEQsV0FBUyxNQUFNUyxLQUFBQTtBQUNuQyxVQUFNOEMsb0JBQW9CdkQsV0FBUyxNQUFNb0QsV0FBQUE7QUFDekMsVUFBTUksY0FBYyxNQUFNbEs7QUFFMUJ1RCxXQUFPNEcsaUJBQWlCSCxhQUFhO01BRW5DLENBQUNFLFdBQUFBLEdBQWM7UUFDYjVMLE9BQU8wTCxZQUFZaEssSUFBSztRQUN4Qm9LLFVBQVU7TUFDWjtNQUVBLENBQUNwSyxJQUFBQSxHQUFPO1FBQ05xSyxZQUFZO1FBQ1ozSSxNQUFNO0FBQ0osZ0JBQU00SSxRQUFRLEtBQUtKLFdBQVk7QUFDL0IsZ0JBQU1LLFNBQVNOLGtCQUFrQkYsVUFBVztBQUM1QyxjQUFJUyxTQUFTRixLQUFRLEdBQUE7QUFDbkIsbUJBQU8vRyxPQUFPQyxPQUFPLENBQUEsR0FBSStHLFFBQVFELEtBQUFBOztBQUVuQyxpQkFBT0csZUFBZUgsT0FBT0MsTUFBQUE7UUFDL0I7UUFDQXBMLElBQUliLE9BQU87QUFDVCxlQUFLNEwsV0FBQUEsSUFBZTVMO1FBQ3RCO01BQ0Y7SUFDRixDQUFBO0VBQ0Y7RUFFQXNMLE1BQU1jLFVBQVU7QUFDZEEsYUFBU0MsUUFBUSxDQUFDZixVQUFVQSxNQUFNLElBQUksQ0FBQTtFQUN4QztBQUNGO0FBR0EsSUFBQTFLLFlBQStCLG9CQUFJbUksU0FBUztFQUMxQ3RILGFBQWEsQ0FBQ0MsU0FBUyxDQUFDQSxLQUFLc0csV0FBVyxJQUFBO0VBQ3hDeEcsWUFBWSxDQUFDRSxTQUFTQSxTQUFTO0VBQy9Cd0ksT0FBTztJQUNMM0ksV0FBVztFQUNiO0VBQ0FpSixhQUFhO0lBQ1gvSSxhQUFhO0lBQ2JELFlBQVk7RUFDZDtBQUNGLEdBQUc7RUFBQ2I7RUFBeUJ5QjtFQUFzQm9EO0NBQW1CO0FDdEovRCxTQUFTOEcsYUFBYTFDLE1BQWdCO0FBQzNDLE1BQUksQ0FBQ0EsUUFBUTJDLGNBQWMzQyxLQUFLRSxJQUFJLEtBQUt5QyxjQUFjM0MsS0FBS0MsTUFBTSxHQUFHO0FBQ25FLFdBQU87O0FBR1QsVUFBUUQsS0FBS0csUUFBUUgsS0FBS0csUUFBUSxNQUFNLE9BQ3JDSCxLQUFLSyxTQUFTTCxLQUFLSyxTQUFTLE1BQU0sTUFDbkNMLEtBQUtFLE9BQU8sUUFDWkYsS0FBS0M7QUFDVDtBQUtPLFNBQVMyQyxhQUNkcEMsS0FDQXFDLE1BQ0FDLElBQ0FDLFNBQ0FDLFFBQ0E7QUFDQSxNQUFJQyxZQUFZSixLQUFLRyxNQUFPO0FBQzVCLE1BQUksQ0FBQ0MsV0FBVztBQUNkQSxnQkFBWUosS0FBS0csTUFBTyxJQUFHeEMsSUFBSTBDLFlBQVlGLE1BQUFBLEVBQVFqRztBQUNuRCtGLE9BQUdLLEtBQUtILE1BQUFBOztBQUVWLE1BQUlDLFlBQVlGLFNBQVM7QUFDdkJBLGNBQVVFOztBQUVaLFNBQU9GO0FBQ1Q7QUFTTyxTQUFTSyxhQUNkNUMsS0FDQVIsTUFDQXFELGVBQ0FDLE9BQ0E7QUFDQUEsVUFBUUEsU0FBUyxDQUFBO0FBQ2pCLE1BQUlULE9BQU9TLE1BQU1ULE9BQU9TLE1BQU1ULFFBQVEsQ0FBQTtBQUN0QyxNQUFJQyxLQUFLUSxNQUFNQyxpQkFBaUJELE1BQU1DLGtCQUFrQixDQUFBO0FBRXhELE1BQUlELE1BQU10RCxTQUFTQSxNQUFNO0FBQ3ZCNkMsV0FBT1MsTUFBTVQsT0FBTyxDQUFBO0FBQ3BCQyxTQUFLUSxNQUFNQyxpQkFBaUIsQ0FBQTtBQUM1QkQsVUFBTXRELE9BQU9BOztBQUdmUSxNQUFJZ0QsS0FBSTtBQUVSaEQsTUFBSVIsT0FBT0E7QUFDWCxNQUFJK0MsVUFBVTtBQUNkLFFBQU1VLE9BQU9KLGNBQWM3STtBQUMzQixNQUFJcUUsSUFBVzZFLElBQVdDLE1BQWNDLE9BQXdCQztBQUNoRSxPQUFLaEYsS0FBSSxHQUFHQSxLQUFJNEUsTUFBTTVFLE1BQUs7QUFDekIrRSxZQUFRUCxjQUFjeEUsRUFBRTtBQUd4QixRQUFJK0UsVUFBVXpNLFVBQWF5TSxVQUFVLFFBQVEsQ0FBQzVKLFFBQVE0SixLQUFRLEdBQUE7QUFDNURiLGdCQUFVSCxhQUFhcEMsS0FBS3FDLE1BQU1DLElBQUlDLFNBQVNhLEtBQUFBO2VBQ3RDNUosUUFBUTRKLEtBQVEsR0FBQTtBQUd6QixXQUFLRixLQUFJLEdBQUdDLE9BQU9DLE1BQU1wSixRQUFRa0osS0FBSUMsTUFBTUQsTUFBSztBQUM5Q0csc0JBQWNELE1BQU1GLEVBQUU7QUFFdEIsWUFBSUcsZ0JBQWdCMU0sVUFBYTBNLGdCQUFnQixRQUFRLENBQUM3SixRQUFRNkosV0FBYyxHQUFBO0FBQzlFZCxvQkFBVUgsYUFBYXBDLEtBQUtxQyxNQUFNQyxJQUFJQyxTQUFTYyxXQUFBQTs7TUFFbkQ7O0VBRUo7QUFFQXJELE1BQUlzRCxRQUFPO0FBRVgsUUFBTUMsUUFBUWpCLEdBQUd0SSxTQUFTO0FBQzFCLE1BQUl1SixRQUFRVixjQUFjN0ksUUFBUTtBQUNoQyxTQUFLcUUsS0FBSSxHQUFHQSxLQUFJa0YsT0FBT2xGLE1BQUs7QUFDMUIsYUFBT2dFLEtBQUtDLEdBQUdqRSxFQUFBQSxDQUFFO0lBQ25CO0FBQ0FpRSxPQUFHa0IsT0FBTyxHQUFHRCxLQUFBQTs7QUFFZixTQUFPaEI7QUFDVDtBQVVPLFNBQVNrQixZQUFZNUosT0FBYzZKLE9BQWVuSCxPQUFlO0FBQ3RFLFFBQU0yQyxtQkFBbUJyRixNQUFNOEo7QUFDL0IsUUFBTUMsWUFBWXJILFVBQVUsSUFBSXZKLEtBQUtrSCxJQUFJcUMsUUFBUSxHQUFHLEdBQUEsSUFBTztBQUMzRCxTQUFPdkosS0FBSzZRLE9BQU9ILFFBQVFFLGFBQWExRSxnQkFBQUEsSUFBb0JBLG1CQUFtQjBFO0FBQ2pGO0FBS08sU0FBU0UsWUFBWUMsUUFBNEIvRCxLQUFnQztBQUN0RixNQUFJLENBQUNBLE9BQU8sQ0FBQytELFFBQVE7QUFDbkI7O0FBR0YvRCxRQUFNQSxPQUFPK0QsT0FBT0MsV0FBVyxJQUFBO0FBRS9CaEUsTUFBSWdELEtBQUk7QUFHUmhELE1BQUlpRSxlQUFjO0FBQ2xCakUsTUFBSWtFLFVBQVUsR0FBRyxHQUFHSCxPQUFPeEgsT0FBT3dILE9BQU9JLE1BQU07QUFDL0NuRSxNQUFJc0QsUUFBTztBQUNiO0FBU08sU0FBU2MsVUFDZHBFLEtBQ0FySCxTQUNBMEwsSUFDQUMsSUFDQTtBQUVBQyxrQkFBZ0J2RSxLQUFLckgsU0FBUzBMLElBQUdDLElBQUcsSUFBSTtBQUMxQztBQUdPLFNBQVNDLGdCQUNkdkUsS0FDQXJILFNBQ0EwTCxJQUNBQyxJQUNBRSxJQUNBO0FBQ0EsTUFBSTNPLE1BQWM0TyxTQUFpQkMsU0FBaUJoRixNQUFjaUYsY0FBc0JwSSxPQUFlcUksVUFBa0JDO0FBQ3pILFFBQU1sRixRQUFRaEgsUUFBUW1NO0FBQ3RCLFFBQU1DLFdBQVdwTSxRQUFRb007QUFDekIsUUFBTUMsU0FBU3JNLFFBQVFxTTtBQUN2QixNQUFJQyxPQUFPRixZQUFZLEtBQUtHO0FBRTVCLE1BQUl2RixTQUFTLE9BQU9BLFVBQVUsVUFBVTtBQUN0QzlKLFdBQU84SixNQUFNN0osU0FBUTtBQUNyQixRQUFJRCxTQUFTLCtCQUErQkEsU0FBUyw4QkFBOEI7QUFDakZtSyxVQUFJZ0QsS0FBSTtBQUNSaEQsVUFBSW1GLFVBQVVkLElBQUdDLEVBQUFBO0FBQ2pCdEUsVUFBSW9GLE9BQU9ILEdBQUFBO0FBQ1hqRixVQUFJcUYsVUFBVTFGLE9BQU8sQ0FBQ0EsTUFBTXBELFFBQVEsR0FBRyxDQUFDb0QsTUFBTXdFLFNBQVMsR0FBR3hFLE1BQU1wRCxPQUFPb0QsTUFBTXdFLE1BQU07QUFDbkZuRSxVQUFJc0QsUUFBTztBQUNYOzs7QUFJSixNQUFJOUksTUFBTXdLLE1BQVdBLEtBQUFBLFVBQVUsR0FBRztBQUNoQzs7QUFHRmhGLE1BQUlzRixVQUFTO0FBRWIsVUFBUTNGLE9BQUFBOztJQUVOO0FBQ0UsVUFBSTZFLElBQUc7QUFDTHhFLFlBQUl1RixRQUFRbEIsSUFBR0MsSUFBR0UsS0FBSSxHQUFHUSxRQUFRLEdBQUcsR0FBRzdSLEdBQUFBO2FBQ2xDO0FBQ0w2TSxZQUFJd0YsSUFBSW5CLElBQUdDLElBQUdVLFFBQVEsR0FBRzdSLEdBQUFBOztBQUUzQjZNLFVBQUl5RixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBQ0hsSixjQUFRaUksS0FBSUEsS0FBSSxJQUFJUTtBQUNwQmhGLFVBQUkwRixPQUFPckIsS0FBSXJSLEtBQUtFLElBQUkrUixHQUFPMUksSUFBQUEsT0FBTytILEtBQUl0UixLQUFLb0IsSUFBSTZRLEdBQU9ELElBQUFBLE1BQUFBO0FBQzFEQyxhQUFPVTtBQUNQM0YsVUFBSTRGLE9BQU92QixLQUFJclIsS0FBS0UsSUFBSStSLEdBQU8xSSxJQUFBQSxPQUFPK0gsS0FBSXRSLEtBQUtvQixJQUFJNlEsR0FBT0QsSUFBQUEsTUFBQUE7QUFDMURDLGFBQU9VO0FBQ1AzRixVQUFJNEYsT0FBT3ZCLEtBQUlyUixLQUFLRSxJQUFJK1IsR0FBTzFJLElBQUFBLE9BQU8rSCxLQUFJdFIsS0FBS29CLElBQUk2USxHQUFPRCxJQUFBQSxNQUFBQTtBQUMxRGhGLFVBQUl5RixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBUUhkLHFCQUFlSyxTQUFTO0FBQ3hCdEYsYUFBT3NGLFNBQVNMO0FBQ2hCRixnQkFBVXpSLEtBQUtvQixJQUFJNlEsTUFBTVksVUFBY25HLElBQUFBO0FBQ3ZDa0YsaUJBQVc1UixLQUFLb0IsSUFBSTZRLE1BQU1ZLFVBQUFBLEtBQWVyQixLQUFJQSxLQUFJLElBQUlHLGVBQWVqRjtBQUNwRWdGLGdCQUFVMVIsS0FBS0UsSUFBSStSLE1BQU1ZLFVBQWNuRyxJQUFBQTtBQUN2Q21GLGlCQUFXN1IsS0FBS0UsSUFBSStSLE1BQU1ZLFVBQUFBLEtBQWVyQixLQUFJQSxLQUFJLElBQUlHLGVBQWVqRjtBQUNwRU0sVUFBSXdGLElBQUluQixLQUFJTyxVQUFVTixLQUFJSSxTQUFTQyxjQUFjTSxNQUFNelEsSUFBSXlRLE1BQU01USxPQUFBQTtBQUNqRTJMLFVBQUl3RixJQUFJbkIsS0FBSVEsVUFBVVAsS0FBSUcsU0FBU0UsY0FBY00sTUFBTTVRLFNBQVM0USxHQUFBQTtBQUNoRWpGLFVBQUl3RixJQUFJbkIsS0FBSU8sVUFBVU4sS0FBSUksU0FBU0MsY0FBY00sS0FBS0EsTUFBTTVRLE9BQUFBO0FBQzVEMkwsVUFBSXdGLElBQUluQixLQUFJUSxVQUFVUCxLQUFJRyxTQUFTRSxjQUFjTSxNQUFNNVEsU0FBUzRRLE1BQU16USxFQUFBQTtBQUN0RXdMLFVBQUl5RixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBQ0gsVUFBSSxDQUFDVixVQUFVO0FBQ2JyRixlQUFPMU0sS0FBSzhTLFVBQVVkO0FBQ3RCekksZ0JBQVFpSSxLQUFJQSxLQUFJLElBQUk5RTtBQUNwQk0sWUFBSStGLEtBQUsxQixLQUFJOUgsT0FBTytILEtBQUk1RSxNQUFNLElBQUluRCxPQUFPLElBQUltRCxJQUFBQTtBQUM3Qzs7QUFFRnVGLGFBQU9ZOztJQUVULEtBQUs7QUFDSGpCLGlCQUFXNVIsS0FBS29CLElBQUk2USxHQUFBQSxLQUFRVCxLQUFJQSxLQUFJLElBQUlRO0FBQ3hDUCxnQkFBVXpSLEtBQUtvQixJQUFJNlEsR0FBT0QsSUFBQUE7QUFDMUJOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQU9ELElBQUFBO0FBQzFCSCxpQkFBVzdSLEtBQUtFLElBQUkrUixHQUFBQSxLQUFRVCxLQUFJQSxLQUFJLElBQUlRO0FBQ3hDaEYsVUFBSTBGLE9BQU9yQixLQUFJTyxVQUFVTixLQUFJSSxPQUFBQTtBQUM3QjFFLFVBQUk0RixPQUFPdkIsS0FBSVEsVUFBVVAsS0FBSUcsT0FBQUE7QUFDN0J6RSxVQUFJNEYsT0FBT3ZCLEtBQUlPLFVBQVVOLEtBQUlJLE9BQUFBO0FBQzdCMUUsVUFBSTRGLE9BQU92QixLQUFJUSxVQUFVUCxLQUFJRyxPQUFBQTtBQUM3QnpFLFVBQUl5RixVQUFTO0FBQ2I7SUFDRixLQUFLO0FBQ0hSLGFBQU9ZOztJQUVULEtBQUs7QUFDSGpCLGlCQUFXNVIsS0FBS29CLElBQUk2USxHQUFBQSxLQUFRVCxLQUFJQSxLQUFJLElBQUlRO0FBQ3hDUCxnQkFBVXpSLEtBQUtvQixJQUFJNlEsR0FBT0QsSUFBQUE7QUFDMUJOLGdCQUFVMVIsS0FBS0UsSUFBSStSLEdBQU9ELElBQUFBO0FBQzFCSCxpQkFBVzdSLEtBQUtFLElBQUkrUixHQUFBQSxLQUFRVCxLQUFJQSxLQUFJLElBQUlRO0FBQ3hDaEYsVUFBSTBGLE9BQU9yQixLQUFJTyxVQUFVTixLQUFJSSxPQUFBQTtBQUM3QjFFLFVBQUk0RixPQUFPdkIsS0FBSU8sVUFBVU4sS0FBSUksT0FBQUE7QUFDN0IxRSxVQUFJMEYsT0FBT3JCLEtBQUlRLFVBQVVQLEtBQUlHLE9BQUFBO0FBQzdCekUsVUFBSTRGLE9BQU92QixLQUFJUSxVQUFVUCxLQUFJRyxPQUFBQTtBQUM3QjtJQUNGLEtBQUs7QUFDSEcsaUJBQVc1UixLQUFLb0IsSUFBSTZRLEdBQUFBLEtBQVFULEtBQUlBLEtBQUksSUFBSVE7QUFDeENQLGdCQUFVelIsS0FBS29CLElBQUk2USxHQUFPRCxJQUFBQTtBQUMxQk4sZ0JBQVUxUixLQUFLRSxJQUFJK1IsR0FBT0QsSUFBQUE7QUFDMUJILGlCQUFXN1IsS0FBS0UsSUFBSStSLEdBQUFBLEtBQVFULEtBQUlBLEtBQUksSUFBSVE7QUFDeENoRixVQUFJMEYsT0FBT3JCLEtBQUlPLFVBQVVOLEtBQUlJLE9BQUFBO0FBQzdCMUUsVUFBSTRGLE9BQU92QixLQUFJTyxVQUFVTixLQUFJSSxPQUFBQTtBQUM3QjFFLFVBQUkwRixPQUFPckIsS0FBSVEsVUFBVVAsS0FBSUcsT0FBQUE7QUFDN0J6RSxVQUFJNEYsT0FBT3ZCLEtBQUlRLFVBQVVQLEtBQUlHLE9BQUFBO0FBQzdCUSxhQUFPWTtBQUNQakIsaUJBQVc1UixLQUFLb0IsSUFBSTZRLEdBQUFBLEtBQVFULEtBQUlBLEtBQUksSUFBSVE7QUFDeENQLGdCQUFVelIsS0FBS29CLElBQUk2USxHQUFPRCxJQUFBQTtBQUMxQk4sZ0JBQVUxUixLQUFLRSxJQUFJK1IsR0FBT0QsSUFBQUE7QUFDMUJILGlCQUFXN1IsS0FBS0UsSUFBSStSLEdBQUFBLEtBQVFULEtBQUlBLEtBQUksSUFBSVE7QUFDeENoRixVQUFJMEYsT0FBT3JCLEtBQUlPLFVBQVVOLEtBQUlJLE9BQUFBO0FBQzdCMUUsVUFBSTRGLE9BQU92QixLQUFJTyxVQUFVTixLQUFJSSxPQUFBQTtBQUM3QjFFLFVBQUkwRixPQUFPckIsS0FBSVEsVUFBVVAsS0FBSUcsT0FBQUE7QUFDN0J6RSxVQUFJNEYsT0FBT3ZCLEtBQUlRLFVBQVVQLEtBQUlHLE9BQUFBO0FBQzdCO0lBQ0YsS0FBSztBQUNIQSxnQkFBVUQsS0FBSUEsS0FBSSxJQUFJeFIsS0FBS29CLElBQUk2USxHQUFBQSxJQUFPRDtBQUN0Q04sZ0JBQVUxUixLQUFLRSxJQUFJK1IsR0FBT0QsSUFBQUE7QUFDMUJoRixVQUFJMEYsT0FBT3JCLEtBQUlJLFNBQVNILEtBQUlJLE9BQUFBO0FBQzVCMUUsVUFBSTRGLE9BQU92QixLQUFJSSxTQUFTSCxLQUFJSSxPQUFBQTtBQUM1QjtJQUNGLEtBQUs7QUFDSDFFLFVBQUkwRixPQUFPckIsSUFBR0MsRUFBQUE7QUFDZHRFLFVBQUk0RixPQUFPdkIsS0FBSXJSLEtBQUtvQixJQUFJNlEsR0FBQUEsS0FBUVQsS0FBSUEsS0FBSSxJQUFJUSxTQUFTVixLQUFJdFIsS0FBS0UsSUFBSStSLEdBQU9ELElBQUFBLE1BQUFBO0FBQ3pFO0lBQ0YsS0FBSztBQUNIaEYsVUFBSXlGLFVBQVM7QUFDYjtFQUNKO0FBRUF6RixNQUFJZ0csS0FBSTtBQUNSLE1BQUlyTixRQUFRc04sY0FBYyxHQUFHO0FBQzNCakcsUUFBSWtHLE9BQU07O0FBRWQ7QUFTTyxTQUFTQyxlQUNkQyxPQUNBQyxNQUNBQyxRQUNBO0FBQ0FBLFdBQVNBLFVBQVU7QUFFbkIsU0FBTyxDQUFDRCxRQUFTRCxTQUFTQSxNQUFNL0IsSUFBSWdDLEtBQUsvTixPQUFPZ08sVUFBVUYsTUFBTS9CLElBQUlnQyxLQUFLak8sUUFBUWtPLFVBQ2pGRixNQUFNOUIsSUFBSStCLEtBQUtsTyxNQUFNbU8sVUFBVUYsTUFBTTlCLElBQUkrQixLQUFLaE8sU0FBU2lPO0FBQ3pEO0FBRU8sU0FBU0MsU0FBU3ZHLEtBQStCcUcsTUFBWTtBQUNsRXJHLE1BQUlnRCxLQUFJO0FBQ1JoRCxNQUFJc0YsVUFBUztBQUNidEYsTUFBSStGLEtBQUtNLEtBQUsvTixNQUFNK04sS0FBS2xPLEtBQUtrTyxLQUFLak8sUUFBUWlPLEtBQUsvTixNQUFNK04sS0FBS2hPLFNBQVNnTyxLQUFLbE8sR0FBRztBQUM1RTZILE1BQUl0RSxLQUFJO0FBQ1Y7QUFFTyxTQUFTOEssV0FBV3hHLEtBQStCO0FBQ3hEQSxNQUFJc0QsUUFBTztBQUNiO0FBZ0RBLFNBQVNtRCxjQUFjQyxLQUErQkMsTUFBc0I7QUFDMUUsTUFBSUEsS0FBS0MsYUFBYTtBQUNwQkYsUUFBSUcsVUFBVUYsS0FBS0MsWUFBWSxDQUFBLEdBQUlELEtBQUtDLFlBQVksQ0FBRSxDQUFBOztBQUd4RCxNQUFJLENBQUNFLGNBQWNILEtBQUtJLFFBQVEsR0FBRztBQUNqQ0wsUUFBSU0sT0FBT0wsS0FBS0ksUUFBUTs7QUFHMUIsTUFBSUosS0FBS00sT0FBTztBQUNkUCxRQUFJUSxZQUFZUCxLQUFLTTs7QUFHdkIsTUFBSU4sS0FBS1EsV0FBVztBQUNsQlQsUUFBSVMsWUFBWVIsS0FBS1E7O0FBR3ZCLE1BQUlSLEtBQUtTLGNBQWM7QUFDckJWLFFBQUlVLGVBQWVULEtBQUtTOztBQUU1QjtBQUVBLFNBQVNDLGFBQ1BYLEtBQ0FZLElBQ0FDLElBQ0FDLE1BQ0FiLE1BQ0E7QUFDQSxNQUFJQSxLQUFLYyxpQkFBaUJkLEtBQUtlLFdBQVc7QUFReEMsVUFBTUMsVUFBVWpCLElBQUlrQixZQUFZSixJQUFBQTtBQUNoQyxVQUFNSyxPQUFPUCxLQUFJSyxRQUFRRztBQUN6QixVQUFNQyxRQUFRVCxLQUFJSyxRQUFRSztBQUMxQixVQUFNQyxNQUFNVixLQUFJSSxRQUFRTztBQUN4QixVQUFNQyxTQUFTWixLQUFJSSxRQUFRUztBQUMzQixVQUFNQyxjQUFjMUIsS0FBS2MsaUJBQWlCUSxNQUFNRSxVQUFVLElBQUlBO0FBRTlEekIsUUFBSTRCLGNBQWM1QixJQUFJUTtBQUN0QlIsUUFBSTZCLFVBQVM7QUFDYjdCLFFBQUk4QixZQUFZN0IsS0FBSzhCLG1CQUFtQjtBQUN4Qy9CLFFBQUlnQyxPQUFPYixNQUFNUSxXQUFBQTtBQUNqQjNCLFFBQUlpQyxPQUFPWixPQUFPTSxXQUFBQTtBQUNsQjNCLFFBQUlrQyxPQUFNOztBQUVkO0FBRUEsU0FBU0MsYUFBYW5DLEtBQStCQyxNQUF1QjtBQUMxRSxRQUFNbUMsV0FBV3BDLElBQUlRO0FBRXJCUixNQUFJUSxZQUFZUCxLQUFLTTtBQUNyQlAsTUFBSXFDLFNBQVNwQyxLQUFLa0IsTUFBTWxCLEtBQUtzQixLQUFLdEIsS0FBS3FDLE9BQU9yQyxLQUFLc0MsTUFBTTtBQUN6RHZDLE1BQUlRLFlBQVk0QjtBQUNsQjtBQUtPLFNBQVNJLFdBQ2R4QyxLQUNBeUMsTUFDQTdCLElBQ0FDLElBQ0E2QixNQUNBekMsT0FBdUIsQ0FBQSxHQUN2QjtBQUNBLFFBQU0wQyxRQUFRQyxRQUFRSCxJQUFBQSxJQUFRQSxPQUFPO0lBQUNBO0VBQUs7QUFDM0MsUUFBTVAsU0FBU2pDLEtBQUs0QyxjQUFjLEtBQUs1QyxLQUFLNkMsZ0JBQWdCO0FBQzVELE1BQUlDLElBQVdqQztBQUVmZCxNQUFJZ0QsS0FBSTtBQUNSaEQsTUFBSTBDLE9BQU9BLEtBQUtPO0FBQ2hCbEQsZ0JBQWNDLEtBQUtDLElBQUFBO0FBRW5CLE9BQUs4QyxLQUFJLEdBQUdBLEtBQUlKLE1BQU1PLFFBQVEsRUFBRUgsSUFBRztBQUNqQ2pDLFdBQU82QixNQUFNSSxFQUFFO0FBRWYsUUFBSTlDLEtBQUtrRCxVQUFVO0FBQ2pCaEIsbUJBQWFuQyxLQUFLQyxLQUFLa0QsUUFBUTs7QUFHakMsUUFBSWpCLFFBQVE7QUFDVixVQUFJakMsS0FBSzZDLGFBQWE7QUFDcEI5QyxZQUFJNEIsY0FBYzNCLEtBQUs2Qzs7QUFHekIsVUFBSSxDQUFDMUMsY0FBY0gsS0FBSzRDLFdBQVcsR0FBRztBQUNwQzdDLFlBQUk4QixZQUFZN0IsS0FBSzRDOztBQUd2QjdDLFVBQUlvRCxXQUFXdEMsTUFBTUYsSUFBR0MsSUFBR1osS0FBS29ELFFBQVE7O0FBRzFDckQsUUFBSXNELFNBQVN4QyxNQUFNRixJQUFHQyxJQUFHWixLQUFLb0QsUUFBUTtBQUN0QzFDLGlCQUFhWCxLQUFLWSxJQUFHQyxJQUFHQyxNQUFNYixJQUFBQTtBQUU5QlksSUFBQUEsTUFBSzBDLE9BQU9iLEtBQUtjLFVBQVU7RUFDN0I7QUFFQXhELE1BQUl5RCxRQUFPO0FBQ2I7QUFPTyxTQUFTQyxtQkFDZDFELEtBQ0EyRCxNQUNBO0FBQ0EsUUFBTSxFQUFDL0MsR0FBQUEsSUFBR0MsR0FBQUEsSUFBRytDLEdBQUFBLElBQUdDLEdBQUFBLElBQUdDLE9BQU0sSUFBSUg7QUFHN0IzRCxNQUFJK0QsSUFBSW5ELEtBQUlrRCxPQUFPRSxTQUFTbkQsS0FBSWlELE9BQU9FLFNBQVNGLE9BQU9FLFNBQVMsTUFBTUMsSUFBSUEsSUFBSSxJQUFJO0FBR2xGakUsTUFBSWlDLE9BQU9yQixJQUFHQyxLQUFJZ0QsS0FBSUMsT0FBT0ksVUFBVTtBQUd2Q2xFLE1BQUkrRCxJQUFJbkQsS0FBSWtELE9BQU9JLFlBQVlyRCxLQUFJZ0QsS0FBSUMsT0FBT0ksWUFBWUosT0FBT0ksWUFBWUQsSUFBSUUsU0FBUyxJQUFJO0FBRzlGbkUsTUFBSWlDLE9BQU9yQixLQUFJZ0QsS0FBSUUsT0FBT00sYUFBYXZELEtBQUlnRCxFQUFBQTtBQUczQzdELE1BQUkrRCxJQUFJbkQsS0FBSWdELEtBQUlFLE9BQU9NLGFBQWF2RCxLQUFJZ0QsS0FBSUMsT0FBT00sYUFBYU4sT0FBT00sYUFBYUQsU0FBUyxHQUFHLElBQUk7QUFHcEduRSxNQUFJaUMsT0FBT3JCLEtBQUlnRCxJQUFHL0MsS0FBSWlELE9BQU9PLFFBQVE7QUFHckNyRSxNQUFJK0QsSUFBSW5ELEtBQUlnRCxLQUFJRSxPQUFPTyxVQUFVeEQsS0FBSWlELE9BQU9PLFVBQVVQLE9BQU9PLFVBQVUsR0FBRyxDQUFDRixTQUFTLElBQUk7QUFHeEZuRSxNQUFJaUMsT0FBT3JCLEtBQUlrRCxPQUFPRSxTQUFTbkQsRUFBQUE7QUFDakM7QUN4Z0JBLElBQU15RCxjQUFjO0FBQ3BCLElBQU1DLGFBQWE7QUFjWixTQUFTQyxhQUFhQyxPQUF3QkMsTUFBc0I7QUFDekUsUUFBTUMsV0FBVyxLQUFLRixPQUFPRyxNQUFNTixXQUFBQTtBQUNuQyxNQUFJLENBQUNLLFdBQVdBLFFBQVEsQ0FBQSxNQUFPLFVBQVU7QUFDdkMsV0FBT0QsT0FBTzs7QUFHaEJELFVBQVEsQ0FBQ0UsUUFBUSxDQUFFO0FBRW5CLFVBQVFBLFFBQVEsQ0FBRSxHQUFBO0lBQ2hCLEtBQUs7QUFDSCxhQUFPRjtJQUNULEtBQUs7QUFDSEEsZUFBUztBQUNUO0VBR0o7QUFFQSxTQUFPQyxPQUFPRDtBQUNoQjtBQUVBLElBQU1JLGVBQWUsQ0FBQ0MsT0FBZSxDQUFDQSxNQUFLO0FBUXBDLFNBQVNDLGtCQUFrQk4sT0FBd0NPLE9BQTBDO0FBQ2xILFFBQU1DLE1BQU0sQ0FBQTtBQUNaLFFBQU1DLFdBQVdDLFNBQVNILEtBQUFBO0FBQzFCLFFBQU1JLE9BQU9GLFdBQVdHLE9BQU9ELEtBQUtKLEtBQUFBLElBQVNBO0FBQzdDLFFBQU1NLE9BQU9ILFNBQVNWLEtBQUFBLElBQ2xCUyxXQUNFSyxDQUFBQSxTQUFRQyxlQUFlZixNQUFNYyxJQUFBQSxHQUFPZCxNQUFNTyxNQUFNTyxJQUFLLENBQUEsQ0FBQyxJQUN0REEsQ0FBQUEsU0FBUWQsTUFBTWMsSUFBQUEsSUFDaEIsTUFBTWQ7QUFFVixhQUFXYyxRQUFRSCxNQUFNO0FBQ3ZCSCxRQUFJTSxJQUFBQSxJQUFRVixhQUFhUyxLQUFLQyxJQUFBQSxDQUFBQTtFQUNoQztBQUNBLFNBQU9OO0FBQ1Q7QUFVTyxTQUFTUSxPQUFPaEIsT0FBOEI7QUFDbkQsU0FBT00sa0JBQWtCTixPQUFPO0lBQUNsRCxLQUFLO0lBQUtGLE9BQU87SUFBS0ksUUFBUTtJQUFLTixNQUFNO0VBQUcsQ0FBQTtBQUMvRTtBQVNPLFNBQVN1RSxjQUFjakIsT0FBNkI7QUFDekQsU0FBT00sa0JBQWtCTixPQUFPO0lBQUM7SUFBVztJQUFZO0lBQWM7RUFBYyxDQUFBO0FBQ3RGO0FBVU8sU0FBU2tCLFVBQVVsQixPQUFrQztBQUMxRCxRQUFNbUIsTUFBTUgsT0FBT2hCLEtBQUFBO0FBRW5CbUIsTUFBSXRELFFBQVFzRCxJQUFJekUsT0FBT3lFLElBQUl2RTtBQUMzQnVFLE1BQUlyRCxTQUFTcUQsSUFBSXJFLE1BQU1xRSxJQUFJbkU7QUFFM0IsU0FBT21FO0FBQ1Q7QUFVTyxTQUFTQyxPQUFPQyxTQUE0QkMsVUFBOEI7QUFDL0VELFlBQVVBLFdBQVcsQ0FBQTtBQUNyQkMsYUFBV0EsWUFBWUMsVUFBU3REO0FBRWhDLE1BQUlnQyxPQUFPYyxlQUFlTSxRQUFRcEIsTUFBTXFCLFNBQVNyQixJQUFJO0FBRXJELE1BQUksT0FBT0EsU0FBUyxVQUFVO0FBQzVCQSxXQUFPdUIsU0FBU3ZCLE1BQU0sRUFBQTs7QUFFeEIsTUFBSXdCLFFBQVFWLGVBQWVNLFFBQVFJLE9BQU9ILFNBQVNHLEtBQUs7QUFDeEQsTUFBSUEsU0FBUyxFQUFFLEtBQUtBLE9BQU90QixNQUFNTCxVQUFhLEdBQUE7QUFDNUM0QixZQUFRQyxLQUFLLG9DQUFvQ0YsUUFBUSxHQUFBO0FBQ3pEQSxZQUFRRzs7QUFHVixRQUFNM0QsT0FBTztJQUNYNEQsUUFBUWQsZUFBZU0sUUFBUVEsUUFBUVAsU0FBU08sTUFBTTtJQUN0RDlDLFlBQVlnQixhQUFhZ0IsZUFBZU0sUUFBUXRDLFlBQVl1QyxTQUFTdkMsVUFBVSxHQUFHa0IsSUFBQUE7SUFDbEZBO0lBQ0F3QjtJQUNBSyxRQUFRZixlQUFlTSxRQUFRUyxRQUFRUixTQUFTUSxNQUFNO0lBQ3REdEQsUUFBUTtFQUNWO0FBRUFQLE9BQUtPLFNBQVN1RCxhQUFhOUQsSUFBQUE7QUFDM0IsU0FBT0E7QUFDVDtBQWFPLFNBQVMrRCxRQUFRQyxRQUF3QkMsU0FBa0JDLE9BQWdCQyxNQUErQjtBQUMvRyxNQUFJQyxZQUFZO0FBQ2hCLE1BQUkvRCxJQUFXZ0UsTUFBY3RDO0FBRTdCLE9BQUsxQixLQUFJLEdBQUdnRSxPQUFPTCxPQUFPeEQsUUFBUUgsS0FBSWdFLE1BQU0sRUFBRWhFLElBQUc7QUFDL0MwQixZQUFRaUMsT0FBTzNELEVBQUU7QUFDakIsUUFBSTBCLFVBQVU0QixRQUFXO0FBQ3ZCOztBQUVGLFFBQUlNLFlBQVlOLFVBQWEsT0FBTzVCLFVBQVUsWUFBWTtBQUN4REEsY0FBUUEsTUFBTWtDLE9BQUFBO0FBQ2RHLGtCQUFZOztBQUVkLFFBQUlGLFVBQVVQLFVBQWF6RCxRQUFRNkIsS0FBUSxHQUFBO0FBQ3pDQSxjQUFRQSxNQUFNbUMsUUFBUW5DLE1BQU12QixNQUFNO0FBQ2xDNEQsa0JBQVk7O0FBRWQsUUFBSXJDLFVBQVU0QixRQUFXO0FBQ3ZCLFVBQUlRLFFBQVEsQ0FBQ0MsV0FBVztBQUN0QkQsYUFBS0MsWUFBWTs7QUFFbkIsYUFBT3JDOztFQUVYO0FBQ0Y7QUFRTyxTQUFTdUMsVUFBVUMsUUFBdUNDLE9BQXdCQyxhQUFzQjtBQUM3RyxRQUFNLEVBQUNDLEtBQUtDLElBQUFBLElBQU9KO0FBQ25CLFFBQU1LLFNBQVNDLFlBQVlMLFFBQVFHLE1BQU1ELE9BQU8sQ0FBQTtBQUNoRCxRQUFNSSxXQUFXLENBQUMvQyxPQUFlZ0QsUUFBZ0JOLGVBQWUxQyxVQUFVLElBQUksSUFBSUEsUUFBUWdEO0FBQzFGLFNBQU87SUFDTEwsS0FBS0ksU0FBU0osS0FBSyxDQUFDTSxLQUFLQyxJQUFJTCxNQUFBQSxDQUFBQTtJQUM3QkQsS0FBS0csU0FBU0gsS0FBS0MsTUFBQUE7RUFDckI7QUFDRjtBQVVPLFNBQVNNLGNBQWNDLGVBQXVCbEIsU0FBaUI7QUFDcEUsU0FBT3RCLE9BQU95QyxPQUFPekMsT0FBTzBDLE9BQU9GLGFBQWdCbEIsR0FBQUEsT0FBQUE7QUFDckQ7QUNuTE8sU0FBU3FCLGdCQUlkQyxRQUNBQyxXQUFXO0VBQUM7R0FDWkMsWUFDQXBDLFVBQ0FxQyxZQUFZLE1BQU1ILE9BQU8sQ0FBQSxHQUN6QjtBQUNBLFFBQU1JLGtCQUFrQkYsY0FBY0Y7QUFDdEMsTUFBSSxPQUFPbEMsYUFBYSxhQUFhO0FBQ25DQSxlQUFXdUMsU0FBUyxhQUFhTCxNQUFBQTs7QUFFbkMsUUFBTU0sUUFBNkI7SUFDakMsQ0FBQ0MsT0FBT0MsV0FBVyxHQUFHO0lBQ3RCQyxZQUFZO0lBQ1pDLFNBQVNWO0lBQ1RXLGFBQWFQO0lBQ2JRLFdBQVc5QztJQUNYK0MsWUFBWVY7SUFDWlcsVUFBVSxDQUFDQyxVQUFxQmhCLGdCQUFnQjtNQUFDZ0I7TUFBVWYsR0FBQUE7SUFBTyxHQUFFQyxVQUFVRyxpQkFBaUJ0QyxRQUFBQTtFQUNqRztBQUNBLFNBQU8sSUFBSWtELE1BQU1WLE9BQU87Ozs7SUFJdEJXLGVBQWVDLFFBQVE1RCxNQUFjO0FBQ25DLGFBQU80RCxPQUFPNUQsSUFBSztBQUNuQixhQUFPNEQsT0FBT0M7QUFDZCxhQUFPbkIsT0FBTyxDQUFBLEVBQUcxQyxJQUFBQTtBQUNqQixhQUFPO0lBQ1Q7Ozs7SUFLQThELElBQUlGLFFBQVE1RCxNQUFjO0FBQ3hCLGFBQU8rRCxRQUFRSCxRQUFRNUQsTUFDckIsTUFBTWdFLHFCQUFxQmhFLE1BQU0yQyxVQUFVRCxRQUFRa0IsTUFBQUEsQ0FBQUE7SUFDdkQ7Ozs7O0lBTUFLLHlCQUF5QkwsUUFBUTVELE1BQU07QUFDckMsYUFBT2tFLFFBQVFELHlCQUF5QkwsT0FBT1IsUUFBUSxDQUFBLEdBQUlwRCxJQUFBQTtJQUM3RDs7OztJQUtBbUUsaUJBQWlCO0FBQ2YsYUFBT0QsUUFBUUMsZUFBZXpCLE9BQU8sQ0FBRSxDQUFBO0lBQ3pDOzs7O0lBS0EwQixJQUFJUixRQUFRNUQsTUFBYztBQUN4QixhQUFPcUUscUJBQXFCVCxNQUFRVSxFQUFBQSxTQUFTdEUsSUFBQUE7SUFDL0M7Ozs7SUFLQXVFLFFBQVFYLFFBQVE7QUFDZCxhQUFPUyxxQkFBcUJULE1BQUFBO0lBQzlCOzs7O0lBS0FZLElBQUlaLFFBQVE1RCxNQUFjZCxPQUFPO0FBQy9CLFlBQU11RixVQUFVYixPQUFPYyxhQUFhZCxPQUFPYyxXQUFXN0IsVUFBVTtBQUNoRWUsYUFBTzVELElBQUFBLElBQVF5RSxRQUFRekUsSUFBSyxJQUFHZDtBQUMvQixhQUFPMEUsT0FBT0M7QUFDZCxhQUFPO0lBQ1Q7RUFDRixDQUFBO0FBQ0Y7QUFVTyxTQUFTYyxlQUlkQyxPQUNBeEQsU0FDQXlELFVBQ0FDLG9CQUNBO0FBQ0EsUUFBTTlCLFFBQTRCO0lBQ2hDRyxZQUFZO0lBQ1o0QixRQUFRSDtJQUNSSSxVQUFVNUQ7SUFDVjZELFdBQVdKO0lBQ1hLLFFBQVEsb0JBQUlDLElBQUFBO0lBQ1pDLGNBQWNBLGFBQWFSLE9BQU9FLGtCQUFBQTtJQUNsQ08sWUFBWSxDQUFDNUssUUFBbUJrSyxlQUFlQyxPQUFPbkssS0FBS29LLFVBQVVDLGtCQUFBQTtJQUNyRXRCLFVBQVUsQ0FBQ0MsVUFBcUJrQixlQUFlQyxNQUFNcEIsU0FBU0MsS0FBQUEsR0FBUXJDLFNBQVN5RCxVQUFVQyxrQkFBQUE7RUFDM0Y7QUFDQSxTQUFPLElBQUlwQixNQUFNVixPQUFPOzs7O0lBSXRCVyxlQUFlQyxRQUFRNUQsTUFBTTtBQUMzQixhQUFPNEQsT0FBTzVELElBQUs7QUFDbkIsYUFBTzRFLE1BQU01RSxJQUFLO0FBQ2xCLGFBQU87SUFDVDs7OztJQUtBOEQsSUFBSUYsUUFBUTVELE1BQWNzRixVQUFVO0FBQ2xDLGFBQU92QixRQUFRSCxRQUFRNUQsTUFDckIsTUFBTXVGLG9CQUFvQjNCLFFBQVE1RCxNQUFNc0YsUUFBQUEsQ0FBQUE7SUFDNUM7Ozs7O0lBTUFyQix5QkFBeUJMLFFBQVE1RCxNQUFNO0FBQ3JDLGFBQU80RCxPQUFPd0IsYUFBYUksVUFDdkJ0QixRQUFRRSxJQUFJUSxPQUFPNUUsSUFBUSxJQUFBO1FBQUN5RixZQUFZO1FBQU1DLGNBQWM7TUFBSSxJQUFJNUUsU0FDcEVvRCxRQUFRRCx5QkFBeUJXLE9BQU81RSxJQUFLO0lBQ25EOzs7O0lBS0FtRSxpQkFBaUI7QUFDZixhQUFPRCxRQUFRQyxlQUFlUyxLQUFBQTtJQUNoQzs7OztJQUtBUixJQUFJUixRQUFRNUQsTUFBTTtBQUNoQixhQUFPa0UsUUFBUUUsSUFBSVEsT0FBTzVFLElBQUFBO0lBQzVCOzs7O0lBS0F1RSxVQUFVO0FBQ1IsYUFBT0wsUUFBUUssUUFBUUssS0FBQUE7SUFDekI7Ozs7SUFLQUosSUFBSVosUUFBUTVELE1BQU1kLE9BQU87QUFDdkIwRixZQUFNNUUsSUFBQUEsSUFBUWQ7QUFDZCxhQUFPMEUsT0FBTzVELElBQUs7QUFDbkIsYUFBTztJQUNUO0VBQ0YsQ0FBQTtBQUNGO0FBS08sU0FBU29GLGFBQ2RSLE9BQ0FuRSxZQUErQjtFQUFDa0YsWUFBWTtFQUFNQyxXQUFXO0FBQUksR0FDckQ7QUFDWixRQUFNLEVBQUNDLGNBQWNwRixVQUFTa0YsWUFBWUcsYUFBYXJGLFVBQVNtRixXQUFXRyxXQUFXdEYsVUFBUytFLFFBQU8sSUFBSVo7QUFDMUcsU0FBTztJQUNMWSxTQUFTTztJQUNUSixZQUFZRTtJQUNaRCxXQUFXRTtJQUNYRSxjQUFjQyxXQUFXSixXQUFBQSxJQUFlQSxjQUFjLE1BQU1BO0lBQzVESyxhQUFhRCxXQUFXSCxVQUFBQSxJQUFjQSxhQUFhLE1BQU1BO0VBQzNEO0FBQ0Y7QUFFQSxJQUFNSyxVQUFVLENBQUNDLFFBQWdCQyxTQUFpQkQsU0FBU0EsU0FBU0UsWUFBWUQsSUFBQUEsSUFBUUE7QUFDeEYsSUFBTUUsbUJBQW1CLENBQUN2RyxNQUFjZCxVQUFtQlUsU0FBU1YsS0FBQUEsS0FBVWMsU0FBUyxlQUNwRkYsT0FBT3FFLGVBQWVqRixLQUFXLE1BQUEsUUFBUUEsTUFBTXNILGdCQUFnQjFHO0FBRWxFLFNBQVNpRSxRQUNQSCxRQUNBNUQsTUFDQWtCLFVBQ0E7QUFDQSxNQUFJcEIsT0FBTzJHLFVBQVVDLGVBQWVDLEtBQUsvQyxRQUFRNUQsSUFBU0EsS0FBQUEsU0FBUyxlQUFlO0FBQ2hGLFdBQU80RCxPQUFPNUQsSUFBSzs7QUFHckIsUUFBTWQsUUFBUWdDLFNBQUFBO0FBRWQwQyxTQUFPNUQsSUFBQUEsSUFBUWQ7QUFDZixTQUFPQTtBQUNUO0FBRUEsU0FBU3FHLG9CQUNQM0IsUUFDQTVELE1BQ0FzRixVQUNBO0FBQ0EsUUFBTSxFQUFDUCxRQUFRQyxVQUFVQyxXQUFXRyxjQUFjd0IsYUFBVyxJQUFJaEQ7QUFDakUsTUFBSTFFLFFBQVE2RixPQUFPL0UsSUFBQUE7QUFHbkIsTUFBSWlHLFdBQVcvRyxLQUFBQSxLQUFVMEgsYUFBWVosYUFBYWhHLElBQU8sR0FBQTtBQUN2RGQsWUFBUTJILG1CQUFtQjdHLE1BQU1kLE9BQU8wRSxRQUFRMEIsUUFBQUE7O0FBRWxELE1BQUlqSSxRQUFRNkIsS0FBQUEsS0FBVUEsTUFBTXZCLFFBQVE7QUFDbEN1QixZQUFRNEgsY0FBYzlHLE1BQU1kLE9BQU8wRSxRQUFRZ0QsYUFBWVYsV0FBVzs7QUFFcEUsTUFBSUssaUJBQWlCdkcsTUFBTWQsS0FBUSxHQUFBO0FBRWpDQSxZQUFReUYsZUFBZXpGLE9BQU84RixVQUFVQyxhQUFhQSxVQUFVakYsSUFBQUEsR0FBTzRHLFlBQUFBOztBQUV4RSxTQUFPMUg7QUFDVDtBQUVBLFNBQVMySCxtQkFDUDdHLE1BQ0ErRyxVQUNBbkQsUUFDQTBCLFVBQ0E7QUFDQSxRQUFNLEVBQUNQLFFBQVFDLFVBQVVDLFdBQVdDLE9BQU0sSUFBSXRCO0FBQzlDLE1BQUlzQixPQUFPZCxJQUFJcEUsSUFBTyxHQUFBO0FBQ3BCLFVBQU0sSUFBSWdILE1BQU0seUJBQXlCQyxNQUFNQyxLQUFLaEMsTUFBQUEsRUFBUWlDLEtBQUssSUFBUSxJQUFBLE9BQU9uSCxJQUFNOztBQUV4RmtGLFNBQU9oRCxJQUFJbEMsSUFBQUE7QUFDWCxNQUFJZCxRQUFRNkgsU0FBUy9CLFVBQVVDLGFBQWFLLFFBQUFBO0FBQzVDSixTQUFPa0MsT0FBT3BILElBQUFBO0FBQ2QsTUFBSXVHLGlCQUFpQnZHLE1BQU1kLEtBQVEsR0FBQTtBQUVqQ0EsWUFBUW1JLGtCQUFrQnRDLE9BQU8zQixTQUFTMkIsUUFBUS9FLE1BQU1kLEtBQUFBOztBQUUxRCxTQUFPQTtBQUNUO0FBRUEsU0FBUzRILGNBQ1A5RyxNQUNBZCxPQUNBMEUsUUFDQXNDLGFBQ0E7QUFDQSxRQUFNLEVBQUNuQixRQUFRQyxVQUFVQyxXQUFXRyxjQUFjd0IsYUFBVyxJQUFJaEQ7QUFFakUsTUFBSSxPQUFPb0IsU0FBUzNELFVBQVUsZUFBZTZFLFlBQVlsRyxJQUFPLEdBQUE7QUFDOUQsV0FBT2QsTUFBTThGLFNBQVMzRCxRQUFRbkMsTUFBTXZCLE1BQU07RUFDNUMsV0FBV2lDLFNBQVNWLE1BQU0sQ0FBQSxDQUFFLEdBQUc7QUFFN0IsVUFBTW9JLE1BQU1wSTtBQUNaLFVBQU13RCxTQUFTcUMsT0FBTzNCLFFBQVFtRSxPQUFPQyxDQUFBQSxPQUFLQSxPQUFNRixHQUFBQTtBQUNoRHBJLFlBQVEsQ0FBQTtBQUNSLGVBQVd1SSxRQUFRSCxLQUFLO0FBQ3RCLFlBQU1JLFdBQVdMLGtCQUFrQjNFLFFBQVFxQyxRQUFRL0UsTUFBTXlILElBQUFBO0FBQ3pEdkksWUFBTXlJLEtBQUtoRCxlQUFlK0MsVUFBVTFDLFVBQVVDLGFBQWFBLFVBQVVqRixJQUFBQSxHQUFPNEcsWUFBQUEsQ0FBQUE7SUFDOUU7O0FBRUYsU0FBTzFIO0FBQ1Q7QUFFQSxTQUFTMEksZ0JBQ1BwSCxVQUNBUixNQUNBZCxPQUNBO0FBQ0EsU0FBTytHLFdBQVd6RixRQUFBQSxJQUFZQSxTQUFTUixNQUFNZCxLQUFBQSxJQUFTc0I7QUFDeEQ7QUFFQSxJQUFNcUgsV0FBVyxDQUFDQyxLQUF3QkMsV0FBc0JELFFBQVEsT0FBT0MsU0FDM0UsT0FBT0QsUUFBUSxXQUFXRSxpQkFBaUJELFFBQVFELEdBQUFBLElBQU9oSDtBQUU5RCxTQUFTbUgsVUFDUHpELE1BQ0EwRCxjQUNBSixLQUNBSyxnQkFDQWpKLE9BQ0E7QUFDQSxhQUFXNkksVUFBVUcsY0FBYztBQUNqQyxVQUFNekUsUUFBUW9FLFNBQVNDLEtBQUtDLE1BQUFBO0FBQzVCLFFBQUl0RSxPQUFPO0FBQ1RlLE1BQUFBLEtBQUl0QyxJQUFJdUIsS0FBQUE7QUFDUixZQUFNakQsV0FBV29ILGdCQUFnQm5FLE1BQU1ILFdBQVd3RSxLQUFLNUksS0FBQUE7QUFDdkQsVUFBSSxPQUFPc0IsYUFBYSxlQUFlQSxhQUFhc0gsT0FBT3RILGFBQWEySCxnQkFBZ0I7QUFHdEYsZUFBTzNIOztlQUVBaUQsVUFBVSxTQUFTLE9BQU8wRSxtQkFBbUIsZUFBZUwsUUFBUUssZ0JBQWdCO0FBRzdGLGFBQU87O0VBRVg7QUFDQSxTQUFPO0FBQ1Q7QUFFQSxTQUFTZCxrQkFDUGEsY0FDQVIsVUFDQTFILE1BQ0FkLE9BQ0E7QUFDQSxRQUFNMEQsYUFBYThFLFNBQVNyRTtBQUM1QixRQUFNN0MsV0FBV29ILGdCQUFnQkYsU0FBU3BFLFdBQVd0RCxNQUFNZCxLQUFBQTtBQUMzRCxRQUFNa0osWUFBWTtJQUFJRixHQUFBQTtJQUFpQnRGLEdBQUFBO0VBQVc7QUFDbEQsUUFBTTRCLE9BQU0sb0JBQUlXLElBQUFBO0FBQ2hCWCxFQUFBQSxLQUFJdEMsSUFBSWhELEtBQUFBO0FBQ1IsTUFBSTRJLE1BQU1PLGlCQUFpQjdELE1BQUs0RCxXQUFXcEksTUFBTVEsWUFBWVIsTUFBTWQsS0FBQUE7QUFDbkUsTUFBSTRJLFFBQVEsTUFBTTtBQUNoQixXQUFPOztBQUVULE1BQUksT0FBT3RILGFBQWEsZUFBZUEsYUFBYVIsTUFBTTtBQUN4RDhILFVBQU1PLGlCQUFpQjdELE1BQUs0RCxXQUFXNUgsVUFBVXNILEtBQUs1SSxLQUFBQTtBQUN0RCxRQUFJNEksUUFBUSxNQUFNO0FBQ2hCLGFBQU87OztBQUdYLFNBQU9yRixnQkFBZ0J3RSxNQUFNQyxLQUFLMUMsSUFBTSxHQUFBO0lBQUM7RUFBRyxHQUFFNUIsWUFBWXBDLFVBQ3hELE1BQU04SCxhQUFhWixVQUFVMUgsTUFBZ0JkLEtBQUFBLENBQUFBO0FBQ2pEO0FBRUEsU0FBU21KLGlCQUNQN0QsTUFDQTRELFdBQ0FOLEtBQ0F0SCxVQUNBaUgsTUFDQTtBQUNBLFNBQU9LLEtBQUs7QUFDVkEsVUFBTUcsVUFBVXpELE1BQUs0RCxXQUFXTixLQUFLdEgsVUFBVWlILElBQUFBO0VBQ2pEO0FBQ0EsU0FBT0s7QUFDVDtBQUVBLFNBQVNRLGFBQ1BaLFVBQ0ExSCxNQUNBZCxPQUNBO0FBQ0EsUUFBTTZJLFNBQVNMLFNBQVNuRSxXQUFVO0FBQ2xDLE1BQUksRUFBRXZELFFBQVErSCxTQUFTO0FBQ3JCQSxXQUFPL0gsSUFBSyxJQUFHLENBQUE7O0FBRWpCLFFBQU00RCxTQUFTbUUsT0FBTy9ILElBQUs7QUFDM0IsTUFBSTNDLFFBQVF1RyxNQUFXaEUsS0FBQUEsU0FBU1YsS0FBUSxHQUFBO0FBRXRDLFdBQU9BOztBQUVULFNBQU8wRSxVQUFVLENBQUE7QUFDbkI7QUFFQSxTQUFTSSxxQkFDUGhFLE1BQ0EyQyxVQUNBRCxRQUNBa0MsT0FDQTtBQUNBLE1BQUkxRjtBQUNKLGFBQVdrSCxVQUFVekQsVUFBVTtBQUM3QnpELFlBQVE2RCxTQUFTb0QsUUFBUUMsUUFBUXBHLElBQU8wQyxHQUFBQSxNQUFBQTtBQUN4QyxRQUFJLE9BQU94RCxVQUFVLGFBQWE7QUFDaEMsYUFBT3FILGlCQUFpQnZHLE1BQU1kLEtBQzFCbUksSUFBQUEsa0JBQWtCM0UsUUFBUWtDLE9BQU81RSxNQUFNZCxLQUFBQSxJQUN2Q0E7O0VBRVI7QUFDRjtBQUVBLFNBQVM2RCxTQUFTK0UsS0FBYXBGLFFBQXFCO0FBQ2xELGFBQVdlLFNBQVNmLFFBQVE7QUFDMUIsUUFBSSxDQUFDZSxPQUFPO0FBQ1Y7O0FBRUYsVUFBTXZFLFFBQVF1RSxNQUFNcUUsR0FBSTtBQUN4QixRQUFJLE9BQU81SSxVQUFVLGFBQWE7QUFDaEMsYUFBT0E7O0VBRVg7QUFDRjtBQUVBLFNBQVNtRixxQkFBcUJULFFBQXVCO0FBQ25ELE1BQUkvRCxPQUFPK0QsT0FBT0M7QUFDbEIsTUFBSSxDQUFDaEUsTUFBTTtBQUNUQSxXQUFPK0QsT0FBT0MsUUFBUTBFLHlCQUF5QjNFLE9BQU9SLE9BQU87O0FBRS9ELFNBQU92RDtBQUNUO0FBRUEsU0FBUzBJLHlCQUF5QjdGLFFBQXFCO0FBQ3JELFFBQU04QixPQUFNLG9CQUFJVyxJQUFBQTtBQUNoQixhQUFXMUIsU0FBU2YsUUFBUTtBQUMxQixlQUFXb0YsT0FBT2hJLE9BQU9ELEtBQUs0RCxLQUFPOEQsRUFBQUEsT0FBT2lCLENBQUFBLE1BQUssQ0FBQ0EsRUFBRUMsV0FBVyxHQUFPLENBQUEsR0FBQTtBQUNwRWpFLE1BQUFBLEtBQUl0QyxJQUFJNEYsR0FBQUE7SUFDVjtFQUNGO0FBQ0EsU0FBT2IsTUFBTUMsS0FBSzFDLElBQUFBO0FBQ3BCO0FDN2FBLElBQU1rRSxVQUFVQyxPQUFPRCxXQUFXO0FDRzNCLFNBQVNFLGtCQUEyQjtBQUN6QyxTQUFPLE9BQU9DLFdBQVcsZUFBZSxPQUFPQyxhQUFhO0FBQzlEO0FBS08sU0FBU0MsZUFBZUMsU0FBK0M7QUFDNUUsTUFBSUMsU0FBU0QsUUFBUUU7QUFDckIsTUFBSUQsVUFBVUEsT0FBT0UsU0FBUSxNQUFPLHVCQUF1QjtBQUN6REYsYUFBVUEsT0FBc0JHOztBQUVsQyxTQUFPSDtBQUNUO0FBT0EsU0FBU0ksY0FBY0MsWUFBNkJDLE1BQW1CQyxnQkFBd0I7QUFDN0YsTUFBSUM7QUFDSixNQUFJLE9BQU9ILGVBQWUsVUFBVTtBQUNsQ0csb0JBQWdCQyxTQUFTSixZQUFZLEVBQUE7QUFFckMsUUFBSUEsV0FBV0ssUUFBUSxHQUFBLE1BQVMsSUFBSTtBQUVsQ0Ysc0JBQWdCLGdCQUFpQixNQUFPRixLQUFLTCxXQUFXTSxjQUFlOztTQUVwRTtBQUNMQyxvQkFBZ0JIOztBQUdsQixTQUFPRztBQUNUO0FBRUEsSUFBTUcsb0JBQW1CLENBQUNDLFlBQ3hCQSxRQUFRQyxjQUFjQyxZQUFZSCxpQkFBaUJDLFNBQVMsSUFBSTtBQUUzRCxTQUFTRyxTQUFTQyxJQUFpQkMsVUFBMEI7QUFDbEUsU0FBT04sa0JBQWlCSyxFQUFJRSxFQUFBQSxpQkFBaUJELFFBQUFBO0FBQy9DO0FBRUEsSUFBTUUsWUFBWTtFQUFDO0VBQU87RUFBUztFQUFVO0FBQU87QUFDcEQsU0FBU0MsbUJBQW1CQyxRQUE2QkMsT0FBZUMsUUFBNEI7QUFDbEcsUUFBTUMsU0FBUyxDQUFBO0FBQ2ZELFdBQVNBLFNBQVMsTUFBTUEsU0FBUztBQUNqQyxXQUFTRSxLQUFJLEdBQUdBLEtBQUksR0FBR0EsTUFBSztBQUMxQixVQUFNQyxNQUFNUCxVQUFVTSxFQUFFO0FBQ3hCRCxXQUFPRSxHQUFJLElBQUdDLFdBQVdOLE9BQU9DLFFBQVEsTUFBTUksTUFBTUgsTUFBQUEsQ0FBTyxLQUFLO0VBQ2xFO0FBQ0FDLFNBQU9JLFFBQVFKLE9BQU9LLE9BQU9MLE9BQU9NO0FBQ3BDTixTQUFPTyxTQUFTUCxPQUFPUSxNQUFNUixPQUFPUztBQUNwQyxTQUFPVDtBQUNUO0FBRUEsSUFBTVUsZUFBZSxDQUFDQyxJQUFXQyxJQUFXQyxZQUN6Q0YsS0FBSSxLQUFLQyxLQUFJLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLE9BQXdCQztBQU8zRCxTQUFTQyxrQkFDUEMsSUFDQUMsUUFLRTtBQUNGLFFBQU1DLFVBQVVGLEdBQWtCRTtBQUNsQyxRQUFNQyxTQUFVRCxXQUFXQSxRQUFRRSxTQUFTRixRQUFRLENBQUUsSUFBR0Y7QUFDekQsUUFBTSxFQUFDSyxTQUFTQyxRQUFBQSxJQUFXSDtBQUMzQixNQUFJSSxNQUFNO0FBQ1YsTUFBSVosSUFBR0M7QUFDUCxNQUFJRixhQUFhVyxTQUFTQyxTQUFTTixHQUFFSCxNQUFNLEdBQUc7QUFDNUNGLElBQUFBLEtBQUlVO0FBQ0pULElBQUFBLEtBQUlVO1NBQ0M7QUFDTCxVQUFNRSxPQUFPUCxPQUFPUSxzQkFBcUI7QUFDekNkLElBQUFBLEtBQUlRLE9BQU9PLFVBQVVGLEtBQUtuQjtBQUMxQk8sSUFBQUEsS0FBSU8sT0FBT1EsVUFBVUgsS0FBS2hCO0FBQzFCZSxVQUFNOztBQUVSLFNBQU87SUFBQ1osR0FBQUE7SUFBR0MsR0FBQUE7SUFBR1c7RUFBRztBQUNuQjtBQVNPLFNBQVNLLG9CQUNkQyxPQUNBQyxPQUMwQjtBQUMxQixNQUFJLFlBQVlELE9BQU87QUFDckIsV0FBT0E7O0FBR1QsUUFBTSxFQUFDWixRQUFRYyx3QkFBQUEsSUFBMkJEO0FBQzFDLFFBQU1oQyxRQUFRWCxrQkFBaUI4QixNQUFBQTtBQUMvQixRQUFNZSxZQUFZbEMsTUFBTW1DLGNBQWM7QUFDdEMsUUFBTUMsV0FBV3RDLG1CQUFtQkUsT0FBTyxTQUFBO0FBQzNDLFFBQU1xQyxVQUFVdkMsbUJBQW1CRSxPQUFPLFVBQVUsT0FBQTtBQUNwRCxRQUFNLEVBQUNhLEdBQUFBLElBQUdDLEdBQUFBLElBQUdXLElBQUcsSUFBSVIsa0JBQWtCYyxPQUFPWixNQUFBQTtBQUM3QyxRQUFNbUIsVUFBVUYsU0FBUzdCLFFBQVFrQixPQUFPWSxRQUFROUI7QUFDaEQsUUFBTWdDLFVBQVVILFNBQVMxQixPQUFPZSxPQUFPWSxRQUFRM0I7QUFFL0MsTUFBSSxFQUFDSixPQUFPRyxPQUFBQSxJQUFVdUI7QUFDdEIsTUFBSUUsV0FBVztBQUNiNUIsYUFBUzhCLFNBQVM5QixRQUFRK0IsUUFBUS9CO0FBQ2xDRyxjQUFVMkIsU0FBUzNCLFNBQVM0QixRQUFRNUI7O0FBRXRDLFNBQU87SUFDTEksR0FBRzJCLEtBQUtDLE9BQU81QixLQUFJeUIsV0FBV2hDLFFBQVFhLE9BQU9iLFFBQVEyQix1QkFBQUE7SUFDckRuQixHQUFHMEIsS0FBS0MsT0FBTzNCLEtBQUl5QixXQUFXOUIsU0FBU1UsT0FBT1YsU0FBU3dCLHVCQUFBQTtFQUN6RDtBQUNGO0FBRUEsU0FBU1MsaUJBQWlCdkIsUUFBMkJiLE9BQWVHLFFBQWdDO0FBQ2xHLE1BQUlrQyxVQUFrQkM7QUFFdEIsTUFBSXRDLFVBQVV1QyxVQUFhcEMsV0FBV29DLFFBQVc7QUFDL0MsVUFBTUMsWUFBWTNCLFVBQVUzQyxlQUFlMkMsTUFBQUE7QUFDM0MsUUFBSSxDQUFDMkIsV0FBVztBQUNkeEMsY0FBUWEsT0FBTzRCO0FBQ2Z0QyxlQUFTVSxPQUFPNkI7V0FDWDtBQUNMLFlBQU10QixPQUFPb0IsVUFBVW5CLHNCQUFxQjtBQUM1QyxZQUFNc0IsaUJBQWlCNUQsa0JBQWlCeUQsU0FBQUE7QUFDeEMsWUFBTUksa0JBQWtCcEQsbUJBQW1CbUQsZ0JBQWdCLFVBQVUsT0FBQTtBQUNyRSxZQUFNRSxtQkFBbUJyRCxtQkFBbUJtRCxnQkFBZ0IsU0FBQTtBQUM1RDNDLGNBQVFvQixLQUFLcEIsUUFBUTZDLGlCQUFpQjdDLFFBQVE0QyxnQkFBZ0I1QztBQUM5REcsZUFBU2lCLEtBQUtqQixTQUFTMEMsaUJBQWlCMUMsU0FBU3lDLGdCQUFnQnpDO0FBQ2pFa0MsaUJBQVc3RCxjQUFjbUUsZUFBZU4sVUFBVUcsV0FBVyxhQUFBO0FBQzdERixrQkFBWTlELGNBQWNtRSxlQUFlTCxXQUFXRSxXQUFXLGNBQUE7OztBQUduRSxTQUFPO0lBQ0x4QztJQUNBRztJQUNBa0MsVUFBVUEsWUFBWVM7SUFDdEJSLFdBQVdBLGFBQWFRO0VBQzFCO0FBQ0Y7QUFFQSxJQUFNQyxTQUFTLENBQUNDLE9BQWNkLEtBQUtDLE1BQU1hLEtBQUksRUFBTSxJQUFBO0FBRzVDLFNBQVNDLGVBQ2RwQyxRQUNBcUMsU0FDQUMsVUFDQUMsYUFDbUM7QUFDbkMsUUFBTTFELFFBQVFYLGtCQUFpQjhCLE1BQUFBO0FBQy9CLFFBQU13QyxVQUFVN0QsbUJBQW1CRSxPQUFPLFFBQUE7QUFDMUMsUUFBTTJDLFdBQVc3RCxjQUFja0IsTUFBTTJDLFVBQVV4QixRQUFRLGFBQWtCaUMsS0FBQUE7QUFDekUsUUFBTVIsWUFBWTlELGNBQWNrQixNQUFNNEMsV0FBV3pCLFFBQVEsY0FBbUJpQyxLQUFBQTtBQUM1RSxRQUFNUSxnQkFBZ0JsQixpQkFBaUJ2QixRQUFRcUMsU0FBU0MsUUFBQUE7QUFDeEQsTUFBSSxFQUFDbkQsT0FBT0csT0FBQUEsSUFBVW1EO0FBRXRCLE1BQUk1RCxNQUFNbUMsY0FBYyxlQUFlO0FBQ3JDLFVBQU1FLFVBQVV2QyxtQkFBbUJFLE9BQU8sVUFBVSxPQUFBO0FBQ3BELFVBQU1vQyxXQUFXdEMsbUJBQW1CRSxPQUFPLFNBQUE7QUFDM0NNLGFBQVM4QixTQUFTOUIsUUFBUStCLFFBQVEvQjtBQUNsQ0csY0FBVTJCLFNBQVMzQixTQUFTNEIsUUFBUTVCOztBQUV0Q0gsVUFBUWtDLEtBQUtxQixJQUFJLEdBQUd2RCxRQUFRcUQsUUFBUXJELEtBQUs7QUFDekNHLFdBQVMrQixLQUFLcUIsSUFBSSxHQUFHSCxjQUFjcEQsUUFBUW9ELGNBQWNqRCxTQUFTa0QsUUFBUWxELE1BQU07QUFDaEZILFVBQVErQyxPQUFPYixLQUFLc0IsSUFBSXhELE9BQU9xQyxVQUFVaUIsY0FBY2pCLFFBQVEsQ0FBQTtBQUMvRGxDLFdBQVM0QyxPQUFPYixLQUFLc0IsSUFBSXJELFFBQVFtQyxXQUFXZ0IsY0FBY2hCLFNBQVMsQ0FBQTtBQUNuRSxNQUFJdEMsU0FBUyxDQUFDRyxRQUFRO0FBR3BCQSxhQUFTNEMsT0FBTy9DLFFBQVEsQ0FBQTs7QUFHMUIsUUFBTXlELGlCQUFpQlAsWUFBWVgsVUFBYVksYUFBYVo7QUFFN0QsTUFBSWtCLGtCQUFrQkwsZUFBZUUsY0FBY25ELFVBQVVBLFNBQVNtRCxjQUFjbkQsUUFBUTtBQUMxRkEsYUFBU21ELGNBQWNuRDtBQUN2QkgsWUFBUStDLE9BQU9iLEtBQUt3QixNQUFNdkQsU0FBU2lELFdBQUFBLENBQUFBOztBQUdyQyxTQUFPO0lBQUNwRDtJQUFPRztFQUFNO0FBQ3ZCO0FBUU8sU0FBU3dELFlBQ2RqQyxPQUNBa0MsWUFDQUMsWUFDZ0I7QUFDaEIsUUFBTUMsYUFBYUYsY0FBYztBQUNqQyxRQUFNRyxlQUFlaEIsT0FBT3JCLE1BQU12QixTQUFTMkQsVUFBQUE7QUFDM0MsUUFBTUUsY0FBY2pCLE9BQU9yQixNQUFNMUIsUUFBUThELFVBQUFBO0FBRXhDcEMsUUFBdUJ2QixTQUFTNEMsT0FBT3JCLE1BQU12QixNQUFNO0FBQ25EdUIsUUFBdUIxQixRQUFRK0MsT0FBT3JCLE1BQU0xQixLQUFLO0FBRWxELFFBQU1hLFNBQVNhLE1BQU1iO0FBS3JCLE1BQUlBLE9BQU9uQixVQUFVbUUsY0FBZSxDQUFDaEQsT0FBT25CLE1BQU1TLFVBQVUsQ0FBQ1UsT0FBT25CLE1BQU1NLFFBQVM7QUFDakZhLFdBQU9uQixNQUFNUyxTQUFTLEdBQUd1QixNQUFNdkIsTUFBTTtBQUNyQ1UsV0FBT25CLE1BQU1NLFFBQVEsR0FBRzBCLE1BQU0xQixLQUFLOztBQUdyQyxNQUFJMEIsTUFBTUMsNEJBQTRCbUMsY0FDL0JqRCxPQUFPVixXQUFXNEQsZ0JBQ2xCbEQsT0FBT2IsVUFBVWdFLGFBQWE7QUFDbEN0QyxVQUF1QkMsMEJBQTBCbUM7QUFDbERqRCxXQUFPVixTQUFTNEQ7QUFDaEJsRCxXQUFPYixRQUFRZ0U7QUFDZnRDLFVBQU11QyxJQUFJQyxhQUFhSixZQUFZLEdBQUcsR0FBR0EsWUFBWSxHQUFHLENBQUE7QUFDeEQsV0FBTzs7QUFFVCxTQUFPO0FBQ1Q7QUFPYUssSUFBQUEsZ0NBQWdDLFdBQVc7QUFDdEQsTUFBSUMsbUJBQW1CO0FBQ3ZCLE1BQUk7QUFDRixVQUFNQyxVQUFVO01BQ2QsSUFBSUMsVUFBVTtBQUNaRiwyQkFBbUI7QUFDbkIsZUFBTztNQUNUO0lBQ0Y7QUFFQSxRQUFJckcsZ0JBQW1CLEdBQUE7QUFDckJDLGFBQU91RyxpQkFBaUIsUUFBUSxNQUFNRixPQUFBQTtBQUN0Q3JHLGFBQU93RyxvQkFBb0IsUUFBUSxNQUFNSCxPQUFBQTs7RUFFN0MsU0FBU3pELElBQUc7RUFFWjtBQUNBLFNBQU93RDtBQUNULEdBQUs7QUFZRSxTQUFTSyxhQUNkekYsU0FDQUssVUFDb0I7QUFDcEIsUUFBTXFGLFFBQVF2RixTQUFTSCxTQUFTSyxRQUFBQTtBQUNoQyxRQUFNc0YsVUFBVUQsU0FBU0EsTUFBTUUsTUFBTSxtQkFBQTtBQUNyQyxTQUFPRCxVQUFVLENBQUNBLFFBQVEsQ0FBQSxJQUFLcEM7QUFDakM7QUVuUkEsSUFBTXNDLHdCQUF3QixTQUFTQyxPQUFlQyxPQUEyQjtBQUMvRSxTQUFPO0lBQ0xDLEVBQUVBLElBQUc7QUFDSCxhQUFPRixRQUFRQSxRQUFRQyxRQUFRQztJQUNqQztJQUNBQyxTQUFTQyxJQUFHO0FBQ1ZILGNBQVFHO0lBQ1Y7SUFDQUMsVUFBVUMsT0FBTztBQUNmLFVBQUlBLFVBQVUsVUFBVTtBQUN0QixlQUFPQTs7QUFFVCxhQUFPQSxVQUFVLFVBQVUsU0FBUztJQUN0QztJQUNBQyxNQUFNTCxJQUFHTSxPQUFPO0FBQ2QsYUFBT04sS0FBSU07SUFDYjtJQUNBQyxXQUFXUCxJQUFHUSxXQUFXO0FBQ3ZCLGFBQU9SLEtBQUlRO0lBQ2I7RUFDRjtBQUNGO0FBRUEsSUFBTUMsd0JBQXdCLFdBQXVCO0FBQ25ELFNBQU87SUFDTFQsRUFBRUEsSUFBRztBQUNILGFBQU9BO0lBQ1Q7SUFDQUMsU0FBU0MsSUFBRztJQUFBO0lBRVpDLFVBQVVDLE9BQU87QUFDZixhQUFPQTtJQUNUO0lBQ0FDLE1BQU1MLElBQUdNLE9BQU87QUFDZCxhQUFPTixLQUFJTTtJQUNiO0lBQ0FDLFdBQVdQLElBQUdVLFlBQVk7QUFDeEIsYUFBT1Y7SUFDVDtFQUNGO0FBQ0Y7QUFFTyxTQUFTVyxjQUFjQyxLQUFjZCxPQUFlQyxPQUFlO0FBQ3hFLFNBQU9hLE1BQU1mLHNCQUFzQkMsT0FBT0MsS0FBQUEsSUFBU1Usc0JBQXVCO0FBQzVFO0FBRU8sU0FBU0ksc0JBQXNCQyxLQUErQkMsV0FBMEI7QUFDN0YsTUFBSUMsT0FBNEJDO0FBQ2hDLE1BQUlGLGNBQWMsU0FBU0EsY0FBYyxPQUFPO0FBQzlDQyxZQUFRRixJQUFJSSxPQUFPRjtBQUNuQkMsZUFBVztNQUNURCxNQUFNRyxpQkFBaUIsV0FBQTtNQUN2QkgsTUFBTUksb0JBQW9CLFdBQUE7SUFDM0I7QUFFREosVUFBTUssWUFBWSxhQUFhTixXQUFXLFdBQUE7QUFDekNELFFBQWlEUSxvQkFBb0JMOztBQUUxRTtBQUVPLFNBQVNNLHFCQUFxQlQsS0FBK0JHLFVBQTZCO0FBQy9GLE1BQUlBLGFBQWFPLFFBQVc7QUFDMUIsV0FBUVYsSUFBaURRO0FBQ3pEUixRQUFJSSxPQUFPRixNQUFNSyxZQUFZLGFBQWFKLFNBQVMsQ0FBQSxHQUFJQSxTQUFTLENBQUUsQ0FBQTs7QUFFdEU7QUV2RUEsU0FBU1EsZUFBZUMsT0FBY0MsV0FBc0JDLE9BQXdCO0FBQ2xGLFNBQU9GLE1BQU1HLFFBQVFDLE9BQU9KLE1BQU1FLEtBQU0sSUFBR0QsVUFBVUMsS0FBTTtBQUM3RDtBQUVBLFNBQVNHLGVBQWVDLE1BQWlCTCxXQUE0QjtBQUNuRSxRQUFNLEVBQUNNLFFBQVFDLE9BQUFBLElBQVVGO0FBQ3pCLE1BQUlDLFVBQVVDLFFBQVE7QUFDcEIsV0FBTztNQUNMQyxNQUFNVixlQUFlUSxRQUFRTixXQUFXLE1BQUE7TUFDeENTLE9BQU9YLGVBQWVRLFFBQVFOLFdBQVcsT0FBQTtNQUN6Q1UsS0FBS1osZUFBZVMsUUFBUVAsV0FBVyxLQUFBO01BQ3ZDVyxRQUFRYixlQUFlUyxRQUFRUCxXQUFXLFFBQUE7SUFDNUM7O0FBRUYsU0FBT0E7QUFDVDtBQUVPLFNBQVNZLG1CQUFtQkMsT0FBY1IsTUFBK0I7QUFDOUUsUUFBTUYsT0FBT0UsS0FBS1M7QUFDbEIsTUFBSVgsS0FBS1ksVUFBVTtBQUNqQixXQUFPOztBQUVULFFBQU1DLE9BQU9aLGVBQWVDLE1BQU1RLE1BQU1iLFNBQVM7QUFFakQsU0FBTztJQUNMUSxNQUFNTCxLQUFLSyxTQUFTLFFBQVEsSUFBSVEsS0FBS1IsUUFBUUwsS0FBS0ssU0FBUyxPQUFPLElBQUlMLEtBQUtLO0lBQzNFQyxPQUFPTixLQUFLTSxVQUFVLFFBQVFJLE1BQU1JLFFBQVFELEtBQUtQLFNBQVNOLEtBQUtNLFVBQVUsT0FBTyxJQUFJTixLQUFLTTtJQUN6RkMsS0FBS1AsS0FBS08sUUFBUSxRQUFRLElBQUlNLEtBQUtOLE9BQU9QLEtBQUtPLFFBQVEsT0FBTyxJQUFJUCxLQUFLTztJQUN2RUMsUUFBUVIsS0FBS1EsV0FBVyxRQUFRRSxNQUFNSyxTQUFTRixLQUFLTCxVQUFVUixLQUFLUSxXQUFXLE9BQU8sSUFBSVIsS0FBS1E7RUFDaEc7QUFDRjs7O0FDckJPLElBQU1RLFdBQU4sTUFBTUE7RUFDWEMsY0FBYztBQUNaLFNBQUtDLFdBQVc7QUFDaEIsU0FBS0MsVUFBVSxvQkFBSUMsSUFBQUE7QUFDbkIsU0FBS0MsV0FBVztBQUNoQixTQUFLQyxZQUFZQztFQUNuQjtFQUtBQyxRQUFRQyxPQUFPQyxPQUFPQyxNQUFNQyxNQUFNO0FBQ2hDLFVBQU1DLFlBQVlILE1BQU1JLFVBQVVGLElBQUs7QUFDdkMsVUFBTUcsV0FBV0wsTUFBTU07QUFFdkJILGNBQVVJLFFBQVFDLENBQUFBLFFBQU1BLElBQUc7TUFDekJUO01BQ0FVLFNBQVNULE1BQU1TO01BQ2ZKO01BQ0FLLGFBQWFDLEtBQUtDLElBQUlYLE9BQU9ELE1BQU1hLE9BQU9SLFFBQUFBO0lBQzVDLENBQUEsQ0FBQTtFQUNGO0VBS0FTLFdBQVc7QUFDVCxRQUFJLEtBQUt0QixVQUFVO0FBQ2pCOztBQUVGLFNBQUtHLFdBQVc7QUFFaEIsU0FBS0gsV0FBV3VCLGlCQUFpQkMsS0FBS0MsUUFBUSxNQUFNO0FBQ2xELFdBQUtDLFFBQU87QUFDWixXQUFLMUIsV0FBVztBQUVoQixVQUFJLEtBQUtHLFVBQVU7QUFDakIsYUFBS21CLFNBQVE7O0lBRWpCLENBQUE7RUFDRjtFQUtBSSxRQUFRakIsT0FBT2tCLEtBQUtDLElBQUcsR0FBSTtBQUN6QixRQUFJQyxZQUFZO0FBRWhCLFNBQUs1QixRQUFRYyxRQUFRLENBQUNQLE9BQU9ELFVBQVU7QUFDckMsVUFBSSxDQUFDQyxNQUFNc0IsV0FBVyxDQUFDdEIsTUFBTXVCLE1BQU1DLFFBQVE7QUFDekM7O0FBRUYsWUFBTUQsUUFBUXZCLE1BQU11QjtBQUNwQixVQUFJRSxLQUFJRixNQUFNQyxTQUFTO0FBQ3ZCLFVBQUlFLE9BQU87QUFDWCxVQUFJQztBQUVKLGFBQU9GLE1BQUssR0FBRyxFQUFFQSxJQUFHO0FBQ2xCRSxlQUFPSixNQUFNRSxFQUFFO0FBRWYsWUFBSUUsS0FBS0MsU0FBUztBQUNoQixjQUFJRCxLQUFLRSxTQUFTN0IsTUFBTU0sVUFBVTtBQUdoQ04sa0JBQU1NLFdBQVdxQixLQUFLRTs7QUFFeEJGLGVBQUtHLEtBQUs3QixJQUFBQTtBQUNWeUIsaUJBQU87ZUFDRjtBQUdMSCxnQkFBTUUsRUFBQUEsSUFBS0YsTUFBTUEsTUFBTUMsU0FBUyxDQUFFO0FBQ2xDRCxnQkFBTVEsSUFBRzs7TUFFYjtBQUVBLFVBQUlMLE1BQU07QUFDUjNCLGNBQU0yQixLQUFJO0FBQ1YsYUFBSzVCLFFBQVFDLE9BQU9DLE9BQU9DLE1BQU0sVUFBQTs7QUFHbkMsVUFBSSxDQUFDc0IsTUFBTUMsUUFBUTtBQUNqQnhCLGNBQU1zQixVQUFVO0FBQ2hCLGFBQUt4QixRQUFRQyxPQUFPQyxPQUFPQyxNQUFNLFVBQUE7QUFDakNELGNBQU1TLFVBQVU7O0FBR2xCWSxtQkFBYUUsTUFBTUM7SUFDckIsQ0FBQTtBQUVBLFNBQUs1QixZQUFZSztBQUVqQixRQUFJb0IsY0FBYyxHQUFHO0FBQ25CLFdBQUsxQixXQUFXOztFQUVwQjtFQUtBcUMsVUFBVWpDLE9BQU87QUFDZixVQUFNa0MsU0FBUyxLQUFLeEM7QUFDcEIsUUFBSU8sUUFBUWlDLE9BQU9DLElBQUluQyxLQUFBQTtBQUN2QixRQUFJLENBQUNDLE9BQU87QUFDVkEsY0FBUTtRQUNOc0IsU0FBUztRQUNUYixTQUFTO1FBQ1RjLE9BQU8sQ0FBQTtRQUNQbkIsV0FBVztVQUNUK0IsVUFBVSxDQUFBO1VBQ1ZDLFVBQVUsQ0FBQTtRQUNaO01BQ0Y7QUFDQUgsYUFBT0ksSUFBSXRDLE9BQU9DLEtBQUFBOztBQUVwQixXQUFPQTtFQUNUO0VBT0FzQyxPQUFPdkMsT0FBT3dDLE9BQU9DLElBQUk7QUFDdkIsU0FBS1IsVUFBVWpDLEtBQUFBLEVBQU9LLFVBQVVtQyxLQUFBQSxFQUFPRSxLQUFLRCxFQUFBQTtFQUM5QztFQU9BRSxJQUFJM0MsT0FBT3dCLE9BQU87QUFDaEIsUUFBSSxDQUFDQSxTQUFTLENBQUNBLE1BQU1DLFFBQVE7QUFDM0I7O0FBRUYsU0FBS1EsVUFBVWpDLEtBQUFBLEVBQU93QixNQUFNa0IsS0FBUWxCLEdBQUFBLEtBQUFBO0VBQ3RDO0VBTUFvQixJQUFJNUMsT0FBTztBQUNULFdBQU8sS0FBS2lDLFVBQVVqQyxLQUFBQSxFQUFPd0IsTUFBTUMsU0FBUztFQUM5QztFQU1BWCxNQUFNZCxPQUFPO0FBQ1gsVUFBTUMsUUFBUSxLQUFLUCxRQUFReUMsSUFBSW5DLEtBQUFBO0FBQy9CLFFBQUksQ0FBQ0MsT0FBTztBQUNWOztBQUVGQSxVQUFNc0IsVUFBVTtBQUNoQnRCLFVBQU1hLFFBQVFNLEtBQUtDLElBQUc7QUFDdEJwQixVQUFNTSxXQUFXTixNQUFNdUIsTUFBTXFCLE9BQU8sQ0FBQ0MsS0FBS0MsUUFBUW5DLEtBQUtvQyxJQUFJRixLQUFLQyxJQUFJRSxTQUFTLEdBQUcsQ0FBQTtBQUNoRixTQUFLbEMsU0FBUTtFQUNmO0VBRUFRLFFBQVF2QixPQUFPO0FBQ2IsUUFBSSxDQUFDLEtBQUtKLFVBQVU7QUFDbEIsYUFBTzs7QUFFVCxVQUFNSyxRQUFRLEtBQUtQLFFBQVF5QyxJQUFJbkMsS0FBQUE7QUFDL0IsUUFBSSxDQUFDQyxTQUFTLENBQUNBLE1BQU1zQixXQUFXLENBQUN0QixNQUFNdUIsTUFBTUMsUUFBUTtBQUNuRCxhQUFPOztBQUVULFdBQU87RUFDVDtFQU1BeUIsS0FBS2xELE9BQU87QUFDVixVQUFNQyxRQUFRLEtBQUtQLFFBQVF5QyxJQUFJbkMsS0FBQUE7QUFDL0IsUUFBSSxDQUFDQyxTQUFTLENBQUNBLE1BQU11QixNQUFNQyxRQUFRO0FBQ2pDOztBQUVGLFVBQU1ELFFBQVF2QixNQUFNdUI7QUFDcEIsUUFBSUUsS0FBSUYsTUFBTUMsU0FBUztBQUV2QixXQUFPQyxNQUFLLEdBQUcsRUFBRUEsSUFBRztBQUNsQkYsWUFBTUUsRUFBRSxFQUFDeUIsT0FBTTtJQUNqQjtBQUNBbEQsVUFBTXVCLFFBQVEsQ0FBQTtBQUNkLFNBQUt6QixRQUFRQyxPQUFPQyxPQUFPbUIsS0FBS0MsSUFBRyxHQUFJLFVBQUE7RUFDekM7RUFNQStCLE9BQU9wRCxPQUFPO0FBQ1osV0FBTyxLQUFLTixRQUFRMkQsT0FBT3JELEtBQUFBO0VBQzdCO0FBQ0Y7QUFHQSxJQUFBLFdBQStCLG9CQUFJVCxTQUFXO0FDak45QyxJQUFNK0QsY0FBYztBQUNwQixJQUFNQyxnQkFBZ0I7RUFDcEJDLFFBQVFDLE9BQU1DLEtBQUlDLFFBQVE7QUFDeEIsV0FBT0EsU0FBUyxNQUFNRCxNQUFLRDtFQUM3QjtFQU1BRyxNQUFNSCxPQUFNQyxLQUFJQyxRQUFRO0FBQ3RCLFVBQU1FLEtBQUtDLE1BQWFMLFNBQVFILFdBQUFBO0FBQ2hDLFVBQU1TLEtBQUtGLEdBQUdHLFNBQVNGLE1BQWFKLE9BQU1KLFdBQUFBO0FBQzFDLFdBQU9TLE1BQU1BLEdBQUdDLFFBQ1pELEdBQUdFLElBQUlKLElBQUlGLE1BQUFBLEVBQVFPLFVBQVMsSUFDNUJSO0VBQ047RUFDQVMsT0FBT1YsT0FBTUMsS0FBSUMsUUFBUTtBQUN2QixXQUFPRixTQUFRQyxNQUFLRCxTQUFRRTtFQUM5QjtBQUNGO0FBRWUsSUFBTVMsWUFBTixNQUFNQTtFQUNuQjVFLFlBQVk2RSxLQUFLQyxRQUFRQyxNQUFNYixLQUFJO0FBQ2pDLFVBQU1jLGVBQWVGLE9BQU9DLElBQUs7QUFFakNiLElBQUFBLE1BQUtlLFFBQVE7TUFBQ0osSUFBSVg7TUFBSUE7TUFBSWM7TUFBY0gsSUFBSVo7SUFBSyxDQUFBO0FBQ2pELFVBQU1BLFFBQU9nQixRQUFRO01BQUNKLElBQUlaO01BQU1lO01BQWNkO0lBQUcsQ0FBQTtBQUVqRCxTQUFLN0IsVUFBVTtBQUNmLFNBQUs2QyxNQUFNTCxJQUFJNUQsTUFBTThDLGNBQWNjLElBQUlsRSxRQUFRLE9BQU9zRCxLQUFLO0FBQzNELFNBQUtrQixVQUFVQyxRQUFRUCxJQUFJUSxNQUFNLEtBQUtELFFBQVFFO0FBQzlDLFNBQUtDLFNBQVNuRSxLQUFLb0UsTUFBTTVELEtBQUtDLElBQUcsS0FBTWdELElBQUlZLFNBQVMsRUFBQTtBQUNwRCxTQUFLaEMsWUFBWSxLQUFLbkIsU0FBU2xCLEtBQUtvRSxNQUFNWCxJQUFJOUQsUUFBUTtBQUN0RCxTQUFLMkUsUUFBUSxDQUFDLENBQUNiLElBQUljO0FBQ25CLFNBQUtDLFVBQVVkO0FBQ2YsU0FBS2UsUUFBUWQ7QUFDYixTQUFLZSxRQUFRN0I7QUFDYixTQUFLOEIsTUFBTTdCO0FBQ1gsU0FBSzhCLFlBQVkxRjtFQUNuQjtFQUVBMkYsU0FBUztBQUNQLFdBQU8sS0FBSzVEO0VBQ2Q7RUFFQTZELE9BQU9yQixLQUFLWCxLQUFJeEQsTUFBTTtBQUNwQixRQUFJLEtBQUsyQixTQUFTO0FBQ2hCLFdBQUs5QixRQUFRLEtBQUs7QUFFbEIsWUFBTXlFLGVBQWUsS0FBS1ksUUFBUSxLQUFLQyxLQUFLO0FBQzVDLFlBQU1NLFVBQVV6RixPQUFPLEtBQUs2RTtBQUM1QixZQUFNYSxTQUFTLEtBQUszQyxZQUFZMEM7QUFDaEMsV0FBS1osU0FBUzdFO0FBQ2QsV0FBSytDLFlBQVlyQyxLQUFLb0UsTUFBTXBFLEtBQUtvQyxJQUFJNEMsUUFBUXZCLElBQUk5RCxRQUFRLENBQUE7QUFDekQsV0FBS3VCLFVBQVU2RDtBQUNmLFdBQUtULFFBQVEsQ0FBQyxDQUFDYixJQUFJYztBQUNuQixXQUFLSSxNQUFNZCxRQUFRO1FBQUNKLElBQUlYO1FBQUlBO1FBQUljO1FBQWNILElBQUlaO01BQUssQ0FBQTtBQUN2RCxXQUFLNkIsUUFBUWIsUUFBUTtRQUFDSixJQUFJWjtRQUFNZTtRQUFjZDtNQUFHLENBQUE7O0VBRXJEO0VBRUFQLFNBQVM7QUFDUCxRQUFJLEtBQUt0QixTQUFTO0FBRWhCLFdBQUtFLEtBQUtYLEtBQUtDLElBQUcsQ0FBQTtBQUNsQixXQUFLUSxVQUFVO0FBQ2YsV0FBSzlCLFFBQVEsS0FBSzs7RUFFdEI7RUFFQWdDLEtBQUs3QixNQUFNO0FBQ1QsVUFBTXlGLFVBQVV6RixPQUFPLEtBQUs2RTtBQUM1QixVQUFNeEUsV0FBVyxLQUFLMEM7QUFDdEIsVUFBTXNCLE9BQU8sS0FBS2M7QUFDbEIsVUFBTTVCLFFBQU8sS0FBSzZCO0FBQ2xCLFVBQU1ILE9BQU8sS0FBS0Q7QUFDbEIsVUFBTXhCLE1BQUssS0FBSzZCO0FBQ2hCLFFBQUk1QjtBQUVKLFNBQUs5QixVQUFVNEIsVUFBU0MsUUFBT3lCLFFBQVNRLFVBQVVwRjtBQUVsRCxRQUFJLENBQUMsS0FBS3NCLFNBQVM7QUFDakIsV0FBS3VELFFBQVFiLElBQUFBLElBQVFiO0FBQ3JCLFdBQUszRCxRQUFRLElBQUk7QUFDakI7O0FBR0YsUUFBSTRGLFVBQVUsR0FBRztBQUNmLFdBQUtQLFFBQVFiLElBQUFBLElBQVFkO0FBQ3JCOztBQUdGRSxhQUFVZ0MsVUFBVXBGLFdBQVk7QUFDaENvRCxhQUFTd0IsUUFBUXhCLFNBQVMsSUFBSSxJQUFJQSxTQUFTQTtBQUMzQ0EsYUFBUyxLQUFLZ0IsUUFBUS9ELEtBQUtDLElBQUksR0FBR0QsS0FBS29DLElBQUksR0FBR1csTUFBQUEsQ0FBQUEsQ0FBQUE7QUFFOUMsU0FBS3lCLFFBQVFiLElBQUssSUFBRyxLQUFLRyxJQUFJakIsT0FBTUMsS0FBSUMsTUFBQUE7RUFDMUM7RUFFQWtDLE9BQU87QUFDTCxVQUFNQyxXQUFXLEtBQUtOLGNBQWMsS0FBS0EsWUFBWSxDQUFBO0FBQ3JELFdBQU8sSUFBSU8sUUFBUSxDQUFDQyxLQUFLQyxRQUFRO0FBQy9CSCxlQUFTcEQsS0FBSztRQUFDc0Q7UUFBS0M7TUFBRyxDQUFBO0lBQ3pCLENBQUE7RUFDRjtFQUVBbEcsUUFBUW1HLFVBQVU7QUFDaEIsVUFBTUMsU0FBU0QsV0FBVyxRQUFRO0FBQ2xDLFVBQU1KLFdBQVcsS0FBS04sYUFBYSxDQUFBO0FBQ25DLGFBQVM5RCxLQUFJLEdBQUdBLEtBQUlvRSxTQUFTckUsUUFBUUMsTUFBSztBQUN4Q29FLGVBQVNwRSxFQUFFLEVBQUN5RSxNQUFPLEVBQUE7SUFDckI7RUFDRjtBQUNGO0FDakhlLElBQU1DLGFBQU4sTUFBTUE7RUFDbkI1RyxZQUFZUSxPQUFPcUcsUUFBUTtBQUN6QixTQUFLQyxTQUFTdEc7QUFDZCxTQUFLdUcsY0FBYyxvQkFBSTVHLElBQUFBO0FBQ3ZCLFNBQUs2RyxVQUFVSCxNQUFBQTtFQUNqQjtFQUVBRyxVQUFVSCxRQUFRO0FBQ2hCLFFBQUksQ0FBQ0ksU0FBU0osTUFBUyxHQUFBO0FBQ3JCOztBQUdGLFVBQU1LLG1CQUFtQkMsT0FBT0MsS0FBS0MsVUFBU0MsU0FBUztBQUN2RCxVQUFNQyxnQkFBZ0IsS0FBS1I7QUFFM0JJLFdBQU9LLG9CQUFvQlgsTUFBQUEsRUFBUTdGLFFBQVF5RyxDQUFBQSxRQUFPO0FBQ2hELFlBQU01QyxNQUFNZ0MsT0FBT1ksR0FBSTtBQUN2QixVQUFJLENBQUNSLFNBQVNwQyxHQUFNLEdBQUE7QUFDbEI7O0FBRUYsWUFBTTZCLFdBQVcsQ0FBQTtBQUNqQixpQkFBV2dCLFVBQVVSLGtCQUFrQjtBQUNyQ1IsaUJBQVNnQixNQUFBQSxJQUFVN0MsSUFBSTZDLE1BQU87TUFDaEM7QUFFQ0MsT0FBQUEsUUFBUTlDLElBQUkrQyxVQUFVLEtBQUsvQyxJQUFJK0MsY0FBYztRQUFDSDtNQUFJLEdBQUV6RyxRQUFRLENBQUMrRCxTQUFTO0FBQ3JFLFlBQUlBLFNBQVMwQyxPQUFPLENBQUNGLGNBQWNuRSxJQUFJMkIsSUFBTyxHQUFBO0FBQzVDd0Msd0JBQWN6RSxJQUFJaUMsTUFBTTJCLFFBQUFBOztNQUU1QixDQUFBO0lBQ0YsQ0FBQTtFQUNGO0VBTUFtQixnQkFBZ0IvQyxRQUFRZ0QsUUFBUTtBQUM5QixVQUFNQyxhQUFhRCxPQUFPRTtBQUMxQixVQUFNQSxVQUFVQyxxQkFBcUJuRCxRQUFRaUQsVUFBQUE7QUFDN0MsUUFBSSxDQUFDQyxTQUFTO0FBQ1osYUFBTyxDQUFBOztBQUdULFVBQU1FLGFBQWEsS0FBS0Msa0JBQWtCSCxTQUFTRCxVQUFBQTtBQUNuRCxRQUFJQSxXQUFXSyxTQUFTO0FBSXRCQyxlQUFTdkQsT0FBT2tELFFBQVFNLGFBQWFQLFVBQVlRLEVBQUFBLEtBQUssTUFBTTtBQUMxRHpELGVBQU9rRCxVQUFVRDtNQUNuQixHQUFHLE1BQU07TUFFVCxDQUFBOztBQUdGLFdBQU9HO0VBQ1Q7RUFLQUMsa0JBQWtCckQsUUFBUWdELFFBQVE7QUFDaEMsVUFBTVAsZ0JBQWdCLEtBQUtSO0FBQzNCLFVBQU1tQixhQUFhLENBQUE7QUFDbkIsVUFBTW5HLFVBQVUrQyxPQUFPd0QsZ0JBQWdCeEQsT0FBT3dELGNBQWMsQ0FBQTtBQUM1RCxVQUFNRSxRQUFRckIsT0FBT0MsS0FBS1UsTUFBQUE7QUFDMUIsVUFBTXBILE9BQU9rQixLQUFLQyxJQUFHO0FBQ3JCLFFBQUlLO0FBRUosU0FBS0EsS0FBSXNHLE1BQU12RyxTQUFTLEdBQUdDLE1BQUssR0FBRyxFQUFFQSxJQUFHO0FBQ3RDLFlBQU02QyxPQUFPeUQsTUFBTXRHLEVBQUU7QUFDckIsVUFBSTZDLEtBQUswRCxPQUFPLENBQUEsTUFBTyxLQUFLO0FBQzFCOztBQUdGLFVBQUkxRCxTQUFTLFdBQVc7QUFDdEJtRCxtQkFBV2hGLEtBQVEsR0FBQSxLQUFLMkUsZ0JBQWdCL0MsUUFBUWdELE1BQUFBLENBQUFBO0FBQ2hEOztBQUVGLFlBQU1ZLFFBQVFaLE9BQU8vQyxJQUFLO0FBQzFCLFVBQUl1QyxZQUFZdkYsUUFBUWdELElBQUs7QUFDN0IsWUFBTUYsTUFBTTBDLGNBQWM1RSxJQUFJb0MsSUFBQUE7QUFFOUIsVUFBSXVDLFdBQVc7QUFDYixZQUFJekMsT0FBT3lDLFVBQVVyQixPQUFNLEdBQUk7QUFFN0JxQixvQkFBVXBCLE9BQU9yQixLQUFLNkQsT0FBT2hJLElBQUFBO0FBQzdCO2VBQ0s7QUFDTDRHLG9CQUFVM0QsT0FBTTs7O0FBR3BCLFVBQUksQ0FBQ2tCLE9BQU8sQ0FBQ0EsSUFBSTlELFVBQVU7QUFFekIrRCxlQUFPQyxJQUFBQSxJQUFRMkQ7QUFDZjs7QUFHRjNHLGNBQVFnRCxJQUFBQSxJQUFRdUMsWUFBWSxJQUFJMUMsVUFBVUMsS0FBS0MsUUFBUUMsTUFBTTJELEtBQUFBO0FBQzdEUixpQkFBV2hGLEtBQUtvRSxTQUFBQTtJQUNsQjtBQUNBLFdBQU9ZO0VBQ1Q7RUFTQWhDLE9BQU9wQixRQUFRZ0QsUUFBUTtBQUNyQixRQUFJLEtBQUtmLFlBQVk0QixTQUFTLEdBQUc7QUFFL0J4QixhQUFPeUIsT0FBTzlELFFBQVFnRCxNQUFBQTtBQUN0Qjs7QUFHRixVQUFNSSxhQUFhLEtBQUtDLGtCQUFrQnJELFFBQVFnRCxNQUFBQTtBQUVsRCxRQUFJSSxXQUFXakcsUUFBUTtBQUNyQjRHLGVBQVMxRixJQUFJLEtBQUsyRCxRQUFRb0IsVUFBQUE7QUFDMUIsYUFBTzs7RUFFWDtBQUNGO0FBRUEsU0FBU0csU0FBU0gsWUFBWU4sWUFBWTtBQUN4QyxRQUFNN0YsVUFBVSxDQUFBO0FBQ2hCLFFBQU1xRixPQUFPRCxPQUFPQyxLQUFLUSxVQUFBQTtBQUN6QixXQUFTMUYsS0FBSSxHQUFHQSxLQUFJa0YsS0FBS25GLFFBQVFDLE1BQUs7QUFDcEMsVUFBTTRHLE9BQU9aLFdBQVdkLEtBQUtsRixFQUFBQSxDQUFFO0FBQy9CLFFBQUk0RyxRQUFRQSxLQUFLN0MsT0FBTSxHQUFJO0FBQ3pCbEUsY0FBUW1CLEtBQUs0RixLQUFLekMsS0FBSSxDQUFBOztFQUUxQjtBQUVBLFNBQU9FLFFBQVF3QyxJQUFJaEgsT0FBQUE7QUFDckI7QUFFQSxTQUFTa0cscUJBQXFCbkQsUUFBUWlELFlBQVk7QUFDaEQsTUFBSSxDQUFDQSxZQUFZO0FBQ2Y7O0FBRUYsTUFBSUMsVUFBVWxELE9BQU9rRDtBQUNyQixNQUFJLENBQUNBLFNBQVM7QUFDWmxELFdBQU9rRCxVQUFVRDtBQUNqQjs7QUFFRixNQUFJQyxRQUFRSSxTQUFTO0FBR25CdEQsV0FBT2tELFVBQVVBLFVBQVViLE9BQU95QixPQUFPLENBQUEsR0FBSVosU0FBUztNQUFDSSxTQUFTO01BQU9FLGFBQWEsQ0FBQTtJQUFFLENBQUE7O0FBRXhGLFNBQU9OO0FBQ1Q7QUN0SkEsU0FBU2dCLFVBQVVDLE9BQU9DLGlCQUFpQjtBQUN6QyxRQUFNQyxPQUFPRixTQUFTQSxNQUFNakIsV0FBVyxDQUFBO0FBQ3ZDLFFBQU1vQixVQUFVRCxLQUFLQztBQUNyQixRQUFNL0gsTUFBTThILEtBQUs5SCxRQUFRZixTQUFZNEksa0JBQWtCO0FBQ3ZELFFBQU0xRixNQUFNMkYsS0FBSzNGLFFBQVFsRCxTQUFZNEksa0JBQWtCO0FBQ3ZELFNBQU87SUFDTDVILE9BQU84SCxVQUFVNUYsTUFBTW5DO0lBQ3ZCZ0ksS0FBS0QsVUFBVS9ILE1BQU1tQztFQUN2QjtBQUNGO0FBRUEsU0FBUzhGLFlBQVlDLFFBQVFDLFFBQVFOLGlCQUFpQjtBQUNwRCxNQUFJQSxvQkFBb0IsT0FBTztBQUM3QixXQUFPOztBQUVULFFBQU1PLEtBQUlULFVBQVVPLFFBQVFMLGVBQUFBO0FBQzVCLFFBQU1RLEtBQUlWLFVBQVVRLFFBQVFOLGVBQUFBO0FBRTVCLFNBQU87SUFDTFMsS0FBS0QsR0FBRUw7SUFDUE8sT0FBT0gsR0FBRUo7SUFDVFEsUUFBUUgsR0FBRXBJO0lBQ1Z3SSxNQUFNTCxHQUFFbkk7RUFDVjtBQUNGO0FBRUEsU0FBU3lJLE9BQU9yQixPQUFPO0FBQ3JCLE1BQUlzQixJQUFHQyxJQUFHQyxJQUFHQztBQUViLE1BQUlsRCxTQUFTeUIsS0FBUSxHQUFBO0FBQ25Cc0IsSUFBQUEsS0FBSXRCLE1BQU1pQjtBQUNWTSxJQUFBQSxLQUFJdkIsTUFBTWtCO0FBQ1ZNLElBQUFBLEtBQUl4QixNQUFNbUI7QUFDVk0sSUFBQUEsS0FBSXpCLE1BQU1vQjtTQUNMO0FBQ0xFLElBQUFBLEtBQUlDLEtBQUlDLEtBQUlDLEtBQUl6Qjs7QUFHbEIsU0FBTztJQUNMaUIsS0FBS0s7SUFDTEosT0FBT0s7SUFDUEosUUFBUUs7SUFDUkosTUFBTUs7SUFDTkMsVUFBVTFCLFVBQVU7RUFDdEI7QUFDRjtBQUVBLFNBQVMyQix3QkFBd0I3SixPQUFPOEosZUFBZTtBQUNyRCxRQUFNbEQsT0FBTyxDQUFBO0FBQ2IsUUFBTW1ELFdBQVcvSixNQUFNZ0ssdUJBQXVCRixhQUFBQTtBQUM5QyxNQUFJcEksSUFBR3VJO0FBRVAsT0FBS3ZJLEtBQUksR0FBR3VJLE9BQU9GLFNBQVN0SSxRQUFRQyxLQUFJdUksTUFBTSxFQUFFdkksSUFBRztBQUNqRGtGLFNBQUtsRSxLQUFLcUgsU0FBU3JJLEVBQUFBLEVBQUd3SSxLQUFLO0VBQzdCO0FBQ0EsU0FBT3REO0FBQ1Q7QUFFQSxTQUFTdUQsV0FBV0MsT0FBT2xDLE9BQU9tQyxTQUFTN0MsVUFBVSxDQUFBLEdBQUk7QUFDdkQsUUFBTVosT0FBT3dELE1BQU14RDtBQUNuQixRQUFNMEQsYUFBYTlDLFFBQVErQyxTQUFTO0FBQ3BDLE1BQUk3SSxJQUFHdUksTUFBTU8sY0FBY0M7QUFFM0IsTUFBSXZDLFVBQVUsTUFBTTtBQUNsQjs7QUFHRixNQUFJd0MsUUFBUTtBQUNaLE9BQUtoSixLQUFJLEdBQUd1SSxPQUFPckQsS0FBS25GLFFBQVFDLEtBQUl1SSxNQUFNLEVBQUV2SSxJQUFHO0FBQzdDOEksbUJBQWUsQ0FBQzVELEtBQUtsRixFQUFFO0FBQ3ZCLFFBQUk4SSxpQkFBaUJILFNBQVM7QUFDNUJLLGNBQVE7QUFDUixVQUFJbEQsUUFBUWUsS0FBSztBQUNmOztBQUVGOztBQUVGa0MsaUJBQWFMLE1BQU05QyxPQUFPa0QsWUFBYTtBQUN2QyxRQUFJRyxlQUFTRixVQUFnQkgsTUFBQUEsY0FBZXBDLFVBQVUsS0FBSzBDLEtBQUsxQyxLQUFBQSxNQUFXMEMsS0FBS0gsVUFBQUEsSUFBZTtBQUM3RnZDLGVBQVN1Qzs7RUFFYjtBQUVBLE1BQUksQ0FBQ0MsU0FBUyxDQUFDbEQsUUFBUWUsS0FBSztBQUMxQixXQUFPOztBQUdULFNBQU9MO0FBQ1Q7QUFFQSxTQUFTMkMseUJBQXlCQyxNQUFNQyxNQUFNO0FBQzVDLFFBQU0sRUFBQ0MsUUFBUUMsT0FBQUEsSUFBVUY7QUFDekIsUUFBTUcsV0FBV0YsT0FBT0csU0FBUyxNQUFNLE1BQU07QUFDN0MsUUFBTUMsV0FBV0gsT0FBT0UsU0FBUyxNQUFNLE1BQU07QUFDN0MsUUFBTXZFLE9BQU9ELE9BQU9DLEtBQUtrRSxJQUFBQTtBQUN6QixRQUFNTyxRQUFRLElBQUlDLE1BQU0xRSxLQUFLbkYsTUFBTTtBQUNuQyxNQUFJQyxJQUFHdUksTUFBTWhEO0FBQ2IsT0FBS3ZGLEtBQUksR0FBR3VJLE9BQU9yRCxLQUFLbkYsUUFBUUMsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDN0N1RixVQUFNTCxLQUFLbEYsRUFBRTtBQUNiMkosVUFBTTNKLEVBQUFBLElBQUs7TUFDVCxDQUFDd0osUUFBQUEsR0FBV2pFO01BQ1osQ0FBQ21FLFFBQVMsR0FBRU4sS0FBSzdELEdBQUk7SUFDdkI7RUFDRjtBQUNBLFNBQU9vRTtBQUNUO0FBRUEsU0FBU0UsVUFBVTlDLE9BQU9zQyxNQUFNO0FBQzlCLFFBQU1TLFVBQVUvQyxTQUFTQSxNQUFNakIsUUFBUWdFO0FBQ3ZDLFNBQU9BLFdBQVlBLFlBQVkxTCxVQUFhaUwsS0FBS1gsVUFBVXRLO0FBQzdEO0FBRUEsU0FBUzJMLFlBQVlDLFlBQVlDLFlBQVlaLE1BQU07QUFDakQsU0FBTyxHQUFHVyxXQUFXRSxFQUFFLElBQUlELFdBQVdDLEVBQUUsSUFBSWIsS0FBS1gsU0FBU1csS0FBSzVLLElBQUk7QUFDckU7QUFFQSxTQUFTMEwsY0FBY3BELE9BQU87QUFDNUIsUUFBTSxFQUFDNUgsS0FBS21DLEtBQUs4SSxZQUFZQyxXQUFVLElBQUl0RCxNQUFNb0QsY0FBYTtBQUM5RCxTQUFPO0lBQ0xoTCxLQUFLaUwsYUFBYWpMLE1BQU1tTCxPQUFPQztJQUMvQmpKLEtBQUsrSSxhQUFhL0ksTUFBTWdKLE9BQU9FO0VBQ2pDO0FBQ0Y7QUFFQSxTQUFTQyxpQkFBaUJDLFFBQVFDLFVBQVVDLFlBQVk7QUFDdEQsUUFBTUMsV0FBV0gsT0FBT0MsUUFBUyxNQUFLRCxPQUFPQyxRQUFBQSxJQUFZLENBQUE7QUFDekQsU0FBT0UsU0FBU0QsVUFBQUEsTUFBZ0JDLFNBQVNELFVBQUFBLElBQWMsQ0FBQTtBQUN6RDtBQUVBLFNBQVNFLG9CQUFvQnBDLE9BQU9hLFFBQVF3QixVQUFVdE0sTUFBTTtBQUMxRCxhQUFXNEssUUFBUUUsT0FBT3lCLHdCQUF3QnZNLElBQUFBLEVBQU15SSxRQUFPLEdBQUk7QUFDakUsVUFBTVYsUUFBUWtDLE1BQU1XLEtBQUtiLEtBQUs7QUFDOUIsUUFBSSxZQUFhaEMsUUFBUSxLQUFPLENBQUN1RSxZQUFZdkUsUUFBUSxHQUFJO0FBQ3ZELGFBQU82QyxLQUFLYjs7RUFFaEI7QUFFQSxTQUFPO0FBQ1Q7QUFFQSxTQUFTeUMsYUFBYUMsWUFBWUMsUUFBUTtBQUN4QyxRQUFNLEVBQUM3TSxPQUFPOE0sYUFBYS9CLEtBQUFBLElBQVE2QjtBQUNuQyxRQUFNUixTQUFTcE0sTUFBTStNLFlBQVkvTSxNQUFNK00sVUFBVSxDQUFBO0FBQ2pELFFBQU0sRUFBQy9CLFFBQVFDLFFBQVFmLE9BQU9NLGFBQUFBLElBQWdCTztBQUM5QyxRQUFNaUMsUUFBUWhDLE9BQU9HO0FBQ3JCLFFBQU04QixRQUFRaEMsT0FBT0U7QUFDckIsUUFBTWxFLE1BQU13RSxZQUFZVCxRQUFRQyxRQUFRRixJQUFBQTtBQUN4QyxRQUFNZCxPQUFPNEMsT0FBT3BMO0FBQ3BCLE1BQUkySTtBQUVKLFdBQVMxSSxLQUFJLEdBQUdBLEtBQUl1SSxNQUFNLEVBQUV2SSxJQUFHO0FBQzdCLFVBQU1FLE9BQU9pTCxPQUFPbkwsRUFBRTtBQUN0QixVQUFNLEVBQUMsQ0FBQ3NMLEtBQUFBLEdBQVE5QyxPQUFPLENBQUMrQyxLQUFNLEdBQUUvRSxNQUFLLElBQUl0RztBQUN6QyxVQUFNc0wsYUFBYXRMLEtBQUttTCxZQUFZbkwsS0FBS21MLFVBQVUsQ0FBQTtBQUNuRDNDLFlBQVE4QyxXQUFXRCxLQUFBQSxJQUFTZCxpQkFBaUJDLFFBQVFuRixLQUFLaUQsS0FBQUE7QUFDMURFLFVBQU1JLFlBQUFBLElBQWdCdEM7QUFFdEJrQyxVQUFNK0MsT0FBT1gsb0JBQW9CcEMsT0FBT2EsUUFBUSxNQUFNRixLQUFLNUssSUFBSTtBQUMvRGlLLFVBQU1nRCxVQUFVWixvQkFBb0JwQyxPQUFPYSxRQUFRLE9BQU9GLEtBQUs1SyxJQUFJO0FBRW5FLFVBQU1rTixlQUFlakQsTUFBTWtELGtCQUFrQmxELE1BQU1rRCxnQkFBZ0IsQ0FBQTtBQUNuRUQsaUJBQWE3QyxZQUFBQSxJQUFnQnRDO0VBQy9CO0FBQ0Y7QUFFQSxTQUFTcUYsZ0JBQWdCdk4sT0FBT21MLE1BQU07QUFDcEMsUUFBTXFDLFNBQVN4TixNQUFNd047QUFDckIsU0FBTzdHLE9BQU9DLEtBQUs0RyxNQUFBQSxFQUFRQyxPQUFPeEcsQ0FBQUEsUUFBT3VHLE9BQU92RyxHQUFJLEVBQUNrRSxTQUFTQSxJQUFBQSxFQUFNdUMsTUFBSztBQUMzRTtBQUVBLFNBQVNDLHFCQUFxQkMsUUFBUTFELE9BQU87QUFDM0MsU0FBTzJELGNBQWNELFFBQ25CO0lBQ0VuSSxRQUFRO0lBQ1JxSSxTQUFTaE87SUFDVDBLLGNBQWNOO0lBQ2RBO0lBQ0FLLE1BQU07SUFDTnBLLE1BQU07RUFDUixDQUFBO0FBRUo7QUFFQSxTQUFTNE4sa0JBQWtCSCxRQUFRMUQsT0FBTzhELFNBQVM7QUFDakQsU0FBT0gsY0FBY0QsUUFBUTtJQUMzQm5JLFFBQVE7SUFDUndJLFdBQVcvRDtJQUNYMkMsUUFBUS9NO0lBQ1JvTyxLQUFLcE87SUFDTGtPO0lBQ0E5RDtJQUNBSyxNQUFNO0lBQ05wSyxNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRUEsU0FBU2dPLFlBQVlwRCxNQUFNdkosT0FBTztBQUVoQyxRQUFNZ0osZUFBZU8sS0FBSzZCLFdBQVcxQztBQUNyQyxRQUFNaUIsT0FBT0osS0FBS0UsVUFBVUYsS0FBS0UsT0FBT0U7QUFDeEMsTUFBSSxDQUFDQSxNQUFNO0FBQ1Q7O0FBR0YzSixVQUFRQSxTQUFTdUosS0FBS3FEO0FBQ3RCLGFBQVd2QixVQUFVckwsT0FBTztBQUMxQixVQUFNNEssU0FBU1MsT0FBT0U7QUFDdEIsUUFBSSxDQUFDWCxVQUFVQSxPQUFPakIsSUFBSyxNQUFLckwsVUFBYXNNLE9BQU9qQixJQUFBQSxFQUFNWCxZQUFBQSxNQUFrQjFLLFFBQVc7QUFDckY7O0FBRUYsV0FBT3NNLE9BQU9qQixJQUFLLEVBQUNYLFlBQWE7QUFDakMsUUFBSTRCLE9BQU9qQixJQUFLLEVBQUNtQyxrQkFBa0J4TixVQUFhc00sT0FBT2pCLElBQUFBLEVBQU1tQyxjQUFjOUMsWUFBQUEsTUFBa0IxSyxRQUFXO0FBQ3RHLGFBQU9zTSxPQUFPakIsSUFBQUEsRUFBTW1DLGNBQWM5QyxZQUFhOztFQUVuRDtBQUNGO0FBRUEsSUFBTTZELHFCQUFxQixDQUFDOUQsU0FBU0EsU0FBUyxXQUFXQSxTQUFTO0FBQ2xFLElBQU0rRCxtQkFBbUIsQ0FBQ0MsUUFBUUMsV0FBV0EsU0FBU0QsU0FBUzVILE9BQU95QixPQUFPLENBQUEsR0FBSW1HLE1BQU87QUFDeEYsSUFBTUUsY0FBYyxDQUFDQyxVQUFVM0QsTUFBTS9LLFVBQVUwTyxZQUFZLENBQUMzRCxLQUFLNEQsVUFBVTVELEtBQUs2RCxZQUMzRTtFQUFDaEksTUFBTWlELHdCQUF3QjdKLE9BQU8sSUFBSTtFQUFHc0gsUUFBUTtBQUFJO0FBRS9DLElBQU11SCxvQkFBTixNQUFNQTtFQXFCbkJyUCxZQUFZUSxPQUFPd0ssY0FBYztBQUMvQixTQUFLeEssUUFBUUE7QUFDYixTQUFLOE8sT0FBTzlPLE1BQU0rTztBQUNsQixTQUFLN0UsUUFBUU07QUFDYixTQUFLd0Usa0JBQWtCLENBQUE7QUFDdkIsU0FBS2xDLGNBQWMsS0FBS21DLFFBQU87QUFDL0IsU0FBS0MsUUFBUSxLQUFLcEMsWUFBWTNNO0FBQzlCLFNBQUtxSCxVQUFVMUg7QUFFZixTQUFLcVAsV0FBVztBQUNoQixTQUFLQyxRQUFRdFA7QUFDYixTQUFLdVAsY0FBY3ZQO0FBQ25CLFNBQUt3UCxpQkFBaUJ4UDtBQUN0QixTQUFLeVAsYUFBYXpQO0FBQ2xCLFNBQUswUCxhQUFhMVA7QUFDbEIsU0FBSzJQLHNCQUFzQjtBQUMzQixTQUFLQyxxQkFBcUI7QUFDMUIsU0FBS0MsV0FBVzdQO0FBQ2hCLFNBQUs4UCxZQUFZLENBQUE7QUFDakIsU0FBS0MscUJBQXFCLFdBQVdBO0FBQ3JDLFNBQUtDLGtCQUFrQixXQUFXQTtBQUVsQyxTQUFLQyxXQUFVO0VBQ2pCO0VBRUFBLGFBQWE7QUFDWCxVQUFNaEYsT0FBTyxLQUFLK0I7QUFDbEIsU0FBS3RHLFVBQVM7QUFDZCxTQUFLd0osV0FBVTtBQUNmakYsU0FBSzZELFdBQVdyRCxVQUFVUixLQUFLRSxRQUFRRixJQUFBQTtBQUN2QyxTQUFLa0YsWUFBVztBQUVoQixRQUFJLEtBQUt6SSxRQUFRMEksUUFBUSxDQUFDLEtBQUtsUSxNQUFNbVEsZ0JBQWdCLFFBQVcsR0FBQTtBQUM5REMsY0FBUUMsS0FBSyxvS0FBQTs7RUFFakI7RUFFQUMsWUFBWTlGLGNBQWM7QUFDeEIsUUFBSSxLQUFLTixVQUFVTSxjQUFjO0FBQy9CMkQsa0JBQVksS0FBS3JCLFdBQVc7O0FBRTlCLFNBQUs1QyxRQUFRTTtFQUNmO0VBRUF3RixhQUFhO0FBQ1gsVUFBTWhRLFFBQVEsS0FBS0E7QUFDbkIsVUFBTStLLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU1nQixVQUFVLEtBQUt5QyxXQUFVO0FBRS9CLFVBQU1DLFdBQVcsQ0FBQ3JGLE1BQU1sQyxJQUFHQyxJQUFHTyxPQUFNMEIsU0FBUyxNQUFNbEMsS0FBSWtDLFNBQVMsTUFBTTFCLEtBQUlQO0FBRTFFLFVBQU11SCxNQUFNMUYsS0FBSzJGLFVBQVVDLGVBQWU3QyxRQUFRNEMsU0FBU25ELGdCQUFnQnZOLE9BQU8sR0FBQSxDQUFBO0FBQ2xGLFVBQU00USxNQUFNN0YsS0FBSzhGLFVBQVVGLGVBQWU3QyxRQUFRK0MsU0FBU3RELGdCQUFnQnZOLE9BQU8sR0FBQSxDQUFBO0FBQ2xGLFVBQU04USxNQUFNL0YsS0FBS2dHLFVBQVVKLGVBQWU3QyxRQUFRaUQsU0FBU3hELGdCQUFnQnZOLE9BQU8sR0FBQSxDQUFBO0FBQ2xGLFVBQU1nUixZQUFZakcsS0FBS2lHO0FBQ3ZCLFVBQU1DLE1BQU1sRyxLQUFLbUcsVUFBVVYsU0FBU1EsV0FBV1AsS0FBS0csS0FBS0UsR0FBQUE7QUFDekQsVUFBTUssTUFBTXBHLEtBQUtxRyxVQUFVWixTQUFTUSxXQUFXSixLQUFLSCxLQUFLSyxHQUFBQTtBQUN6RC9GLFNBQUtoQyxTQUFTLEtBQUtzSSxjQUFjWixHQUFBQTtBQUNqQzFGLFNBQUsvQixTQUFTLEtBQUtxSSxjQUFjVCxHQUFBQTtBQUNqQzdGLFNBQUt1RyxTQUFTLEtBQUtELGNBQWNQLEdBQUFBO0FBQ2pDL0YsU0FBS0MsU0FBUyxLQUFLcUcsY0FBY0osR0FBQUE7QUFDakNsRyxTQUFLRSxTQUFTLEtBQUtvRyxjQUFjRixHQUFBQTtFQUNuQztFQUVBWixhQUFhO0FBQ1gsV0FBTyxLQUFLdlEsTUFBTThLLEtBQUt5RyxTQUFTLEtBQUtySCxLQUFLO0VBQzVDO0VBRUErRSxVQUFVO0FBQ1IsV0FBTyxLQUFLalAsTUFBTXdSLGVBQWUsS0FBS3RILEtBQUs7RUFDN0M7RUFNQW1ILGNBQWNJLFNBQVM7QUFDckIsV0FBTyxLQUFLelIsTUFBTXdOLE9BQU9pRSxPQUFRO0VBQ25DO0VBS0FDLGVBQWVqSixPQUFPO0FBQ3BCLFVBQU1zQyxPQUFPLEtBQUsrQjtBQUNsQixXQUFPckUsVUFBVXNDLEtBQUtDLFNBQ2xCRCxLQUFLRSxTQUNMRixLQUFLQztFQUNYO0VBRUEyRyxRQUFRO0FBQ04sU0FBS3hRLFFBQVEsT0FBQTtFQUNmO0VBS0F5USxXQUFXO0FBQ1QsVUFBTTdHLE9BQU8sS0FBSytCO0FBQ2xCLFFBQUksS0FBS3NDLE9BQU87QUFDZHlDLDBCQUFvQixLQUFLekMsT0FBTyxJQUFJOztBQUV0QyxRQUFJckUsS0FBSzZELFVBQVU7QUFDakJULGtCQUFZcEQsSUFBQUE7O0VBRWhCO0VBS0ErRyxhQUFhO0FBQ1gsVUFBTWhFLFVBQVUsS0FBS3lDLFdBQVU7QUFDL0IsVUFBTXpGLE9BQU9nRCxRQUFRaEQsU0FBU2dELFFBQVFoRCxPQUFPLENBQUE7QUFDN0MsVUFBTXNFLFFBQVEsS0FBS0E7QUFNbkIsUUFBSTNJLFNBQVNxRSxJQUFPLEdBQUE7QUFDbEIsWUFBTUMsT0FBTyxLQUFLK0I7QUFDbEIsV0FBS3NDLFFBQVF2RSx5QkFBeUJDLE1BQU1DLElBQUFBO2VBQ25DcUUsVUFBVXRFLE1BQU07QUFDekIsVUFBSXNFLE9BQU87QUFFVHlDLDRCQUFvQnpDLE9BQU8sSUFBSTtBQUUvQixjQUFNckUsT0FBTyxLQUFLK0I7QUFDbEJxQixvQkFBWXBELElBQUFBO0FBQ1pBLGFBQUtxRCxVQUFVLENBQUE7O0FBRWpCLFVBQUl0RCxRQUFRbkUsT0FBT29MLGFBQWFqSCxJQUFPLEdBQUE7QUFDckNrSCwwQkFBa0JsSCxNQUFNLElBQUk7O0FBRTlCLFdBQUs4RSxZQUFZLENBQUE7QUFDakIsV0FBS1IsUUFBUXRFOztFQUVqQjtFQUVBbUYsY0FBYztBQUNaLFVBQU1sRixPQUFPLEtBQUsrQjtBQUVsQixTQUFLZ0YsV0FBVTtBQUVmLFFBQUksS0FBS2pDLG9CQUFvQjtBQUMzQjlFLFdBQUsrQyxVQUFVLElBQUksS0FBSytCLG1CQUFrQjs7RUFFOUM7RUFFQW9DLHNCQUFzQkMsa0JBQWtCO0FBQ3RDLFVBQU1uSCxPQUFPLEtBQUsrQjtBQUNsQixVQUFNZ0IsVUFBVSxLQUFLeUMsV0FBVTtBQUMvQixRQUFJNEIsZUFBZTtBQUVuQixTQUFLTCxXQUFVO0FBR2YsVUFBTU0sYUFBYXJILEtBQUs2RDtBQUN4QjdELFNBQUs2RCxXQUFXckQsVUFBVVIsS0FBS0UsUUFBUUYsSUFBQUE7QUFHdkMsUUFBSUEsS0FBS1gsVUFBVTBELFFBQVExRCxPQUFPO0FBQ2hDK0gscUJBQWU7QUFFZmhFLGtCQUFZcEQsSUFBQUE7QUFDWkEsV0FBS1gsUUFBUTBELFFBQVExRDs7QUFLdkIsU0FBS2lJLGdCQUFnQkgsZ0JBQUFBO0FBR3JCLFFBQUlDLGdCQUFnQkMsZUFBZXJILEtBQUs2RCxVQUFVO0FBQ2hEakMsbUJBQWEsTUFBTTVCLEtBQUtxRCxPQUFPO0FBQy9CckQsV0FBSzZELFdBQVdyRCxVQUFVUixLQUFLRSxRQUFRRixJQUFBQTs7RUFFM0M7RUFNQXZFLFlBQVk7QUFDVixVQUFNSCxTQUFTLEtBQUtyRyxNQUFNcUc7QUFDMUIsVUFBTWlNLFlBQVlqTSxPQUFPa00saUJBQWlCLEtBQUtyRCxLQUFLO0FBQ3BELFVBQU1zRCxTQUFTbk0sT0FBT29NLGdCQUFnQixLQUFLbEMsV0FBVSxHQUFJK0IsV0FBVyxJQUFJO0FBQ3hFLFNBQUs5SyxVQUFVbkIsT0FBT3FNLGVBQWVGLFFBQVEsS0FBS0csV0FBVSxDQUFBO0FBQzVELFNBQUt4RCxXQUFXLEtBQUszSCxRQUFRb0w7QUFDN0IsU0FBSzVELGtCQUFrQixDQUFBO0VBQ3pCO0VBTUE2RCxNQUFNL1IsT0FBT2dTLE9BQU87QUFDbEIsVUFBTSxFQUFDaEcsYUFBYS9CLE1BQU1xRSxPQUFPdEUsS0FBSSxJQUFJO0FBQ3pDLFVBQU0sRUFBQ0UsUUFBUTRELFNBQUFBLElBQVk3RDtBQUMzQixVQUFNaUMsUUFBUWhDLE9BQU9HO0FBRXJCLFFBQUk0SCxTQUFTalMsVUFBVSxLQUFLZ1MsVUFBVWhJLEtBQUtySixTQUFTLE9BQU9zSixLQUFLaUk7QUFDaEUsUUFBSUMsT0FBT25TLFFBQVEsS0FBS2lLLEtBQUtxRCxRQUFRdE4sUUFBUSxDQUFFO0FBQy9DLFFBQUlZLElBQUdxQixLQUFLOEo7QUFFWixRQUFJLEtBQUtzQyxhQUFhLE9BQU87QUFDM0JwRSxXQUFLcUQsVUFBVXREO0FBQ2ZDLFdBQUtpSSxVQUFVO0FBQ2ZuRyxlQUFTL0I7V0FDSjtBQUNMLFVBQUkzRCxRQUFRMkQsS0FBS2hLLEtBQUFBLENBQU0sR0FBRztBQUN4QitMLGlCQUFTLEtBQUtxRyxlQUFlbkksTUFBTUQsTUFBTWhLLE9BQU9nUyxLQUFBQTtNQUNsRCxXQUFXck0sU0FBU3FFLEtBQUtoSyxLQUFBQSxDQUFNLEdBQUc7QUFDaEMrTCxpQkFBUyxLQUFLc0csZ0JBQWdCcEksTUFBTUQsTUFBTWhLLE9BQU9nUyxLQUFBQTthQUM1QztBQUNMakcsaUJBQVMsS0FBS3VHLG1CQUFtQnJJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7O0FBR3RELFlBQU1PLDZCQUE2QixNQUFNdFEsSUFBSWlLLEtBQUFBLE1BQVcsUUFBU2lHLFFBQVFsUSxJQUFJaUssS0FBQUEsSUFBU2lHLEtBQUtqRyxLQUFNO0FBQ2pHLFdBQUt0TCxLQUFJLEdBQUdBLEtBQUlvUixPQUFPLEVBQUVwUixJQUFHO0FBQzFCcUosYUFBS3FELFFBQVExTSxLQUFJWixLQUFBQSxJQUFTaUMsTUFBTThKLE9BQU9uTCxFQUFFO0FBQ3pDLFlBQUlxUixRQUFRO0FBQ1YsY0FBSU0sMkJBQThCLEdBQUE7QUFDaENOLHFCQUFTOztBQUVYRSxpQkFBT2xROztNQUVYO0FBQ0FnSSxXQUFLaUksVUFBVUQ7O0FBR2pCLFFBQUluRSxVQUFVO0FBQ1pqQyxtQkFBYSxNQUFNRSxNQUFBQTs7RUFFdkI7RUFhQXVHLG1CQUFtQnJJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUMzQyxVQUFNLEVBQUM5SCxRQUFRQyxPQUFBQSxJQUFVRjtBQUN6QixVQUFNaUMsUUFBUWhDLE9BQU9HO0FBQ3JCLFVBQU04QixRQUFRaEMsT0FBT0U7QUFDckIsVUFBTW1JLFNBQVN0SSxPQUFPdUksVUFBUztBQUMvQixVQUFNQyxjQUFjeEksV0FBV0M7QUFDL0IsVUFBTTRCLFNBQVMsSUFBSXZCLE1BQU13SCxLQUFBQTtBQUN6QixRQUFJcFIsSUFBR3VJLE1BQU1DO0FBRWIsU0FBS3hJLEtBQUksR0FBR3VJLE9BQU82SSxPQUFPcFIsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDdkN3SSxjQUFReEksS0FBSVo7QUFDWitMLGFBQU9uTCxFQUFBQSxJQUFLO1FBQ1YsQ0FBQ3NMLEtBQUFBLEdBQVF3RyxlQUFleEksT0FBTzZILE1BQU1TLE9BQU9wSixLQUFBQSxHQUFRQSxLQUFBQTtRQUNwRCxDQUFDK0MsS0FBQUEsR0FBUWhDLE9BQU80SCxNQUFNL0gsS0FBS1osS0FBQUEsR0FBUUEsS0FBQUE7TUFDckM7SUFDRjtBQUNBLFdBQU8yQztFQUNUO0VBYUFxRyxlQUFlbkksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQ3ZDLFVBQU0sRUFBQy9KLFFBQVFDLE9BQUFBLElBQVUrQjtBQUN6QixVQUFNOEIsU0FBUyxJQUFJdkIsTUFBTXdILEtBQUFBO0FBQ3pCLFFBQUlwUixJQUFHdUksTUFBTUMsT0FBT3RJO0FBRXBCLFNBQUtGLEtBQUksR0FBR3VJLE9BQU82SSxPQUFPcFIsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDdkN3SSxjQUFReEksS0FBSVo7QUFDWmMsYUFBT2tKLEtBQUtaLEtBQU07QUFDbEIyQyxhQUFPbkwsRUFBQUEsSUFBSztRQUNWdUgsR0FBR0YsT0FBTzhKLE1BQU1qUixLQUFLLENBQUEsR0FBSXNJLEtBQUFBO1FBQ3pCaEIsR0FBR0YsT0FBTzZKLE1BQU1qUixLQUFLLENBQUEsR0FBSXNJLEtBQUFBO01BQzNCO0lBQ0Y7QUFDQSxXQUFPMkM7RUFDVDtFQWFBc0csZ0JBQWdCcEksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQ3hDLFVBQU0sRUFBQy9KLFFBQVFDLE9BQUFBLElBQVUrQjtBQUN6QixVQUFNLEVBQUMwSSxXQUFXLEtBQUtDLFdBQVcsSUFBQSxJQUFPLEtBQUt2RTtBQUM5QyxVQUFNdEMsU0FBUyxJQUFJdkIsTUFBTXdILEtBQUFBO0FBQ3pCLFFBQUlwUixJQUFHdUksTUFBTUMsT0FBT3RJO0FBRXBCLFNBQUtGLEtBQUksR0FBR3VJLE9BQU82SSxPQUFPcFIsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDdkN3SSxjQUFReEksS0FBSVo7QUFDWmMsYUFBT2tKLEtBQUtaLEtBQU07QUFDbEIyQyxhQUFPbkwsRUFBQUEsSUFBSztRQUNWdUgsR0FBR0YsT0FBTzhKLE1BQU1jLGlCQUFpQi9SLE1BQU02UixRQUFXdkosR0FBQUEsS0FBQUE7UUFDbERoQixHQUFHRixPQUFPNkosTUFBTWMsaUJBQWlCL1IsTUFBTThSLFFBQVd4SixHQUFBQSxLQUFBQTtNQUNwRDtJQUNGO0FBQ0EsV0FBTzJDO0VBQ1Q7RUFLQStHLFVBQVUxSixPQUFPO0FBQ2YsV0FBTyxLQUFLNEMsWUFBWXNCLFFBQVFsRSxLQUFNO0VBQ3hDO0VBS0EySixlQUFlM0osT0FBTztBQUNwQixXQUFPLEtBQUs0QyxZQUFZaEMsS0FBS1osS0FBTTtFQUNyQztFQUtBQyxXQUFXMUIsT0FBT29FLFFBQVF0QyxNQUFNO0FBQzlCLFVBQU12SyxRQUFRLEtBQUtBO0FBQ25CLFVBQU0rSyxPQUFPLEtBQUsrQjtBQUNsQixVQUFNNUUsUUFBUTJFLE9BQU9wRSxNQUFNMEMsSUFBSTtBQUMvQixVQUFNZixRQUFRO01BQ1p4RCxNQUFNaUQsd0JBQXdCN0osT0FBTyxJQUFJO01BQ3pDc0gsUUFBUXVGLE9BQU9FLFFBQVF0RSxNQUFNMEMsSUFBSSxFQUFFbUM7SUFDckM7QUFDQSxXQUFPbkQsV0FBV0MsT0FBT2xDLE9BQU82QyxLQUFLYixPQUFPO01BQUNLO0lBQUksQ0FBQTtFQUNuRDtFQUtBdUosc0JBQXNCQyxRQUFPdEwsT0FBT29FLFFBQVF6QyxPQUFPO0FBQ2pELFVBQU00SixjQUFjbkgsT0FBT3BFLE1BQU0wQyxJQUFJO0FBQ3JDLFFBQUlqRCxRQUFROEwsZ0JBQWdCLE9BQU9DLE1BQU1EO0FBQ3pDLFVBQU0xTSxTQUFTOEMsU0FBU3lDLE9BQU9FLFFBQVF0RSxNQUFNMEMsSUFBSTtBQUNqRCxRQUFJZixTQUFTOUMsUUFBUTtBQUNuQjhDLFlBQU05QyxTQUFTQTtBQUNmWSxjQUFRaUMsV0FBV0MsT0FBTzRKLGFBQWEsS0FBS2xILFlBQVk1QyxLQUFLOztBQUUvRDZKLElBQUFBLE9BQU1sVCxNQUFNRCxLQUFLQyxJQUFJa1QsT0FBTWxULEtBQUtxSCxLQUFBQTtBQUNoQzZMLElBQUFBLE9BQU0vUSxNQUFNcEMsS0FBS29DLElBQUkrUSxPQUFNL1EsS0FBS2tGLEtBQUFBO0VBQ2xDO0VBS0FnTSxVQUFVekwsT0FBT2lHLFVBQVU7QUFDekIsVUFBTTNELE9BQU8sS0FBSytCO0FBQ2xCLFVBQU1zQixVQUFVckQsS0FBS3FEO0FBQ3JCLFVBQU0yRSxTQUFTaEksS0FBS2lJLFdBQVd2SyxVQUFVc0MsS0FBS0M7QUFDOUMsVUFBTWYsT0FBT21FLFFBQVEzTTtBQUNyQixVQUFNMFMsYUFBYSxLQUFLekMsZUFBZWpKLEtBQUFBO0FBQ3ZDLFVBQU0yQixRQUFRcUUsWUFBWUMsVUFBVTNELE1BQU0sS0FBSy9LLEtBQUs7QUFDcEQsVUFBTStULFNBQVE7TUFBQ2xULEtBQUttTCxPQUFPRTtNQUFtQmxKLEtBQUtnSixPQUFPQztJQUFpQjtBQUMzRSxVQUFNLEVBQUNwTCxLQUFLdVQsVUFBVXBSLEtBQUtxUixTQUFRLElBQUl4SSxjQUFjc0ksVUFBQUE7QUFDckQsUUFBSXpTLElBQUdtTDtBQUVQLGFBQVN5SCxRQUFRO0FBQ2Z6SCxlQUFTdUIsUUFBUTFNLEVBQUU7QUFDbkIsWUFBTStJLGFBQWFvQyxPQUFPc0gsV0FBV2hKLElBQUk7QUFDekMsYUFBTyxDQUFDUixlQUFTa0MsT0FBT3BFLE1BQU0wQyxJQUFJLENBQUMsS0FBS2lKLFdBQVczSixjQUFjNEosV0FBVzVKO0lBQzlFO0FBRUEsU0FBSy9JLEtBQUksR0FBR0EsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDekIsVUFBSTRTLE1BQVMsR0FBQTtBQUNYOztBQUVGLFdBQUtSLHNCQUFzQkMsUUFBT3RMLE9BQU9vRSxRQUFRekMsS0FBQUE7QUFDakQsVUFBSTJJLFFBQVE7QUFFVjs7SUFFSjtBQUNBLFFBQUlBLFFBQVE7QUFFVixXQUFLclIsS0FBSXVJLE9BQU8sR0FBR3ZJLE1BQUssR0FBRyxFQUFFQSxJQUFHO0FBQzlCLFlBQUk0UyxNQUFTLEdBQUE7QUFDWDs7QUFFRixhQUFLUixzQkFBc0JDLFFBQU90TCxPQUFPb0UsUUFBUXpDLEtBQUFBO0FBQ2pEO01BQ0Y7O0FBRUYsV0FBTzJKO0VBQ1Q7RUFFQVEsbUJBQW1COUwsT0FBTztBQUN4QixVQUFNb0UsU0FBUyxLQUFLQyxZQUFZc0I7QUFDaEMsVUFBTTlHLFNBQVMsQ0FBQTtBQUNmLFFBQUk1RixJQUFHdUksTUFBTS9CO0FBRWIsU0FBS3hHLEtBQUksR0FBR3VJLE9BQU80QyxPQUFPcEwsUUFBUUMsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDL0N3RyxjQUFRMkUsT0FBT25MLEVBQUFBLEVBQUcrRyxNQUFNMEMsSUFBSTtBQUM1QixVQUFJUixlQUFTekMsS0FBUSxHQUFBO0FBQ25CWixlQUFPNUUsS0FBS3dGLEtBQUFBOztJQUVoQjtBQUNBLFdBQU9aO0VBQ1Q7RUFNQWtOLGlCQUFpQjtBQUNmLFdBQU87RUFDVDtFQUtBQyxpQkFBaUJ2SyxPQUFPO0FBQ3RCLFVBQU1hLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU05QixTQUFTRCxLQUFLQztBQUNwQixVQUFNQyxTQUFTRixLQUFLRTtBQUNwQixVQUFNNEIsU0FBUyxLQUFLK0csVUFBVTFKLEtBQUFBO0FBQzlCLFdBQU87TUFDTHdLLE9BQU8xSixTQUFTLEtBQUtBLE9BQU8ySixpQkFBaUI5SCxPQUFPN0IsT0FBT0csSUFBSSxDQUFDLElBQUk7TUFDcEVqRCxPQUFPK0MsU0FBUyxLQUFLQSxPQUFPMEosaUJBQWlCOUgsT0FBTzVCLE9BQU9FLElBQUksQ0FBQyxJQUFJO0lBQ3RFO0VBQ0Y7RUFLQWhLLFFBQVFvSixNQUFNO0FBQ1osVUFBTVEsT0FBTyxLQUFLK0I7QUFDbEIsU0FBS3BILE9BQU82RSxRQUFRLFNBQUE7QUFDcEJRLFNBQUs2SixRQUFRckwsT0FBT29ILGVBQWUsS0FBS25KLFFBQVFxTixNQUFNL0wsWUFBWWlDLEtBQUtoQyxRQUFRZ0MsS0FBSy9CLFFBQVEsS0FBS3dMLGVBQWMsQ0FBQSxDQUFBLENBQUE7RUFDakg7RUFLQTlPLE9BQU82RSxNQUFNO0VBQUE7RUFFYjVJLE9BQU87QUFDTCxVQUFNb04sTUFBTSxLQUFLRDtBQUNqQixVQUFNOU8sUUFBUSxLQUFLQTtBQUNuQixVQUFNK0ssT0FBTyxLQUFLK0I7QUFDbEIsVUFBTWdJLFdBQVcvSixLQUFLRCxRQUFRLENBQUE7QUFDOUIsVUFBTWlLLE9BQU8vVSxNQUFNZ1Y7QUFDbkIsVUFBTXZQLFNBQVMsQ0FBQTtBQUNmLFVBQU0zRSxRQUFRLEtBQUt5TyxjQUFjO0FBQ2pDLFVBQU11RCxRQUFRLEtBQUt0RCxjQUFlc0YsU0FBU3JULFNBQVNYO0FBQ3BELFVBQU1tVSwwQkFBMEIsS0FBS3pOLFFBQVF5TjtBQUM3QyxRQUFJdlQ7QUFFSixRQUFJcUosS0FBSytDLFNBQVM7QUFDaEIvQyxXQUFLK0MsUUFBUW5NLEtBQUtvTixLQUFLZ0csTUFBTWpVLE9BQU9nUyxLQUFBQTs7QUFHdEMsU0FBS3BSLEtBQUlaLE9BQU9ZLEtBQUlaLFFBQVFnUyxPQUFPLEVBQUVwUixJQUFHO0FBQ3RDLFlBQU1zTSxVQUFVOEcsU0FBU3BULEVBQUU7QUFDM0IsVUFBSXNNLFFBQVFXLFFBQVE7QUFDbEI7O0FBRUYsVUFBSVgsUUFBUXZJLFVBQVV3UCx5QkFBeUI7QUFDN0N4UCxlQUFPL0MsS0FBS3NMLE9BQUFBO2FBQ1A7QUFDTEEsZ0JBQVFyTSxLQUFLb04sS0FBS2dHLElBQUFBOztJQUV0QjtBQUVBLFNBQUtyVCxLQUFJLEdBQUdBLEtBQUkrRCxPQUFPaEUsUUFBUSxFQUFFQyxJQUFHO0FBQ2xDK0QsYUFBTy9ELEVBQUFBLEVBQUdDLEtBQUtvTixLQUFLZ0csSUFBQUE7SUFDdEI7RUFDRjtFQVNBRyxTQUFTaEwsT0FBT3pFLFFBQVE7QUFDdEIsVUFBTThFLE9BQU85RSxTQUFTLFdBQVc7QUFDakMsV0FBT3lFLFVBQVVwSyxVQUFhLEtBQUtnTixZQUFZZ0IsVUFDM0MsS0FBS3FILDZCQUE2QjVLLElBQUFBLElBQ2xDLEtBQUs2SywwQkFBMEJsTCxTQUFTLEdBQUdLLElBQUs7RUFDdEQ7RUFLQW9JLFdBQVd6SSxPQUFPekUsUUFBUThFLE1BQU07QUFDOUIsVUFBTXVELFVBQVUsS0FBS3lDLFdBQVU7QUFDL0IsUUFBSThFO0FBQ0osUUFBSW5MLFNBQVMsS0FBS0EsUUFBUSxLQUFLNEMsWUFBWWhDLEtBQUtySixRQUFRO0FBQ3RELFlBQU11TSxVQUFVLEtBQUtsQixZQUFZaEMsS0FBS1osS0FBTTtBQUM1Q21MLGdCQUFVckgsUUFBUTJCLGFBQ2YzQixRQUFRMkIsV0FBVzVCLGtCQUFrQixLQUFLNEUsV0FBVSxHQUFJekksT0FBTzhELE9BQU87QUFDekVxSCxjQUFReEksU0FBUyxLQUFLK0csVUFBVTFKLEtBQUFBO0FBQ2hDbUwsY0FBUW5ILE1BQU1KLFFBQVFoRCxLQUFLWixLQUFNO0FBQ2pDbUwsY0FBUW5MLFFBQVFtTCxRQUFRcEgsWUFBWS9EO1dBQy9CO0FBQ0xtTCxnQkFBVSxLQUFLMUYsYUFDWixLQUFLQSxXQUFXaEMscUJBQXFCLEtBQUszTixNQUFNMlMsV0FBVSxHQUFJLEtBQUt6SSxLQUFLO0FBQzNFbUwsY0FBUXZILFVBQVVBO0FBQ2xCdUgsY0FBUW5MLFFBQVFtTCxRQUFRN0ssZUFBZSxLQUFLTjs7QUFHOUNtTCxZQUFRNVAsU0FBUyxDQUFDLENBQUNBO0FBQ25CNFAsWUFBUTlLLE9BQU9BO0FBQ2YsV0FBTzhLO0VBQ1Q7RUFNQUYsNkJBQTZCNUssTUFBTTtBQUNqQyxXQUFPLEtBQUsrSyx1QkFBdUIsS0FBS3pGLG1CQUFtQmpFLElBQUlyQixJQUFBQTtFQUNqRTtFQU9BNkssMEJBQTBCbEwsT0FBT0ssTUFBTTtBQUNyQyxXQUFPLEtBQUsrSyx1QkFBdUIsS0FBS3hGLGdCQUFnQmxFLElBQUlyQixNQUFNTCxLQUFBQTtFQUNwRTtFQUtBb0wsdUJBQXVCQyxhQUFhaEwsT0FBTyxXQUFXTCxPQUFPO0FBQzNELFVBQU16RSxTQUFTOEUsU0FBUztBQUN4QixVQUFNaUwsUUFBUSxLQUFLeEc7QUFDbkIsVUFBTXlHLFdBQVdGLGNBQWMsTUFBTWhMO0FBQ3JDLFVBQU1nRSxTQUFTaUgsTUFBTUMsUUFBUztBQUM5QixVQUFNQyxVQUFVLEtBQUtqRyx1QkFBdUJrRyxRQUFRekwsS0FBQUE7QUFDcEQsUUFBSXFFLFFBQVE7QUFDVixhQUFPRCxpQkFBaUJDLFFBQVFtSCxPQUFBQTs7QUFFbEMsVUFBTXJQLFNBQVMsS0FBS3JHLE1BQU1xRztBQUMxQixVQUFNaU0sWUFBWWpNLE9BQU91UCx3QkFBd0IsS0FBSzFHLE9BQU9xRyxXQUFBQTtBQUM3RCxVQUFNTSxXQUFXcFEsU0FBUztNQUFDLEdBQUc4UCxXQUFZO01BQVE7TUFBU0E7TUFBYTtRQUFNO01BQUNBO01BQWE7SUFBRztBQUMvRixVQUFNL0MsU0FBU25NLE9BQU9vTSxnQkFBZ0IsS0FBS2xDLFdBQVUsR0FBSStCLFNBQUFBO0FBQ3pELFVBQU13RCxTQUFRblAsT0FBT0MsS0FBS0MsVUFBU2lPLFNBQVNTLFdBQVksQ0FBQTtBQUd4RCxVQUFNRixVQUFVLE1BQU0sS0FBSzFDLFdBQVd6SSxPQUFPekUsUUFBUThFLElBQUFBO0FBQ3JELFVBQU1qRCxTQUFTakIsT0FBTzBQLG9CQUFvQnZELFFBQVFzRCxRQUFPVCxTQUFTUSxRQUFBQTtBQUVsRSxRQUFJdk8sT0FBT00sU0FBUztBQUdsQk4sYUFBT00sVUFBVThOO0FBS2pCRixZQUFNQyxRQUFTLElBQUc5TyxPQUFPcVAsT0FBTzFILGlCQUFpQmhILFFBQVFvTyxPQUFBQSxDQUFBQTs7QUFHM0QsV0FBT3BPO0VBQ1Q7RUFNQTJPLG1CQUFtQi9MLE9BQU9nTSxZQUFZelEsUUFBUTtBQUM1QyxVQUFNekYsUUFBUSxLQUFLQTtBQUNuQixVQUFNd1YsUUFBUSxLQUFLeEc7QUFDbkIsVUFBTXlHLFdBQVcsYUFBYVMsVUFBQUE7QUFDOUIsVUFBTTNILFNBQVNpSCxNQUFNQyxRQUFTO0FBQzlCLFFBQUlsSCxRQUFRO0FBQ1YsYUFBT0E7O0FBRVQsUUFBSS9HO0FBQ0osUUFBSXhILE1BQU13SCxRQUFRVixjQUFjLE9BQU87QUFDckMsWUFBTVQsU0FBUyxLQUFLckcsTUFBTXFHO0FBQzFCLFlBQU1pTSxZQUFZak0sT0FBTzhQLDBCQUEwQixLQUFLakgsT0FBT2dILFVBQUFBO0FBQy9ELFlBQU0xRCxTQUFTbk0sT0FBT29NLGdCQUFnQixLQUFLbEMsV0FBVSxHQUFJK0IsU0FBQUE7QUFDekQ5SyxnQkFBVW5CLE9BQU9xTSxlQUFlRixRQUFRLEtBQUtHLFdBQVd6SSxPQUFPekUsUUFBUXlRLFVBQUFBLENBQUFBOztBQUV6RSxVQUFNeE8sYUFBYSxJQUFJdEIsV0FBV3BHLE9BQU93SCxXQUFXQSxRQUFRRSxVQUFVO0FBQ3RFLFFBQUlGLFdBQVdBLFFBQVE0TyxZQUFZO0FBQ2pDWixZQUFNQyxRQUFBQSxJQUFZOU8sT0FBT3FQLE9BQU90TyxVQUFBQTs7QUFFbEMsV0FBT0E7RUFDVDtFQU1BMk8saUJBQWlCN08sU0FBUztBQUN4QixRQUFJLENBQUNBLFFBQVFJLFNBQVM7QUFDcEI7O0FBRUYsV0FBTyxLQUFLMEgsbUJBQW1CLEtBQUtBLGlCQUFpQjNJLE9BQU95QixPQUFPLENBQUEsR0FBSVosT0FBTztFQUNoRjtFQU1BOE8sZUFBZS9MLE1BQU1nTSxlQUFlO0FBQ2xDLFdBQU8sQ0FBQ0EsaUJBQWlCbEksbUJBQW1COUQsSUFBQUEsS0FBUyxLQUFLdkssTUFBTXdXO0VBQ2xFO0VBS0FDLGtCQUFrQjNWLE9BQU95SixNQUFNO0FBQzdCLFVBQU1tTSxZQUFZLEtBQUt0QiwwQkFBMEJ0VSxPQUFPeUosSUFBQUE7QUFDeEQsVUFBTW9NLDBCQUEwQixLQUFLckg7QUFDckMsVUFBTWlILGdCQUFnQixLQUFLRixpQkFBaUJLLFNBQUFBO0FBQzVDLFVBQU1KLGlCQUFpQixLQUFLQSxlQUFlL0wsTUFBTWdNLGFBQUFBLEtBQW1CQSxrQkFBa0JJO0FBQ3RGLFNBQUtDLG9CQUFvQkwsZUFBZWhNLE1BQU1tTSxTQUFBQTtBQUM5QyxXQUFPO01BQUNIO01BQWVEO0lBQWM7RUFDdkM7RUFNQU8sY0FBYzdJLFNBQVM5RCxPQUFPOUMsWUFBWW1ELE1BQU07QUFDOUMsUUFBSThELG1CQUFtQjlELElBQU8sR0FBQTtBQUM1QjVELGFBQU95QixPQUFPNEYsU0FBUzVHLFVBQUFBO1dBQ2xCO0FBQ0wsV0FBSzZPLG1CQUFtQi9MLE9BQU9LLElBQU03RSxFQUFBQSxPQUFPc0ksU0FBUzVHLFVBQUFBOztFQUV6RDtFQU1Bd1Asb0JBQW9CTCxlQUFlaE0sTUFBTWhELFlBQVk7QUFDbkQsUUFBSWdQLGlCQUFpQixDQUFDbEksbUJBQW1COUQsSUFBTyxHQUFBO0FBQzlDLFdBQUswTCxtQkFBbUJuVyxRQUFXeUssSUFBTTdFLEVBQUFBLE9BQU82USxlQUFlaFAsVUFBQUE7O0VBRW5FO0VBS0F1UCxVQUFVOUksU0FBUzlELE9BQU9LLE1BQU05RSxRQUFRO0FBQ3RDdUksWUFBUXZJLFNBQVNBO0FBQ2pCLFVBQU0rQixVQUFVLEtBQUswTixTQUFTaEwsT0FBT3pFLE1BQUFBO0FBQ3JDLFNBQUt3USxtQkFBbUIvTCxPQUFPSyxNQUFNOUUsTUFBUUMsRUFBQUEsT0FBT3NJLFNBQVM7TUFHM0R4RyxTQUFTLENBQUUvQixVQUFVLEtBQUs0USxpQkFBaUI3TyxPQUFhQSxLQUFBQTtJQUMxRCxDQUFBO0VBQ0Y7RUFFQXVQLGlCQUFpQi9JLFNBQVN4RCxjQUFjTixPQUFPO0FBQzdDLFNBQUs0TSxVQUFVOUksU0FBUzlELE9BQU8sVUFBVSxLQUFLO0VBQ2hEO0VBRUE4TSxjQUFjaEosU0FBU3hELGNBQWNOLE9BQU87QUFDMUMsU0FBSzRNLFVBQVU5SSxTQUFTOUQsT0FBTyxVQUFVLElBQUk7RUFDL0M7RUFLQStNLDJCQUEyQjtBQUN6QixVQUFNakosVUFBVSxLQUFLbEIsWUFBWWdCO0FBRWpDLFFBQUlFLFNBQVM7QUFDWCxXQUFLOEksVUFBVTlJLFNBQVNsTyxRQUFXLFVBQVUsS0FBSzs7RUFFdEQ7RUFLQW9YLHdCQUF3QjtBQUN0QixVQUFNbEosVUFBVSxLQUFLbEIsWUFBWWdCO0FBRWpDLFFBQUlFLFNBQVM7QUFDWCxXQUFLOEksVUFBVTlJLFNBQVNsTyxRQUFXLFVBQVUsSUFBSTs7RUFFckQ7RUFLQXVTLGdCQUFnQkgsa0JBQWtCO0FBQ2hDLFVBQU1wSCxPQUFPLEtBQUtzRTtBQUNsQixVQUFNMEYsV0FBVyxLQUFLaEksWUFBWWhDO0FBR2xDLGVBQVcsQ0FBQzNFLFFBQVFnUixNQUFNQyxJQUFBQSxLQUFTLEtBQUt4SCxXQUFXO0FBQ2pELFdBQUt6SixNQUFPLEVBQUNnUixNQUFNQyxJQUFBQTtJQUNyQjtBQUNBLFNBQUt4SCxZQUFZLENBQUE7QUFFakIsVUFBTXlILFVBQVV2QyxTQUFTclQ7QUFDekIsVUFBTTZWLFVBQVV4TSxLQUFLcko7QUFDckIsVUFBTXFSLFFBQVFsUyxLQUFLQyxJQUFJeVcsU0FBU0QsT0FBQUE7QUFFaEMsUUFBSXZFLE9BQU87QUFLVCxXQUFLRCxNQUFNLEdBQUdDLEtBQUFBOztBQUdoQixRQUFJd0UsVUFBVUQsU0FBUztBQUNyQixXQUFLRSxnQkFBZ0JGLFNBQVNDLFVBQVVELFNBQVNuRixnQkFBQUE7ZUFDeENvRixVQUFVRCxTQUFTO0FBQzVCLFdBQUtHLGdCQUFnQkYsU0FBU0QsVUFBVUMsT0FBQUE7O0VBRTVDO0VBS0FDLGdCQUFnQnpXLE9BQU9nUyxPQUFPWixtQkFBbUIsTUFBTTtBQUNyRCxVQUFNbkgsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTWhDLE9BQU9DLEtBQUtEO0FBQ2xCLFVBQU1qQyxNQUFNL0gsUUFBUWdTO0FBQ3BCLFFBQUlwUjtBQUVKLFVBQU0rVixPQUFPLENBQUNDLFFBQVE7QUFDcEJBLFVBQUlqVyxVQUFVcVI7QUFDZCxXQUFLcFIsS0FBSWdXLElBQUlqVyxTQUFTLEdBQUdDLE1BQUttSCxLQUFLbkgsTUFBSztBQUN0Q2dXLFlBQUloVyxFQUFFLElBQUdnVyxJQUFJaFcsS0FBSW9SLEtBQU07TUFDekI7SUFDRjtBQUNBMkUsU0FBSzNNLElBQUFBO0FBRUwsU0FBS3BKLEtBQUlaLE9BQU9ZLEtBQUltSCxLQUFLLEVBQUVuSCxJQUFHO0FBQzVCb0osV0FBS3BKLEVBQUUsSUFBRyxJQUFJLEtBQUtvTyxnQkFBZTtJQUNwQztBQUVBLFFBQUksS0FBS1gsVUFBVTtBQUNqQnNJLFdBQUsxTSxLQUFLcUQsT0FBTzs7QUFFbkIsU0FBS3lFLE1BQU0vUixPQUFPZ1MsS0FBQUE7QUFFbEIsUUFBSVosa0JBQWtCO0FBQ3BCLFdBQUt5RixlQUFlN00sTUFBTWhLLE9BQU9nUyxPQUFPLE9BQUE7O0VBRTVDO0VBRUE2RSxlQUFlM0osU0FBU2xOLE9BQU9nUyxPQUFPdkksTUFBTTtFQUFBO0VBSzVDaU4sZ0JBQWdCMVcsT0FBT2dTLE9BQU87QUFDNUIsVUFBTS9ILE9BQU8sS0FBSytCO0FBQ2xCLFFBQUksS0FBS3FDLFVBQVU7QUFDakIsWUFBTXlJLFVBQVU3TSxLQUFLcUQsUUFBUXlKLE9BQU8vVyxPQUFPZ1MsS0FBQUE7QUFDM0MsVUFBSS9ILEtBQUs2RCxVQUFVO0FBQ2pCVCxvQkFBWXBELE1BQU02TSxPQUFBQTs7O0FBR3RCN00sU0FBS0QsS0FBSytNLE9BQU8vVyxPQUFPZ1MsS0FBQUE7RUFDMUI7RUFLQWdGLE1BQU1DLE1BQU07QUFDVixRQUFJLEtBQUs1SSxVQUFVO0FBQ2pCLFdBQUtTLFVBQVVsTixLQUFLcVYsSUFBQUE7V0FDZjtBQUNMLFlBQU0sQ0FBQzVSLFFBQVFnUixNQUFNQyxJQUFBQSxJQUFRVztBQUM3QixXQUFLNVIsTUFBTyxFQUFDZ1IsTUFBTUMsSUFBQUE7O0FBRXJCLFNBQUtwWCxNQUFNZ1ksYUFBYXRWLEtBQUs7TUFBQyxLQUFLd0g7TUFBVTZOLEdBQUFBO0lBQUssQ0FBQTtFQUNwRDtFQUVBRSxjQUFjO0FBQ1osVUFBTW5GLFFBQVFvRixVQUFVelc7QUFDeEIsU0FBS3FXLE1BQU07TUFBQztNQUFtQixLQUFLdkgsV0FBVSxFQUFHekYsS0FBS3JKLFNBQVNxUjtNQUFPQTtJQUFNLENBQUE7RUFDOUU7RUFFQXFGLGFBQWE7QUFDWCxTQUFLTCxNQUFNO01BQUM7TUFBbUIsS0FBS2hMLFlBQVloQyxLQUFLckosU0FBUztNQUFHO0lBQUUsQ0FBQTtFQUNyRTtFQUVBMlcsZUFBZTtBQUNiLFNBQUtOLE1BQU07TUFBQztNQUFtQjtNQUFHO0lBQUUsQ0FBQTtFQUN0QztFQUVBTyxjQUFjdlgsT0FBT2dTLE9BQU87QUFDMUIsUUFBSUEsT0FBTztBQUNULFdBQUtnRixNQUFNO1FBQUM7UUFBbUJoWDtRQUFPZ1M7TUFBTSxDQUFBOztBQUU5QyxVQUFNd0YsV0FBV0osVUFBVXpXLFNBQVM7QUFDcEMsUUFBSTZXLFVBQVU7QUFDWixXQUFLUixNQUFNO1FBQUM7UUFBbUJoWDtRQUFPd1g7TUFBUyxDQUFBOztFQUVuRDtFQUVBQyxpQkFBaUI7QUFDZixTQUFLVCxNQUFNO01BQUM7TUFBbUI7TUFBR0ksVUFBVXpXO0lBQU8sQ0FBQTtFQUNyRDtBQUNGO0FBdDBCRSxjQUxtQm9OLG1CQUtaaEksWUFBVyxDQUFBO0FBS2xCLGNBVm1CZ0ksbUJBVVpnQixzQkFBcUI7QUFLNUIsY0FmbUJoQixtQkFlWmlCLG1CQUFrQjtBQ2xQM0IsU0FBUzBJLGtCQUFrQi9QLE9BQU90SSxNQUFNO0FBQ3RDLE1BQUksQ0FBQ3NJLE1BQU1nUSxPQUFPQyxNQUFNO0FBQ3RCLFVBQU1DLGVBQWVsUSxNQUFNaUUsd0JBQXdCdk0sSUFBQUE7QUFDbkQsUUFBSW1ILFNBQVMsQ0FBQTtBQUViLGFBQVM1RixLQUFJLEdBQUd1SSxPQUFPME8sYUFBYWxYLFFBQVFDLEtBQUl1SSxNQUFNdkksTUFBSztBQUN6RDRGLGVBQVNBLE9BQU9zUixPQUFPRCxhQUFhalgsRUFBQUEsRUFBR2tMLFdBQVcySCxtQkFBbUI5TCxLQUFBQSxDQUFBQTtJQUN2RTtBQUNBQSxVQUFNZ1EsT0FBT0MsT0FBT0csYUFBYXZSLE9BQU93UixLQUFLLENBQUNDLElBQUdyUCxPQUFNcVAsS0FBSXJQLEVBQUFBLENBQUFBOztBQUU3RCxTQUFPakIsTUFBTWdRLE9BQU9DO0FBQ3RCO0FBTUEsU0FBU00scUJBQXFCak8sTUFBTTtBQUNsQyxRQUFNdEMsUUFBUXNDLEtBQUtDO0FBQ25CLFFBQU0xRCxTQUFTa1Isa0JBQWtCL1AsT0FBT3NDLEtBQUs1SyxJQUFJO0FBQ2pELE1BQUlVLE1BQU00SCxNQUFNd1E7QUFDaEIsTUFBSXZYLElBQUd1SSxNQUFNaVAsTUFBTWpHO0FBQ25CLFFBQU1rRyxtQkFBbUIsTUFBTTtBQUM3QixRQUFJRCxTQUFTLFNBQVNBLFNBQVMsUUFBUTtBQUVyQzs7QUFFRixRQUFJdkQsUUFBUTFDLElBQU8sR0FBQTtBQUVqQnBTLFlBQU1ELEtBQUtDLElBQUlBLEtBQUtELEtBQUt3WSxJQUFJRixPQUFPakcsSUFBU3BTLEtBQUFBLEdBQUFBOztBQUUvQ29TLFdBQU9pRztFQUNUO0FBRUEsT0FBS3hYLEtBQUksR0FBR3VJLE9BQU8zQyxPQUFPN0YsUUFBUUMsS0FBSXVJLE1BQU0sRUFBRXZJLElBQUc7QUFDL0N3WCxXQUFPelEsTUFBTTRRLGlCQUFpQi9SLE9BQU81RixFQUFFLENBQUE7QUFDdkN5WCxxQkFBQUE7RUFDRjtBQUVBbEcsU0FBT25UO0FBQ1AsT0FBSzRCLEtBQUksR0FBR3VJLE9BQU94QixNQUFNNlEsTUFBTTdYLFFBQVFDLEtBQUl1SSxNQUFNLEVBQUV2SSxJQUFHO0FBQ3BEd1gsV0FBT3pRLE1BQU04USxnQkFBZ0I3WCxFQUFBQTtBQUM3QnlYLHFCQUFBQTtFQUNGO0FBRUEsU0FBT3RZO0FBQ1Q7QUFRQSxTQUFTMlkseUJBQXlCdFAsT0FBT3VQLE9BQU9qUyxTQUFTa1MsWUFBWTtBQUNuRSxRQUFNQyxZQUFZblMsUUFBUW9TO0FBQzFCLE1BQUl6UixNQUFNMFI7QUFFVixNQUFJQyxjQUFjSCxTQUFZLEdBQUE7QUFDNUJ4UixXQUFPc1IsTUFBTTVZLE1BQU0yRyxRQUFRdVM7QUFDM0JGLFlBQVFyUyxRQUFRd1M7U0FDWDtBQUlMN1IsV0FBT3dSLFlBQVlEO0FBQ25CRyxZQUFROztBQUdWLFNBQU87SUFDTEksT0FBTzlSLE9BQU91UjtJQUNkRztJQUNBL1ksT0FBTzJZLE1BQU1TLE9BQU9oUSxLQUFBQSxJQUFVL0IsT0FBTztFQUN2QztBQUNGO0FBUUEsU0FBU2dTLDBCQUEwQmpRLE9BQU91UCxPQUFPalMsU0FBU2tTLFlBQVk7QUFDcEUsUUFBTVEsU0FBU1QsTUFBTVM7QUFDckIsUUFBTWhCLE9BQU9nQixPQUFPaFEsS0FBTTtBQUMxQixNQUFJK0ksT0FBTy9JLFFBQVEsSUFBSWdRLE9BQU9oUSxRQUFRLENBQUEsSUFBSztBQUMzQyxNQUFJa1EsT0FBT2xRLFFBQVFnUSxPQUFPelksU0FBUyxJQUFJeVksT0FBT2hRLFFBQVEsQ0FBRSxJQUFHO0FBQzNELFFBQU1tUSxVQUFVN1MsUUFBUXVTO0FBRXhCLE1BQUk5RyxTQUFTLE1BQU07QUFHakJBLFdBQU9pRyxRQUFRa0IsU0FBUyxPQUFPWCxNQUFNNVEsTUFBTTRRLE1BQU0zWSxRQUFRc1osT0FBT2xCOztBQUdsRSxNQUFJa0IsU0FBUyxNQUFNO0FBRWpCQSxXQUFPbEIsT0FBT0EsT0FBT2pHOztBQUd2QixRQUFNblMsUUFBUW9ZLFFBQVFBLE9BQU90WSxLQUFLQyxJQUFJb1MsTUFBTW1ILElBQUksS0FBSyxJQUFJQztBQUN6RCxRQUFNbFMsT0FBT3ZILEtBQUt3WSxJQUFJZ0IsT0FBT25ILElBQUFBLElBQVEsSUFBSW9IO0FBRXpDLFNBQU87SUFDTEosT0FBTzlSLE9BQU91UjtJQUNkRyxPQUFPclMsUUFBUXdTO0lBQ2ZsWjtFQUNGO0FBQ0Y7QUFFQSxTQUFTd1osY0FBY0MsT0FBTzNZLE1BQU1xSixRQUFRdkosSUFBRztBQUM3QyxRQUFNOFksYUFBYXZQLE9BQU80SCxNQUFNMEgsTUFBTSxDQUFBLEdBQUk3WSxFQUFBQTtBQUMxQyxRQUFNK1ksV0FBV3hQLE9BQU80SCxNQUFNMEgsTUFBTSxDQUFBLEdBQUk3WSxFQUFBQTtBQUN4QyxRQUFNYixNQUFNRCxLQUFLQyxJQUFJMlosWUFBWUMsUUFBQUE7QUFDakMsUUFBTXpYLE1BQU1wQyxLQUFLb0MsSUFBSXdYLFlBQVlDLFFBQUFBO0FBQ2pDLE1BQUlDLFdBQVc3WjtBQUNmLE1BQUk4WixTQUFTM1g7QUFFYixNQUFJcEMsS0FBS3dZLElBQUl2WSxHQUFBQSxJQUFPRCxLQUFLd1ksSUFBSXBXLEdBQU0sR0FBQTtBQUNqQzBYLGVBQVcxWDtBQUNYMlgsYUFBUzlaOztBQUtYZSxPQUFLcUosT0FBT0UsSUFBSSxJQUFJd1A7QUFFcEIvWSxPQUFLZ1osVUFBVTtJQUNiRjtJQUNBQztJQUNBN1osT0FBTzBaO0lBQ1AzUixLQUFLNFI7SUFDTDVaO0lBQ0FtQztFQUNGO0FBQ0Y7QUFFQSxTQUFTNlgsV0FBV04sT0FBTzNZLE1BQU1xSixRQUFRdkosSUFBRztBQUMxQyxNQUFJeUYsUUFBUW9ULEtBQVEsR0FBQTtBQUNsQkQsa0JBQWNDLE9BQU8zWSxNQUFNcUosUUFBUXZKLEVBQUFBO1NBQzlCO0FBQ0xFLFNBQUtxSixPQUFPRSxJQUFJLElBQUlGLE9BQU80SCxNQUFNMEgsT0FBTzdZLEVBQUFBOztBQUUxQyxTQUFPRTtBQUNUO0FBRUEsU0FBU2taLHNCQUFzQi9QLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN2RCxRQUFNOUgsU0FBU0QsS0FBS0M7QUFDcEIsUUFBTUMsU0FBU0YsS0FBS0U7QUFDcEIsUUFBTXFJLFNBQVN0SSxPQUFPdUksVUFBUztBQUMvQixRQUFNQyxjQUFjeEksV0FBV0M7QUFDL0IsUUFBTTRCLFNBQVMsQ0FBQTtBQUNmLE1BQUluTCxJQUFHdUksTUFBTXJJLE1BQU0yWTtBQUVuQixPQUFLN1ksS0FBSVosT0FBT21KLE9BQU9uSixRQUFRZ1MsT0FBT3BSLEtBQUl1SSxNQUFNLEVBQUV2SSxJQUFHO0FBQ25ENlksWUFBUXpQLEtBQUtwSixFQUFFO0FBQ2ZFLFdBQU8sQ0FBQTtBQUNQQSxTQUFLb0osT0FBT0csSUFBSSxJQUFJcUksZUFBZXhJLE9BQU82SCxNQUFNUyxPQUFPNVIsRUFBQUEsR0FBSUEsRUFBQUE7QUFDM0RtTCxXQUFPbkssS0FBS21ZLFdBQVdOLE9BQU8zWSxNQUFNcUosUUFBUXZKLEVBQUFBLENBQUFBO0VBQzlDO0FBQ0EsU0FBT21MO0FBQ1Q7QUFFQSxTQUFTa08sV0FBV0MsUUFBUTtBQUMxQixTQUFPQSxVQUFVQSxPQUFPTixhQUFhNWEsVUFBYWtiLE9BQU9MLFdBQVc3YTtBQUN0RTtBQUVBLFNBQVNtYixRQUFROVMsTUFBTThDLFFBQVFpUSxZQUFZO0FBQ3pDLE1BQUkvUyxTQUFTLEdBQUc7QUFDZCxXQUFPeUMsS0FBS3pDLElBQUFBOztBQUVkLFVBQVE4QyxPQUFPa1EsYUFBWSxJQUFLLElBQUksT0FBT2xRLE9BQU9wSyxPQUFPcWEsYUFBYSxJQUFJO0FBQzVFO0FBRUEsU0FBU0UsWUFBWWhVLFlBQVk7QUFDL0IsTUFBSXdCLFNBQVM5SCxPQUFPK0gsS0FBS00sS0FBS0U7QUFDOUIsTUFBSWpDLFdBQVdpVSxZQUFZO0FBQ3pCelMsY0FBVXhCLFdBQVdrVSxPQUFPbFUsV0FBVzZCO0FBQ3ZDbkksWUFBUTtBQUNSK0gsVUFBTTtTQUNEO0FBQ0xELGNBQVV4QixXQUFXa1UsT0FBT2xVLFdBQVc4QjtBQUN2Q3BJLFlBQVE7QUFDUitILFVBQU07O0FBRVIsTUFBSUQsU0FBUztBQUNYTyxVQUFNO0FBQ05FLGFBQVM7U0FDSjtBQUNMRixVQUFNO0FBQ05FLGFBQVM7O0FBRVgsU0FBTztJQUFDdkk7SUFBTytIO0lBQUtEO0lBQVNPO0lBQUtFO0VBQU07QUFDMUM7QUFFQSxTQUFTa1MsaUJBQWlCblUsWUFBWUksU0FBUzRDLE9BQU9GLE9BQU87QUFDM0QsTUFBSXNSLE9BQU9oVSxRQUFRaVU7QUFDbkIsUUFBTXpWLE1BQU0sQ0FBQTtBQUVaLE1BQUksQ0FBQ3dWLE1BQU07QUFDVHBVLGVBQVdxVSxnQkFBZ0J6VjtBQUMzQjs7QUFHRixNQUFJd1YsU0FBUyxNQUFNO0FBQ2pCcFUsZUFBV3FVLGdCQUFnQjtNQUFDdFMsS0FBSztNQUFNQyxPQUFPO01BQU1DLFFBQVE7TUFBTUMsTUFBTTtJQUFJO0FBQzVFOztBQUdGLFFBQU0sRUFBQ3hJLE9BQU8rSCxLQUFLRCxTQUFTTyxLQUFLRSxPQUFBQSxJQUFVK1IsWUFBWWhVLFVBQUFBO0FBRXZELE1BQUlvVSxTQUFTLFlBQVlwUixPQUFPO0FBQzlCaEQsZUFBV3NVLHFCQUFxQjtBQUNoQyxTQUFLdFIsTUFBTStDLFFBQVEsT0FBT2pELE9BQU87QUFDL0JzUixhQUFPclM7Z0JBQ0dpQixNQUFNZ0QsV0FBVyxPQUFPbEQsT0FBTztBQUN6Q3NSLGFBQU9uUztXQUNGO0FBQ0xyRCxVQUFJMlYsVUFBVXRTLFFBQVF2SSxPQUFPK0gsS0FBS0QsT0FBQUEsQ0FBQUEsSUFBWTtBQUM5QzRTLGFBQU9yUzs7O0FBSVhuRCxNQUFJMlYsVUFBVUgsTUFBTTFhLE9BQU8rSCxLQUFLRCxPQUFBQSxDQUFBQSxJQUFZO0FBQzVDeEIsYUFBV3FVLGdCQUFnQnpWO0FBQzdCO0FBRUEsU0FBUzJWLFVBQVVILE1BQU16QyxJQUFHclAsSUFBR2QsU0FBUztBQUN0QyxNQUFJQSxTQUFTO0FBQ1g0UyxXQUFPSSxLQUFLSixNQUFNekMsSUFBR3JQLEVBQUFBO0FBQ3JCOFIsV0FBT0ssU0FBU0wsTUFBTTlSLElBQUdxUCxFQUFBQTtTQUNwQjtBQUNMeUMsV0FBT0ssU0FBU0wsTUFBTXpDLElBQUdyUCxFQUFBQTs7QUFFM0IsU0FBTzhSO0FBQ1Q7QUFFQSxTQUFTSSxLQUFLRSxNQUFNQyxJQUFJQyxJQUFJO0FBQzFCLFNBQU9GLFNBQVNDLEtBQUtDLEtBQUtGLFNBQVNFLEtBQUtELEtBQUtEO0FBQy9DO0FBRUEsU0FBU0QsU0FBU0ksSUFBR25iLE9BQU8rSCxLQUFLO0FBQy9CLFNBQU9vVCxPQUFNLFVBQVVuYixRQUFRbWIsT0FBTSxRQUFRcFQsTUFBTW9UO0FBQ3JEO0FBRUEsU0FBU0MsaUJBQWlCOVUsWUFBWSxFQUFDK1UsY0FBQUEsR0FBZ0J0QyxPQUFPO0FBQzVEelMsYUFBVytVLGdCQUFnQkEsa0JBQWtCLFNBQ3pDdEMsVUFBVSxJQUFJLE9BQU8sSUFDckJzQztBQUNOO0FBRWUsSUFBTUMsZ0JBQU4sY0FBNEJ2TixrQkFBQUE7RUFnRHpDdUUsbUJBQW1CckksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQzNDLFdBQU9nSSxzQkFBc0IvUCxNQUFNRCxNQUFNaEssT0FBT2dTLEtBQUFBO0VBQ2xEO0VBT0FJLGVBQWVuSSxNQUFNRCxNQUFNaEssT0FBT2dTLE9BQU87QUFDdkMsV0FBT2dJLHNCQUFzQi9QLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7RUFDbEQ7RUFPQUssZ0JBQWdCcEksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQ3hDLFVBQU0sRUFBQzlILFFBQVFDLE9BQUFBLElBQVVGO0FBQ3pCLFVBQU0sRUFBQzBJLFdBQVcsS0FBS0MsV0FBVyxJQUFBLElBQU8sS0FBS3ZFO0FBQzlDLFVBQU1qRSxXQUFXRixPQUFPRyxTQUFTLE1BQU1zSSxXQUFXQztBQUNsRCxVQUFNdEksV0FBV0gsT0FBT0UsU0FBUyxNQUFNc0ksV0FBV0M7QUFDbEQsVUFBTTdHLFNBQVMsQ0FBQTtBQUNmLFFBQUluTCxJQUFHdUksTUFBTXJJLE1BQU15YTtBQUNuQixTQUFLM2EsS0FBSVosT0FBT21KLE9BQU9uSixRQUFRZ1MsT0FBT3BSLEtBQUl1SSxNQUFNLEVBQUV2SSxJQUFHO0FBQ25EMmEsWUFBTXZSLEtBQUtwSixFQUFFO0FBQ2JFLGFBQU8sQ0FBQTtBQUNQQSxXQUFLb0osT0FBT0csSUFBSSxJQUFJSCxPQUFPNkgsTUFBTWMsaUJBQWlCMEksS0FBS25SLFFBQVd4SixHQUFBQSxFQUFBQTtBQUNsRW1MLGFBQU9uSyxLQUFLbVksV0FBV2xILGlCQUFpQjBJLEtBQUtqUixRQUFBQSxHQUFXeEosTUFBTXFKLFFBQVF2SixFQUFBQSxDQUFBQTtJQUN4RTtBQUNBLFdBQU9tTDtFQUNUO0VBS0FpSCxzQkFBc0JDLFFBQU90TCxPQUFPb0UsUUFBUXpDLE9BQU87QUFDakQsVUFBTTBKLHNCQUFzQkMsUUFBT3RMLE9BQU9vRSxRQUFRekMsS0FBQUE7QUFDbEQsVUFBTTRRLFNBQVNuTyxPQUFPK047QUFDdEIsUUFBSUksVUFBVXZTLFVBQVUsS0FBS3FFLFlBQVk3QixRQUFRO0FBRS9DOEksTUFBQUEsT0FBTWxULE1BQU1ELEtBQUtDLElBQUlrVCxPQUFNbFQsS0FBS21hLE9BQU9uYSxHQUFHO0FBQzFDa1QsTUFBQUEsT0FBTS9RLE1BQU1wQyxLQUFLb0MsSUFBSStRLE9BQU0vUSxLQUFLZ1ksT0FBT2hZLEdBQUc7O0VBRTlDO0VBTUF3UixpQkFBaUI7QUFDZixXQUFPO0VBQ1Q7RUFLQUMsaUJBQWlCdkssT0FBTztBQUN0QixVQUFNYSxPQUFPLEtBQUsrQjtBQUNsQixVQUFNLEVBQUM5QixRQUFRQyxPQUFBQSxJQUFVRjtBQUN6QixVQUFNOEIsU0FBUyxLQUFLK0csVUFBVTFKLEtBQUFBO0FBQzlCLFVBQU04USxTQUFTbk8sT0FBTytOO0FBQ3RCLFVBQU0xUyxRQUFRNlMsV0FBV0MsTUFDckIsSUFBQSxNQUFNQSxPQUFPbGEsUUFBUSxPQUFPa2EsT0FBT25TLE1BQU0sTUFDekMsS0FBS29DLE9BQU8wSixpQkFBaUI5SCxPQUFPNUIsT0FBT0UsSUFBSSxDQUFDO0FBRXBELFdBQU87TUFDTHVKLE9BQU8sS0FBSzFKLE9BQU8ySixpQkFBaUI5SCxPQUFPN0IsT0FBT0csSUFBSSxDQUFDO01BQ3ZEakQ7SUFDRjtFQUNGO0VBRUE2SCxhQUFhO0FBQ1gsU0FBS04sc0JBQXNCO0FBRTNCLFVBQU1NLFdBQVU7QUFFaEIsVUFBTWhGLE9BQU8sS0FBSytCO0FBQ2xCL0IsU0FBS1gsUUFBUSxLQUFLbUcsV0FBVSxFQUFHbkc7RUFDakM7RUFFQTFFLE9BQU82RSxNQUFNO0FBQ1gsVUFBTVEsT0FBTyxLQUFLK0I7QUFDbEIsU0FBSzZLLGVBQWU1TSxLQUFLRCxNQUFNLEdBQUdDLEtBQUtELEtBQUtySixRQUFROEksSUFBQUE7RUFDdEQ7RUFFQW9OLGVBQWUyRSxNQUFNeGIsT0FBT2dTLE9BQU92SSxNQUFNO0FBQ3ZDLFVBQU1vSCxTQUFRcEgsU0FBUztBQUN2QixVQUFNLEVBQUNMLE9BQU80QyxhQUFhLEVBQUM3QixPQUFBQSxFQUFPLElBQUk7QUFDdkMsVUFBTXFRLE9BQU9yUSxPQUFPc1IsYUFBWTtBQUNoQyxVQUFNbEIsYUFBYXBRLE9BQU9rUSxhQUFZO0FBQ3RDLFVBQU0xQixRQUFRLEtBQUsrQyxVQUFTO0FBQzVCLFVBQU0sRUFBQ2pHLGVBQWVELGVBQWMsSUFBSSxLQUFLRyxrQkFBa0IzVixPQUFPeUosSUFBQUE7QUFFdEUsYUFBUzdJLEtBQUlaLE9BQU9ZLEtBQUlaLFFBQVFnUyxPQUFPcFIsTUFBSztBQUMxQyxZQUFNbUwsU0FBUyxLQUFLK0csVUFBVWxTLEVBQUFBO0FBQzlCLFlBQU0rYSxVQUFVOUssVUFBU21JLGNBQWNqTixPQUFPNUIsT0FBT0UsSUFBSSxDQUFDLElBQUk7UUFBQ21RO1FBQU1vQixNQUFNcEI7TUFBSSxJQUFJLEtBQUtxQix5QkFBeUJqYixFQUFFO0FBQ25ILFlBQU1rYixVQUFVLEtBQUtDLHlCQUF5Qm5iLElBQUcrWCxLQUFBQTtBQUNqRCxZQUFNclAsU0FBU3lDLE9BQU9FLFdBQVcsQ0FBQSxHQUFJOUIsT0FBT0UsSUFBSTtBQUVoRCxZQUFNL0QsYUFBYTtRQUNqQmlVO1FBQ0FDLE1BQU1tQixRQUFRbkI7UUFDZEksb0JBQW9CLENBQUN0UixTQUFTMlEsV0FBV2xPLE9BQU8rTixPQUFPLEtBQU0xUSxVQUFVRSxNQUFNK0MsUUFBUWpELFVBQVVFLE1BQU1nRDtRQUNyR25FLEdBQUdvUyxhQUFhb0IsUUFBUUMsT0FBT0UsUUFBUUU7UUFDdkM1VCxHQUFHbVMsYUFBYXVCLFFBQVFFLFNBQVNMLFFBQVFDO1FBQ3pDSyxRQUFRMUIsYUFBYXVCLFFBQVF6VSxPQUFPdkgsS0FBS3dZLElBQUlxRCxRQUFRdFUsSUFBSTtRQUN6RDZVLE9BQU8zQixhQUFhemEsS0FBS3dZLElBQUlxRCxRQUFRdFUsSUFBSSxJQUFJeVUsUUFBUXpVO01BQ3ZEO0FBRUEsVUFBSW1PLGdCQUFnQjtBQUNsQmxQLG1CQUFXSSxVQUFVK08saUJBQWlCLEtBQUtuQiwwQkFBMEIxVCxJQUFHNGEsS0FBSzVhLEVBQUUsRUFBQytELFNBQVMsV0FBVzhFLElBQUk7O0FBRTFHLFlBQU0vQyxVQUFVSixXQUFXSSxXQUFXOFUsS0FBSzVhLEVBQUFBLEVBQUc4RjtBQUM5QytULHVCQUFpQm5VLFlBQVlJLFNBQVM0QyxPQUFPRixLQUFBQTtBQUM3Q2dTLHVCQUFpQjlVLFlBQVlJLFNBQVNpUyxNQUFNSSxLQUFLO0FBQ2pELFdBQUtoRCxjQUFjeUYsS0FBSzVhLEVBQUUsR0FBRUEsSUFBRzBGLFlBQVltRCxJQUFBQTtJQUM3QztFQUNGO0VBU0EwUyxXQUFXQyxNQUFNalAsV0FBVztBQUMxQixVQUFNLEVBQUNqRCxPQUFNLElBQUksS0FBSzhCO0FBQ3RCLFVBQU0vQyxXQUFXaUIsT0FBTzBCLHdCQUF3QixLQUFLd0MsS0FBSyxFQUN2RHpCLE9BQU8xQyxDQUFBQSxTQUFRQSxLQUFLNkIsV0FBV3BGLFFBQVEyVixPQUFPO0FBQ2pELFVBQU0zUixVQUFVUixPQUFPeEQsUUFBUWdFO0FBQy9CLFVBQU1ZLFNBQVMsQ0FBQTtBQUNmLFVBQU1nUixnQkFBZ0IsS0FBS3RRLFlBQVlGLFdBQVdnSCxVQUFVM0YsU0FBQUE7QUFDNUQsVUFBTW9QLGNBQWNELGlCQUFpQkEsY0FBY3BTLE9BQU9HLElBQUk7QUFFOUQsVUFBTW1TLFdBQVcsQ0FBQ3ZTLFNBQVM7QUFDekIsWUFBTThCLFNBQVM5QixLQUFLcUQsUUFBUW1QLEtBQUszYixDQUFBQSxTQUFRQSxLQUFLb0osT0FBT0csSUFBSSxNQUFNa1MsV0FBQUE7QUFDL0QsWUFBTUcsTUFBTTNRLFVBQVVBLE9BQU85QixLQUFLRSxPQUFPRSxJQUFJO0FBRTdDLFVBQUkyTyxjQUFjMEQsR0FBUUMsS0FBQUEsTUFBTUQsR0FBTSxHQUFBO0FBQ3BDLGVBQU87O0lBRVg7QUFFQSxlQUFXelMsUUFBUWhCLFVBQVU7QUFDM0IsVUFBSWtFLGNBQWNuTyxVQUFhd2QsU0FBU3ZTLElBQU8sR0FBQTtBQUM3Qzs7QUFRRixVQUFJUyxZQUFZLFNBQVNZLE9BQU9zUixRQUFRM1MsS0FBS1gsS0FBSyxNQUFNLE1BQ3pEb0IsWUFBWTFMLFVBQWFpTCxLQUFLWCxVQUFVdEssUUFBWTtBQUNqRHNNLGVBQU8xSixLQUFLcUksS0FBS1gsS0FBSzs7QUFFeEIsVUFBSVcsS0FBS2IsVUFBVWdULE1BQU07QUFDdkI7O0lBRUo7QUFLQSxRQUFJLENBQUM5USxPQUFPM0ssUUFBUTtBQUNsQjJLLGFBQU8xSixLQUFLNUMsTUFBQUE7O0FBR2QsV0FBT3NNO0VBQ1Q7RUFNQXVSLGVBQWV6VCxPQUFPO0FBQ3BCLFdBQU8sS0FBSytTLFdBQVduZCxRQUFXb0ssS0FBQUEsRUFBT3pJO0VBQzNDO0VBRUFtYyxnQkFBZ0I7QUFDZCxXQUFPLEtBQUtDLFNBQVEsRUFBR3BjO0VBQ3pCO0VBRUFxYyw4QkFBOEI7QUFDNUIsVUFBTXRRLFNBQVMsS0FBS3hOLE1BQU13TjtBQUMxQixVQUFNdVEsZUFBZSxLQUFLL2QsTUFBTXdILFFBQVF3SjtBQUN4QyxXQUFPckssT0FBT0MsS0FBSzRHLE1BQUFBLEVBQVFDLE9BQU94RyxDQUFBQSxRQUFPdUcsT0FBT3ZHLEdBQUksRUFBQ2tFLFNBQVM0UyxZQUFBQSxFQUFjclEsTUFBSztFQUNuRjtFQUVBbVEsV0FBVztBQUNULFVBQU0xUyxPQUFPLENBQUE7QUFDYixVQUFNNlMsbUJBQW1CLEtBQUtGLDRCQUEyQjtBQUN6RCxlQUFXaFEsV0FBVyxLQUFLOU4sTUFBTThLLEtBQUt5RyxVQUFVO0FBQzlDcEcsV0FBS3dGLGVBQ0gsS0FBSzNRLE1BQU13SCxRQUFRd0osY0FBYyxNQUFNbEQsUUFBUTRDLFVBQVU1QyxRQUFRK0MsU0FBU21OLGdCQUFBQSxDQUFBQSxJQUN2RTtJQUNQO0FBQ0EsV0FBT3JYLE9BQU9DLEtBQUt1RSxJQUFBQTtFQUNyQjtFQVVBOFMsZUFBZXpULGNBQWMwVCxNQUFNalEsV0FBVztBQUM1QyxVQUFNN0IsU0FBUyxLQUFLNlEsV0FBV3pTLGNBQWN5RCxTQUFBQTtBQUM3QyxVQUFNL0QsUUFBUSxTQUFVcEssU0FDcEJzTSxPQUFPc1IsUUFBUVEsSUFDZixJQUFBO0FBRUosV0FBUWhVLFVBQVUsS0FDZGtDLE9BQU8zSyxTQUFTLElBQ2hCeUk7RUFDTjtFQUtBc1MsWUFBWTtBQUNWLFVBQU03VCxPQUFPLEtBQUtuQjtBQUNsQixVQUFNdUQsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTTlCLFNBQVNELEtBQUtDO0FBQ3BCLFVBQU1rUCxTQUFTLENBQUE7QUFDZixRQUFJeFksSUFBR3VJO0FBRVAsU0FBS3ZJLEtBQUksR0FBR3VJLE9BQU9jLEtBQUtELEtBQUtySixRQUFRQyxLQUFJdUksTUFBTSxFQUFFdkksSUFBRztBQUNsRHdZLGFBQU94WCxLQUFLc0ksT0FBT3FPLGlCQUFpQixLQUFLekYsVUFBVWxTLEVBQUUsRUFBQ3NKLE9BQU9HLElBQUksR0FBR3pKLEVBQUFBLENBQUFBO0lBQ3RFO0FBRUEsVUFBTWtZLGVBQWVqUixLQUFLaVI7QUFDMUIsVUFBTS9ZLE1BQU0rWSxnQkFBZ0JaLHFCQUFxQmpPLElBQUFBO0FBRWpELFdBQU87TUFDTGxLO01BQ0FxWjtNQUNBcFosT0FBT2tLLE9BQU9tVDtNQUNkdFYsS0FBS21DLE9BQU9vVDtNQUNaMUUsWUFBWSxLQUFLaUUsZUFBYztNQUMvQmxWLE9BQU91QztNQUNQbVMsU0FBU3hVLEtBQUt3VTtNQUVkdEQsT0FBT0QsZUFBZSxJQUFJalIsS0FBS29SLHFCQUFxQnBSLEtBQUtxUjtJQUMzRDtFQUNGO0VBTUEyQyx5QkFBeUJ6UyxPQUFPO0FBQzlCLFVBQU0sRUFBQzRDLGFBQWEsRUFBQzdCLFFBQVEyRCxVQUFVMUUsT0FBT00sYUFBQUEsR0FBZWhELFNBQVMsRUFBQzhULE1BQU0rQyxXQUFXQyxhQUFBQSxFQUFhLElBQUk7QUFDekcsVUFBTXBELGFBQWFtRCxhQUFhO0FBQ2hDLFVBQU14UixTQUFTLEtBQUsrRyxVQUFVMUosS0FBQUE7QUFDOUIsVUFBTThRLFNBQVNuTyxPQUFPK047QUFDdEIsVUFBTTJELFdBQVd4RCxXQUFXQyxNQUFBQTtBQUM1QixRQUFJOVMsUUFBUTJFLE9BQU81QixPQUFPRSxJQUFJO0FBQzlCLFFBQUlySyxRQUFRO0FBQ1osUUFBSVcsU0FBU21OLFdBQVcsS0FBS3pFLFdBQVdjLFFBQVE0QixRQUFRK0IsUUFBQUEsSUFBWTFHO0FBQ3BFLFFBQUl3VSxNQUFNdlU7QUFFVixRQUFJMUcsV0FBV3lHLE9BQU87QUFDcEJwSCxjQUFRVyxTQUFTeUc7QUFDakJ6RyxlQUFTeUc7O0FBR1gsUUFBSXFXLFVBQVU7QUFDWnJXLGNBQVE4UyxPQUFPTjtBQUNmalosZUFBU3VaLE9BQU9MLFNBQVNLLE9BQU9OO0FBRWhDLFVBQUl4UyxVQUFVLEtBQUswQyxLQUFLMUMsS0FBQUEsTUFBVzBDLEtBQUtvUSxPQUFPTCxNQUFNLEdBQUc7QUFDdEQ3WixnQkFBUTs7QUFFVkEsZUFBU29IOztBQUdYLFVBQU1zUyxhQUFhLENBQUNWLGNBQWN1RSxTQUFBQSxLQUFjLENBQUNFLFdBQVdGLFlBQVl2ZDtBQUN4RSxRQUFJd2EsT0FBT3JRLE9BQU9vTyxpQkFBaUJtQixVQUFBQTtBQUVuQyxRQUFJLEtBQUt4YSxNQUFNd2Usa0JBQWtCdFUsS0FBUSxHQUFBO0FBQ3ZDd1MsYUFBT3pSLE9BQU9vTyxpQkFBaUJ2WSxRQUFRVyxNQUFBQTtXQUNsQztBQUVMaWIsYUFBT3BCOztBQUdUblQsV0FBT3VVLE9BQU9wQjtBQUVkLFFBQUkxYSxLQUFLd1ksSUFBSWpSLElBQUFBLElBQVFtVyxjQUFjO0FBQ2pDblcsYUFBTzhTLFFBQVE5UyxNQUFNOEMsUUFBUWlRLFVBQWNvRCxJQUFBQTtBQUMzQyxVQUFJcFcsVUFBVWdULFlBQVk7QUFDeEJJLGdCQUFRblQsT0FBTzs7QUFFakIsWUFBTXNXLGFBQWF4VCxPQUFPeVQsbUJBQW1CLENBQUE7QUFDN0MsWUFBTUMsV0FBVzFULE9BQU95VCxtQkFBbUIsQ0FBQTtBQUMzQyxZQUFNN2QsTUFBTUQsS0FBS0MsSUFBSTRkLFlBQVlFLFFBQUFBO0FBQ2pDLFlBQU0zYixNQUFNcEMsS0FBS29DLElBQUl5YixZQUFZRSxRQUFBQTtBQUNqQ3JELGFBQU8xYSxLQUFLb0MsSUFBSXBDLEtBQUtDLElBQUl5YSxNQUFNdFksR0FBTW5DLEdBQUFBLEdBQUFBO0FBQ3JDNmIsYUFBT3BCLE9BQU9uVDtBQUVkLFVBQUl5RyxZQUFZLENBQUMyUCxVQUFVO0FBRXpCMVIsZUFBT0UsUUFBUTlCLE9BQU9FLElBQUksRUFBRW1DLGNBQWM5QyxZQUFhLElBQUdTLE9BQU8yVCxpQkFBaUJsQyxJQUFRelIsSUFBQUEsT0FBTzJULGlCQUFpQnRELElBQUFBOzs7QUFJdEgsUUFBSUEsU0FBU3JRLE9BQU9vTyxpQkFBaUI2QixVQUFhLEdBQUE7QUFDaEQsWUFBTTJELFdBQVdqVSxLQUFLekMsSUFBQUEsSUFBUThDLE9BQU82VCxxQkFBcUI1RCxVQUFjLElBQUE7QUFDeEVJLGNBQVF1RDtBQUNSMVcsY0FBUTBXOztBQUdWLFdBQU87TUFDTDFXO01BQ0FtVDtNQUNBb0I7TUFDQUksUUFBUUosT0FBT3ZVLE9BQU87SUFDeEI7RUFDRjtFQUtBMFUseUJBQXlCM1MsT0FBT3VQLE9BQU87QUFDckMsVUFBTWhSLFFBQVFnUixNQUFNaFI7QUFDcEIsVUFBTWpCLFVBQVUsS0FBS0E7QUFDckIsVUFBTThWLFdBQVc5VixRQUFROFY7QUFDekIsVUFBTXlCLGtCQUFrQnBPLGVBQWVuSixRQUFRdVgsaUJBQWlCQyxRQUFBQTtBQUNoRSxRQUFJbEMsUUFBUTNVO0FBQ1osVUFBTThXLFlBQVksS0FBS3JCLGNBQWE7QUFDcEMsUUFBSW5FLE1BQU0wRCxTQUFTO0FBQ2pCLFlBQU16RCxhQUFhNEQsV0FBVyxLQUFLSyxlQUFlelQsS0FBQUEsSUFBU3VQLE1BQU1DO0FBQ2pFLFlBQU0zRixTQUFRdk0sUUFBUW9TLGlCQUFpQixTQUNuQ08sMEJBQTBCalEsT0FBT3VQLE9BQU9qUyxTQUFTa1MsYUFBYXVGLFNBQUFBLElBQzlEekYseUJBQXlCdFAsT0FBT3VQLE9BQU9qUyxTQUFTa1MsYUFBYXVGLFNBQVU7QUFDM0UsWUFBTUMsU0FBUyxLQUFLbGYsTUFBTXdILFFBQVF3SixjQUFjLE1BQU0sS0FBS1QsV0FBVSxFQUFHRyxVQUFVLEtBQUtILFdBQVUsRUFBR007QUFDcEcsWUFBTXNPLGFBQWEsS0FBS3RCLFNBQVEsRUFBR0gsUUFBUS9NLGVBQWV1TyxRQUFRLEtBQUtwQiw0QkFBMkIsQ0FBQSxDQUFBO0FBQ2xHLFlBQU1zQixhQUFhLEtBQUtuQixlQUFlLEtBQUsvVCxPQUFPLEtBQUs0QyxZQUFZMUMsT0FBT2tULFdBQVdwVCxRQUFRcEssTUFBUyxJQUFJcWY7QUFDM0dyQyxlQUFTL0ksT0FBTWpULFFBQVNpVCxPQUFNa0csUUFBUW1GLGFBQWVyTCxPQUFNa0csUUFBUTtBQUNuRTlSLGFBQU92SCxLQUFLQyxJQUFJa2UsaUJBQWlCaEwsT0FBTWtHLFFBQVFsRyxPQUFNOEYsS0FBSztXQUNyRDtBQUVMaUQsZUFBU3JVLE1BQU00USxpQkFBaUIsS0FBS3pGLFVBQVUxSixLQUFBQSxFQUFPekIsTUFBTTBDLElBQUksR0FBR2pCLEtBQUFBO0FBQ25FL0IsYUFBT3ZILEtBQUtDLElBQUlrZSxpQkFBaUJ0RixNQUFNNVksTUFBTTRZLE1BQU1JLEtBQUs7O0FBSTFELFdBQU87TUFDTHlCLE1BQU13QixTQUFTM1UsT0FBTztNQUN0QnVVLE1BQU1JLFNBQVMzVSxPQUFPO01BQ3RCMlU7TUFDQTNVO0lBQ0Y7RUFDRjtFQUVBeEcsT0FBTztBQUNMLFVBQU1vSixPQUFPLEtBQUsrQjtBQUNsQixVQUFNN0IsU0FBU0YsS0FBS0U7QUFDcEIsVUFBTW9VLFFBQVF0VSxLQUFLRDtBQUNuQixVQUFNYixPQUFPb1YsTUFBTTVkO0FBQ25CLFFBQUlDLEtBQUk7QUFFUixXQUFPQSxLQUFJdUksTUFBTSxFQUFFdkksSUFBRztBQUNwQixVQUFJLEtBQUtrUyxVQUFVbFMsRUFBRSxFQUFDdUosT0FBT0UsSUFBSSxNQUFNLFFBQVEsQ0FBQ2tVLE1BQU0zZCxFQUFFLEVBQUNpTixRQUFRO0FBQy9EMFEsY0FBTTNkLEVBQUUsRUFBQ0MsS0FBSyxLQUFLbU4sSUFBSTs7SUFFM0I7RUFDRjtBQUVGO0FBdGFFLGNBRm1Cc04sZUFFWnhRLE1BQUs7QUFLWixjQVBtQndRLGVBT1p2VixZQUFXO0VBQ2hCZ0osb0JBQW9CO0VBQ3BCQyxpQkFBaUI7RUFFakJpSyxvQkFBb0I7RUFDcEJDLGVBQWU7RUFDZm1ELFNBQVM7RUFFVHpWLFlBQVk7SUFDVjRYLFNBQVM7TUFDUG5mLE1BQU07TUFDTmlILFlBQVk7UUFBQztRQUFLO1FBQUs7UUFBUTtRQUFTO01BQVM7SUFDbkQ7RUFDRjs7QUFNRixjQTFCbUJnVixlQTBCWm1ELGFBQVk7RUFDakIvUixRQUFRO0lBQ05nUyxTQUFTO01BQ1ByZixNQUFNO01BQ05zZixRQUFRO01BQ1JDLE1BQU07UUFDSkQsUUFBUTtNQUNWO0lBQ0Y7SUFDQUUsU0FBUztNQUNQeGYsTUFBTTtNQUNOeWYsYUFBYTtJQUNmO0VBQ0Y7O0FFL1JKLFNBQVNDLGtCQUFrQkMsVUFBVUMsZUFBZUMsUUFBUTtBQUMxRCxNQUFJQyxTQUFTO0FBQ2IsTUFBSUMsU0FBUztBQUNiLE1BQUlDLFVBQVU7QUFDZCxNQUFJQyxVQUFVO0FBRWQsTUFBSUwsZ0JBQWdCTSxLQUFLO0FBQ3ZCLFVBQU1DLGFBQWFSO0FBQ25CLFVBQU1TLFdBQVdELGFBQWFQO0FBQzlCLFVBQU1TLFNBQVNDLEtBQUtDLElBQUlKLFVBQUFBO0FBQ3hCLFVBQU1LLFNBQVNGLEtBQUtHLElBQUlOLFVBQUFBO0FBQ3hCLFVBQU1PLE9BQU9KLEtBQUtDLElBQUlILFFBQUFBO0FBQ3RCLFVBQU1PLE9BQU9MLEtBQUtHLElBQUlMLFFBQUFBO0FBQ3RCLFVBQU1RLFVBQVUsQ0FBQ0MsT0FBT0MsSUFBR0MsT0FBTUMsY0FBY0gsT0FBT1YsWUFBWUMsVUFBVSxJQUFJLElBQUksSUFBSUUsS0FBS1csSUFBSUgsSUFBR0EsS0FBSWpCLFFBQVFrQixJQUFHQSxLQUFJbEIsTUFBTztBQUM5SCxVQUFNcUIsVUFBVSxDQUFDTCxPQUFPQyxJQUFHQyxPQUFNQyxjQUFjSCxPQUFPVixZQUFZQyxVQUFVLElBQUksSUFBSSxLQUFLRSxLQUFLYSxJQUFJTCxJQUFHQSxLQUFJakIsUUFBUWtCLElBQUdBLEtBQUlsQixNQUFPO0FBQy9ILFVBQU11QixPQUFPUixRQUFRLEdBQUdQLFFBQVFLLElBQUFBO0FBQ2hDLFVBQU1XLE9BQU9ULFFBQVFVLFNBQVNkLFFBQVFHLElBQUFBO0FBQ3RDLFVBQU1ZLE9BQU9MLFFBQVFNLElBQUluQixRQUFRSyxJQUFBQTtBQUNqQyxVQUFNZSxPQUFPUCxRQUFRTSxLQUFLRixTQUFTZCxRQUFRRyxJQUFBQTtBQUMzQ2IsY0FBVXNCLE9BQU9HLFFBQVE7QUFDekJ4QixjQUFVc0IsT0FBT0ksUUFBUTtBQUN6QnpCLGNBQVUsRUFBRW9CLE9BQU9HLFFBQVE7QUFDM0J0QixjQUFVLEVBQUVvQixPQUFPSSxRQUFROztBQUU3QixTQUFPO0lBQUMzQjtJQUFRQztJQUFRQztJQUFTQztFQUFPO0FBQzFDO0FBRWUsSUFBTXlCLHFCQUFOLGNBQWlDQyxrQkFBQUE7RUE2RjlDQyxZQUFZQyxPQUFPQyxjQUFjO0FBQy9CLFVBQU1ELE9BQU9DLFlBQUFBO0FBRWIsU0FBS0Msc0JBQXNCO0FBQzNCLFNBQUtDLGNBQWNDO0FBQ25CLFNBQUtDLGNBQWNEO0FBQ25CLFNBQUtqQyxVQUFVaUM7QUFDZixTQUFLaEMsVUFBVWdDO0VBQ2pCO0VBRUFFLGFBQWE7RUFBQTtFQUtiQyxNQUFNQyxPQUFPQyxPQUFPO0FBQ2xCLFVBQU1DLE9BQU8sS0FBS0MsV0FBVSxFQUFHRDtBQUMvQixVQUFNRSxPQUFPLEtBQUtDO0FBRWxCLFFBQUksS0FBS0MsYUFBYSxPQUFPO0FBQzNCRixXQUFLRyxVQUFVTDtXQUNWO0FBQ0wsVUFBSU0sU0FBUyxDQUFDQyxPQUFNLENBQUNQLEtBQUtPLEVBQUU7QUFFNUIsVUFBSUMsU0FBU1IsS0FBS0YsS0FBQUEsQ0FBTSxHQUFHO0FBQ3pCLGNBQU0sRUFBQ1csTUFBTSxRQUFBLElBQVcsS0FBS0w7QUFDN0JFLGlCQUFTLENBQUNDLE9BQU0sQ0FBQ0csaUJBQWlCVixLQUFLTyxFQUFBQSxHQUFJRSxHQUFBQTs7QUFHN0MsVUFBSUYsSUFBR0k7QUFDUCxXQUFLSixLQUFJVCxPQUFPYSxPQUFPYixRQUFRQyxPQUFPUSxLQUFJSSxNQUFNLEVBQUVKLElBQUc7QUFDbkRMLGFBQUtHLFFBQVFFLEVBQUUsSUFBR0QsT0FBT0MsRUFBQUE7TUFDM0I7O0VBRUo7RUFLQUssZUFBZTtBQUNiLFdBQU9DLFVBQVUsS0FBS0MsUUFBUTFELFdBQVcsRUFBQTtFQUMzQztFQUtBMkQsb0JBQW9CO0FBQ2xCLFdBQU9GLFVBQVUsS0FBS0MsUUFBUXpELGFBQWE7RUFDN0M7RUFNQTJELHNCQUFzQjtBQUNwQixRQUFJcEMsTUFBTWpCO0FBQ1YsUUFBSWUsTUFBTSxDQUFDZjtBQUVYLGFBQVM0QyxLQUFJLEdBQUdBLEtBQUksS0FBS2pCLE1BQU1VLEtBQUtpQixTQUFTQyxRQUFRLEVBQUVYLElBQUc7QUFDeEQsVUFBSSxLQUFLakIsTUFBTTZCLGlCQUFpQlosRUFBQUEsS0FBTSxLQUFLakIsTUFBTThCLGVBQWViLEVBQUdjLEVBQUFBLFNBQVMsS0FBS0MsT0FBTztBQUN0RixjQUFNQyxhQUFhLEtBQUtqQyxNQUFNOEIsZUFBZWIsRUFBQUEsRUFBR2dCO0FBQ2hELGNBQU1uRSxXQUFXbUUsV0FBV1gsYUFBWTtBQUN4QyxjQUFNdkQsZ0JBQWdCa0UsV0FBV1Isa0JBQWlCO0FBRWxEbkMsY0FBTWIsS0FBS2EsSUFBSUEsS0FBS3hCLFFBQUFBO0FBQ3BCc0IsY0FBTVgsS0FBS1csSUFBSUEsS0FBS3RCLFdBQVdDLGFBQUFBOztJQUVuQztBQUVBLFdBQU87TUFDTEQsVUFBVXdCO01BQ1Z2QixlQUFlcUIsTUFBTUU7SUFDdkI7RUFDRjtFQUtBNEMsT0FBT0MsTUFBTTtBQUNYLFVBQU1uQyxRQUFRLEtBQUtBO0FBQ25CLFVBQU0sRUFBQ29DLFVBQVMsSUFBSXBDO0FBQ3BCLFVBQU1ZLE9BQU8sS0FBS0M7QUFDbEIsVUFBTXdCLE9BQU96QixLQUFLRjtBQUNsQixVQUFNNEIsVUFBVSxLQUFLQyxrQkFBaUIsSUFBSyxLQUFLQyxhQUFhSCxJQUFRLElBQUEsS0FBS2IsUUFBUWM7QUFDbEYsVUFBTUcsVUFBVWhFLEtBQUtXLEtBQUtYLEtBQUthLElBQUk4QyxVQUFVTSxPQUFPTixVQUFVTyxNQUFNLElBQUlMLFdBQVcsR0FBRyxDQUFBO0FBQ3RGLFVBQU10RSxTQUFTUyxLQUFLYSxJQUFJc0QsYUFBYSxLQUFLcEIsUUFBUXhELFFBQVF5RSxPQUFVLEdBQUEsQ0FBQTtBQUNwRSxVQUFNSSxjQUFjLEtBQUtDLGVBQWUsS0FBS0MsS0FBSztBQUtsRCxVQUFNLEVBQUNoRixlQUFlRCxTQUFBQSxJQUFZLEtBQUs0RCxvQkFBbUI7QUFDMUQsVUFBTSxFQUFDekQsUUFBUUMsUUFBUUMsU0FBU0MsUUFBQUEsSUFBV1Asa0JBQWtCQyxVQUFVQyxlQUFlQyxNQUFBQTtBQUN0RixVQUFNZ0YsWUFBWVosVUFBVU0sUUFBUUosV0FBV3JFO0FBQy9DLFVBQU1nRixhQUFhYixVQUFVTyxTQUFTTCxXQUFXcEU7QUFDakQsVUFBTWdGLFlBQVl6RSxLQUFLVyxJQUFJWCxLQUFLYSxJQUFJMEQsVUFBVUMsU0FBQUEsSUFBYSxHQUFHLENBQUE7QUFDOUQsVUFBTTVDLGNBQWM4QyxZQUFZLEtBQUszQixRQUFRNEIsUUFBUUYsU0FBQUE7QUFDckQsVUFBTS9DLGNBQWMxQixLQUFLVyxJQUFJaUIsY0FBY3JDLFFBQVEsQ0FBQTtBQUNuRCxVQUFNcUYsZ0JBQWdCaEQsY0FBY0YsZUFBZSxLQUFLbUQsOEJBQTZCO0FBQ3JGLFNBQUtuRixVQUFVQSxVQUFVa0M7QUFDekIsU0FBS2pDLFVBQVVBLFVBQVVpQztBQUV6Qk8sU0FBSzJDLFFBQVEsS0FBS0MsZUFBYztBQUVoQyxTQUFLbkQsY0FBY0EsY0FBY2dELGVBQWUsS0FBS0kscUJBQXFCLEtBQUtWLEtBQUs7QUFDcEYsU0FBSzVDLGNBQWMxQixLQUFLVyxJQUFJLEtBQUtpQixjQUFjZ0QsZUFBZVIsYUFBYSxDQUFBO0FBRTNFLFNBQUthLGVBQWVyQixNQUFNLEdBQUdBLEtBQUtULFFBQVFPLElBQUFBO0VBQzVDO0VBS0F3QixlQUFlMUMsSUFBRzJDLFFBQU87QUFDdkIsVUFBTUMsT0FBTyxLQUFLckM7QUFDbEIsVUFBTVosT0FBTyxLQUFLQztBQUNsQixVQUFNOUMsZ0JBQWdCLEtBQUswRCxrQkFBaUI7QUFDNUMsUUFBSW1DLFVBQVVDLEtBQUtDLFVBQVVDLGlCQUFrQixDQUFDLEtBQUsvRCxNQUFNZ0Usa0JBQWtCL0MsRUFBTUwsS0FBQUEsS0FBS0csUUFBUUUsRUFBRSxNQUFLLFFBQVFMLEtBQUtGLEtBQUtPLEVBQUFBLEVBQUdnRCxRQUFRO0FBQ2xJLGFBQU87O0FBRVQsV0FBTyxLQUFLQyx1QkFBdUJ0RCxLQUFLRyxRQUFRRSxFQUFFLElBQUdsRCxnQkFBZ0JNLEdBQUFBO0VBQ3ZFO0VBRUFxRixlQUFlckIsTUFBTTdCLE9BQU9DLE9BQU8wQixNQUFNO0FBQ3ZDLFVBQU15QixTQUFRekIsU0FBUztBQUN2QixVQUFNbkMsUUFBUSxLQUFLQTtBQUNuQixVQUFNb0MsWUFBWXBDLE1BQU1vQztBQUN4QixVQUFNeUIsT0FBTzdELE1BQU13QjtBQUNuQixVQUFNMkMsZ0JBQWdCTixLQUFLQztBQUMzQixVQUFNTSxXQUFXaEMsVUFBVWlDLE9BQU9qQyxVQUFVa0MsU0FBUztBQUNyRCxVQUFNQyxXQUFXbkMsVUFBVW9DLE1BQU1wQyxVQUFVcUMsVUFBVTtBQUNyRCxVQUFNQyxlQUFlZCxVQUFTTyxjQUFjTztBQUM1QyxVQUFNdkUsY0FBY3VFLGVBQWUsSUFBSSxLQUFLdkU7QUFDNUMsVUFBTUUsY0FBY3FFLGVBQWUsSUFBSSxLQUFLckU7QUFDNUMsVUFBTSxFQUFDc0UsZUFBZUMsZUFBYyxJQUFJLEtBQUtDLGtCQUFrQnJFLE9BQU8yQixJQUFBQTtBQUN0RSxRQUFJN0QsYUFBYSxLQUFLZ0QsYUFBWTtBQUNsQyxRQUFJTDtBQUVKLFNBQUtBLEtBQUksR0FBR0EsS0FBSVQsT0FBTyxFQUFFUyxJQUFHO0FBQzFCM0Msb0JBQWMsS0FBS3FGLGVBQWUxQyxJQUFHMkMsTUFBQUE7SUFDdkM7QUFFQSxTQUFLM0MsS0FBSVQsT0FBT1MsS0FBSVQsUUFBUUMsT0FBTyxFQUFFUSxJQUFHO0FBQ3RDLFlBQU1sRCxnQkFBZ0IsS0FBSzRGLGVBQWUxQyxJQUFHMkMsTUFBQUE7QUFDN0MsWUFBTWtCLE1BQU16QyxLQUFLcEIsRUFBRTtBQUNuQixZQUFNOEQsYUFBYTtRQUNqQkMsR0FBR1osVUFBVSxLQUFLakc7UUFDbEI4RyxHQUFHVixVQUFVLEtBQUtuRztRQUNsQkU7UUFDQUMsVUFBVUQsYUFBYVA7UUFDdkJBO1FBQ0FzQztRQUNBRjtNQUNGO0FBQ0EsVUFBSXlFLGdCQUFnQjtBQUNsQkcsbUJBQVd2RCxVQUFVbUQsaUJBQWlCLEtBQUtPLDBCQUEwQmpFLElBQUc2RCxJQUFJSyxTQUFTLFdBQVdoRCxJQUFJOztBQUV0RzdELG9CQUFjUDtBQUVkLFdBQUtxSCxjQUFjTixLQUFLN0QsSUFBRzhELFlBQVk1QyxJQUFBQTtJQUN6QztFQUNGO0VBRUFxQixpQkFBaUI7QUFDZixVQUFNNUMsT0FBTyxLQUFLQztBQUNsQixVQUFNd0UsV0FBV3pFLEtBQUtGO0FBQ3RCLFFBQUk2QyxRQUFRO0FBQ1osUUFBSXRDO0FBRUosU0FBS0EsS0FBSSxHQUFHQSxLQUFJb0UsU0FBU3pELFFBQVFYLE1BQUs7QUFDcEMsWUFBTXFFLFFBQVExRSxLQUFLRyxRQUFRRSxFQUFFO0FBQzdCLFVBQUlxRSxVQUFVLFFBQVEsQ0FBQ0MsTUFBTUQsS0FBQUEsS0FBVSxLQUFLdEYsTUFBTWdFLGtCQUFrQi9DLEVBQUFBLEtBQU0sQ0FBQ29FLFNBQVNwRSxFQUFFLEVBQUNnRCxRQUFRO0FBQzdGVixpQkFBUzlFLEtBQUsrRyxJQUFJRixLQUFBQTs7SUFFdEI7QUFFQSxXQUFPL0I7RUFDVDtFQUVBVyx1QkFBdUJvQixPQUFPO0FBQzVCLFVBQU0vQixRQUFRLEtBQUsxQyxZQUFZMEM7QUFDL0IsUUFBSUEsUUFBUSxLQUFLLENBQUNnQyxNQUFNRCxLQUFRLEdBQUE7QUFDOUIsYUFBT2pILE9BQU9JLEtBQUsrRyxJQUFJRixLQUFBQSxJQUFTL0I7O0FBRWxDLFdBQU87RUFDVDtFQUVBa0MsaUJBQWlCMUMsT0FBTztBQUN0QixVQUFNbkMsT0FBTyxLQUFLQztBQUNsQixVQUFNYixRQUFRLEtBQUtBO0FBQ25CLFVBQU0wRixTQUFTMUYsTUFBTVUsS0FBS2dGLFVBQVUsQ0FBQTtBQUNwQyxVQUFNSixRQUFRSyxhQUFhL0UsS0FBS0csUUFBUWdDLEtBQUFBLEdBQVEvQyxNQUFNd0IsUUFBUW9FLE1BQU07QUFFcEUsV0FBTztNQUNMQyxPQUFPSCxPQUFPM0MsS0FBQUEsS0FBVTtNQUN4QnVDO0lBQ0Y7RUFDRjtFQUVBL0Msa0JBQWtCRixNQUFNO0FBQ3RCLFFBQUlqRCxNQUFNO0FBQ1YsVUFBTVksUUFBUSxLQUFLQTtBQUNuQixRQUFJaUIsSUFBR0ksTUFBTVQsTUFBTXFCLFlBQVlUO0FBRS9CLFFBQUksQ0FBQ2EsTUFBTTtBQUVULFdBQUtwQixLQUFJLEdBQUdJLE9BQU9yQixNQUFNVSxLQUFLaUIsU0FBU0MsUUFBUVgsS0FBSUksTUFBTSxFQUFFSixJQUFHO0FBQzVELFlBQUlqQixNQUFNNkIsaUJBQWlCWixFQUFJLEdBQUE7QUFDN0JMLGlCQUFPWixNQUFNOEIsZUFBZWIsRUFBQUE7QUFDNUJvQixpQkFBT3pCLEtBQUtGO0FBQ1p1Qix1QkFBYXJCLEtBQUtxQjtBQUNsQjs7TUFFSjs7QUFHRixRQUFJLENBQUNJLE1BQU07QUFDVCxhQUFPOztBQUdULFNBQUtwQixLQUFJLEdBQUdJLE9BQU9nQixLQUFLVCxRQUFRWCxLQUFJSSxNQUFNLEVBQUVKLElBQUc7QUFDN0NPLGdCQUFVUyxXQUFXaUQsMEJBQTBCakUsRUFBQUE7QUFDL0MsVUFBSU8sUUFBUXNFLGdCQUFnQixTQUFTO0FBQ25DMUcsY0FBTVgsS0FBS1csSUFBSUEsS0FBS29DLFFBQVF1RSxlQUFlLEdBQUd2RSxRQUFRd0Usb0JBQW9CLENBQUE7O0lBRTlFO0FBQ0EsV0FBTzVHO0VBQ1Q7RUFFQW9ELGFBQWFILE1BQU07QUFDakIsUUFBSWpELE1BQU07QUFFVixhQUFTNkIsS0FBSSxHQUFHSSxPQUFPZ0IsS0FBS1QsUUFBUVgsS0FBSUksTUFBTSxFQUFFSixJQUFHO0FBQ2pELFlBQU1PLFVBQVUsS0FBSzBELDBCQUEwQmpFLEVBQUFBO0FBQy9DN0IsWUFBTVgsS0FBS1csSUFBSUEsS0FBS29DLFFBQVF5RSxVQUFVLEdBQUd6RSxRQUFRMEUsZUFBZSxDQUFBO0lBQ2xFO0FBQ0EsV0FBTzlHO0VBQ1Q7RUFNQXFFLHFCQUFxQnhELGNBQWM7QUFDakMsUUFBSWtHLG1CQUFtQjtBQUV2QixhQUFTbEYsS0FBSSxHQUFHQSxLQUFJaEIsY0FBYyxFQUFFZ0IsSUFBRztBQUNyQyxVQUFJLEtBQUtqQixNQUFNNkIsaUJBQWlCWixFQUFJLEdBQUE7QUFDbENrRiw0QkFBb0IsS0FBS3JELGVBQWU3QixFQUFBQTs7SUFFNUM7QUFFQSxXQUFPa0Y7RUFDVDtFQUtBckQsZUFBZTdDLGNBQWM7QUFDM0IsV0FBT3hCLEtBQUtXLElBQUlnSCxlQUFlLEtBQUtwRyxNQUFNVSxLQUFLaUIsU0FBUzFCLFlBQUFBLEVBQWNvRyxRQUFRLENBQUksR0FBQSxDQUFBO0VBQ3BGO0VBTUEvQyxnQ0FBZ0M7QUFDOUIsV0FBTyxLQUFLRyxxQkFBcUIsS0FBS3pELE1BQU1VLEtBQUtpQixTQUFTQyxNQUFNLEtBQUs7RUFDdkU7QUFDRjtBQXhXRSxjQUZtQi9CLG9CQUVaeUcsTUFBSztBQUtaLGNBUG1Cekcsb0JBT1owRyxZQUFXO0VBQ2hCQyxvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUNqQjNDLFdBQVc7SUFFVEMsZUFBZTtJQUVmVyxjQUFjO0VBQ2hCO0VBQ0FnQyxZQUFZO0lBQ1ZDLFNBQVM7TUFDUDVFLE1BQU07TUFDTmdELFlBQVk7UUFBQztRQUFpQjtRQUFZO1FBQWU7UUFBZTtRQUFjO1FBQUs7UUFBSztRQUFVO1FBQWU7TUFBVTtJQUNySTtFQUNGO0VBRUEvRyxRQUFRO0VBR1JGLFVBQVU7RUFHVkMsZUFBZTtFQUdmcUYsUUFBUTtFQUdSZCxTQUFTO0VBRVRzRSxXQUFXOztBQUdiLGNBeENtQi9HLG9CQXdDWmdILGVBQWM7RUFDbkJDLGFBQWEsQ0FBQ0MsU0FBU0EsU0FBUztFQUNoQ0MsWUFBWSxDQUFDRCxTQUFTQSxTQUFTLGFBQWEsQ0FBQ0EsS0FBS0UsV0FBVyxZQUFpQixLQUFBLENBQUNGLEtBQUtFLFdBQVcsaUJBQUE7O0FBTWpHLGNBaERtQnBILG9CQWdEWnFILGFBQVk7RUFDakJDLGFBQWE7RUFHYkMsU0FBUztJQUNQQyxRQUFRO01BQ04zQixRQUFRO1FBQ040QixlQUFldEgsT0FBTztBQUNwQixnQkFBTVUsT0FBT1YsTUFBTVU7QUFDbkIsZ0JBQU0sRUFBQ2dGLFFBQVEsRUFBQzZCLFlBQVlDLFdBQVdDLE9BQUFBLFFBQU9DLGlCQUFpQkMsYUFBQUEsRUFBYSxJQUFJM0gsTUFBTXFILE9BQU83RjtBQUM3RixjQUFJZCxLQUFLZ0YsT0FBTzlELFVBQVVsQixLQUFLaUIsU0FBU0MsUUFBUTtBQUM5QyxtQkFBT2xCLEtBQUtnRixPQUFPa0MsSUFBSSxDQUFDL0IsT0FBTzVFLE9BQU07QUFDbkMsb0JBQU1MLE9BQU9aLE1BQU04QixlQUFlLENBQUE7QUFDbEMsb0JBQU0rRixRQUFRakgsS0FBS3FCLFdBQVc2RixTQUFTN0csRUFBQUE7QUFFdkMscUJBQU87Z0JBQ0w4RyxNQUFNbEM7Z0JBQ05tQyxXQUFXSCxNQUFNSTtnQkFDakJDLFdBQVdUO2dCQUNYeEQsUUFBUSxDQUFDakUsTUFBTWdFLGtCQUFrQi9DLEVBQUFBO2dCQUNqQ2tILFVBQVVOLE1BQU1PO2dCQUNoQkMsZ0JBQWdCUixNQUFNUztnQkFDdEJDLFVBQVVWLE1BQU1XO2dCQUNoQkMsV0FBV1osTUFBTTlCO2dCQUNqQjJDLGFBQWFiLE1BQU1jO2dCQUNuQm5CO2dCQUNBRDtnQkFDQUksY0FBY0Qsb0JBQW9CQyxnQkFBZ0JFLE1BQU1GO2dCQUV4RDVFLE9BQU85QjtjQUNUO1lBQ0YsQ0FBQTs7QUFFRixpQkFBTyxDQUFBO1FBQ1Q7TUFDRjtNQUVBMkgsUUFBUUMsSUFBR0MsWUFBWXpCLFFBQVE7QUFDN0JBLGVBQU9ySCxNQUFNK0kscUJBQXFCRCxXQUFXL0YsS0FBSztBQUNsRHNFLGVBQU9ySCxNQUFNa0MsT0FBTTtNQUNyQjtJQUNGO0VBQ0Y7O0FHM0hXLElBQU04RyxnQkFBTixjQUE0QkMsbUJBQUFBO0FBb0IzQztBQWxCRSxjQUZtQkQsZUFFWkUsTUFBSztBQUtaLGNBUG1CRixlQU9aRyxZQUFXO0VBRWhCQyxRQUFRO0VBR1JDLFVBQVU7RUFHVkMsZUFBZTtFQUdmQyxRQUFROztBRzJDWixTQUFTQyxXQUF3QjtBQUMvQixRQUFNLElBQUlDLE1BQU0saUZBQW1GO0FBQ3JHO0FBUUEsSUFBTUMsa0JBQU4sTUFBTUEsaUJBQUFBO0VBb0JKQyxZQUFZQyxTQUFxQjtBQUZ4QkE7QUFHUCxTQUFLQSxVQUFVQSxXQUFXLENBQUE7RUFDNUI7Ozs7Ozs7Ozs7O0VBVkEsT0FBT0MsU0FDTEMsU0FDQTtBQUNBQyxXQUFPQyxPQUFPTixpQkFBZ0JPLFdBQVdILE9BQUFBO0VBQzNDOztFQVNBSSxPQUFPO0VBQUE7RUFFUEMsVUFBaUQ7QUFDL0MsV0FBT1gsU0FBQUE7RUFDVDtFQUVBWSxRQUF1QjtBQUNyQixXQUFPWixTQUFBQTtFQUNUO0VBRUFhLFNBQWlCO0FBQ2YsV0FBT2IsU0FBQUE7RUFDVDtFQUVBYyxNQUFjO0FBQ1osV0FBT2QsU0FBQUE7RUFDVDtFQUVBZSxPQUFlO0FBQ2IsV0FBT2YsU0FBQUE7RUFDVDtFQUVBZ0IsVUFBa0I7QUFDaEIsV0FBT2hCLFNBQUFBO0VBQ1Q7RUFFQWlCLFFBQWdCO0FBQ2QsV0FBT2pCLFNBQUFBO0VBQ1Q7QUFDRjtBQUVBLElBQUEsV0FBZTtFQUNia0IsT0FBT2hCO0FBTVQ7QUNwSEEsU0FBU2lCLGFBQWFDLFNBQVNDLE1BQU1DLE9BQU9DLFdBQVc7QUFDckQsUUFBTSxFQUFDQyxZQUFZQyxNQUFNQyxRQUFBQSxJQUFXTjtBQUNwQyxRQUFNTyxTQUFTSCxXQUFXSSxZQUFZRDtBQUN0QyxRQUFNRSxXQUFXVCxRQUFRVSxVQUFVVixRQUFRVSxRQUFRMUIsVUFBVWdCLFFBQVFVLFFBQVExQixRQUFReUIsV0FBVyxPQUFPO0FBRXZHLE1BQUlGLFVBQVVOLFNBQVNNLE9BQU9OLFFBQVFBLFNBQVMsT0FBT0ssV0FBV0QsS0FBS00sUUFBUTtBQUM1RSxVQUFNQyxlQUFlTCxPQUFPTSxpQkFBaUJDLGdCQUFnQkM7QUFDN0QsUUFBSSxDQUFDWixXQUFXO0FBQ2QsWUFBTWEsU0FBU0osYUFBYVAsTUFBTUosTUFBTUMsS0FBQUE7QUFDeEMsVUFBSU8sVUFBVTtBQUNaLGNBQU0sRUFBQ1EsT0FBQUEsSUFBVWIsV0FBV0k7QUFDNUIsY0FBTSxFQUFDVSxRQUFPLElBQUlsQjtBQUVsQixjQUFNbUIsc0JBQXVCRCxRQUMxQkUsTUFBTSxHQUFHSixPQUFPSyxLQUFLLENBQ3JCQyxFQUFBQSxRQUFPLEVBQ1BDLFVBQ0NDLENBQUFBLFVBQVMsQ0FBQ0MsY0FBY0QsTUFBTVAsT0FBT2hCLElBQUksQ0FBQyxDQUFBO0FBQzlDZSxlQUFPSyxNQUFNSyxLQUFLQyxJQUFJLEdBQUdSLG1CQUFBQTtBQUV6QixjQUFNUyxzQkFBdUJWLFFBQzFCRSxNQUFNSixPQUFPYSxFQUFFLEVBQ2ZOLFVBQ0NDLENBQUFBLFVBQVMsQ0FBQ0MsY0FBY0QsTUFBTVAsT0FBT2hCLElBQUksQ0FBQyxDQUFBO0FBQzlDZSxlQUFPYSxNQUFNSCxLQUFLQyxJQUFJLEdBQUdDLG1CQUFBQTs7QUFFM0IsYUFBT1o7ZUFDRVosV0FBVzBCLGdCQUFnQjtBQUlwQyxZQUFNQyxLQUFLMUIsS0FBSyxDQUFFO0FBQ2xCLFlBQU0yQixTQUFRLE9BQU9ELEdBQUdFLGFBQWEsY0FBY0YsR0FBR0UsU0FBU2hDLElBQUFBO0FBQy9ELFVBQUkrQixRQUFPO0FBQ1QsY0FBTUUsUUFBUXRCLGFBQWFQLE1BQU1KLE1BQU1DLFFBQVE4QixNQUFBQTtBQUMvQyxjQUFNRyxNQUFNdkIsYUFBYVAsTUFBTUosTUFBTUMsUUFBUThCLE1BQUFBO0FBQzdDLGVBQU87VUFBQ1gsSUFBSWEsTUFBTWI7VUFBSVEsSUFBSU0sSUFBSU47UUFBRTs7OztBQUt0QyxTQUFPO0lBQUNSLElBQUk7SUFBR1EsSUFBSXhCLEtBQUtNLFNBQVM7RUFBQztBQUNwQztBQVVBLFNBQVN5Qix5QkFBeUJDLE9BQU9wQyxNQUFNcUMsVUFBVUMsU0FBU3BDLFdBQVc7QUFDM0UsUUFBTXFDLFdBQVdILE1BQU1JLDZCQUE0QjtBQUNuRCxRQUFNdkMsUUFBUW9DLFNBQVNyQyxJQUFLO0FBQzVCLFdBQVN5QyxLQUFJLEdBQUdDLE9BQU9ILFNBQVM3QixRQUFRK0IsS0FBSUMsTUFBTSxFQUFFRCxJQUFHO0FBQ3JELFVBQU0sRUFBQ0UsT0FBT3ZDLEtBQUFBLElBQVFtQyxTQUFTRSxFQUFFO0FBQ2pDLFVBQU0sRUFBQ3JCLElBQUlRLEdBQUFBLElBQU05QixhQUFheUMsU0FBU0UsRUFBQUEsR0FBSXpDLE1BQU1DLE9BQU9DLFNBQUFBO0FBQ3hELGFBQVMwQyxLQUFJeEIsSUFBSXdCLE1BQUtoQixJQUFJLEVBQUVnQixJQUFHO0FBQzdCLFlBQU1DLFVBQVV6QyxLQUFLd0MsRUFBRTtBQUN2QixVQUFJLENBQUNDLFFBQVFDLE1BQU07QUFDakJSLGdCQUFRTyxTQUFTRixPQUFPQyxFQUFBQTs7SUFFNUI7RUFDRjtBQUNGO0FBT0EsU0FBU0cseUJBQXlCL0MsTUFBTTtBQUN0QyxRQUFNZ0QsT0FBT2hELEtBQUtpRCxRQUFRLEdBQUEsTUFBUztBQUNuQyxRQUFNQyxPQUFPbEQsS0FBS2lELFFBQVEsR0FBQSxNQUFTO0FBRW5DLFNBQU8sU0FBU0UsS0FBS0MsS0FBSztBQUN4QixVQUFNQyxTQUFTTCxPQUFPdkIsS0FBSzZCLElBQUlILElBQUlJLElBQUlILElBQUlHLENBQUMsSUFBSTtBQUNoRCxVQUFNQyxTQUFTTixPQUFPekIsS0FBSzZCLElBQUlILElBQUlNLElBQUlMLElBQUlLLENBQUMsSUFBSTtBQUNoRCxXQUFPaEMsS0FBS2lDLEtBQUtqQyxLQUFLa0MsSUFBSU4sUUFBUSxDQUFLNUIsSUFBQUEsS0FBS2tDLElBQUlILFFBQVEsQ0FBQSxDQUFBO0VBQzFEO0FBQ0Y7QUFXQSxTQUFTSSxrQkFBa0J4QixPQUFPQyxVQUFVckMsTUFBTTZELGtCQUFrQkMsa0JBQWtCO0FBQ3BGLFFBQU1DLFFBQVEsQ0FBQTtBQUVkLE1BQUksQ0FBQ0Qsb0JBQW9CLENBQUMxQixNQUFNNEIsY0FBYzNCLFFBQVcsR0FBQTtBQUN2RCxXQUFPMEI7O0FBR1QsUUFBTUUsaUJBQWlCLFNBQVNwQixTQUFTcUIsY0FBY3ZCLE9BQU87QUFDNUQsUUFBSSxDQUFDbUIsb0JBQW9CLENBQUNLLGVBQWV0QixTQUFTVCxNQUFNZ0MsV0FBVyxDQUFJLEdBQUE7QUFDckU7O0FBRUYsUUFBSXZCLFFBQVF3QixRQUFRaEMsU0FBU2tCLEdBQUdsQixTQUFTb0IsR0FBR0ksZ0JBQW1CLEdBQUE7QUFDN0RFLFlBQU1PLEtBQUs7UUFBQ3pCO1FBQVNxQjtRQUFjdkI7TUFBSyxDQUFBOztFQUU1QztBQUVBUiwyQkFBeUJDLE9BQU9wQyxNQUFNcUMsVUFBVTRCLGdCQUFnQixJQUFJO0FBQ3BFLFNBQU9GO0FBQ1Q7QUFVQSxTQUFTUSxzQkFBc0JuQyxPQUFPQyxVQUFVckMsTUFBTTZELGtCQUFrQjtBQUN0RSxNQUFJRSxRQUFRLENBQUE7QUFFWixXQUFTRSxlQUFlcEIsU0FBU3FCLGNBQWN2QixPQUFPO0FBQ3BELFVBQU0sRUFBQzZCLFlBQVlDLFNBQUFBLElBQVk1QixRQUFRNkIsU0FBUztNQUFDO01BQWM7T0FBYWIsZ0JBQUFBO0FBQzVFLFVBQU0sRUFBQ2MsTUFBQUEsSUFBU0Msa0JBQWtCL0IsU0FBUztNQUFDVSxHQUFHbEIsU0FBU2tCO01BQUdFLEdBQUdwQixTQUFTb0I7SUFBQyxDQUFBO0FBRXhFLFFBQUlvQixjQUFjRixPQUFPSCxZQUFZQyxRQUFXLEdBQUE7QUFDOUNWLFlBQU1PLEtBQUs7UUFBQ3pCO1FBQVNxQjtRQUFjdkI7TUFBSyxDQUFBOztFQUU1QztBQUVBUiwyQkFBeUJDLE9BQU9wQyxNQUFNcUMsVUFBVTRCLGNBQUFBO0FBQ2hELFNBQU9GO0FBQ1Q7QUFZQSxTQUFTZSx5QkFBeUIxQyxPQUFPQyxVQUFVckMsTUFBTUUsV0FBVzJELGtCQUFrQkMsa0JBQWtCO0FBQ3RHLE1BQUlDLFFBQVEsQ0FBQTtBQUNaLFFBQU1nQixpQkFBaUJoQyx5QkFBeUIvQyxJQUFBQTtBQUNoRCxNQUFJZ0YsY0FBY0MsT0FBT0M7QUFFekIsV0FBU2pCLGVBQWVwQixTQUFTcUIsY0FBY3ZCLE9BQU87QUFDcEQsVUFBTTBCLFdBQVV4QixRQUFRd0IsUUFBUWhDLFNBQVNrQixHQUFHbEIsU0FBU29CLEdBQUdJLGdCQUFBQTtBQUN4RCxRQUFJM0QsYUFBYSxDQUFDbUUsVUFBUztBQUN6Qjs7QUFHRixVQUFNYyxTQUFTdEMsUUFBUXVDLGVBQWV2QixnQkFBQUE7QUFDdEMsVUFBTXdCLGNBQWMsQ0FBQyxDQUFDdkIsb0JBQW9CMUIsTUFBTTRCLGNBQWNtQixNQUFBQTtBQUM5RCxRQUFJLENBQUNFLGVBQWUsQ0FBQ2hCLFVBQVM7QUFDNUI7O0FBR0YsVUFBTWlCLFdBQVdQLGVBQWUxQyxVQUFVOEMsTUFBQUE7QUFDMUMsUUFBSUcsV0FBV04sYUFBYTtBQUMxQmpCLGNBQVE7UUFBQztVQUFDbEI7VUFBU3FCO1VBQWN2QjtRQUFLO01BQUU7QUFDeENxQyxvQkFBY007ZUFDTEEsYUFBYU4sYUFBYTtBQUVuQ2pCLFlBQU1PLEtBQUs7UUFBQ3pCO1FBQVNxQjtRQUFjdkI7TUFBSyxDQUFBOztFQUU1QztBQUVBUiwyQkFBeUJDLE9BQU9wQyxNQUFNcUMsVUFBVTRCLGNBQUFBO0FBQ2hELFNBQU9GO0FBQ1Q7QUFZQSxTQUFTd0IsZ0JBQWdCbkQsT0FBT0MsVUFBVXJDLE1BQU1FLFdBQVcyRCxrQkFBa0JDLGtCQUFrQjtBQUM3RixNQUFJLENBQUNBLG9CQUFvQixDQUFDMUIsTUFBTTRCLGNBQWMzQixRQUFXLEdBQUE7QUFDdkQsV0FBTyxDQUFBOztBQUdULFNBQU9yQyxTQUFTLE9BQU8sQ0FBQ0UsWUFDcEJxRSxzQkFBc0JuQyxPQUFPQyxVQUFVckMsTUFBTTZELGdCQUFBQSxJQUM3Q2lCLHlCQUF5QjFDLE9BQU9DLFVBQVVyQyxNQUFNRSxXQUFXMkQsa0JBQWtCQyxnQkFBaUI7QUFDcEc7QUFXQSxTQUFTMEIsYUFBYXBELE9BQU9DLFVBQVVyQyxNQUFNRSxXQUFXMkQsa0JBQWtCO0FBQ3hFLFFBQU1FLFFBQVEsQ0FBQTtBQUNkLFFBQU0wQixjQUFjekYsU0FBUyxNQUFNLGFBQWE7QUFDaEQsTUFBSTBGLGlCQUFpQjtBQUVyQnZELDJCQUF5QkMsT0FBT3BDLE1BQU1xQyxVQUFVLENBQUNRLFNBQVNxQixjQUFjdkIsVUFBVTtBQUNoRixRQUFJRSxRQUFRNEMsV0FBWSxLQUFJNUMsUUFBUTRDLFdBQVksRUFBQ3BELFNBQVNyQyxJQUFLLEdBQUU2RCxnQkFBbUIsR0FBQTtBQUNsRkUsWUFBTU8sS0FBSztRQUFDekI7UUFBU3FCO1FBQWN2QjtNQUFLLENBQUE7QUFDeEMrQyx1QkFBaUJBLGtCQUFrQjdDLFFBQVF3QixRQUFRaEMsU0FBU2tCLEdBQUdsQixTQUFTb0IsR0FBR0ksZ0JBQUFBOztFQUUvRSxDQUFBO0FBSUEsTUFBSTNELGFBQWEsQ0FBQ3dGLGdCQUFnQjtBQUNoQyxXQUFPLENBQUE7O0FBRVQsU0FBTzNCO0FBQ1Q7QUFNQSxJQUFBLGNBQWU7RUFFYjVCO0VBR0F3RCxPQUFPO0lBWUxoRCxNQUFNUCxPQUFPd0QsSUFBRzdHLFNBQVM4RSxrQkFBa0I7QUFDekMsWUFBTXhCLFdBQVd3RCxvQkFBb0JELElBQUd4RCxLQUFBQTtBQUV4QyxZQUFNcEMsT0FBT2pCLFFBQVFpQixRQUFRO0FBQzdCLFlBQU04RCxtQkFBbUIvRSxRQUFRK0Usb0JBQW9CO0FBQ3JELFlBQU1DLFFBQVFoRixRQUFRbUIsWUFDbEIwRCxrQkFBa0J4QixPQUFPQyxVQUFVckMsTUFBTTZELGtCQUFrQkMsZ0JBQUFBLElBQzNEeUIsZ0JBQWdCbkQsT0FBT0MsVUFBVXJDLE1BQU0sT0FBTzZELGtCQUFrQkMsZ0JBQWlCO0FBQ3JGLFlBQU1nQyxXQUFXLENBQUE7QUFFakIsVUFBSSxDQUFDL0IsTUFBTXJELFFBQVE7QUFDakIsZUFBTyxDQUFBOztBQUdUMEIsWUFBTUksNkJBQTRCLEVBQUd1RCxRQUFRLENBQUNDLFNBQVM7QUFDckQsY0FBTXJELFFBQVFvQixNQUFNLENBQUEsRUFBR3BCO0FBQ3ZCLGNBQU1FLFVBQVVtRCxLQUFLNUYsS0FBS3VDLEtBQU07QUFHaEMsWUFBSUUsV0FBVyxDQUFDQSxRQUFRQyxNQUFNO0FBQzVCZ0QsbUJBQVN4QixLQUFLO1lBQUN6QjtZQUFTcUIsY0FBYzhCLEtBQUtyRDtZQUFPQTtVQUFLLENBQUE7O01BRTNELENBQUE7QUFFQSxhQUFPbUQ7SUFDVDtJQVlBckYsUUFBUTJCLE9BQU93RCxJQUFHN0csU0FBUzhFLGtCQUFrQjtBQUMzQyxZQUFNeEIsV0FBV3dELG9CQUFvQkQsSUFBR3hELEtBQUFBO0FBQ3hDLFlBQU1wQyxPQUFPakIsUUFBUWlCLFFBQVE7QUFDN0IsWUFBTThELG1CQUFtQi9FLFFBQVErRSxvQkFBb0I7QUFDckQsVUFBSUMsUUFBUWhGLFFBQVFtQixZQUNoQjBELGtCQUFrQnhCLE9BQU9DLFVBQVVyQyxNQUFNNkQsa0JBQWtCQyxnQkFBQUEsSUFDN0R5QixnQkFBZ0JuRCxPQUFPQyxVQUFVckMsTUFBTSxPQUFPNkQsa0JBQWtCQyxnQkFBaUI7QUFFbkYsVUFBSUMsTUFBTXJELFNBQVMsR0FBRztBQUNwQixjQUFNd0QsZUFBZUgsTUFBTSxDQUFBLEVBQUdHO0FBQzlCLGNBQU05RCxPQUFPZ0MsTUFBTTZELGVBQWUvQixZQUFBQSxFQUFjOUQ7QUFDaEQyRCxnQkFBUSxDQUFBO0FBQ1IsaUJBQVN0QixLQUFJLEdBQUdBLEtBQUlyQyxLQUFLTSxRQUFRLEVBQUUrQixJQUFHO0FBQ3BDc0IsZ0JBQU1PLEtBQUs7WUFBQ3pCLFNBQVN6QyxLQUFLcUMsRUFBRTtZQUFFeUI7WUFBY3ZCLE9BQU9GO1VBQUMsQ0FBQTtRQUN0RDs7QUFHRixhQUFPc0I7SUFDVDtJQVlBeEMsTUFBTWEsT0FBT3dELElBQUc3RyxTQUFTOEUsa0JBQWtCO0FBQ3pDLFlBQU14QixXQUFXd0Qsb0JBQW9CRCxJQUFHeEQsS0FBQUE7QUFDeEMsWUFBTXBDLE9BQU9qQixRQUFRaUIsUUFBUTtBQUM3QixZQUFNOEQsbUJBQW1CL0UsUUFBUStFLG9CQUFvQjtBQUNyRCxhQUFPRixrQkFBa0J4QixPQUFPQyxVQUFVckMsTUFBTTZELGtCQUFrQkMsZ0JBQUFBO0lBQ3BFO0lBV0FvQyxRQUFROUQsT0FBT3dELElBQUc3RyxTQUFTOEUsa0JBQWtCO0FBQzNDLFlBQU14QixXQUFXd0Qsb0JBQW9CRCxJQUFHeEQsS0FBQUE7QUFDeEMsWUFBTXBDLE9BQU9qQixRQUFRaUIsUUFBUTtBQUM3QixZQUFNOEQsbUJBQW1CL0UsUUFBUStFLG9CQUFvQjtBQUNyRCxhQUFPeUIsZ0JBQWdCbkQsT0FBT0MsVUFBVXJDLE1BQU1qQixRQUFRbUIsV0FBVzJELGtCQUFrQkMsZ0JBQUFBO0lBQ3JGO0lBV0FQLEVBQUVuQixPQUFPd0QsSUFBRzdHLFNBQVM4RSxrQkFBa0I7QUFDckMsWUFBTXhCLFdBQVd3RCxvQkFBb0JELElBQUd4RCxLQUFBQTtBQUN4QyxhQUFPb0QsYUFBYXBELE9BQU9DLFVBQVUsS0FBS3RELFFBQVFtQixXQUFXMkQsZ0JBQUFBO0lBQy9EO0lBV0FKLEVBQUVyQixPQUFPd0QsSUFBRzdHLFNBQVM4RSxrQkFBa0I7QUFDckMsWUFBTXhCLFdBQVd3RCxvQkFBb0JELElBQUd4RCxLQUFBQTtBQUN4QyxhQUFPb0QsYUFBYXBELE9BQU9DLFVBQVUsS0FBS3RELFFBQVFtQixXQUFXMkQsZ0JBQUFBO0lBQy9EO0VBQ0Y7QUFDRjtBQzNYQSxJQUFNc0MsbUJBQW1CO0VBQUM7RUFBUTtFQUFPO0VBQVM7QUFBUztBQUUzRCxTQUFTQyxpQkFBaUJDLE9BQU9oRSxVQUFVO0FBQ3pDLFNBQU9nRSxNQUFNQyxPQUFPQyxDQUFBQSxPQUFLQSxHQUFFQyxRQUFRbkUsUUFBQUE7QUFDckM7QUFFQSxTQUFTb0UsNEJBQTRCSixPQUFPckcsTUFBTTtBQUNoRCxTQUFPcUcsTUFBTUMsT0FBT0MsQ0FBQUEsT0FBS0osaUJBQWlCbEQsUUFBUXNELEdBQUVDLEdBQUcsTUFBTSxNQUFNRCxHQUFFRyxJQUFJMUcsU0FBU0EsSUFBQUE7QUFDcEY7QUFFQSxTQUFTMkcsYUFBYU4sT0FBT2hGLFNBQVM7QUFDcEMsU0FBT2dGLE1BQU1PLEtBQUssQ0FBQ0MsSUFBR0MsT0FBTTtBQUMxQixVQUFNQyxLQUFLMUYsVUFBVXlGLEtBQUlEO0FBQ3pCLFVBQU1HLEtBQUszRixVQUFVd0YsS0FBSUM7QUFDekIsV0FBT0MsR0FBR0UsV0FBV0QsR0FBR0MsU0FDdEJGLEdBQUdwRSxRQUFRcUUsR0FBR3JFLFFBQ2RvRSxHQUFHRSxTQUFTRCxHQUFHQztFQUNuQixDQUFBO0FBQ0Y7QUFFQSxTQUFTQyxVQUFVQyxPQUFPO0FBQ3hCLFFBQU1DLGNBQWMsQ0FBQTtBQUNwQixNQUFJM0UsSUFBR0MsTUFBTWdFLEtBQUtGLEtBQUthLE9BQU9DO0FBRTlCLE9BQUs3RSxLQUFJLEdBQUdDLFFBQVF5RSxTQUFTLENBQUEsR0FBSXpHLFFBQVErQixLQUFJQyxNQUFNLEVBQUVELElBQUc7QUFDdERpRSxVQUFNUyxNQUFNMUUsRUFBRTtBQUNiLEtBQUEsRUFBQ0osVUFBVW1FLEtBQUt6SCxTQUFTLEVBQUNzSSxPQUFPQyxjQUFjLEVBQUMsRUFBQyxJQUFJWjtBQUN0RFUsZ0JBQVk5QyxLQUFLO01BQ2YzQixPQUFPRjtNQUNQaUU7TUFDQUY7TUFDQWUsWUFBWWIsSUFBSWMsYUFBWTtNQUM1QlAsUUFBUVAsSUFBSU87TUFDWkksT0FBT0EsU0FBVWIsTUFBTWE7TUFDdkJDO0lBQ0YsQ0FBQTtFQUNGO0FBQ0EsU0FBT0Y7QUFDVDtBQUVBLFNBQVNLLFlBQVlDLFVBQVM7QUFDNUIsUUFBTUMsU0FBUyxDQUFBO0FBQ2YsYUFBV0MsUUFBUUYsVUFBUztBQUMxQixVQUFNLEVBQUNMLE9BQU9iLEtBQUtjLFlBQUFBLElBQWVNO0FBQ2xDLFFBQUksQ0FBQ1AsU0FBUyxDQUFDbEIsaUJBQWlCMEIsU0FBU3JCLEdBQU0sR0FBQTtBQUM3Qzs7QUFFRixVQUFNc0IsU0FBU0gsT0FBT04sS0FBQUEsTUFBV00sT0FBT04sS0FBQUEsSUFBUztNQUFDVSxPQUFPO01BQUdDLFFBQVE7TUFBR2YsUUFBUTtNQUFHZ0IsTUFBTTs7QUFDeEZILFdBQU9DO0FBQ1BELFdBQU9iLFVBQVVLO0VBQ25CO0FBQ0EsU0FBT0s7QUFDVDtBQUtBLFNBQVNPLGNBQWNSLFVBQVNTLFFBQVE7QUFDdEMsUUFBTVIsU0FBU0YsWUFBWUMsUUFBQUE7QUFDM0IsUUFBTSxFQUFDVSxjQUFjQyxjQUFBQSxJQUFpQkY7QUFDdEMsTUFBSTFGLElBQUdDLE1BQU00RjtBQUNiLE9BQUs3RixLQUFJLEdBQUdDLE9BQU9nRixTQUFRaEgsUUFBUStCLEtBQUlDLE1BQU0sRUFBRUQsSUFBRztBQUNoRDZGLGFBQVNaLFNBQVFqRixFQUFFO0FBQ25CLFVBQU0sRUFBQzhGLFNBQUFBLElBQVlELE9BQU81QjtBQUMxQixVQUFNVyxRQUFRTSxPQUFPVyxPQUFPakIsS0FBSztBQUNqQyxVQUFNbUIsU0FBU25CLFNBQVNpQixPQUFPaEIsY0FBY0QsTUFBTUo7QUFDbkQsUUFBSXFCLE9BQU9mLFlBQVk7QUFDckJlLGFBQU9HLFFBQVFELFNBQVNBLFNBQVNKLGVBQWVHLFlBQVlKLE9BQU9PO0FBQ25FSixhQUFPSyxTQUFTTjtXQUNYO0FBQ0xDLGFBQU9HLFFBQVFMO0FBQ2ZFLGFBQU9LLFNBQVNILFNBQVNBLFNBQVNILGdCQUFnQkUsWUFBWUosT0FBT1M7O0VBRXpFO0FBQ0EsU0FBT2pCO0FBQ1Q7QUFFQSxTQUFTa0IsaUJBQWlCMUIsT0FBTztBQUMvQixRQUFNQyxjQUFjRixVQUFVQyxLQUFBQTtBQUM5QixRQUFNb0IsV0FBVzVCLGFBQWFTLFlBQVlkLE9BQU9zQixDQUFBQSxTQUFRQSxLQUFLbEIsSUFBSTZCLFFBQVEsR0FBRyxJQUFJO0FBQ2pGLFFBQU1PLE9BQU9uQyxhQUFhUCxpQkFBaUJnQixhQUFhLE1BQUEsR0FBUyxJQUFJO0FBQ3JFLFFBQU0yQixRQUFRcEMsYUFBYVAsaUJBQWlCZ0IsYUFBYSxPQUFBLENBQUE7QUFDekQsUUFBTTRCLE1BQU1yQyxhQUFhUCxpQkFBaUJnQixhQUFhLEtBQUEsR0FBUSxJQUFJO0FBQ25FLFFBQU02QixTQUFTdEMsYUFBYVAsaUJBQWlCZ0IsYUFBYSxRQUFBLENBQUE7QUFDMUQsUUFBTThCLG1CQUFtQnpDLDRCQUE0QlcsYUFBYSxHQUFBO0FBQ2xFLFFBQU0rQixpQkFBaUIxQyw0QkFBNEJXLGFBQWEsR0FBQTtBQUVoRSxTQUFPO0lBQ0xtQjtJQUNBYSxZQUFZTixLQUFLTyxPQUFPTCxHQUFBQTtJQUN4Qk0sZ0JBQWdCUCxNQUFNTSxPQUFPRixjQUFBQSxFQUFnQkUsT0FBT0osTUFBQUEsRUFBUUksT0FBT0gsZ0JBQUFBO0lBQ25FOUUsV0FBV2dDLGlCQUFpQmdCLGFBQWEsV0FBQTtJQUN6Q21DLFVBQVVULEtBQUtPLE9BQU9OLEtBQUFBLEVBQU9NLE9BQU9GLGNBQUFBO0lBQ3BDNUIsWUFBWXlCLElBQUlLLE9BQU9KLE1BQUFBLEVBQVFJLE9BQU9ILGdCQUFBQTtFQUN4QztBQUNGO0FBRUEsU0FBU00sZUFBZUMsWUFBWXJGLFdBQVd5QyxJQUFHQyxJQUFHO0FBQ25ELFNBQU9yRixLQUFLQyxJQUFJK0gsV0FBVzVDLEVBQUUsR0FBRXpDLFVBQVV5QyxFQUFBQSxDQUFFLElBQUlwRixLQUFLQyxJQUFJK0gsV0FBVzNDLEVBQUFBLEdBQUkxQyxVQUFVMEMsRUFBRSxDQUFBO0FBQ3JGO0FBRUEsU0FBUzRDLGlCQUFpQkQsWUFBWUUsWUFBWTtBQUNoREYsYUFBV1QsTUFBTXZILEtBQUtDLElBQUkrSCxXQUFXVCxLQUFLVyxXQUFXWCxHQUFHO0FBQ3hEUyxhQUFXWCxPQUFPckgsS0FBS0MsSUFBSStILFdBQVdYLE1BQU1hLFdBQVdiLElBQUk7QUFDM0RXLGFBQVdSLFNBQVN4SCxLQUFLQyxJQUFJK0gsV0FBV1IsUUFBUVUsV0FBV1YsTUFBTTtBQUNqRVEsYUFBV1YsUUFBUXRILEtBQUtDLElBQUkrSCxXQUFXVixPQUFPWSxXQUFXWixLQUFLO0FBQ2hFO0FBRUEsU0FBU2EsV0FBV3hGLFdBQVcrRCxRQUFRRyxRQUFRWCxRQUFRO0FBQ3JELFFBQU0sRUFBQ25CLEtBQUtFLElBQUFBLElBQU80QjtBQUNuQixRQUFNbUIsYUFBYXJGLFVBQVVxRjtBQUc3QixNQUFJLENBQUNJLFNBQVNyRCxHQUFNLEdBQUE7QUFDbEIsUUFBSThCLE9BQU9MLE1BQU07QUFFZjdELGdCQUFVb0MsR0FBQUEsS0FBUThCLE9BQU9MOztBQUUzQixVQUFNWixRQUFRTSxPQUFPVyxPQUFPakIsS0FBSyxLQUFLO01BQUNZLE1BQU07TUFBR0YsT0FBTztJQUFDO0FBQ3hEVixVQUFNWSxPQUFPeEcsS0FBS0MsSUFBSTJGLE1BQU1ZLE1BQU1LLE9BQU9mLGFBQWFiLElBQUlpQyxTQUFTakMsSUFBSStCLEtBQUs7QUFDNUVILFdBQU9MLE9BQU9aLE1BQU1ZLE9BQU9aLE1BQU1VO0FBQ2pDM0QsY0FBVW9DLEdBQUFBLEtBQVE4QixPQUFPTDs7QUFHM0IsTUFBSXZCLElBQUlvRCxZQUFZO0FBQ2xCSixxQkFBaUJELFlBQVkvQyxJQUFJb0QsV0FBVSxDQUFBOztBQUc3QyxRQUFNQyxXQUFXdEksS0FBS0MsSUFBSSxHQUFHeUcsT0FBTzZCLGFBQWFSLGVBQWVDLFlBQVlyRixXQUFXLFFBQVEsT0FBQSxDQUFBO0FBQy9GLFFBQU02RixZQUFZeEksS0FBS0MsSUFBSSxHQUFHeUcsT0FBTytCLGNBQWNWLGVBQWVDLFlBQVlyRixXQUFXLE9BQU8sUUFBQSxDQUFBO0FBQ2hHLFFBQU0rRixlQUFlSixhQUFhM0YsVUFBVWdHO0FBQzVDLFFBQU1DLGdCQUFnQkosY0FBYzdGLFVBQVVrRztBQUM5Q2xHLFlBQVVnRyxJQUFJTDtBQUNkM0YsWUFBVWtHLElBQUlMO0FBR2QsU0FBTzNCLE9BQU9mLGFBQ1Y7SUFBQ2dELE1BQU1KO0lBQWNLLE9BQU9IO01BQzVCO0lBQUNFLE1BQU1GO0lBQWVHLE9BQU9MOztBQUNuQztBQUVBLFNBQVNNLGlCQUFpQnJHLFdBQVc7QUFDbkMsUUFBTXFGLGFBQWFyRixVQUFVcUY7QUFFN0IsV0FBU2lCLFVBQVVsRSxLQUFLO0FBQ3RCLFVBQU1tRSxTQUFTbEosS0FBS0MsSUFBSStILFdBQVdqRCxHQUFBQSxJQUFPcEMsVUFBVW9DLEdBQUFBLEdBQU0sQ0FBQTtBQUMxRHBDLGNBQVVvQyxHQUFBQSxLQUFRbUU7QUFDbEIsV0FBT0E7RUFDVDtBQUNBdkcsWUFBVVgsS0FBS2lILFVBQVUsS0FBQTtBQUN6QnRHLFlBQVViLEtBQUttSCxVQUFVLE1BQUE7QUFDekJBLFlBQVUsT0FBQTtBQUNWQSxZQUFVLFFBQUE7QUFDWjtBQUVBLFNBQVNFLFdBQVdyRCxZQUFZbkQsV0FBVztBQUN6QyxRQUFNcUYsYUFBYXJGLFVBQVVxRjtBQUU3QixXQUFTb0IsbUJBQW1CQyxZQUFXO0FBQ3JDLFVBQU1DLFNBQVM7TUFBQ2pDLE1BQU07TUFBR0UsS0FBSztNQUFHRCxPQUFPO01BQUdFLFFBQVE7SUFBQztBQUNwRDZCLElBQUFBLFdBQVUvRSxRQUFRLENBQUNTLFFBQVE7QUFDekJ1RSxhQUFPdkUsR0FBQUEsSUFBTy9FLEtBQUtDLElBQUkwQyxVQUFVb0MsR0FBSSxHQUFFaUQsV0FBV2pELEdBQUksQ0FBQTtJQUN4RCxDQUFBO0FBQ0EsV0FBT3VFO0VBQ1Q7QUFFQSxTQUFPeEQsYUFDSHNELG1CQUFtQjtJQUFDO0lBQVE7RUFBUSxDQUFBLElBQ3BDQSxtQkFBbUI7SUFBQztJQUFPO0dBQVM7QUFDMUM7QUFFQSxTQUFTRyxTQUFTN0QsT0FBTy9DLFdBQVcrRCxRQUFRUixRQUFRO0FBQ2xELFFBQU1zRCxhQUFhLENBQUE7QUFDbkIsTUFBSXhJLElBQUdDLE1BQU00RixRQUFRNUIsS0FBS3dFLE9BQU9DO0FBRWpDLE9BQUsxSSxLQUFJLEdBQUdDLE9BQU95RSxNQUFNekcsUUFBUXdLLFFBQVEsR0FBR3pJLEtBQUlDLE1BQU0sRUFBRUQsSUFBRztBQUN6RDZGLGFBQVNuQixNQUFNMUUsRUFBRTtBQUNqQmlFLFVBQU00QixPQUFPNUI7QUFFYkEsUUFBSTBFLE9BQ0Y5QyxPQUFPRyxTQUFTckUsVUFBVWdHLEdBQzFCOUIsT0FBT0ssVUFBVXZFLFVBQVVrRyxHQUMzQk0sV0FBV3RDLE9BQU9mLFlBQVluRCxTQUFBQSxDQUFBQTtBQUVoQyxVQUFNLEVBQUNtRyxNQUFNQyxNQUFBQSxJQUFTWixXQUFXeEYsV0FBVytELFFBQVFHLFFBQVFYLE1BQUFBO0FBSTVEdUQsYUFBU1gsUUFBUVUsV0FBV3ZLO0FBRzVCeUssY0FBVUEsV0FBV1g7QUFFckIsUUFBSSxDQUFDOUQsSUFBSTZCLFVBQVU7QUFDakIwQyxpQkFBVzNHLEtBQUtnRSxNQUFBQTs7RUFFcEI7QUFFQSxTQUFPNEMsU0FBU0YsU0FBU0MsWUFBWTdHLFdBQVcrRCxRQUFRUixNQUFXd0QsS0FBQUE7QUFDckU7QUFFQSxTQUFTRSxXQUFXM0UsS0FBS29DLE1BQU1FLEtBQUtQLE9BQU9FLFFBQVE7QUFDakRqQyxNQUFJc0MsTUFBTUE7QUFDVnRDLE1BQUlvQyxPQUFPQTtBQUNYcEMsTUFBSXFDLFFBQVFELE9BQU9MO0FBQ25CL0IsTUFBSXVDLFNBQVNELE1BQU1MO0FBQ25CakMsTUFBSStCLFFBQVFBO0FBQ1ovQixNQUFJaUMsU0FBU0E7QUFDZjtBQUVBLFNBQVMyQyxXQUFXbkUsT0FBTy9DLFdBQVcrRCxRQUFRUixRQUFRO0FBQ3BELFFBQU00RCxjQUFjcEQsT0FBT3FEO0FBQzNCLE1BQUksRUFBQ2pJLEdBQUFBLElBQUdFLEdBQUFBLEdBQUFBLElBQUtXO0FBRWIsYUFBV2tFLFVBQVVuQixPQUFPO0FBQzFCLFVBQU1ULE1BQU00QixPQUFPNUI7QUFDbkIsVUFBTVcsUUFBUU0sT0FBT1csT0FBT2pCLEtBQUssS0FBSztNQUFDVSxPQUFPO01BQUdDLFFBQVE7TUFBR2YsUUFBUTtJQUFDO0FBQ3JFLFVBQU1BLFNBQVMsT0FBUUssY0FBY0QsTUFBTUosVUFBVztBQUN0RCxRQUFJcUIsT0FBT2YsWUFBWTtBQUNyQixZQUFNa0IsUUFBUXJFLFVBQVVnRyxJQUFJbkQ7QUFDNUIsWUFBTTBCLFNBQVN0QixNQUFNWSxRQUFRdkIsSUFBSWlDO0FBQ2pDLFVBQUk4QyxRQUFRcEUsTUFBTXBGLEtBQUssR0FBRztBQUN4QndCLFFBQUFBLEtBQUk0RCxNQUFNcEY7O0FBRVosVUFBSXlFLElBQUk2QixVQUFVO0FBQ2hCOEMsbUJBQVczRSxLQUFLNkUsWUFBWXpDLE1BQU1yRixJQUFHMEUsT0FBTzZCLGFBQWF1QixZQUFZeEMsUUFBUXdDLFlBQVl6QyxNQUFNSCxNQUFBQTthQUMxRjtBQUNMMEMsbUJBQVczRSxLQUFLdEMsVUFBVTBFLE9BQU96QixNQUFNVyxRQUFRdkUsSUFBR2dGLE9BQU9FLE1BQUFBOztBQUUzRHRCLFlBQU1wRixRQUFRd0I7QUFDZDRELFlBQU1XLFVBQVVTO0FBQ2hCaEYsTUFBQUEsS0FBSWlELElBQUl1QztXQUNIO0FBQ0wsWUFBTU4sU0FBU3ZFLFVBQVVrRyxJQUFJckQ7QUFDN0IsWUFBTXdCLFFBQVFwQixNQUFNWSxRQUFRdkIsSUFBSStCO0FBQ2hDLFVBQUlnRCxRQUFRcEUsTUFBTXBGLEtBQUssR0FBRztBQUN4QnNCLFFBQUFBLEtBQUk4RCxNQUFNcEY7O0FBRVosVUFBSXlFLElBQUk2QixVQUFVO0FBQ2hCOEMsbUJBQVczRSxLQUFLbkQsSUFBR2dJLFlBQVl2QyxLQUFLUCxPQUFPTixPQUFPK0IsY0FBY3FCLFlBQVl0QyxTQUFTc0MsWUFBWXZDLEdBQUc7YUFDL0Y7QUFDTHFDLG1CQUFXM0UsS0FBS25ELElBQUdhLFVBQVU0RSxNQUFNM0IsTUFBTVcsUUFBUVMsT0FBT0UsTUFBQUE7O0FBRTFEdEIsWUFBTXBGLFFBQVFzQjtBQUNkOEQsWUFBTVcsVUFBVVc7QUFDaEJwRixNQUFBQSxLQUFJbUQsSUFBSXFDOztFQUVaO0FBRUEzRSxZQUFVYixJQUFJQTtBQUNkYSxZQUFVWCxJQUFJQTtBQUNoQjtBQXdCQSxJQUFBLFVBQWU7RUFRYmlJLE9BQU90SixPQUFPdUosTUFBTTtBQUNsQixRQUFJLENBQUN2SixNQUFNK0UsT0FBTztBQUNoQi9FLFlBQU0rRSxRQUFRLENBQUE7O0FBSWhCd0UsU0FBS3BELFdBQVdvRCxLQUFLcEQsWUFBWTtBQUNqQ29ELFNBQUt0SixXQUFXc0osS0FBS3RKLFlBQVk7QUFDakNzSixTQUFLMUUsU0FBUzBFLEtBQUsxRSxVQUFVO0FBRTdCMEUsU0FBS0MsVUFBVUQsS0FBS0MsV0FBVyxXQUFXO0FBQ3hDLGFBQU87UUFBQztVQUNOQyxHQUFHO1VBQ0hDLEtBQUsxSCxXQUFXO0FBQ2R1SCxpQkFBS0csS0FBSzFILFNBQUFBO1VBQ1o7UUFDRjtNQUFFO0lBQ0o7QUFFQWhDLFVBQU0rRSxNQUFNN0MsS0FBS3FILElBQUFBO0VBQ25CO0VBT0FJLFVBQVUzSixPQUFPNEosWUFBWTtBQUMzQixVQUFNckosUUFBUVAsTUFBTStFLFFBQVEvRSxNQUFNK0UsTUFBTWxFLFFBQVErSSxVQUFjLElBQUE7QUFDOUQsUUFBSXJKLFVBQVUsSUFBSTtBQUNoQlAsWUFBTStFLE1BQU04RSxPQUFPdEosT0FBTyxDQUFBOztFQUU5QjtFQVFBdUosVUFBVTlKLE9BQU91SixNQUFNNU0sU0FBUztBQUM5QjRNLFNBQUtwRCxXQUFXeEosUUFBUXdKO0FBQ3hCb0QsU0FBS3RKLFdBQVd0RCxRQUFRc0Q7QUFDeEJzSixTQUFLMUUsU0FBU2xJLFFBQVFrSTtFQUN4QjtFQVVBbUUsT0FBT2hKLE9BQU9xRyxPQUFPRSxRQUFRd0QsWUFBWTtBQUN2QyxRQUFJLENBQUMvSixPQUFPO0FBQ1Y7O0FBR0YsVUFBTW9KLFVBQVVZLFVBQVVoSyxNQUFNckQsUUFBUXVKLE9BQU9rRCxPQUFPO0FBQ3RELFVBQU05QyxpQkFBaUJqSCxLQUFLQyxJQUFJK0csUUFBUStDLFFBQVEvQyxPQUFPLENBQUE7QUFDdkQsVUFBTUcsa0JBQWtCbkgsS0FBS0MsSUFBSWlILFNBQVM2QyxRQUFRN0MsUUFBUSxDQUFBO0FBQzFELFVBQU14QixRQUFRMEIsaUJBQWlCekcsTUFBTStFLEtBQUs7QUFDMUMsVUFBTWtGLGdCQUFnQmxGLE1BQU1vQztBQUM1QixVQUFNK0Msa0JBQWtCbkYsTUFBTUk7QUFJOUJnRixTQUFLbkssTUFBTStFLE9BQU9ULENBQUFBLFFBQU87QUFDdkIsVUFBSSxPQUFPQSxJQUFJOEYsaUJBQWlCLFlBQVk7QUFDMUM5RixZQUFJOEYsYUFBWTs7SUFFcEIsQ0FBQTtBQTZCQSxVQUFNQywwQkFBMEJKLGNBQWNLLE9BQU8sQ0FBQ0MsT0FBTy9FLFNBQzNEQSxLQUFLbEIsSUFBSTNILFdBQVc2SSxLQUFLbEIsSUFBSTNILFFBQVE2TixZQUFZLFFBQVFELFFBQVFBLFFBQVEsR0FBRyxDQUFNLEtBQUE7QUFFcEYsVUFBTXhFLFNBQVNqSixPQUFPMk4sT0FBTztNQUMzQjdDLFlBQVl2QjtNQUNaeUIsYUFBYXZCO01BQ2I2QztNQUNBOUM7TUFDQUU7TUFDQVIsY0FBY00saUJBQWlCLElBQUkrRDtNQUNuQ3BFLGVBQWVPLGtCQUFrQjtJQUNuQyxDQUFBO0FBQ0EsVUFBTWEsYUFBYXZLLE9BQU9DLE9BQU8sQ0FBQSxHQUFJcU0sT0FBQUE7QUFDckM5QixxQkFBaUJELFlBQVkyQyxVQUFVRCxVQUFBQSxDQUFBQTtBQUN2QyxVQUFNL0gsWUFBWWxGLE9BQU9DLE9BQU87TUFDOUJzSztNQUNBVyxHQUFHMUI7TUFDSDRCLEdBQUcxQjtNQUNIckYsR0FBR2lJLFFBQVExQztNQUNYckYsR0FBRytILFFBQVF4QztPQUNWd0MsT0FBQUE7QUFFSCxVQUFNN0QsU0FBU08sY0FBY21FLGNBQWNoRCxPQUFPaUQsZUFBa0JuRSxHQUFBQSxNQUFBQTtBQUdwRTZDLGFBQVM3RCxNQUFNb0IsVUFBVW5FLFdBQVcrRCxRQUFRUixNQUFBQTtBQUc1Q3FELGFBQVNxQixlQUFlakksV0FBVytELFFBQVFSLE1BQUFBO0FBRzNDLFFBQUlxRCxTQUFTc0IsaUJBQWlCbEksV0FBVytELFFBQVFSLE1BQVMsR0FBQTtBQUV4RHFELGVBQVNxQixlQUFlakksV0FBVytELFFBQVFSLE1BQUFBOztBQUc3QzhDLHFCQUFpQnJHLFNBQUFBO0FBR2pCa0gsZUFBV25FLE1BQU1pQyxZQUFZaEYsV0FBVytELFFBQVFSLE1BQUFBO0FBR2hEdkQsY0FBVWIsS0FBS2EsVUFBVWdHO0FBQ3pCaEcsY0FBVVgsS0FBS1csVUFBVWtHO0FBRXpCZ0IsZUFBV25FLE1BQU1tQyxnQkFBZ0JsRixXQUFXK0QsUUFBUVIsTUFBQUE7QUFFcER2RixVQUFNZ0MsWUFBWTtNQUNoQjBFLE1BQU0xRSxVQUFVMEU7TUFDaEJFLEtBQUs1RSxVQUFVNEU7TUFDZkQsT0FBTzNFLFVBQVUwRSxPQUFPMUUsVUFBVWdHO01BQ2xDbkIsUUFBUTdFLFVBQVU0RSxNQUFNNUUsVUFBVWtHO01BQ2xDM0IsUUFBUXZFLFVBQVVrRztNQUNsQjdCLE9BQU9yRSxVQUFVZ0c7SUFDbkI7QUFHQW1DLFNBQUtwRixNQUFNL0MsV0FBVyxDQUFDa0UsV0FBVztBQUNoQyxZQUFNNUIsTUFBTTRCLE9BQU81QjtBQUNuQnhILGFBQU9DLE9BQU91SCxLQUFLdEUsTUFBTWdDLFNBQVM7QUFDbENzQyxVQUFJMEUsT0FBT2hILFVBQVVnRyxHQUFHaEcsVUFBVWtHLEdBQUc7UUFBQ3hCLE1BQU07UUFBR0UsS0FBSztRQUFHRCxPQUFPO1FBQUdFLFFBQVE7TUFBQyxDQUFBO0lBQzVFLENBQUE7RUFDRjtBQUNGO0FDOWJlLElBQU02RCxlQUFOLE1BQU1BO0VBT25CQyxlQUFlQyxRQUFRQyxhQUFhO0VBQUE7RUFRcENDLGVBQWVDLFNBQVM7QUFDdEIsV0FBTztFQUNUO0VBU0FDLGlCQUFpQmhMLE9BQU9pTCxNQUFNQyxVQUFVO0VBQUE7RUFReENDLG9CQUFvQm5MLE9BQU9pTCxNQUFNQyxVQUFVO0VBQUE7RUFLM0NFLHNCQUFzQjtBQUNwQixXQUFPO0VBQ1Q7RUFTQUMsZUFBZTVLLFNBQVM0RixPQUFPRSxRQUFRc0UsYUFBYTtBQUNsRHhFLFlBQVFoSCxLQUFLQyxJQUFJLEdBQUcrRyxTQUFTNUYsUUFBUTRGLEtBQUs7QUFDMUNFLGFBQVNBLFVBQVU5RixRQUFROEY7QUFDM0IsV0FBTztNQUNMRjtNQUNBRSxRQUFRbEgsS0FBS0MsSUFBSSxHQUFHdUwsY0FBY3hMLEtBQUtpTSxNQUFNakYsUUFBUXdFLFdBQUFBLElBQWV0RSxNQUFNO0lBQzVFO0VBQ0Y7RUFNQWdGLFdBQVdYLFFBQVE7QUFDakIsV0FBTztFQUNUO0VBTUFZLGFBQWFDLFFBQVE7RUFFckI7QUFDRjtBQ3RFZSxJQUFNQyxnQkFBTixjQUE0QmhCLGFBQUFBO0VBQ3pDQyxlQUFlcEIsTUFBTTtBQUluQixXQUFPQSxRQUFRQSxLQUFLb0MsY0FBY3BDLEtBQUtvQyxXQUFXLElBQUEsS0FBUztFQUM3RDtFQUNBSCxhQUFhQyxRQUFRO0FBQ25CQSxXQUFPOU8sUUFBUWlQLFlBQVk7RUFDN0I7QUFDRjtBQ1RBLElBQU1DLGNBQWM7QUFPcEIsSUFBTUMsY0FBYztFQUNsQkMsWUFBWTtFQUNaQyxXQUFXO0VBQ1hDLFVBQVU7RUFDVkMsY0FBYztFQUNkQyxhQUFhO0VBQ2JDLGFBQWE7RUFDYkMsV0FBVztFQUNYQyxjQUFjO0VBQ2RDLFlBQVk7QUFDZDtBQUVBLElBQU1DLGdCQUFnQjNPLENBQUFBLFVBQVNBLFVBQVUsUUFBUUEsVUFBVTtBQVEzRCxTQUFTNE8sV0FBVzdCLFFBQVFDLGFBQWE7QUFDdkMsUUFBTTZCLFFBQVE5QixPQUFPOEI7QUFJckIsUUFBTUMsZUFBZS9CLE9BQU9nQyxhQUFhLFFBQUE7QUFDekMsUUFBTUMsY0FBY2pDLE9BQU9nQyxhQUFhLE9BQUE7QUFHeENoQyxTQUFPaUIsV0FBQUEsSUFBZTtJQUNwQmlCLFNBQVM7TUFDUHZHLFFBQVFvRztNQUNSdEcsT0FBT3dHO01BQ1BILE9BQU87UUFDTGxDLFNBQVNrQyxNQUFNbEM7UUFDZmpFLFFBQVFtRyxNQUFNbkc7UUFDZEYsT0FBT3FHLE1BQU1yRztNQUNmO0lBQ0Y7RUFDRjtBQUtBcUcsUUFBTWxDLFVBQVVrQyxNQUFNbEMsV0FBVztBQUVqQ2tDLFFBQU1LLFlBQVlMLE1BQU1LLGFBQWE7QUFFckMsTUFBSVAsY0FBY0ssV0FBYyxHQUFBO0FBQzlCLFVBQU1HLGVBQWVDLGFBQWFyQyxRQUFRLE9BQUE7QUFDMUMsUUFBSW9DLGlCQUFpQkUsUUFBVztBQUM5QnRDLGFBQU92RSxRQUFRMkc7OztBQUluQixNQUFJUixjQUFjRyxZQUFlLEdBQUE7QUFDL0IsUUFBSS9CLE9BQU84QixNQUFNbkcsV0FBVyxJQUFJO0FBSTlCcUUsYUFBT3JFLFNBQVNxRSxPQUFPdkUsU0FBU3dFLGVBQWU7V0FDMUM7QUFDTCxZQUFNc0MsZ0JBQWdCRixhQUFhckMsUUFBUSxRQUFBO0FBQzNDLFVBQUl1QyxrQkFBa0JELFFBQVc7QUFDL0J0QyxlQUFPckUsU0FBUzRHOzs7O0FBS3RCLFNBQU92QztBQUNUO0FBSUEsSUFBTXdDLHVCQUF1QkMsK0JBQStCO0VBQUNDLFNBQVM7QUFBSSxJQUFJO0FBRTlFLFNBQVNDLFlBQVlDLE1BQU12QyxNQUFNQyxVQUFVO0FBQ3pDLE1BQUlzQyxNQUFNO0FBQ1JBLFNBQUt4QyxpQkFBaUJDLE1BQU1DLFVBQVVrQyxvQkFBQUE7O0FBRTFDO0FBRUEsU0FBU0ssZUFBZXpOLE9BQU9pTCxNQUFNQyxVQUFVO0FBQzdDLE1BQUlsTCxTQUFTQSxNQUFNNEssUUFBUTtBQUN6QjVLLFVBQU00SyxPQUFPTyxvQkFBb0JGLE1BQU1DLFVBQVVrQyxvQkFBQUE7O0FBRXJEO0FBRUEsU0FBU00sZ0JBQWdCQyxPQUFPM04sT0FBTztBQUNyQyxRQUFNaUwsT0FBT2EsWUFBWTZCLE1BQU0xQyxJQUFJLEtBQUswQyxNQUFNMUM7QUFDOUMsUUFBTSxFQUFDOUosR0FBQUEsSUFBR0UsR0FBQUEsR0FBQUEsSUFBS29DLG9CQUFvQmtLLE9BQU8zTixLQUFBQTtBQUMxQyxTQUFPO0lBQ0xpTDtJQUNBakw7SUFDQTROLFFBQVFEO0lBQ1J4TSxHQUFHQSxPQUFNK0wsU0FBWS9MLEtBQUk7SUFDekJFLEdBQUdBLE9BQU02TCxTQUFZN0wsS0FBSTtFQUMzQjtBQUNGO0FBRUEsU0FBU3dNLGlCQUFpQkMsVUFBVWxELFFBQVE7QUFDMUMsYUFBVzRDLFFBQVFNLFVBQVU7QUFDM0IsUUFBSU4sU0FBUzVDLFVBQVU0QyxLQUFLTyxTQUFTbkQsTUFBUyxHQUFBO0FBQzVDLGFBQU87O0VBRVg7QUFDRjtBQUVBLFNBQVNvRCxxQkFBcUJoTyxPQUFPaUwsTUFBTUMsVUFBVTtBQUNuRCxRQUFNTixTQUFTNUssTUFBTTRLO0FBQ3JCLFFBQU1xRCxXQUFXLElBQUlDLGlCQUFpQkMsQ0FBQUEsWUFBVztBQUMvQyxRQUFJQyxVQUFVO0FBQ2QsZUFBV0MsU0FBU0YsU0FBUztBQUMzQkMsZ0JBQVVBLFdBQVdQLGlCQUFpQlEsTUFBTUMsWUFBWTFELE1BQUFBO0FBQ3hEd0QsZ0JBQVVBLFdBQVcsQ0FBQ1AsaUJBQWlCUSxNQUFNRSxjQUFjM0QsTUFBQUE7SUFDN0Q7QUFDQSxRQUFJd0QsU0FBUztBQUNYbEQsZUFBQUE7O0VBRUosQ0FBQTtBQUNBK0MsV0FBU08sUUFBUUMsVUFBVTtJQUFDQyxXQUFXO0lBQU1DLFNBQVM7RUFBSSxDQUFBO0FBQzFELFNBQU9WO0FBQ1Q7QUFFQSxTQUFTVyxxQkFBcUI1TyxPQUFPaUwsTUFBTUMsVUFBVTtBQUNuRCxRQUFNTixTQUFTNUssTUFBTTRLO0FBQ3JCLFFBQU1xRCxXQUFXLElBQUlDLGlCQUFpQkMsQ0FBQUEsWUFBVztBQUMvQyxRQUFJQyxVQUFVO0FBQ2QsZUFBV0MsU0FBU0YsU0FBUztBQUMzQkMsZ0JBQVVBLFdBQVdQLGlCQUFpQlEsTUFBTUUsY0FBYzNELE1BQUFBO0FBQzFEd0QsZ0JBQVVBLFdBQVcsQ0FBQ1AsaUJBQWlCUSxNQUFNQyxZQUFZMUQsTUFBQUE7SUFDM0Q7QUFDQSxRQUFJd0QsU0FBUztBQUNYbEQsZUFBQUE7O0VBRUosQ0FBQTtBQUNBK0MsV0FBU08sUUFBUUMsVUFBVTtJQUFDQyxXQUFXO0lBQU1DLFNBQVM7RUFBSSxDQUFBO0FBQzFELFNBQU9WO0FBQ1Q7QUFFQSxJQUFNWSxxQkFBcUIsb0JBQUlDLElBQUFBO0FBQy9CLElBQUlDLHNCQUFzQjtBQUUxQixTQUFTQyxpQkFBaUI7QUFDeEIsUUFBTUMsTUFBTUMsT0FBT0M7QUFDbkIsTUFBSUYsUUFBUUYscUJBQXFCO0FBQy9COztBQUVGQSx3QkFBc0JFO0FBQ3RCSixxQkFBbUJsTCxRQUFRLENBQUN5TCxRQUFRcFAsVUFBVTtBQUM1QyxRQUFJQSxNQUFNcVAsNEJBQTRCSixLQUFLO0FBQ3pDRyxhQUFBQTs7RUFFSixDQUFBO0FBQ0Y7QUFFQSxTQUFTRSw4QkFBOEJ0UCxPQUFPb1AsUUFBUTtBQUNwRCxNQUFJLENBQUNQLG1CQUFtQmhKLE1BQU07QUFDNUJxSixXQUFPbEUsaUJBQWlCLFVBQVVnRSxjQUFBQTs7QUFFcENILHFCQUFtQlUsSUFBSXZQLE9BQU9vUCxNQUFBQTtBQUNoQztBQUVBLFNBQVNJLGdDQUFnQ3hQLE9BQU87QUFDOUM2TyxxQkFBbUJZLE9BQU96UCxLQUFBQTtBQUMxQixNQUFJLENBQUM2TyxtQkFBbUJoSixNQUFNO0FBQzVCcUosV0FBTy9ELG9CQUFvQixVQUFVNkQsY0FBQUE7O0FBRXpDO0FBRUEsU0FBU1UscUJBQXFCMVAsT0FBT2lMLE1BQU1DLFVBQVU7QUFDbkQsUUFBTU4sU0FBUzVLLE1BQU00SztBQUNyQixRQUFNK0UsWUFBWS9FLFVBQVVnRixlQUFlaEYsTUFBQUE7QUFDM0MsTUFBSSxDQUFDK0UsV0FBVztBQUNkOztBQUVGLFFBQU1QLFNBQVNTLFVBQVUsQ0FBQ3hKLE9BQU9FLFdBQVc7QUFDMUMsVUFBTXlCLEtBQUkySCxVQUFVRztBQUNwQjVFLGFBQVM3RSxPQUFPRSxNQUFBQTtBQUNoQixRQUFJeUIsS0FBSTJILFVBQVVHLGFBQWE7QUFRN0I1RSxlQUFBQTs7S0FFRGdFLE1BQUFBO0FBR0gsUUFBTWpCLFdBQVcsSUFBSThCLGVBQWU1QixDQUFBQSxZQUFXO0FBQzdDLFVBQU1FLFFBQVFGLFFBQVEsQ0FBRTtBQUN4QixVQUFNOUgsUUFBUWdJLE1BQU0yQixZQUFZM0o7QUFDaEMsVUFBTUUsU0FBUzhILE1BQU0yQixZQUFZeko7QUFJakMsUUFBSUYsVUFBVSxLQUFLRSxXQUFXLEdBQUc7QUFDL0I7O0FBRUY2SSxXQUFPL0ksT0FBT0UsTUFBQUE7RUFDaEIsQ0FBQTtBQUNBMEgsV0FBU08sUUFBUW1CLFNBQUFBO0FBQ2pCTCxnQ0FBOEJ0UCxPQUFPb1AsTUFBQUE7QUFFckMsU0FBT25CO0FBQ1Q7QUFFQSxTQUFTZ0MsZ0JBQWdCalEsT0FBT2lMLE1BQU1nRCxVQUFVO0FBQzlDLE1BQUlBLFVBQVU7QUFDWkEsYUFBU2lDLFdBQVU7O0FBRXJCLE1BQUlqRixTQUFTLFVBQVU7QUFDckJ1RSxvQ0FBZ0N4UCxLQUFBQTs7QUFFcEM7QUFFQSxTQUFTbVEscUJBQXFCblEsT0FBT2lMLE1BQU1DLFVBQVU7QUFDbkQsUUFBTU4sU0FBUzVLLE1BQU00SztBQUNyQixRQUFNd0YsUUFBUVAsVUFBVSxDQUFDbEMsVUFBVTtBQUlqQyxRQUFJM04sTUFBTXFRLFFBQVEsTUFBTTtBQUN0Qm5GLGVBQVN3QyxnQkFBZ0JDLE9BQU8zTixLQUFBQSxDQUFBQTs7S0FFakNBLEtBQUFBO0FBRUh1TixjQUFZM0MsUUFBUUssTUFBTW1GLEtBQUFBO0FBRTFCLFNBQU9BO0FBQ1Q7QUFNZSxJQUFNRSxjQUFOLGNBQTBCNUYsYUFBQUE7RUFPdkNDLGVBQWVDLFFBQVFDLGFBQWE7QUFJbEMsVUFBTUUsVUFBVUgsVUFBVUEsT0FBT2UsY0FBY2YsT0FBT2UsV0FBVyxJQUFBO0FBU2pFLFFBQUlaLFdBQVdBLFFBQVFILFdBQVdBLFFBQVE7QUFHeEM2QixpQkFBVzdCLFFBQVFDLFdBQUFBO0FBQ25CLGFBQU9FOztBQUdULFdBQU87RUFDVDtFQUtBRCxlQUFlQyxTQUFTO0FBQ3RCLFVBQU1ILFNBQVNHLFFBQVFIO0FBQ3ZCLFFBQUksQ0FBQ0EsT0FBT2lCLFdBQUFBLEdBQWM7QUFDeEIsYUFBTzs7QUFHVCxVQUFNaUIsVUFBVWxDLE9BQU9pQixXQUFBQSxFQUFhaUI7QUFDcEM7TUFBQztNQUFVO01BQVNuSixRQUFRLENBQUM0TSxTQUFTO0FBQ3BDLFlBQU0xUyxRQUFRaVAsUUFBUXlELElBQUs7QUFDM0IsVUFBSW5SLGNBQWN2QixLQUFRLEdBQUE7QUFDeEIrTSxlQUFPNEYsZ0JBQWdCRCxJQUFBQTthQUNsQjtBQUNMM0YsZUFBTzZGLGFBQWFGLE1BQU0xUyxLQUFBQTs7SUFFOUIsQ0FBQTtBQUVBLFVBQU02TyxRQUFRSSxRQUFRSixTQUFTLENBQUE7QUFDL0I1UCxXQUFPNFQsS0FBS2hFLEtBQUFBLEVBQU8vSSxRQUFRLENBQUNnTixRQUFRO0FBQ2xDL0YsYUFBTzhCLE1BQU1pRSxHQUFBQSxJQUFPakUsTUFBTWlFLEdBQUk7SUFDaEMsQ0FBQTtBQU9BL0YsV0FBT3ZFLFFBQVF1RSxPQUFPdkU7QUFFdEIsV0FBT3VFLE9BQU9pQixXQUFZO0FBQzFCLFdBQU87RUFDVDtFQVFBYixpQkFBaUJoTCxPQUFPaUwsTUFBTUMsVUFBVTtBQUV0QyxTQUFLQyxvQkFBb0JuTCxPQUFPaUwsSUFBQUE7QUFFaEMsVUFBTTJGLFVBQVU1USxNQUFNNlEsYUFBYTdRLE1BQU02USxXQUFXLENBQUE7QUFDcEQsVUFBTUMsV0FBVztNQUNmQyxRQUFRL0M7TUFDUmdELFFBQVFwQztNQUNSUSxRQUFRTTtJQUNWO0FBQ0EsVUFBTXhQLFVBQVU0USxTQUFTN0YsSUFBQUEsS0FBU2tGO0FBQ2xDUyxZQUFRM0YsSUFBQUEsSUFBUS9LLFFBQVFGLE9BQU9pTCxNQUFNQyxRQUFBQTtFQUN2QztFQU9BQyxvQkFBb0JuTCxPQUFPaUwsTUFBTTtBQUMvQixVQUFNMkYsVUFBVTVRLE1BQU02USxhQUFhN1EsTUFBTTZRLFdBQVcsQ0FBQTtBQUNwRCxVQUFNVCxRQUFRUSxRQUFRM0YsSUFBSztBQUUzQixRQUFJLENBQUNtRixPQUFPO0FBQ1Y7O0FBR0YsVUFBTVUsV0FBVztNQUNmQyxRQUFRZDtNQUNSZSxRQUFRZjtNQUNSYixRQUFRYTtJQUNWO0FBQ0EsVUFBTS9QLFVBQVU0USxTQUFTN0YsSUFBQUEsS0FBU3dDO0FBQ2xDdk4sWUFBUUYsT0FBT2lMLE1BQU1tRixLQUFBQTtBQUNyQlEsWUFBUTNGLElBQUFBLElBQVFpQztFQUNsQjtFQUVBOUIsc0JBQXNCO0FBQ3BCLFdBQU84RCxPQUFPQztFQUNoQjtFQVFBOUQsZUFBZVQsUUFBUXZFLE9BQU9FLFFBQVFzRSxhQUFhO0FBQ2pELFdBQU9RLGVBQWVULFFBQVF2RSxPQUFPRSxRQUFRc0UsV0FBQUE7RUFDL0M7RUFLQVUsV0FBV1gsUUFBUTtBQUNqQixVQUFNK0UsWUFBWS9FLFVBQVVnRixlQUFlaEYsTUFBQUE7QUFDM0MsV0FBTyxDQUFDLEVBQUUrRSxhQUFhQSxVQUFVc0I7RUFDbkM7QUFDRjtBQy9YTyxTQUFTQyxnQkFBZ0J0RyxRQUFRO0FBQ3RDLE1BQUksQ0FBQ3VHLGdCQUFzQixLQUFBLE9BQU9DLG9CQUFvQixlQUFleEcsa0JBQWtCd0csaUJBQWtCO0FBQ3ZHLFdBQU8xRjs7QUFFVCxTQUFPNEU7QUFDVDtBQ0xlLElBQU1lLFVBQU4sTUFBTUE7RUFBTjtBQUtibFE7QUFDQUU7QUFDQWlRLGtDQUFTO0FBQ1QzVTtBQUNBNFU7O0VBRUFDLGdCQUFnQi9QLGtCQUFrQztBQUNoRCxVQUFNLEVBQUNOLEdBQUFBLElBQUdFLEdBQUFBLEdBQUFBLElBQUssS0FBS2lCLFNBQVM7TUFBQztNQUFLO09BQU1iLGdCQUFBQTtBQUN6QyxXQUFPO01BQUNOLEdBQUFBO01BQUdFLEdBQUFBO0lBQUM7RUFDZDtFQUVBb1EsV0FBVztBQUNULFdBQU9DLFNBQVMsS0FBS3ZRLENBQUMsS0FBS3VRLFNBQVMsS0FBS3JRLENBQUM7RUFDNUM7RUFTQWlCLFNBQVNxUCxPQUFpQkMsT0FBbUQ7QUFDM0UsVUFBTUMsUUFBUSxLQUFLTjtBQUNuQixRQUFJLENBQUNLLFNBQVMsQ0FBQ0MsT0FBTztBQUVwQixhQUFPOztBQUVULFVBQU1DLE1BQStCLENBQUE7QUFDckNILFVBQU1oTyxRQUFRLENBQUM0TSxTQUFTO0FBQ3RCdUIsVUFBSXZCLElBQUFBLElBQVFzQixNQUFNdEIsSUFBSyxLQUFJc0IsTUFBTXRCLElBQUFBLEVBQU1lLE9BQU0sSUFBS08sTUFBTXRCLElBQUFBLEVBQU13QixNQUFNLEtBQUt4QixJQUFlO0lBQzFGLENBQUE7QUFDQSxXQUFPdUI7RUFDVDtBQUNGO0FBckNFLGNBRm1CVCxTQUVaVyxZQUFXLENBQUE7QUFDbEIsY0FIbUJYLFNBR1pZO0FDUUYsU0FBU0MsU0FBU0MsT0FBT0MsT0FBTztBQUNyQyxRQUFNQyxXQUFXRixNQUFNeFYsUUFBUXlWO0FBQy9CLFFBQU1FLHFCQUFxQkMsa0JBQWtCSixLQUFBQTtBQUM3QyxRQUFNSyxhQUFhblQsS0FBS29ULElBQUlKLFNBQVNLLGlCQUFpQkosb0JBQW9CQSxrQkFBQUE7QUFDMUUsUUFBTUssZUFBZU4sU0FBU08sTUFBTUMsVUFBVUMsZ0JBQWdCVixLQUFBQSxJQUFTLENBQUE7QUFDdkUsUUFBTVcsa0JBQWtCSixhQUFhclU7QUFDckMsUUFBTTBVLFFBQVFMLGFBQWEsQ0FBRTtBQUM3QixRQUFNTSxPQUFPTixhQUFhSSxrQkFBa0IsQ0FBRTtBQUM5QyxRQUFNRyxXQUFXLENBQUE7QUFHakIsTUFBSUgsa0JBQWtCUCxZQUFZO0FBQ2hDVyxlQUFXZixPQUFPYyxVQUFVUCxjQUFjSSxrQkFBa0JQLFVBQUFBO0FBQzVELFdBQU9VOztBQUdULFFBQU1FLFVBQVVDLGlCQUFpQlYsY0FBY1AsT0FBT0ksVUFBQUE7QUFFdEQsTUFBSU8sa0JBQWtCLEdBQUc7QUFDdkIsUUFBSTFTLElBQUdDO0FBQ1AsVUFBTWdULGtCQUFrQlAsa0JBQWtCLElBQUkxVCxLQUFLa1UsT0FBT04sT0FBT0QsVUFBVUQsa0JBQWtCLEVBQUEsSUFBTTtBQUNuR3JTLFNBQUswUixPQUFPYyxVQUFVRSxTQUFTaFUsY0FBY2tVLGVBQUFBLElBQW1CLElBQUlOLFFBQVFNLGlCQUFpQk4sS0FBQUE7QUFDN0YsU0FBSzNTLEtBQUksR0FBR0MsT0FBT3lTLGtCQUFrQixHQUFHMVMsS0FBSUMsTUFBTUQsTUFBSztBQUNyREssV0FBSzBSLE9BQU9jLFVBQVVFLFNBQVNULGFBQWF0UyxFQUFBQSxHQUFJc1MsYUFBYXRTLEtBQUksQ0FBRSxDQUFBO0lBQ3JFO0FBQ0FLLFNBQUswUixPQUFPYyxVQUFVRSxTQUFTSCxNQUFNN1QsY0FBY2tVLGVBQUFBLElBQW1CbEIsTUFBTTlULFNBQVMyVSxPQUFPSyxlQUFlO0FBQzNHLFdBQU9KOztBQUVUeFMsT0FBSzBSLE9BQU9jLFVBQVVFLE9BQUFBO0FBQ3RCLFNBQU9GO0FBQ1Q7QUFFQSxTQUFTWCxrQkFBa0JKLE9BQU87QUFDaEMsUUFBTXFCLFNBQVNyQixNQUFNeFYsUUFBUTZXO0FBQzdCLFFBQU1DLGFBQWF0QixNQUFNdUIsVUFBUztBQUNsQyxRQUFNQyxXQUFXeEIsTUFBTXlCLFVBQVVILGNBQWNELFNBQVMsSUFBSTtBQUM1RCxRQUFNSyxXQUFXMUIsTUFBTTJCLGFBQWFMO0FBQ3BDLFNBQU9wVSxLQUFLaU0sTUFBTWpNLEtBQUtvVCxJQUFJa0IsVUFBVUUsUUFBQUEsQ0FBQUE7QUFDdkM7QUFPQSxTQUFTUixpQkFBaUJWLGNBQWNQLE9BQU9JLFlBQVk7QUFDekQsUUFBTXVCLG1CQUFtQkMsZUFBZXJCLFlBQUFBO0FBQ3hDLFFBQU1TLFVBQVVoQixNQUFNOVQsU0FBU2tVO0FBSS9CLE1BQUksQ0FBQ3VCLGtCQUFrQjtBQUNyQixXQUFPMVUsS0FBS0MsSUFBSThULFNBQVMsQ0FBQTs7QUFHM0IsUUFBTWEsVUFBVUMsV0FBV0gsZ0JBQUFBO0FBQzNCLFdBQVMxVCxLQUFJLEdBQUdDLE9BQU8yVCxRQUFRM1YsU0FBUyxHQUFHK0IsS0FBSUMsTUFBTUQsTUFBSztBQUN4RCxVQUFNK0YsU0FBUzZOLFFBQVE1VCxFQUFFO0FBQ3pCLFFBQUkrRixTQUFTZ04sU0FBUztBQUNwQixhQUFPaE47O0VBRVg7QUFDQSxTQUFPL0csS0FBS0MsSUFBSThULFNBQVMsQ0FBQTtBQUMzQjtBQUtBLFNBQVNOLGdCQUFnQlYsT0FBTztBQUM5QixRQUFNelQsU0FBUyxDQUFBO0FBQ2YsTUFBSTBCLElBQUdDO0FBQ1AsT0FBS0QsS0FBSSxHQUFHQyxPQUFPOFIsTUFBTTlULFFBQVErQixLQUFJQyxNQUFNRCxNQUFLO0FBQzlDLFFBQUkrUixNQUFNL1IsRUFBRSxFQUFDdVMsT0FBTztBQUNsQmpVLGFBQU91RCxLQUFLN0IsRUFBQUE7O0VBRWhCO0FBQ0EsU0FBTzFCO0FBQ1Q7QUFRQSxTQUFTd1UsV0FBV2YsT0FBT2MsVUFBVVAsY0FBY1MsU0FBUztBQUMxRCxNQUFJek4sUUFBUTtBQUNaLE1BQUl3TyxPQUFPeEIsYUFBYSxDQUFFO0FBQzFCLE1BQUl0UztBQUVKK1MsWUFBVS9ULEtBQUsrVSxLQUFLaEIsT0FBQUE7QUFDcEIsT0FBSy9TLEtBQUksR0FBR0EsS0FBSStSLE1BQU05VCxRQUFRK0IsTUFBSztBQUNqQyxRQUFJQSxPQUFNOFQsTUFBTTtBQUNkakIsZUFBU2hSLEtBQUtrUSxNQUFNL1IsRUFBRSxDQUFBO0FBQ3RCc0Y7QUFDQXdPLGFBQU94QixhQUFhaE4sUUFBUXlOLE9BQVE7O0VBRXhDO0FBQ0Y7QUFTQSxTQUFTMVMsS0FBSzBSLE9BQU9jLFVBQVVFLFNBQVNpQixZQUFZQyxVQUFVO0FBQzVELFFBQU16VSxRQUFRMFUsZUFBZUYsWUFBWSxDQUFBO0FBQ3pDLFFBQU12VSxNQUFNVCxLQUFLb1QsSUFBSThCLGVBQWVELFVBQVVsQyxNQUFNOVQsTUFBTSxHQUFHOFQsTUFBTTlULE1BQU07QUFDekUsTUFBSXFILFFBQVE7QUFDWixNQUFJckgsUUFBUStCLElBQUc4VDtBQUVmZixZQUFVL1QsS0FBSytVLEtBQUtoQixPQUFBQTtBQUNwQixNQUFJa0IsVUFBVTtBQUNaaFcsYUFBU2dXLFdBQVdEO0FBQ3BCakIsY0FBVTlVLFNBQVNlLEtBQUtpTSxNQUFNaE4sU0FBUzhVLE9BQUFBOztBQUd6Q2UsU0FBT3RVO0FBRVAsU0FBT3NVLE9BQU8sR0FBRztBQUNmeE87QUFDQXdPLFdBQU85VSxLQUFLa1UsTUFBTTFULFFBQVE4RixRQUFReU4sT0FBQUE7RUFDcEM7QUFFQSxPQUFLL1MsS0FBSWhCLEtBQUtDLElBQUlPLE9BQU8sQ0FBSVEsR0FBQUEsS0FBSVAsS0FBS08sTUFBSztBQUN6QyxRQUFJQSxPQUFNOFQsTUFBTTtBQUNkakIsZUFBU2hSLEtBQUtrUSxNQUFNL1IsRUFBRSxDQUFBO0FBQ3RCc0Y7QUFDQXdPLGFBQU85VSxLQUFLa1UsTUFBTTFULFFBQVE4RixRQUFReU4sT0FBQUE7O0VBRXRDO0FBQ0Y7QUFNQSxTQUFTWSxlQUFlUSxLQUFLO0FBQzNCLFFBQU1DLE1BQU1ELElBQUlsVztBQUNoQixNQUFJK0IsSUFBRy9DO0FBRVAsTUFBSW1YLE1BQU0sR0FBRztBQUNYLFdBQU87O0FBR1QsT0FBS25YLE9BQU9rWCxJQUFJLENBQUUsR0FBRW5VLEtBQUksR0FBR0EsS0FBSW9VLEtBQUssRUFBRXBVLElBQUc7QUFDdkMsUUFBSW1VLElBQUluVSxFQUFFLElBQUdtVSxJQUFJblUsS0FBSSxDQUFFLE1BQUsvQyxNQUFNO0FBQ2hDLGFBQU87O0VBRVg7QUFDQSxTQUFPQTtBQUNUO0FDaktBLElBQU1vWCxlQUFlLENBQUNDLFVBQVVBLFVBQVUsU0FBUyxVQUFVQSxVQUFVLFVBQVUsU0FBU0E7QUFDMUYsSUFBTUMsaUJBQWlCLENBQUN6QyxPQUFPMEMsTUFBTXJCLFdBQVdxQixTQUFTLFNBQVNBLFNBQVMsU0FBUzFDLE1BQU0wQyxJQUFBQSxJQUFRckIsU0FBU3JCLE1BQU0wQyxJQUFBQSxJQUFRckI7QUFDekgsSUFBTXNCLGdCQUFnQixDQUFDQyxhQUFhckMsa0JBQWtCclQsS0FBS29ULElBQUlDLGlCQUFpQnFDLGFBQWFBLFdBQUFBO0FBWTdGLFNBQVNDLE9BQU9SLEtBQUtTLFVBQVU7QUFDN0IsUUFBTXRXLFNBQVMsQ0FBQTtBQUNmLFFBQU11VyxZQUFZVixJQUFJbFcsU0FBUzJXO0FBQy9CLFFBQU1SLE1BQU1ELElBQUlsVztBQUNoQixNQUFJK0IsS0FBSTtBQUVSLFNBQU9BLEtBQUlvVSxLQUFLcFUsTUFBSzZVLFdBQVc7QUFDOUJ2VyxXQUFPdUQsS0FBS3NTLElBQUluVixLQUFLaU0sTUFBTWpMLEVBQUcsQ0FBQSxDQUFBO0VBQ2hDO0FBQ0EsU0FBTzFCO0FBQ1Q7QUFPQSxTQUFTd1csb0JBQW9CaEQsT0FBTzVSLE9BQU82VSxpQkFBaUI7QUFDMUQsUUFBTTlXLFNBQVM2VCxNQUFNQyxNQUFNOVQ7QUFDM0IsUUFBTStXLGNBQWFoVyxLQUFLb1QsSUFBSWxTLE9BQU9qQyxTQUFTLENBQUE7QUFDNUMsUUFBTXVCLFFBQVFzUyxNQUFNbUQ7QUFDcEIsUUFBTXhWLE1BQU1xUyxNQUFNb0Q7QUFDbEIsUUFBTUMsVUFBVTtBQUNoQixNQUFJQyxZQUFZdEQsTUFBTXVELGdCQUFnQkwsV0FBQUE7QUFDdEMsTUFBSTdCO0FBRUosTUFBSTRCLGlCQUFpQjtBQUNuQixRQUFJOVcsV0FBVyxHQUFHO0FBQ2hCa1YsZUFBU25VLEtBQUtDLElBQUltVyxZQUFZNVYsT0FBT0MsTUFBTTJWLFNBQUFBO2VBQ2xDbFYsVUFBVSxHQUFHO0FBQ3RCaVQsZ0JBQVVyQixNQUFNdUQsZ0JBQWdCLENBQUEsSUFBS0QsYUFBYTtXQUM3QztBQUNMakMsZ0JBQVVpQyxZQUFZdEQsTUFBTXVELGdCQUFnQkwsY0FBYSxDQUFBLEtBQU07O0FBRWpFSSxpQkFBYUosY0FBYTlVLFFBQVFpVCxTQUFTLENBQUNBO0FBRzVDLFFBQUlpQyxZQUFZNVYsUUFBUTJWLFdBQVdDLFlBQVkzVixNQUFNMFYsU0FBUztBQUM1RDs7O0FBR0osU0FBT0M7QUFDVDtBQU1BLFNBQVNFLGVBQWVDLFFBQVF0WCxRQUFRO0FBQ3RDNkwsT0FBS3lMLFFBQVEsQ0FBQ0MsVUFBVTtBQUN0QixVQUFNQyxLQUFLRCxNQUFNQztBQUNqQixVQUFNQyxRQUFRRCxHQUFHeFgsU0FBUztBQUMxQixRQUFJK0I7QUFDSixRQUFJMFYsUUFBUXpYLFFBQVE7QUFDbEIsV0FBSytCLEtBQUksR0FBR0EsS0FBSTBWLE9BQU8sRUFBRTFWLElBQUc7QUFDMUIsZUFBT3dWLE1BQU03WCxLQUFLOFgsR0FBR3pWLEVBQUFBLENBQUU7TUFDekI7QUFDQXlWLFNBQUdqTSxPQUFPLEdBQUdrTSxLQUFBQTs7RUFFakIsQ0FBQTtBQUNGO0FBS0EsU0FBU0Msa0JBQWtCclosU0FBUztBQUNsQyxTQUFPQSxRQUFRc1osWUFBWXRaLFFBQVE4VyxhQUFhO0FBQ2xEO0FBS0EsU0FBU3lDLGVBQWV2WixTQUFTd1osVUFBVTtBQUN6QyxNQUFJLENBQUN4WixRQUFRNk4sU0FBUztBQUNwQixXQUFPOztBQUdULFFBQU00TCxPQUFPQyxPQUFPMVosUUFBUXlaLE1BQU1ELFFBQUFBO0FBQ2xDLFFBQU0vTSxVQUFVWSxVQUFVck4sUUFBUXlNLE9BQU87QUFDekMsUUFBTWtOLFFBQVFDLFFBQVE1WixRQUFRNlosSUFBSSxJQUFJN1osUUFBUTZaLEtBQUtsWSxTQUFTO0FBRTVELFNBQU8sUUFBUzhYLEtBQUtLLGFBQWNyTixRQUFRN0M7QUFDN0M7QUFFQSxTQUFTbVEsbUJBQW1CQyxRQUFReEUsT0FBTztBQUN6QyxTQUFPeUUsY0FBY0QsUUFBUTtJQUMzQnhFO0lBQ0FsSCxNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRUEsU0FBUzRMLGtCQUFrQkYsUUFBUXBXLE9BQU91VyxNQUFNO0FBQzlDLFNBQU9GLGNBQWNELFFBQVE7SUFDM0JHO0lBQ0F2VztJQUNBMEssTUFBTTtFQUNSLENBQUE7QUFDRjtBQUVBLFNBQVM4TCxXQUFXcEMsT0FBTzFVLFVBQVVoQixTQUFTO0FBRTVDLE1BQUk2UyxNQUFNa0YsbUJBQW1CckMsS0FBQUE7QUFDN0IsTUFBSSxXQUFZMVUsYUFBYSxXQUFhLENBQUNoQixXQUFXZ0IsYUFBYSxTQUFVO0FBQzNFNlIsVUFBTTRDLGFBQWE1QyxHQUFBQTs7QUFFckIsU0FBT0E7QUFDVDtBQUVBLFNBQVNtRixVQUFVOUUsT0FBT3FCLFFBQVF2VCxVQUFVMFUsT0FBTztBQUNqRCxRQUFNLEVBQUMvTixLQUFLRixNQUFNRyxRQUFRRixPQUFPM0csTUFBSyxJQUFJbVM7QUFDMUMsUUFBTSxFQUFDblEsV0FBV2tWLE9BQUFBLElBQVVsWDtBQUM1QixNQUFJbVgsV0FBVztBQUNmLE1BQUlDLFVBQVVDLFFBQVFDO0FBQ3RCLFFBQU0vUSxTQUFTTSxTQUFTRDtBQUN4QixRQUFNUCxRQUFRTSxRQUFRRDtBQUV0QixNQUFJeUwsTUFBTS9NLGFBQVksR0FBSTtBQUN4QmlTLGFBQVNFLGVBQWU1QyxPQUFPak8sTUFBTUMsS0FBQUE7QUFFckMsUUFBSWMsU0FBU3hILFFBQVcsR0FBQTtBQUN0QixZQUFNdVgsaUJBQWlCMWEsT0FBTzRULEtBQUt6USxRQUFBQSxFQUFVLENBQUU7QUFDL0MsWUFBTXBDLFFBQVFvQyxTQUFTdVgsY0FBZTtBQUN0Q0YsZUFBU0osT0FBT00sY0FBQUEsRUFBZ0JDLGlCQUFpQjVaLEtBQUFBLElBQVMwSSxTQUFTaU47ZUFDMUR2VCxhQUFhLFVBQVU7QUFDaENxWCxnQkFBVXRWLFVBQVU2RSxTQUFTN0UsVUFBVTRFLE9BQU8sSUFBSUwsU0FBU2lOO1dBQ3REO0FBQ0w4RCxlQUFTMUMsZUFBZXpDLE9BQU9sUyxVQUFVdVQsTUFBQUE7O0FBRTNDNEQsZUFBV3pRLFFBQVFEO1NBQ2Q7QUFDTCxRQUFJZSxTQUFTeEgsUUFBVyxHQUFBO0FBQ3RCLFlBQU11WCxpQkFBaUIxYSxPQUFPNFQsS0FBS3pRLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxZQUFNcEMsUUFBUW9DLFNBQVN1WCxjQUFlO0FBQ3RDSCxlQUFTSCxPQUFPTSxjQUFBQSxFQUFnQkMsaUJBQWlCNVosS0FBQUEsSUFBU3dJLFFBQVFtTjtlQUN6RHZULGFBQWEsVUFBVTtBQUNoQ29YLGdCQUFVclYsVUFBVTBFLE9BQU8xRSxVQUFVMkUsU0FBUyxJQUFJTixRQUFRbU47V0FDckQ7QUFDTDZELGVBQVN6QyxlQUFlekMsT0FBT2xTLFVBQVV1VCxNQUFBQTs7QUFFM0M4RCxhQUFTQyxlQUFlNUMsT0FBTzlOLFFBQVFELEdBQUFBO0FBQ3ZDdVEsZUFBV2xYLGFBQWEsU0FBUyxDQUFDeVgsVUFBVUE7O0FBRTlDLFNBQU87SUFBQ0w7SUFBUUM7SUFBUUY7SUFBVUQ7RUFBUTtBQUM1QztBQUVlLElBQU1RLFFBQU4sTUFBTUEsZUFBY3RHLFFBQUFBO0VBR2pDM1UsWUFBWWtiLEtBQUs7QUFDZixVQUFLO0FBR0wsU0FBS0MsS0FBS0QsSUFBSUM7QUFFZCxTQUFLNU0sT0FBTzJNLElBQUkzTTtBQUVoQixTQUFLdE8sVUFBVXVRO0FBRWYsU0FBS21ELE1BQU11SCxJQUFJdkg7QUFFZixTQUFLclEsUUFBUTRYLElBQUk1WDtBQUlqQixTQUFLNEcsTUFBTXNHO0FBRVgsU0FBS3JHLFNBQVNxRztBQUVkLFNBQUt4RyxPQUFPd0c7QUFFWixTQUFLdkcsUUFBUXVHO0FBRWIsU0FBSzdHLFFBQVE2RztBQUViLFNBQUszRyxTQUFTMkc7QUFDZCxTQUFLNEssV0FBVztNQUNkcFIsTUFBTTtNQUNOQyxPQUFPO01BQ1BDLEtBQUs7TUFDTEMsUUFBUTtJQUNWO0FBRUEsU0FBS3VRLFdBQVdsSztBQUVoQixTQUFLNkssWUFBWTdLO0FBRWpCLFNBQUs4SyxhQUFhOUs7QUFFbEIsU0FBSytLLGdCQUFnQi9LO0FBRXJCLFNBQUtnTCxjQUFjaEw7QUFFbkIsU0FBS2lMLGVBQWVqTDtBQUlwQixTQUFLdFAsT0FBT3NQO0FBRVosU0FBS2tMLGdCQUFnQmxMO0FBQ3JCLFNBQUt1RixNQUFNdkY7QUFDWCxTQUFLNU4sTUFBTTROO0FBQ1gsU0FBS21MLFNBQVNuTDtBQUVkLFNBQUtrRixRQUFRLENBQUE7QUFFYixTQUFLa0csaUJBQWlCO0FBRXRCLFNBQUtDLGNBQWM7QUFFbkIsU0FBS0MsY0FBYztBQUNuQixTQUFLNUUsVUFBVTtBQUNmLFNBQUtFLGFBQWE7QUFDbEIsU0FBSzJFLG9CQUFvQixDQUFBO0FBRXpCLFNBQUtuRCxjQUFjcEk7QUFFbkIsU0FBS3FJLFlBQVlySTtBQUNqQixTQUFLMU8saUJBQWlCO0FBQ3RCLFNBQUtrYSxXQUFXeEw7QUFDaEIsU0FBS3lMLFdBQVd6TDtBQUNoQixTQUFLMEwsZ0JBQWdCMUw7QUFDckIsU0FBSzJMLGdCQUFnQjNMO0FBQ3JCLFNBQUs0TCxlQUFlO0FBQ3BCLFNBQUtDLGVBQWU7QUFDcEIsU0FBS0MsU0FBUyxDQUFBO0FBQ2QsU0FBS0Msb0JBQW9CO0FBQ3pCLFNBQUtDLFdBQVdoTTtFQUNsQjtFQU1BalEsS0FBS04sU0FBUztBQUNaLFNBQUtBLFVBQVVBLFFBQVF3YyxXQUFXLEtBQUt4TixXQUFVLENBQUE7QUFFakQsU0FBSy9OLE9BQU9qQixRQUFRaUI7QUFHcEIsU0FBSythLFdBQVcsS0FBS3hiLE1BQU1SLFFBQVE4VixHQUFHO0FBQ3RDLFNBQUtpRyxXQUFXLEtBQUt2YixNQUFNUixRQUFRMkMsR0FBRztBQUN0QyxTQUFLdVosZ0JBQWdCLEtBQUsxYixNQUFNUixRQUFReWMsWUFBWTtBQUNwRCxTQUFLUixnQkFBZ0IsS0FBS3piLE1BQU1SLFFBQVEwYyxZQUFZO0VBQ3REO0VBUUFsYyxNQUFNbWMsS0FBSy9ZLE9BQU87QUFDaEIsV0FBTytZO0VBQ1Q7RUFPQUMsZ0JBQWdCO0FBQ2QsUUFBSSxFQUFDWixVQUFVRCxVQUFVRyxlQUFlRCxjQUFBQSxJQUFpQjtBQUN6REQsZUFBV2EsZ0JBQWdCYixVQUFVOVYsT0FBT0MsaUJBQWlCO0FBQzdENFYsZUFBV2MsZ0JBQWdCZCxVQUFVN1YsT0FBTzRXLGlCQUFpQjtBQUM3RFosb0JBQWdCVyxnQkFBZ0JYLGVBQWVoVyxPQUFPQyxpQkFBaUI7QUFDdkU4VixvQkFBZ0JZLGdCQUFnQlosZUFBZS9WLE9BQU80VyxpQkFBaUI7QUFDdkUsV0FBTztNQUNMaEgsS0FBSytHLGdCQUFnQmIsVUFBVUUsYUFBQUE7TUFDL0J2WixLQUFLa2EsZ0JBQWdCZCxVQUFVRSxhQUFBQTtNQUMvQmMsWUFBWUMsZUFBU2hCLFFBQUFBO01BQ3JCaUIsWUFBWUQsZUFBU2pCLFFBQUFBO0lBQ3ZCO0VBQ0Y7RUFRQW1CLFVBQVVDLFVBQVU7QUFDbEIsUUFBSSxFQUFDckgsS0FBS25ULEtBQUtvYSxZQUFZRSxXQUFBQSxJQUFjLEtBQUtMLGNBQWE7QUFDM0QsUUFBSTVaO0FBRUosUUFBSStaLGNBQWNFLFlBQVk7QUFDNUIsYUFBTztRQUFDbkg7UUFBS25UO01BQUc7O0FBR2xCLFVBQU15YSxRQUFRLEtBQUtDLHdCQUF1QjtBQUMxQyxhQUFTM1osS0FBSSxHQUFHQyxPQUFPeVosTUFBTXpiLFFBQVErQixLQUFJQyxNQUFNLEVBQUVELElBQUc7QUFDbERWLE1BQUFBLFNBQVFvYSxNQUFNMVosRUFBRSxFQUFDdEMsV0FBVzhiLFVBQVUsTUFBTUMsUUFBQUE7QUFDNUMsVUFBSSxDQUFDSixZQUFZO0FBQ2ZqSCxjQUFNcFQsS0FBS29ULElBQUlBLEtBQUs5UyxPQUFNOFMsR0FBRzs7QUFFL0IsVUFBSSxDQUFDbUgsWUFBWTtBQUNmdGEsY0FBTUQsS0FBS0MsSUFBSUEsS0FBS0ssT0FBTUwsR0FBRzs7SUFFakM7QUFHQW1ULFVBQU1tSCxjQUFjbkgsTUFBTW5ULE1BQU1BLE1BQU1tVDtBQUN0Q25ULFVBQU1vYSxjQUFjakgsTUFBTW5ULE1BQU1tVCxNQUFNblQ7QUFFdEMsV0FBTztNQUNMbVQsS0FBSytHLGdCQUFnQi9HLEtBQUsrRyxnQkFBZ0JsYSxLQUFLbVQsR0FBQUEsQ0FBQUE7TUFDL0NuVCxLQUFLa2EsZ0JBQWdCbGEsS0FBS2thLGdCQUFnQi9HLEtBQUtuVCxHQUFBQSxDQUFBQTtJQUNqRDtFQUNGO0VBT0FvSSxhQUFhO0FBQ1gsV0FBTztNQUNMaEIsTUFBTSxLQUFLd1IsZUFBZTtNQUMxQnRSLEtBQUssS0FBS29SLGNBQWM7TUFDeEJyUixPQUFPLEtBQUt3UixnQkFBZ0I7TUFDNUJ0UixRQUFRLEtBQUtvUixpQkFBaUI7SUFDaEM7RUFDRjtFQU9BZ0MsV0FBVztBQUNULFdBQU8sS0FBSzdIO0VBQ2Q7RUFLQThILFlBQVk7QUFDVixVQUFNbGMsT0FBTyxLQUFLZ0MsTUFBTWhDO0FBQ3hCLFdBQU8sS0FBS3JCLFFBQVF3ZCxXQUFXLEtBQUsvVSxhQUFZLElBQUtwSCxLQUFLb2MsVUFBVXBjLEtBQUtxYyxZQUFZcmMsS0FBS21jLFVBQVUsQ0FBQTtFQUN0RztFQUtBRyxjQUFjdFksWUFBWSxLQUFLaEMsTUFBTWdDLFdBQVc7QUFDOUMsVUFBTUwsUUFBUSxLQUFLNFcsZ0JBQWdCLEtBQUtBLGNBQWMsS0FBS2dDLG1CQUFtQnZZLFNBQVM7QUFDdkYsV0FBT0w7RUFDVDtFQUdBeUksZUFBZTtBQUNiLFNBQUs0TyxTQUFTLENBQUE7QUFDZCxTQUFLQyxvQkFBb0I7RUFDM0I7RUFNQXVCLGVBQWU7QUFDYkMsYUFBSyxLQUFLOWQsUUFBUTZkLGNBQWM7TUFBQztJQUFLLENBQUE7RUFDeEM7RUFVQXhSLE9BQU9vTyxVQUFVVyxXQUFXMkMsU0FBUztBQUNuQyxVQUFNLEVBQUNDLGFBQWFDLE9BQU94SSxPQUFPQyxTQUFBQSxJQUFZLEtBQUsxVjtBQUNuRCxVQUFNa2UsYUFBYXhJLFNBQVN3STtBQUc1QixTQUFLTCxhQUFZO0FBR2pCLFNBQUtwRCxXQUFXQTtBQUNoQixTQUFLVyxZQUFZQTtBQUNqQixTQUFLRCxXQUFXNEMsVUFBVTVkLE9BQU9DLE9BQU87TUFDdEMySixNQUFNO01BQ05DLE9BQU87TUFDUEMsS0FBSztNQUNMQyxRQUFRO09BQ1A2VCxPQUFBQTtBQUVILFNBQUt0SSxRQUFRO0FBQ2IsU0FBS29HLGNBQWM7QUFDbkIsU0FBS0YsaUJBQWlCO0FBQ3RCLFNBQUtDLGNBQWM7QUFHbkIsU0FBS3VDLG9CQUFtQjtBQUN4QixTQUFLQyxjQUFhO0FBQ2xCLFNBQUtDLG1CQUFrQjtBQUV2QixTQUFLbEgsYUFBYSxLQUFLMU8sYUFBWSxJQUMvQixLQUFLaUIsUUFBUXFVLFFBQVFoVSxPQUFPZ1UsUUFBUS9ULFFBQ3BDLEtBQUtKLFNBQVNtVSxRQUFROVQsTUFBTThULFFBQVE3VDtBQUd4QyxRQUFJLENBQUMsS0FBS29TLG1CQUFtQjtBQUMzQixXQUFLZ0MsaUJBQWdCO0FBQ3JCLFdBQUtDLG9CQUFtQjtBQUN4QixXQUFLQyxnQkFBZTtBQUNwQixXQUFLOUMsU0FBUytDLFVBQVUsTUFBTVIsT0FBT0QsV0FBQUE7QUFDckMsV0FBSzFCLG9CQUFvQjs7QUFHM0IsU0FBS29DLGlCQUFnQjtBQUVyQixTQUFLakosUUFBUSxLQUFLa0osV0FBVSxLQUFNLENBQUE7QUFHbEMsU0FBS0MsZ0JBQWU7QUFJcEIsVUFBTUMsa0JBQWtCWCxhQUFhLEtBQUt6SSxNQUFNOVQ7QUFDaEQsU0FBS21kLHNCQUFzQkQsa0JBQWtCeEcsT0FBTyxLQUFLNUMsT0FBT3lJLFVBQUFBLElBQWMsS0FBS3pJLEtBQUs7QUFNeEYsU0FBS3RJLFVBQVM7QUFHZCxTQUFLNFIsNkJBQTRCO0FBQ2pDLFNBQUtDLHVCQUFzQjtBQUMzQixTQUFLQyw0QkFBMkI7QUFHaEMsUUFBSXZKLFNBQVM3SCxZQUFZNkgsU0FBU0gsWUFBWUcsU0FBU3dKLFdBQVcsU0FBUztBQUN6RSxXQUFLekosUUFBUUYsU0FBUyxNQUFNLEtBQUtFLEtBQUs7QUFDdEMsV0FBS29HLGNBQWM7QUFDbkIsV0FBS3NELGNBQWE7O0FBR3BCLFFBQUlOLGlCQUFpQjtBQUVuQixXQUFLQyxzQkFBc0IsS0FBS3JKLEtBQUs7O0FBR3ZDLFNBQUsySixVQUFTO0FBQ2QsU0FBS0MsSUFBRztBQUNSLFNBQUtDLFNBQVE7QUFJYixTQUFLQyxZQUFXO0VBQ2xCO0VBS0FwUyxZQUFZO0FBQ1YsUUFBSXFTLGdCQUFnQixLQUFLeGYsUUFBUXNDO0FBQ2pDLFFBQUltZCxZQUFZQztBQUVoQixRQUFJLEtBQUtqWCxhQUFZLEdBQUk7QUFDdkJnWCxtQkFBYSxLQUFLMVY7QUFDbEIyVixpQkFBVyxLQUFLMVY7V0FDWDtBQUNMeVYsbUJBQWEsS0FBS3hWO0FBQ2xCeVYsaUJBQVcsS0FBS3hWO0FBRWhCc1Ysc0JBQWdCLENBQUNBOztBQUVuQixTQUFLN0csY0FBYzhHO0FBQ25CLFNBQUs3RyxZQUFZOEc7QUFDakIsU0FBSzdkLGlCQUFpQjJkO0FBQ3RCLFNBQUt2SSxVQUFVeUksV0FBV0Q7QUFDMUIsU0FBS0UsaUJBQWlCLEtBQUszZixRQUFRNGY7RUFDckM7RUFFQUwsY0FBYztBQUNaekIsYUFBSyxLQUFLOWQsUUFBUXVmLGFBQWE7TUFBQztJQUFLLENBQUE7RUFDdkM7RUFJQXBCLHNCQUFzQjtBQUNwQkwsYUFBSyxLQUFLOWQsUUFBUW1lLHFCQUFxQjtNQUFDO0lBQUssQ0FBQTtFQUMvQztFQUNBQyxnQkFBZ0I7QUFFZCxRQUFJLEtBQUszVixhQUFZLEdBQUk7QUFFdkIsV0FBS2lCLFFBQVEsS0FBSytRO0FBQ2xCLFdBQUsxUSxPQUFPO0FBQ1osV0FBS0MsUUFBUSxLQUFLTjtXQUNiO0FBQ0wsV0FBS0UsU0FBUyxLQUFLd1I7QUFHbkIsV0FBS25SLE1BQU07QUFDWCxXQUFLQyxTQUFTLEtBQUtOOztBQUlyQixTQUFLMlIsY0FBYztBQUNuQixTQUFLRixhQUFhO0FBQ2xCLFNBQUtHLGVBQWU7QUFDcEIsU0FBS0YsZ0JBQWdCO0VBQ3ZCO0VBQ0ErQyxxQkFBcUI7QUFDbkJQLGFBQUssS0FBSzlkLFFBQVFxZSxvQkFBb0I7TUFBQztJQUFLLENBQUE7RUFDOUM7RUFFQXdCLFdBQVdDLE1BQU07QUFDZixTQUFLemMsTUFBTTBjLGNBQWNELE1BQU0sS0FBSzlRLFdBQVUsQ0FBQTtBQUM5QzhPLGFBQUssS0FBSzlkLFFBQVE4ZixJQUFBQSxHQUFPO01BQUM7SUFBSyxDQUFBO0VBQ2pDO0VBR0F4QixtQkFBbUI7QUFDakIsU0FBS3VCLFdBQVcsa0JBQUE7RUFDbEI7RUFDQXRCLHNCQUFzQjtFQUFBO0VBQ3RCQyxrQkFBa0I7QUFDaEIsU0FBS3FCLFdBQVcsaUJBQUE7RUFDbEI7RUFHQW5CLG1CQUFtQjtBQUNqQixTQUFLbUIsV0FBVyxrQkFBQTtFQUNsQjtFQUlBbEIsYUFBYTtBQUNYLFdBQU8sQ0FBQTtFQUNUO0VBQ0FDLGtCQUFrQjtBQUNoQixTQUFLaUIsV0FBVyxpQkFBQTtFQUNsQjtFQUVBRyw4QkFBOEI7QUFDNUJsQyxhQUFLLEtBQUs5ZCxRQUFRZ2dCLDZCQUE2QjtNQUFDO0lBQUssQ0FBQTtFQUN2RDtFQUtBQyxtQkFBbUJ4SyxPQUFPO0FBQ3hCLFVBQU1DLFdBQVcsS0FBSzFWLFFBQVF5VjtBQUM5QixRQUFJL1IsSUFBR0MsTUFBTXdXO0FBQ2IsU0FBS3pXLEtBQUksR0FBR0MsT0FBTzhSLE1BQU05VCxRQUFRK0IsS0FBSUMsTUFBTUQsTUFBSztBQUM5Q3lXLGFBQU8xRSxNQUFNL1IsRUFBRTtBQUNmeVcsV0FBSytGLFFBQVFwQyxTQUFLcEksU0FBU3lLLFVBQVU7UUFBQ2hHLEtBQUtqWjtRQUFPd0M7UUFBRytSO01BQU0sR0FBRSxJQUFJO0lBQ25FO0VBQ0Y7RUFDQTJLLDZCQUE2QjtBQUMzQnRDLGFBQUssS0FBSzlkLFFBQVFvZ0IsNEJBQTRCO01BQUM7SUFBSyxDQUFBO0VBQ3REO0VBSUFyQiwrQkFBK0I7QUFDN0JqQixhQUFLLEtBQUs5ZCxRQUFRK2UsOEJBQThCO01BQUM7SUFBSyxDQUFBO0VBQ3hEO0VBQ0FDLHlCQUF5QjtBQUN2QixVQUFNaGYsVUFBVSxLQUFLQTtBQUNyQixVQUFNMFYsV0FBVzFWLFFBQVF5VjtBQUN6QixVQUFNNEssV0FBV2xJLGNBQWMsS0FBSzFDLE1BQU05VCxRQUFRM0IsUUFBUXlWLE1BQU1NLGFBQWE7QUFDN0UsVUFBTXVLLGNBQWM1SyxTQUFTNEssZUFBZTtBQUM1QyxVQUFNQyxjQUFjN0ssU0FBUzZLO0FBQzdCLFFBQUk5RSxnQkFBZ0I2RTtBQUNwQixRQUFJRSxXQUFXcEYsV0FBV3FGO0FBRTFCLFFBQUksQ0FBQyxLQUFLQyxXQUFVLEtBQU0sQ0FBQ2hMLFNBQVM3SCxXQUFXeVMsZUFBZUMsZUFBZUYsWUFBWSxLQUFLLENBQUMsS0FBSzVYLGFBQVksR0FBSTtBQUNsSCxXQUFLZ1QsZ0JBQWdCNkU7QUFDckI7O0FBR0YsVUFBTUssYUFBYSxLQUFLQyxlQUFjO0FBQ3RDLFVBQU1DLGdCQUFnQkYsV0FBV0csT0FBT3BYO0FBQ3hDLFVBQU1xWCxpQkFBaUJKLFdBQVdLLFFBQVFwWDtBQUkxQyxVQUFNNlEsV0FBV3dHLFlBQVksS0FBSzVkLE1BQU1xRyxRQUFRbVgsZUFBZSxHQUFHLEtBQUtwRyxRQUFRO0FBQy9FK0YsZ0JBQVl4Z0IsUUFBUTZXLFNBQVMsS0FBSzRELFdBQVc0RixXQUFXNUYsWUFBWTRGLFdBQVc7QUFHL0UsUUFBSVEsZ0JBQWdCLElBQUlMLFdBQVc7QUFDakNBLGtCQUFZL0YsWUFBWTRGLFlBQVlyZ0IsUUFBUTZXLFNBQVMsTUFBTTtBQUMzRHVFLGtCQUFZLEtBQUtBLFlBQVkvQixrQkFBa0JyWixRQUFRa2hCLElBQUksSUFDM0R4TCxTQUFTakosVUFBVThNLGVBQWV2WixRQUFRbWhCLE9BQU8sS0FBSzlkLE1BQU1yRCxRQUFReVosSUFBSTtBQUN4RWdILHlCQUFtQi9kLEtBQUtpQyxLQUFLa2MsZ0JBQWdCQSxnQkFBZ0JFLGlCQUFpQkEsY0FBQUE7QUFDOUV0RixzQkFBZ0IyRixVQUFVMWUsS0FBS29ULElBQzdCcFQsS0FBSzJlLEtBQUtKLGFBQWFOLFdBQVdLLFFBQVFwWCxTQUFTLEtBQUs0VyxXQUFXLElBQUksQ0FBQSxDQUFBLEdBQ3ZFOWQsS0FBSzJlLEtBQUtKLFlBQVk3RixZQUFZcUYsa0JBQWtCLElBQUksQ0FBQSxDQUFBLElBQU0vZCxLQUFLMmUsS0FBS0osWUFBWUYsaUJBQWlCTixrQkFBa0IsSUFBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBRTdIaEYsc0JBQWdCL1ksS0FBS0MsSUFBSTJkLGFBQWE1ZCxLQUFLb1QsSUFBSXlLLGFBQWE5RSxhQUFBQSxDQUFBQTs7QUFHOUQsU0FBS0EsZ0JBQWdCQTtFQUN2QjtFQUNBd0QsOEJBQThCO0FBQzVCbkIsYUFBSyxLQUFLOWQsUUFBUWlmLDZCQUE2QjtNQUFDO0lBQUssQ0FBQTtFQUN2RDtFQUNBRSxnQkFBZ0I7RUFBQTtFQUloQkMsWUFBWTtBQUNWdEIsYUFBSyxLQUFLOWQsUUFBUW9mLFdBQVc7TUFBQztJQUFLLENBQUE7RUFDckM7RUFDQUMsTUFBTTtBQUVKLFVBQU1pQyxVQUFVO01BQ2Q1WCxPQUFPO01BQ1BFLFFBQVE7SUFDVjtBQUVBLFVBQU0sRUFBQ3ZHLE9BQU9yRCxTQUFTLEVBQUN5VixPQUFPQyxVQUFVeUwsT0FBT0ksV0FBV0wsTUFBTU0sU0FBQUEsRUFBUyxJQUFJO0FBQzlFLFVBQU0zVCxVQUFVLEtBQUs2UyxXQUFVO0FBQy9CLFVBQU1qWSxlQUFlLEtBQUtBLGFBQVk7QUFFdEMsUUFBSW9GLFNBQVM7QUFDWCxZQUFNNFQsY0FBY2xJLGVBQWVnSSxXQUFXbGUsTUFBTXJELFFBQVF5WixJQUFJO0FBQ2hFLFVBQUloUixjQUFjO0FBQ2hCNlksZ0JBQVE1WCxRQUFRLEtBQUsrUTtBQUNyQjZHLGdCQUFRMVgsU0FBU3lQLGtCQUFrQm1JLFFBQVlDLElBQUFBO2FBQzFDO0FBQ0xILGdCQUFRMVgsU0FBUyxLQUFLd1I7QUFDdEJrRyxnQkFBUTVYLFFBQVEyUCxrQkFBa0JtSSxRQUFZQyxJQUFBQTs7QUFJaEQsVUFBSS9MLFNBQVM3SCxXQUFXLEtBQUs0SCxNQUFNOVQsUUFBUTtBQUN6QyxjQUFNLEVBQUMwVSxPQUFPQyxNQUFNd0ssUUFBUUUsUUFBQUEsSUFBVyxLQUFLSixlQUFjO0FBQzFELGNBQU1jLGNBQWNoTSxTQUFTakosVUFBVTtBQUN2QyxjQUFNa1YsZUFBZUMsVUFBVSxLQUFLbkcsYUFBYTtBQUNqRCxjQUFNb0csTUFBTW5mLEtBQUttZixJQUFJRixZQUFBQTtBQUNyQixjQUFNRyxNQUFNcGYsS0FBS29mLElBQUlILFlBQUFBO0FBRXJCLFlBQUlsWixjQUFjO0FBRWhCLGdCQUFNc1osY0FBY3JNLFNBQVNzTSxTQUFTLElBQUlGLE1BQU1oQixPQUFPcFgsUUFBUW1ZLE1BQU1iLFFBQVFwWDtBQUM3RTBYLGtCQUFRMVgsU0FBU2xILEtBQUtvVCxJQUFJLEtBQUtzRixXQUFXa0csUUFBUTFYLFNBQVNtWSxjQUFjTCxXQUFBQTtlQUNwRTtBQUdMLGdCQUFNTyxhQUFhdk0sU0FBU3NNLFNBQVMsSUFBSUgsTUFBTWYsT0FBT3BYLFFBQVFvWSxNQUFNZCxRQUFRcFg7QUFFNUUwWCxrQkFBUTVYLFFBQVFoSCxLQUFLb1QsSUFBSSxLQUFLMkUsVUFBVTZHLFFBQVE1WCxRQUFRdVksYUFBYVAsV0FBQUE7O0FBRXZFLGFBQUtRLGtCQUFrQjdMLE9BQU9DLE1BQU13TCxLQUFLRCxHQUFBQTs7O0FBSTdDLFNBQUtNLGVBQWM7QUFFbkIsUUFBSTFaLGNBQWM7QUFDaEIsV0FBS2lCLFFBQVEsS0FBS3VOLFVBQVU1VCxNQUFNcUcsUUFBUSxLQUFLeVIsU0FBU3BSLE9BQU8sS0FBS29SLFNBQVNuUjtBQUM3RSxXQUFLSixTQUFTMFgsUUFBUTFYO1dBQ2pCO0FBQ0wsV0FBS0YsUUFBUTRYLFFBQVE1WDtBQUNyQixXQUFLRSxTQUFTLEtBQUtxTixVQUFVNVQsTUFBTXVHLFNBQVMsS0FBS3VSLFNBQVNsUixNQUFNLEtBQUtrUixTQUFTalI7O0VBRWxGO0VBRUFnWSxrQkFBa0I3TCxPQUFPQyxNQUFNd0wsS0FBS0QsS0FBSztBQUN2QyxVQUFNLEVBQUNwTSxPQUFPLEVBQUN1QyxPQUFPdkwsUUFBTyxHQUFHbkosU0FBUSxJQUFJLEtBQUt0RDtBQUNqRCxVQUFNb2lCLFlBQVksS0FBSzNHLGtCQUFrQjtBQUN6QyxVQUFNNEcsbUJBQW1CL2UsYUFBYSxTQUFTLEtBQUtyQyxTQUFTO0FBRTdELFFBQUksS0FBS3dILGFBQVksR0FBSTtBQUN2QixZQUFNNlosYUFBYSxLQUFLdkosZ0JBQWdCLENBQUssSUFBQSxLQUFLaFA7QUFDbEQsWUFBTXdZLGNBQWMsS0FBS3ZZLFFBQVEsS0FBSytPLGdCQUFnQixLQUFLdEQsTUFBTTlULFNBQVMsQ0FBQTtBQUMxRSxVQUFJNFosY0FBYztBQUNsQixVQUFJQyxlQUFlO0FBSW5CLFVBQUk0RyxXQUFXO0FBQ2IsWUFBSUMsa0JBQWtCO0FBQ3BCOUcsd0JBQWNzRyxNQUFNeEwsTUFBTTNNO0FBQzFCOFIseUJBQWVzRyxNQUFNeEwsS0FBSzFNO2VBQ3JCO0FBQ0wyUix3QkFBY3VHLE1BQU16TCxNQUFNek07QUFDMUI0Uix5QkFBZXFHLE1BQU12TCxLQUFLNU07O2lCQUVuQnNPLFVBQVUsU0FBUztBQUM1QndELHVCQUFlbEYsS0FBSzVNO2lCQUNYc08sVUFBVSxPQUFPO0FBQzFCdUQsc0JBQWNsRixNQUFNM007aUJBQ1hzTyxVQUFVLFNBQVM7QUFDNUJ1RCxzQkFBY2xGLE1BQU0zTSxRQUFRO0FBQzVCOFIsdUJBQWVsRixLQUFLNU0sUUFBUTs7QUFJOUIsV0FBSzZSLGNBQWM3WSxLQUFLQyxLQUFLNFksY0FBYytHLGFBQWE3VixXQUFXLEtBQUsvQyxTQUFTLEtBQUtBLFFBQVE0WSxhQUFhLENBQUE7QUFDM0csV0FBSzlHLGVBQWU5WSxLQUFLQyxLQUFLNlksZUFBZStHLGNBQWM5VixXQUFXLEtBQUsvQyxTQUFTLEtBQUtBLFFBQVE2WSxjQUFjLENBQUE7V0FDMUc7QUFDTCxVQUFJbEgsYUFBYS9FLEtBQUsxTSxTQUFTO0FBQy9CLFVBQUkwUixnQkFBZ0JqRixNQUFNek0sU0FBUztBQUVuQyxVQUFJb08sVUFBVSxTQUFTO0FBQ3JCcUQscUJBQWE7QUFDYkMsd0JBQWdCakYsTUFBTXpNO2lCQUNib08sVUFBVSxPQUFPO0FBQzFCcUQscUJBQWEvRSxLQUFLMU07QUFDbEIwUix3QkFBZ0I7O0FBR2xCLFdBQUtELGFBQWFBLGFBQWE1TztBQUMvQixXQUFLNk8sZ0JBQWdCQSxnQkFBZ0I3Tzs7RUFFekM7RUFNQTBWLGlCQUFpQjtBQUNmLFFBQUksS0FBS2hILFVBQVU7QUFDakIsV0FBS0EsU0FBU3BSLE9BQU9ySCxLQUFLQyxJQUFJLEtBQUs0WSxhQUFhLEtBQUtKLFNBQVNwUixJQUFJO0FBQ2xFLFdBQUtvUixTQUFTbFIsTUFBTXZILEtBQUtDLElBQUksS0FBSzBZLFlBQVksS0FBS0YsU0FBU2xSLEdBQUc7QUFDL0QsV0FBS2tSLFNBQVNuUixRQUFRdEgsS0FBS0MsSUFBSSxLQUFLNlksY0FBYyxLQUFLTCxTQUFTblIsS0FBSztBQUNyRSxXQUFLbVIsU0FBU2pSLFNBQVN4SCxLQUFLQyxJQUFJLEtBQUsyWSxlQUFlLEtBQUtILFNBQVNqUixNQUFNOztFQUU1RTtFQUVBb1YsV0FBVztBQUNUeEIsYUFBSyxLQUFLOWQsUUFBUXNmLFVBQVU7TUFBQztJQUFLLENBQUE7RUFDcEM7RUFNQTdXLGVBQWU7QUFDYixVQUFNLEVBQUN4SCxNQUFNcUMsU0FBQUEsSUFBWSxLQUFLdEQ7QUFDOUIsV0FBT3NELGFBQWEsU0FBU0EsYUFBYSxZQUFZckMsU0FBUztFQUNqRTtFQUlBdWhCLGFBQWE7QUFDWCxXQUFPLEtBQUt4aUIsUUFBUXdKO0VBQ3RCO0VBTUFzVixzQkFBc0JySixPQUFPO0FBQzNCLFNBQUt1Syw0QkFBMkI7QUFFaEMsU0FBS0MsbUJBQW1CeEssS0FBQUE7QUFHeEIsUUFBSS9SLElBQUdDO0FBQ1AsU0FBS0QsS0FBSSxHQUFHQyxPQUFPOFIsTUFBTTlULFFBQVErQixLQUFJQyxNQUFNRCxNQUFLO0FBQzlDLFVBQUlqQixjQUFjZ1QsTUFBTS9SLEVBQUUsRUFBQ3djLEtBQUssR0FBRztBQUNqQ3pLLGNBQU12SSxPQUFPeEosSUFBRyxDQUFBO0FBQ2hCQztBQUNBRCxRQUFBQTs7SUFFSjtBQUVBLFNBQUswYywyQkFBMEI7RUFDakM7RUFNQVEsaUJBQWlCO0FBQ2YsUUFBSUQsYUFBYSxLQUFLOUU7QUFFdEIsUUFBSSxDQUFDOEUsWUFBWTtBQUNmLFlBQU16QyxhQUFhLEtBQUtsZSxRQUFReVYsTUFBTXlJO0FBQ3RDLFVBQUl6SSxRQUFRLEtBQUtBO0FBQ2pCLFVBQUl5SSxhQUFhekksTUFBTTlULFFBQVE7QUFDN0I4VCxnQkFBUTRDLE9BQU81QyxPQUFPeUksVUFBQUE7O0FBR3hCLFdBQUtyQyxjQUFjOEUsYUFBYSxLQUFLOEIsbUJBQW1CaE4sT0FBT0EsTUFBTTlULFFBQVEsS0FBSzNCLFFBQVF5VixNQUFNTSxhQUFhOztBQUcvRyxXQUFPNEs7RUFDVDtFQVFBOEIsbUJBQW1CaE4sT0FBTzlULFFBQVFvVSxlQUFlO0FBQy9DLFVBQU0sRUFBQ3JDLEtBQUtvSSxtQkFBbUI3QyxPQUFNLElBQUk7QUFDekMsVUFBTXlKLFNBQVMsQ0FBQTtBQUNmLFVBQU1DLFVBQVUsQ0FBQTtBQUNoQixVQUFNcEssWUFBWTdWLEtBQUtpTSxNQUFNaE4sU0FBU3dXLGNBQWN4VyxRQUFRb1UsYUFBQUEsQ0FBQUE7QUFDNUQsUUFBSTZNLGtCQUFrQjtBQUN0QixRQUFJQyxtQkFBbUI7QUFDdkIsUUFBSW5mLElBQUdHLElBQUdpZixNQUFNNUMsT0FBTzZDLFVBQVVDLFlBQVk5SixPQUFPWSxZQUFZcFEsT0FBT0UsUUFBUXFaO0FBRS9FLFNBQUt2ZixLQUFJLEdBQUdBLEtBQUkvQixRQUFRK0IsTUFBSzZVLFdBQVc7QUFDdEMySCxjQUFRekssTUFBTS9SLEVBQUUsRUFBQ3djO0FBQ2pCNkMsaUJBQVcsS0FBS0csd0JBQXdCeGYsRUFBQUE7QUFDeENnUSxVQUFJK0YsT0FBT3VKLGFBQWFELFNBQVNJO0FBQ2pDakssY0FBUUQsT0FBTytKLFVBQUFBLElBQWMvSixPQUFPK0osVUFBQUEsS0FBZTtRQUFDM2hCLE1BQU0sQ0FBQTtRQUFJOFgsSUFBSSxDQUFBO01BQUU7QUFDcEVXLG1CQUFhaUosU0FBU2pKO0FBQ3RCcFEsY0FBUUUsU0FBUztBQUVqQixVQUFJLENBQUNuSCxjQUFjeWQsS0FBVSxLQUFBLENBQUN0RyxRQUFRc0csS0FBUSxHQUFBO0FBQzVDeFcsZ0JBQVEwWixhQUFhMVAsS0FBS3dGLE1BQU03WCxNQUFNNlgsTUFBTUMsSUFBSXpQLE9BQU93VyxLQUFBQTtBQUN2RHRXLGlCQUFTa1E7aUJBQ0FGLFFBQVFzRyxLQUFRLEdBQUE7QUFFekIsYUFBS3JjLEtBQUksR0FBR2lmLE9BQU81QyxNQUFNdmUsUUFBUWtDLEtBQUlpZixNQUFNLEVBQUVqZixJQUFHO0FBQzlDb2Ysd0JBQXFDL0MsTUFBTXJjLEVBQUU7QUFFN0MsY0FBSSxDQUFDcEIsY0FBY3dnQixXQUFnQixLQUFBLENBQUNySixRQUFRcUosV0FBYyxHQUFBO0FBQ3hEdlosb0JBQVEwWixhQUFhMVAsS0FBS3dGLE1BQU03WCxNQUFNNlgsTUFBTUMsSUFBSXpQLE9BQU91WixXQUFBQTtBQUN2RHJaLHNCQUFVa1E7O1FBRWQ7O0FBRUY0SSxhQUFPbmQsS0FBS21FLEtBQUFBO0FBQ1ppWixjQUFRcGQsS0FBS3FFLE1BQUFBO0FBQ2JnWix3QkFBa0JsZ0IsS0FBS0MsSUFBSStHLE9BQU9rWixlQUFBQTtBQUNsQ0MseUJBQW1CbmdCLEtBQUtDLElBQUlpSCxRQUFRaVosZ0JBQUFBO0lBQ3RDO0FBQ0E3SixtQkFBZUMsUUFBUXRYLE1BQUFBO0FBRXZCLFVBQU1tZixTQUFTNEIsT0FBT3hlLFFBQVEwZSxlQUFBQTtBQUM5QixVQUFNNUIsVUFBVTJCLFFBQVF6ZSxRQUFRMmUsZ0JBQUFBO0FBRWhDLFVBQU1RLFVBQVUsQ0FBQ0MsU0FBUztNQUFDNVosT0FBT2daLE9BQU9ZLEdBQUFBLEtBQVE7TUFBRzFaLFFBQVErWSxRQUFRVyxHQUFBQSxLQUFROztBQUU1RSxXQUFPO01BQ0xqTixPQUFPZ04sUUFBUSxDQUFBO01BQ2YvTSxNQUFNK00sUUFBUTFoQixTQUFTLENBQUE7TUFDdkJtZixRQUFRdUMsUUFBUXZDLE1BQUFBO01BQ2hCRSxTQUFTcUMsUUFBUXJDLE9BQUFBO01BQ2pCMEI7TUFDQUM7SUFDRjtFQUNGO0VBT0FZLGlCQUFpQnJpQixPQUFPO0FBQ3RCLFdBQU9BO0VBQ1Q7RUFTQTRaLGlCQUFpQjVaLE9BQU8wQyxPQUFPO0FBQzdCLFdBQU80ZjtFQUNUO0VBUUFDLGlCQUFpQkMsT0FBTztFQUFBO0VBUXhCM0ssZ0JBQWdCblYsT0FBTztBQUNyQixVQUFNNlIsUUFBUSxLQUFLQTtBQUNuQixRQUFJN1IsUUFBUSxLQUFLQSxRQUFRNlIsTUFBTTlULFNBQVMsR0FBRztBQUN6QyxhQUFPOztBQUVULFdBQU8sS0FBS21aLGlCQUFpQnJGLE1BQU03UixLQUFBQSxFQUFPMUMsS0FBSztFQUNqRDtFQVFBeWlCLG1CQUFtQkMsU0FBUztBQUMxQixRQUFJLEtBQUsvaEIsZ0JBQWdCO0FBQ3ZCK2hCLGdCQUFVLElBQUlBOztBQUdoQixVQUFNRixRQUFRLEtBQUsvSyxjQUFjaUwsVUFBVSxLQUFLM007QUFDaEQsV0FBTzRNLFlBQVksS0FBS2xFLGlCQUFpQm1FLFlBQVksS0FBS3pnQixPQUFPcWdCLE9BQU8sQ0FBQSxJQUFLQSxLQUFLO0VBQ3BGO0VBTUFLLG1CQUFtQkwsT0FBTztBQUN4QixVQUFNRSxXQUFXRixRQUFRLEtBQUsvSyxlQUFlLEtBQUsxQjtBQUNsRCxXQUFPLEtBQUtwVixpQkFBaUIsSUFBSStoQixVQUFVQTtFQUM3QztFQU9BSSxlQUFlO0FBQ2IsV0FBTyxLQUFLbEosaUJBQWlCLEtBQUttSixhQUFZLENBQUE7RUFDaEQ7RUFLQUEsZUFBZTtBQUNiLFVBQU0sRUFBQ25PLEtBQUtuVCxJQUFHLElBQUk7QUFFbkIsV0FBT21ULE1BQU0sS0FBS25ULE1BQU0sSUFBSUEsTUFDMUJtVCxNQUFNLEtBQUtuVCxNQUFNLElBQUltVCxNQUNyQjtFQUNKO0VBS0E5RyxXQUFXcEwsT0FBTztBQUNoQixVQUFNNlIsUUFBUSxLQUFLQSxTQUFTLENBQUE7QUFFNUIsUUFBSTdSLFNBQVMsS0FBS0EsUUFBUTZSLE1BQU05VCxRQUFRO0FBQ3RDLFlBQU13WSxPQUFPMUUsTUFBTTdSLEtBQU07QUFDekIsYUFBT3VXLEtBQUtvQyxhQUNicEMsS0FBS29DLFdBQVdyQyxrQkFBa0IsS0FBS2xMLFdBQVUsR0FBSXBMLE9BQU91VyxJQUFJOztBQUVqRSxXQUFPLEtBQUtvQyxhQUNaLEtBQUtBLFdBQVd4QyxtQkFBbUIsS0FBSzFXLE1BQU0yTCxXQUFVLEdBQUksSUFBSTtFQUNsRTtFQU1BK0gsWUFBWTtBQUNWLFVBQU1tTixjQUFjLEtBQUtsa0IsUUFBUXlWO0FBR2pDLFVBQU0wTyxNQUFNdkMsVUFBVSxLQUFLbkcsYUFBYTtBQUN4QyxVQUFNb0csTUFBTW5mLEtBQUs2QixJQUFJN0IsS0FBS21mLElBQUlzQyxHQUFBQSxDQUFBQTtBQUM5QixVQUFNckMsTUFBTXBmLEtBQUs2QixJQUFJN0IsS0FBS29mLElBQUlxQyxHQUFBQSxDQUFBQTtBQUU5QixVQUFNeEQsYUFBYSxLQUFLQyxlQUFjO0FBQ3RDLFVBQU1uVSxVQUFVeVgsWUFBWUUsbUJBQW1CO0FBQy9DLFVBQU0vWSxLQUFJc1YsYUFBYUEsV0FBV0csT0FBT3BYLFFBQVErQyxVQUFVO0FBQzNELFVBQU1sQixLQUFJb1YsYUFBYUEsV0FBV0ssUUFBUXBYLFNBQVM2QyxVQUFVO0FBRzdELFdBQU8sS0FBS2hFLGFBQVksSUFDcEI4QyxLQUFJc1csTUFBTXhXLEtBQUl5VyxNQUFNelcsS0FBSXdXLE1BQU10VyxLQUFJdVcsTUFDbEN2VyxLQUFJdVcsTUFBTXpXLEtBQUl3VyxNQUFNdFcsS0FBSXNXLE1BQU14VyxLQUFJeVc7RUFDeEM7RUFNQXBCLGFBQWE7QUFDWCxVQUFNN1MsVUFBVSxLQUFLN04sUUFBUTZOO0FBRTdCLFFBQUlBLFlBQVksUUFBUTtBQUN0QixhQUFPLENBQUMsQ0FBQ0E7O0FBR1gsV0FBTyxLQUFLd1Asd0JBQXVCLEVBQUcxYixTQUFTO0VBQ2pEO0VBS0EwaUIsc0JBQXNCaGYsV0FBVztBQUMvQixVQUFNcEUsT0FBTyxLQUFLQTtBQUNsQixVQUFNb0MsUUFBUSxLQUFLQTtBQUNuQixVQUFNckQsVUFBVSxLQUFLQTtBQUNyQixVQUFNLEVBQUNraEIsTUFBTTVkLFVBQVVnaEIsT0FBQUEsSUFBVXRrQjtBQUNqQyxVQUFNNlcsU0FBU3FLLEtBQUtySztBQUNwQixVQUFNcE8sZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU1nTixRQUFRLEtBQUtBO0FBQ25CLFVBQU0yQyxjQUFjM0MsTUFBTTlULFVBQVVrVixTQUFTLElBQUk7QUFDakQsVUFBTTBOLEtBQUtsTCxrQkFBa0I2SCxJQUFBQTtBQUM3QixVQUFNbGMsUUFBUSxDQUFBO0FBRWQsVUFBTXdmLGFBQWFGLE9BQU85SCxXQUFXLEtBQUt4TixXQUFVLENBQUE7QUFDcEQsVUFBTXlWLFlBQVlELFdBQVczVyxVQUFVMlcsV0FBVzlhLFFBQVE7QUFDMUQsVUFBTWdiLGdCQUFnQkQsWUFBWTtBQUNsQyxVQUFNRSxtQkFBbUIsU0FBU2pCLE9BQU87QUFDdkMsYUFBT0ksWUFBWXpnQixPQUFPcWdCLE9BQU9lLFNBQUFBO0lBQ25DO0FBQ0EsUUFBSUcsYUFBYWxoQixJQUFHb1YsV0FBVytMO0FBQy9CLFFBQUlDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLElBQUlDLElBQUlDLElBQUlDO0FBRXBDLFFBQUkvaEIsYUFBYSxPQUFPO0FBQ3RCc2hCLG9CQUFjRCxpQkFBaUIsS0FBS3phLE1BQU07QUFDMUM2YSxZQUFNLEtBQUs3YSxTQUFTcWE7QUFDcEJVLFlBQU1MLGNBQWNGO0FBQ3BCUyxXQUFLUixpQkFBaUJ0ZixVQUFVNEUsR0FBRyxJQUFJeWE7QUFDdkNXLFdBQUtoZ0IsVUFBVTZFO2VBQ041RyxhQUFhLFVBQVU7QUFDaENzaEIsb0JBQWNELGlCQUFpQixLQUFLMWEsR0FBRztBQUN2Q2tiLFdBQUs5ZixVQUFVNEU7QUFDZm9iLFdBQUtWLGlCQUFpQnRmLFVBQVU2RSxNQUFNLElBQUl3YTtBQUMxQ0ssWUFBTUgsY0FBY0Y7QUFDcEJPLFlBQU0sS0FBS2hiLE1BQU1zYTtlQUNSamhCLGFBQWEsUUFBUTtBQUM5QnNoQixvQkFBY0QsaUJBQWlCLEtBQUszYSxLQUFLO0FBQ3pDOGEsWUFBTSxLQUFLOWEsUUFBUXVhO0FBQ25CUyxZQUFNSixjQUFjRjtBQUNwQlEsV0FBS1AsaUJBQWlCdGYsVUFBVTBFLElBQUksSUFBSTJhO0FBQ3hDVSxXQUFLL2YsVUFBVTJFO2VBQ04xRyxhQUFhLFNBQVM7QUFDL0JzaEIsb0JBQWNELGlCQUFpQixLQUFLNWEsSUFBSTtBQUN4Q21iLFdBQUs3ZixVQUFVMEU7QUFDZnFiLFdBQUtULGlCQUFpQnRmLFVBQVUyRSxLQUFLLElBQUkwYTtBQUN6Q0ksWUFBTUYsY0FBY0Y7QUFDcEJNLFlBQU0sS0FBS2piLE9BQU93YTtlQUNUdGpCLFNBQVMsS0FBSztBQUN2QixVQUFJcUMsYUFBYSxVQUFVO0FBQ3pCc2hCLHNCQUFjRCxrQkFBa0J0ZixVQUFVNEUsTUFBTTVFLFVBQVU2RSxVQUFVLElBQUksR0FBQTtpQkFDL0RZLFNBQVN4SCxRQUFXLEdBQUE7QUFDN0IsY0FBTXVYLGlCQUFpQjFhLE9BQU80VCxLQUFLelEsUUFBQUEsRUFBVSxDQUFFO0FBQy9DLGNBQU1wQyxRQUFRb0MsU0FBU3VYLGNBQWU7QUFDdEMrSixzQkFBY0QsaUJBQWlCLEtBQUt0aEIsTUFBTWtYLE9BQU9NLGNBQUFBLEVBQWdCQyxpQkFBaUI1WixLQUFBQSxDQUFBQTs7QUFHcEZpa0IsV0FBSzlmLFVBQVU0RTtBQUNmb2IsV0FBS2hnQixVQUFVNkU7QUFDZjZhLFlBQU1ILGNBQWNGO0FBQ3BCTyxZQUFNRixNQUFNUjtlQUNIdGpCLFNBQVMsS0FBSztBQUN2QixVQUFJcUMsYUFBYSxVQUFVO0FBQ3pCc2hCLHNCQUFjRCxrQkFBa0J0ZixVQUFVMEUsT0FBTzFFLFVBQVUyRSxTQUFTLENBQUE7aUJBQzNEYyxTQUFTeEgsUUFBVyxHQUFBO0FBQzdCLGNBQU11WCxpQkFBaUIxYSxPQUFPNFQsS0FBS3pRLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxjQUFNcEMsUUFBUW9DLFNBQVN1WCxjQUFlO0FBQ3RDK0osc0JBQWNELGlCQUFpQixLQUFLdGhCLE1BQU1rWCxPQUFPTSxjQUFBQSxFQUFnQkMsaUJBQWlCNVosS0FBQUEsQ0FBQUE7O0FBR3BGNGpCLFlBQU1GLGNBQWNGO0FBQ3BCTSxZQUFNRixNQUFNUDtBQUNaVyxXQUFLN2YsVUFBVTBFO0FBQ2ZxYixXQUFLL2YsVUFBVTJFOztBQUdqQixVQUFNc2IsUUFBUTFOLGVBQWU1WCxRQUFReVYsTUFBTU0sZUFBZXFDLFdBQUFBO0FBQzFELFVBQU1tTixPQUFPN2lCLEtBQUtDLElBQUksR0FBR0QsS0FBSytVLEtBQUtXLGNBQWNrTixLQUFBQSxDQUFBQTtBQUNqRCxTQUFLNWhCLEtBQUksR0FBR0EsS0FBSTBVLGFBQWExVSxNQUFLNmhCLE1BQU07QUFDdEMsWUFBTW5YLFVBQVUsS0FBS1ksV0FBV3RMLEVBQUFBO0FBQ2hDLFlBQU04aEIsY0FBY3RFLEtBQUsxRSxXQUFXcE8sT0FBQUE7QUFDcEMsWUFBTXFYLG9CQUFvQm5CLE9BQU85SCxXQUFXcE8sT0FBQUE7QUFFNUMsWUFBTXNYLFlBQVlGLFlBQVlFO0FBQzlCLFlBQU1DLFlBQVlILFlBQVlJO0FBQzlCLFlBQU1DLGFBQWFKLGtCQUFrQkssUUFBUSxDQUFBO0FBQzdDLFlBQU1DLG1CQUFtQk4sa0JBQWtCTztBQUUzQyxZQUFNeEYsWUFBWWdGLFlBQVloRjtBQUM5QixZQUFNeUYsWUFBWVQsWUFBWVM7QUFDOUIsWUFBTUMsaUJBQWlCVixZQUFZVSxrQkFBa0IsQ0FBQTtBQUNyRCxZQUFNQyx1QkFBdUJYLFlBQVlXO0FBRXpDck4sa0JBQVlOLG9CQUFvQixNQUFNOVUsSUFBR21ULE1BQUFBO0FBR3pDLFVBQUlpQyxjQUFjdkksUUFBVztBQUMzQjs7QUFHRnNVLHlCQUFtQmYsWUFBWXpnQixPQUFPeVYsV0FBVzRNLFNBQUFBO0FBRWpELFVBQUlqZCxjQUFjO0FBQ2hCcWMsY0FBTUUsTUFBTUUsS0FBS0UsS0FBS1A7YUFDakI7QUFDTEUsY0FBTUUsTUFBTUUsS0FBS0UsS0FBS1I7O0FBR3hCN2YsWUFBTU8sS0FBSztRQUNUdWY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQTNiLE9BQU9nYztRQUNQRSxPQUFPRDtRQUNQRTtRQUNBRTtRQUNBdkY7UUFDQXlGO1FBQ0FDO1FBQ0FDO01BQ0YsQ0FBQTtJQUNGO0FBRUEsU0FBS2hLLGVBQWUvRDtBQUNwQixTQUFLZ0UsZUFBZXdJO0FBRXBCLFdBQU81ZjtFQUNUO0VBS0E0WSxtQkFBbUJ2WSxXQUFXO0FBQzVCLFVBQU1wRSxPQUFPLEtBQUtBO0FBQ2xCLFVBQU1qQixVQUFVLEtBQUtBO0FBQ3JCLFVBQU0sRUFBQ3NELFVBQVVtUyxPQUFPeU8sWUFBQUEsSUFBZWxrQjtBQUN2QyxVQUFNeUksZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU1nTixRQUFRLEtBQUtBO0FBQ25CLFVBQU0sRUFBQ3VDLE9BQU9vTyxZQUFZM1osU0FBU3VWLE9BQU0sSUFBSWtDO0FBQzdDLFVBQU1LLEtBQUtsTCxrQkFBa0JyWixRQUFRa2hCLElBQUk7QUFDekMsVUFBTW1GLGlCQUFpQjlCLEtBQUs5WDtBQUM1QixVQUFNNlosa0JBQWtCdEUsU0FBUyxDQUFDdlYsVUFBVTRaO0FBQzVDLFVBQU03TCxXQUFXLENBQUNvSCxVQUFVLEtBQUtuRyxhQUFhO0FBQzlDLFVBQU16VyxRQUFRLENBQUE7QUFDZCxRQUFJdEIsSUFBR0MsTUFBTXdXLE1BQU0rRixPQUFPMWIsSUFBR0UsSUFBRzZoQixXQUFXN0MsT0FBT2pLLE1BQU1LLFlBQVkwTSxXQUFXQztBQUMvRSxRQUFJQyxlQUFlO0FBRW5CLFFBQUlwakIsYUFBYSxPQUFPO0FBQ3RCb0IsTUFBQUEsS0FBSSxLQUFLd0YsU0FBU29jO0FBQ2xCQyxrQkFBWSxLQUFLSSx3QkFBdUI7ZUFDL0JyakIsYUFBYSxVQUFVO0FBQ2hDb0IsTUFBQUEsS0FBSSxLQUFLdUYsTUFBTXFjO0FBQ2ZDLGtCQUFZLEtBQUtJLHdCQUF1QjtlQUMvQnJqQixhQUFhLFFBQVE7QUFDOUIsWUFBTTZSLE1BQU0sS0FBS3lSLHdCQUF3QnJDLEVBQUFBO0FBQ3pDZ0Msa0JBQVlwUixJQUFJb1I7QUFDaEIvaEIsTUFBQUEsS0FBSTJRLElBQUkzUTtlQUNDbEIsYUFBYSxTQUFTO0FBQy9CLFlBQU02UixNQUFNLEtBQUt5Uix3QkFBd0JyQyxFQUFBQTtBQUN6Q2dDLGtCQUFZcFIsSUFBSW9SO0FBQ2hCL2hCLE1BQUFBLEtBQUkyUSxJQUFJM1E7ZUFDQ3ZELFNBQVMsS0FBSztBQUN2QixVQUFJcUMsYUFBYSxVQUFVO0FBQ3pCb0IsUUFBQUEsTUFBTVcsVUFBVTRFLE1BQU01RSxVQUFVNkUsVUFBVSxJQUFLbWM7aUJBQ3RDdmIsU0FBU3hILFFBQVcsR0FBQTtBQUM3QixjQUFNdVgsaUJBQWlCMWEsT0FBTzRULEtBQUt6USxRQUFBQSxFQUFVLENBQUU7QUFDL0MsY0FBTXBDLFFBQVFvQyxTQUFTdVgsY0FBZTtBQUN0Q25XLFFBQUFBLEtBQUksS0FBS3JCLE1BQU1rWCxPQUFPTSxjQUFlLEVBQUNDLGlCQUFpQjVaLEtBQVNtbEIsSUFBQUE7O0FBRWxFRSxrQkFBWSxLQUFLSSx3QkFBdUI7ZUFDL0IxbEIsU0FBUyxLQUFLO0FBQ3ZCLFVBQUlxQyxhQUFhLFVBQVU7QUFDekJrQixRQUFBQSxNQUFNYSxVQUFVMEUsT0FBTzFFLFVBQVUyRSxTQUFTLElBQUtxYztpQkFDdEN2YixTQUFTeEgsUUFBVyxHQUFBO0FBQzdCLGNBQU11WCxpQkFBaUIxYSxPQUFPNFQsS0FBS3pRLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxjQUFNcEMsUUFBUW9DLFNBQVN1WCxjQUFlO0FBQ3RDclcsUUFBQUEsS0FBSSxLQUFLbkIsTUFBTWtYLE9BQU9NLGNBQUFBLEVBQWdCQyxpQkFBaUI1WixLQUFBQTs7QUFFekRxbEIsa0JBQVksS0FBS0ssd0JBQXdCckMsRUFBQUEsRUFBSWdDOztBQUcvQyxRQUFJdGxCLFNBQVMsS0FBSztBQUNoQixVQUFJK1csVUFBVSxTQUFTO0FBQ3JCME8sdUJBQWU7aUJBQ04xTyxVQUFVLE9BQU87QUFDMUIwTyx1QkFBZTs7O0FBSW5CLFVBQU0vRixhQUFhLEtBQUtDLGVBQWM7QUFDdEMsU0FBS2xkLEtBQUksR0FBR0MsT0FBTzhSLE1BQU05VCxRQUFRK0IsS0FBSUMsTUFBTSxFQUFFRCxJQUFHO0FBQzlDeVcsYUFBTzFFLE1BQU0vUixFQUFFO0FBQ2Z3YyxjQUFRL0YsS0FBSytGO0FBRWIsWUFBTXNGLGNBQWN0QixZQUFZMUgsV0FBVyxLQUFLeE4sV0FBV3RMLEVBQUFBLENBQUFBO0FBQzNEZ2dCLGNBQVEsS0FBSzNLLGdCQUFnQnJWLEVBQUFBLElBQUt3Z0IsWUFBWTJDO0FBQzlDcE4sYUFBTyxLQUFLeUosd0JBQXdCeGYsRUFBQUE7QUFDcENvVyxtQkFBYUwsS0FBS0s7QUFDbEIwTSxrQkFBWTVNLFFBQVFzRyxLQUFBQSxJQUFTQSxNQUFNdmUsU0FBUztBQUM1QyxZQUFNbWxCLFlBQVlOLFlBQVk7QUFDOUIsWUFBTVosU0FBUUosWUFBWUk7QUFDMUIsWUFBTW1CLGNBQWN2QixZQUFZd0I7QUFDaEMsWUFBTUMsY0FBY3pCLFlBQVkwQjtBQUNoQyxVQUFJQyxnQkFBZ0JaO0FBRXBCLFVBQUk5ZCxjQUFjO0FBQ2hCakUsUUFBQUEsS0FBSWtmO0FBRUosWUFBSTZDLGNBQWMsU0FBUztBQUN6QixjQUFJN2lCLE9BQU1DLE9BQU8sR0FBRztBQUNsQndqQiw0QkFBZ0IsQ0FBQyxLQUFLbm5CLFFBQVFzQyxVQUFVLFVBQVU7cUJBQ3pDb0IsT0FBTSxHQUFHO0FBQ2xCeWpCLDRCQUFnQixDQUFDLEtBQUtubkIsUUFBUXNDLFVBQVUsU0FBUztpQkFDNUM7QUFDTDZrQiw0QkFBZ0I7OztBQUlwQixZQUFJN2pCLGFBQWEsT0FBTztBQUN0QixjQUFJOGlCLGVBQWUsVUFBVTVMLGFBQWEsR0FBRztBQUMzQ2lNLHlCQUFhLENBQUNELFlBQVkxTSxhQUFhQSxhQUFhO3FCQUMzQ3NNLGVBQWUsVUFBVTtBQUNsQ0sseUJBQWEsQ0FBQzlGLFdBQVdLLFFBQVFwWCxTQUFTLElBQUlrZCxZQUFZaE4sYUFBYUE7aUJBQ2xFO0FBQ0wyTSx5QkFBYSxDQUFDOUYsV0FBV0ssUUFBUXBYLFNBQVNrUSxhQUFhOztlQUVwRDtBQUVMLGNBQUlzTSxlQUFlLFVBQVU1TCxhQUFhLEdBQUc7QUFDM0NpTSx5QkFBYTNNLGFBQWE7cUJBQ2pCc00sZUFBZSxVQUFVO0FBQ2xDSyx5QkFBYTlGLFdBQVdLLFFBQVFwWCxTQUFTLElBQUlrZCxZQUFZaE47aUJBQ3BEO0FBQ0wyTSx5QkFBYTlGLFdBQVdLLFFBQVFwWCxTQUFTNGMsWUFBWTFNOzs7QUFHekQsWUFBSWtJLFFBQVE7QUFDVnlFLHdCQUFjOztBQUVoQixZQUFJak0sYUFBYSxLQUFLLENBQUNnTCxZQUFZNEIsbUJBQW1CO0FBQ3BENWlCLFVBQUFBLE1BQUssYUFBYyxJQUFLOUIsS0FBS29mLElBQUl0SCxRQUFBQTs7YUFFOUI7QUFDTDlWLFFBQUFBLEtBQUlnZjtBQUNKK0Msc0JBQWMsSUFBSUQsYUFBYTFNLGFBQWE7O0FBRzlDLFVBQUl1TjtBQUVKLFVBQUk3QixZQUFZNEIsbUJBQW1CO0FBQ2pDLGNBQU1FLGVBQWVqYSxVQUFVbVksWUFBWStCLGVBQWU7QUFDMUQsY0FBTTNkLFNBQVMrVyxXQUFXZ0MsUUFBUWpmLEVBQUU7QUFDcEMsY0FBTWdHLFFBQVFpWCxXQUFXK0IsT0FBT2hmLEVBQUU7QUFFbEMsWUFBSXVHLE1BQU13YyxhQUFhYSxhQUFhcmQ7QUFDcEMsWUFBSUYsT0FBTyxJQUFJdWQsYUFBYXZkO0FBRTVCLGdCQUFRMmMsY0FBQUE7VUFDUixLQUFLO0FBQ0h6YyxtQkFBT0wsU0FBUztBQUNoQjtVQUNGLEtBQUs7QUFDSEssbUJBQU9MO0FBQ1A7UUFHRjtBQUVBLGdCQUFRMmMsV0FBQUE7VUFDUixLQUFLO0FBQ0h4YyxvQkFBUUwsUUFBUTtBQUNoQjtVQUNGLEtBQUs7QUFDSEssb0JBQVFMO0FBQ1I7VUFDRixLQUFLO0FBQ0gsZ0JBQUloRyxPQUFNQyxPQUFPLEdBQUc7QUFDbEJvRyxzQkFBUUw7dUJBQ0NoRyxLQUFJLEdBQUc7QUFDaEJxRyxzQkFBUUwsUUFBUTs7QUFFbEI7UUFHRjtBQUVBMmQsbUJBQVc7VUFDVHRkO1VBQ0FFO1VBQ0FQLE9BQU9BLFFBQVE0ZCxhQUFhNWQ7VUFDNUJFLFFBQVFBLFNBQVMwZCxhQUFhMWQ7VUFFOUJnYyxPQUFPSixZQUFZZ0M7UUFDckI7O0FBR0Z4aUIsWUFBTU8sS0FBSztRQUNUMmE7UUFDQXpHO1FBQ0FnTjtRQUNBem1CLFNBQVM7VUFDUHdhO1VBQ0FvTCxPQUFBQTtVQUNBbUI7VUFDQUU7VUFDQVYsV0FBV1k7VUFDWFQ7VUFDQWUsYUFBYTtZQUFDampCO1lBQUdFO1VBQUU7VUFDbkIyaUI7UUFDRjtNQUNGLENBQUE7SUFDRjtBQUVBLFdBQU9yaUI7RUFDVDtFQUVBMmhCLDBCQUEwQjtBQUN4QixVQUFNLEVBQUNyakIsVUFBVW1TLE1BQUFBLElBQVMsS0FBS3pWO0FBQy9CLFVBQU13YSxXQUFXLENBQUNvSCxVQUFVLEtBQUtuRyxhQUFhO0FBRTlDLFFBQUlqQixVQUFVO0FBQ1osYUFBT2xYLGFBQWEsUUFBUSxTQUFTOztBQUd2QyxRQUFJMFUsUUFBUTtBQUVaLFFBQUl2QyxNQUFNdUMsVUFBVSxTQUFTO0FBQzNCQSxjQUFRO0lBQ1YsV0FBV3ZDLE1BQU11QyxVQUFVLE9BQU87QUFDaENBLGNBQVE7SUFDVixXQUFXdkMsTUFBTXVDLFVBQVUsU0FBUztBQUNsQ0EsY0FBUTs7QUFHVixXQUFPQTtFQUNUO0VBRUE0Tyx3QkFBd0JyQyxJQUFJO0FBQzFCLFVBQU0sRUFBQ2poQixVQUFVbVMsT0FBTyxFQUFDMlEsWUFBWXBFLFFBQVF2VixRQUFBQSxFQUFRLElBQUksS0FBS3pNO0FBQzlELFVBQU0yZ0IsYUFBYSxLQUFLQyxlQUFjO0FBQ3RDLFVBQU15RixpQkFBaUI5QixLQUFLOVg7QUFDNUIsVUFBTXFVLFNBQVNILFdBQVdHLE9BQU9wWDtBQUVqQyxRQUFJNmM7QUFDSixRQUFJL2hCO0FBRUosUUFBSWxCLGFBQWEsUUFBUTtBQUN2QixVQUFJMGUsUUFBUTtBQUNWeGQsUUFBQUEsS0FBSSxLQUFLd0YsUUFBUXlDO0FBRWpCLFlBQUkyWixlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovaEIsVUFBQUEsTUFBTXNjLFNBQVM7ZUFDVjtBQUNMeUYsc0JBQVk7QUFDWi9oQixVQUFBQSxNQUFLc2M7O2FBRUY7QUFDTHRjLFFBQUFBLEtBQUksS0FBS3dGLFFBQVFxYztBQUVqQixZQUFJRCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovaEIsVUFBQUEsTUFBTXNjLFNBQVM7ZUFDVjtBQUNMeUYsc0JBQVk7QUFDWi9oQixVQUFBQSxLQUFJLEtBQUt1Rjs7O2VBR0p6RyxhQUFhLFNBQVM7QUFDL0IsVUFBSTBlLFFBQVE7QUFDVnhkLFFBQUFBLEtBQUksS0FBS3VGLE9BQU8wQztBQUVoQixZQUFJMlosZUFBZSxRQUFRO0FBQ3pCRyxzQkFBWTttQkFDSEgsZUFBZSxVQUFVO0FBQ2xDRyxzQkFBWTtBQUNaL2hCLFVBQUFBLE1BQU1zYyxTQUFTO2VBQ1Y7QUFDTHlGLHNCQUFZO0FBQ1ovaEIsVUFBQUEsTUFBS3NjOzthQUVGO0FBQ0x0YyxRQUFBQSxLQUFJLEtBQUt1RixPQUFPc2M7QUFFaEIsWUFBSUQsZUFBZSxRQUFRO0FBQ3pCRyxzQkFBWTttQkFDSEgsZUFBZSxVQUFVO0FBQ2xDRyxzQkFBWTtBQUNaL2hCLFVBQUFBLE1BQUtzYyxTQUFTO2VBQ1Q7QUFDTHlGLHNCQUFZO0FBQ1ovaEIsVUFBQUEsS0FBSSxLQUFLd0Y7OztXQUdSO0FBQ0x1YyxrQkFBWTs7QUFHZCxXQUFPO01BQUNBO01BQVcvaEIsR0FBQUE7SUFBQztFQUN0QjtFQUtBa2pCLG9CQUFvQjtBQUNsQixRQUFJLEtBQUsxbkIsUUFBUXlWLE1BQU11TSxRQUFRO0FBQzdCOztBQUdGLFVBQU0zZSxRQUFRLEtBQUtBO0FBQ25CLFVBQU1DLFdBQVcsS0FBS3RELFFBQVFzRDtBQUU5QixRQUFJQSxhQUFhLFVBQVVBLGFBQWEsU0FBUztBQUMvQyxhQUFPO1FBQUMyRyxLQUFLO1FBQUdGLE1BQU0sS0FBS0E7UUFBTUcsUUFBUTdHLE1BQU11RztRQUFRSSxPQUFPLEtBQUtBO01BQUs7O0FBQ3hFLFFBQUkxRyxhQUFhLFNBQVNBLGFBQWEsVUFBVTtBQUNqRCxhQUFPO1FBQUMyRyxLQUFLLEtBQUtBO1FBQUtGLE1BQU07UUFBR0csUUFBUSxLQUFLQTtRQUFRRixPQUFPM0csTUFBTXFHO01BQUs7O0VBRTNFO0VBS0FpZSxpQkFBaUI7QUFDZixVQUFNLEVBQUNqVSxLQUFLMVQsU0FBUyxFQUFDNG5CLGdCQUFBQSxHQUFrQjdkLE1BQU1FLEtBQUtQLE9BQU9FLE9BQU0sSUFBSTtBQUNwRSxRQUFJZ2UsaUJBQWlCO0FBQ25CbFUsVUFBSW1VLEtBQUk7QUFDUm5VLFVBQUlvVSxZQUFZRjtBQUNoQmxVLFVBQUlxVSxTQUFTaGUsTUFBTUUsS0FBS1AsT0FBT0UsTUFBQUE7QUFDL0I4SixVQUFJc1UsUUFBTzs7RUFFZjtFQUVBQyxxQkFBcUIvbUIsT0FBTztBQUMxQixVQUFNZ2dCLE9BQU8sS0FBS2xoQixRQUFRa2hCO0FBQzFCLFFBQUksQ0FBQyxLQUFLUixXQUFVLEtBQU0sQ0FBQ1EsS0FBS3JULFNBQVM7QUFDdkMsYUFBTzs7QUFFVCxVQUFNNEgsUUFBUSxLQUFLQTtBQUNuQixVQUFNN1IsUUFBUTZSLE1BQU1sVCxVQUFVMmxCLENBQUFBLE9BQUtBLEdBQUVobkIsVUFBVUEsS0FBQUE7QUFDL0MsUUFBSTBDLFNBQVMsR0FBRztBQUNkLFlBQU11a0IsT0FBT2pILEtBQUsxRSxXQUFXLEtBQUt4TixXQUFXcEwsS0FBQUEsQ0FBQUE7QUFDN0MsYUFBT3VrQixLQUFLekM7O0FBRWQsV0FBTztFQUNUO0VBS0EwQyxTQUFTL2lCLFdBQVc7QUFDbEIsVUFBTTZiLE9BQU8sS0FBS2xoQixRQUFRa2hCO0FBQzFCLFVBQU14TixNQUFNLEtBQUtBO0FBQ2pCLFVBQU0xTyxRQUFRLEtBQUsyVyxtQkFBbUIsS0FBS0EsaUJBQWlCLEtBQUswSSxzQkFBc0JoZixTQUFTO0FBQ2hHLFFBQUkzQixJQUFHQztBQUVQLFVBQU0wa0IsV0FBVyxDQUFDQyxJQUFJQyxJQUFJeFksVUFBVTtBQUNsQyxVQUFJLENBQUNBLE1BQU1yRyxTQUFTLENBQUNxRyxNQUFNNlYsT0FBTztBQUNoQzs7QUFFRmxTLFVBQUltVSxLQUFJO0FBQ1JuVSxVQUFJZ1MsWUFBWTNWLE1BQU1yRztBQUN0QmdLLFVBQUk4VSxjQUFjelksTUFBTTZWO0FBQ3hCbFMsVUFBSStVLFlBQVkxWSxNQUFNOFYsY0FBYyxDQUFBLENBQUU7QUFDdENuUyxVQUFJZ1YsaUJBQWlCM1ksTUFBTWdXO0FBRTNCclMsVUFBSWlWLFVBQVM7QUFDYmpWLFVBQUlrVixPQUFPTixHQUFHOWpCLEdBQUc4akIsR0FBRzVqQixDQUFDO0FBQ3JCZ1AsVUFBSW1WLE9BQU9OLEdBQUcvakIsR0FBRytqQixHQUFHN2pCLENBQUM7QUFDckJnUCxVQUFJb1YsT0FBTTtBQUNWcFYsVUFBSXNVLFFBQU87SUFDYjtBQUVBLFFBQUk5RyxLQUFLclQsU0FBUztBQUNoQixXQUFLbkssS0FBSSxHQUFHQyxPQUFPcUIsTUFBTXJELFFBQVErQixLQUFJQyxNQUFNLEVBQUVELElBQUc7QUFDOUMsY0FBTWtKLE9BQU81SCxNQUFNdEIsRUFBRTtBQUVyQixZQUFJd2QsS0FBSzZILGlCQUFpQjtBQUN4QlYsbUJBQ0U7WUFBQzdqQixHQUFHb0ksS0FBS3NZO1lBQUl4Z0IsR0FBR2tJLEtBQUt1WTthQUNyQjtZQUFDM2dCLEdBQUdvSSxLQUFLd1k7WUFBSTFnQixHQUFHa0ksS0FBS3lZO2FBQ3JCelksSUFBQUE7O0FBSUosWUFBSXNVLEtBQUs1SCxXQUFXO0FBQ2xCK08sbUJBQ0U7WUFBQzdqQixHQUFHb0ksS0FBS2tZO1lBQUtwZ0IsR0FBR2tJLEtBQUttWTthQUN0QjtZQUFDdmdCLEdBQUdvSSxLQUFLb1k7WUFBS3RnQixHQUFHa0ksS0FBS3FZO2FBQ3RCO1lBQ0VXLE9BQU9oWixLQUFLcVo7WUFDWnZjLE9BQU9rRCxLQUFLNFQ7WUFDWnFGLFlBQVlqWixLQUFLc1o7WUFDakJILGtCQUFrQm5aLEtBQUt1WjtVQUN6QixDQUFBOztNQUdOOztFQUVKO0VBS0E2QyxhQUFhO0FBQ1gsVUFBTSxFQUFDM2xCLE9BQU9xUSxLQUFLMVQsU0FBUyxFQUFDc2tCLFFBQVFwRCxLQUFJLEVBQUMsSUFBSTtBQUM5QyxVQUFNc0QsYUFBYUYsT0FBTzlILFdBQVcsS0FBS3hOLFdBQVUsQ0FBQTtBQUNwRCxVQUFNeVYsWUFBWUgsT0FBT3pXLFVBQVUyVyxXQUFXOWEsUUFBUTtBQUN0RCxRQUFJLENBQUMrYSxXQUFXO0FBQ2Q7O0FBRUYsVUFBTXdFLGdCQUFnQi9ILEtBQUsxRSxXQUFXLEtBQUt4TixXQUFXLENBQUEsQ0FBQSxFQUFJMFc7QUFDMUQsVUFBTWQsY0FBYyxLQUFLeEk7QUFDekIsUUFBSThJLElBQUlFLElBQUlELElBQUlFO0FBRWhCLFFBQUksS0FBSzVjLGFBQVksR0FBSTtBQUN2QnljLFdBQUtwQixZQUFZemdCLE9BQU8sS0FBSzBHLE1BQU0wYSxTQUFBQSxJQUFhQSxZQUFZO0FBQzVEVyxXQUFLdEIsWUFBWXpnQixPQUFPLEtBQUsyRyxPQUFPaWYsYUFBQUEsSUFBaUJBLGdCQUFnQjtBQUNyRTlELFdBQUtFLEtBQUtUO1dBQ0w7QUFDTE8sV0FBS3JCLFlBQVl6Z0IsT0FBTyxLQUFLNEcsS0FBS3dhLFNBQUFBLElBQWFBLFlBQVk7QUFDM0RZLFdBQUt2QixZQUFZemdCLE9BQU8sS0FBSzZHLFFBQVErZSxhQUFBQSxJQUFpQkEsZ0JBQWdCO0FBQ3RFL0QsV0FBS0UsS0FBS1I7O0FBRVpsUixRQUFJbVUsS0FBSTtBQUNSblUsUUFBSWdTLFlBQVlsQixXQUFXOWE7QUFDM0JnSyxRQUFJOFUsY0FBY2hFLFdBQVdvQjtBQUU3QmxTLFFBQUlpVixVQUFTO0FBQ2JqVixRQUFJa1YsT0FBTzFELElBQUlDLEVBQUFBO0FBQ2Z6UixRQUFJbVYsT0FBT3pELElBQUlDLEVBQUFBO0FBQ2YzUixRQUFJb1YsT0FBTTtBQUVWcFYsUUFBSXNVLFFBQU87RUFDYjtFQUtBa0IsV0FBVzdqQixXQUFXO0FBQ3BCLFVBQU02ZSxjQUFjLEtBQUtsa0IsUUFBUXlWO0FBRWpDLFFBQUksQ0FBQ3lPLFlBQVlyVyxTQUFTO0FBQ3hCOztBQUdGLFVBQU02RixNQUFNLEtBQUtBO0FBRWpCLFVBQU15VixPQUFPLEtBQUt6QixrQkFBaUI7QUFDbkMsUUFBSXlCLE1BQU07QUFDUkMsZUFBUzFWLEtBQUt5VixJQUFBQTs7QUFHaEIsVUFBTW5rQixRQUFRLEtBQUsyWSxjQUFjdFksU0FBQUE7QUFDakMsZUFBV3VILFFBQVE1SCxPQUFPO0FBQ3hCLFlBQU1xa0Isb0JBQW9CemMsS0FBSzVNO0FBQy9CLFlBQU0raUIsV0FBV25XLEtBQUs2TTtBQUN0QixZQUFNeUcsUUFBUXRULEtBQUtzVDtBQUNuQixZQUFNeGIsS0FBSWtJLEtBQUs2WjtBQUNmNkMsaUJBQVc1VixLQUFLd00sT0FBTyxHQUFHeGIsSUFBR3FlLFVBQVVzRyxpQkFBQUE7SUFDekM7QUFFQSxRQUFJRixNQUFNO0FBQ1JJLGlCQUFXN1YsR0FBQUE7O0VBRWY7RUFLQThWLFlBQVk7QUFDVixVQUFNLEVBQUM5VixLQUFLMVQsU0FBUyxFQUFDc0QsVUFBVTZkLE9BQU83ZSxRQUFPLEVBQUMsSUFBSTtBQUVuRCxRQUFJLENBQUM2ZSxNQUFNdFQsU0FBUztBQUNsQjs7QUFHRixVQUFNNEwsT0FBT0MsT0FBT3lILE1BQU0xSCxJQUFJO0FBQzlCLFVBQU1oTixVQUFVWSxVQUFVOFQsTUFBTTFVLE9BQU87QUFDdkMsVUFBTXVMLFFBQVFtSixNQUFNbko7QUFDcEIsUUFBSW5CLFNBQVM0QyxLQUFLSyxhQUFhO0FBRS9CLFFBQUl4VyxhQUFhLFlBQVlBLGFBQWEsWUFBWXdILFNBQVN4SCxRQUFXLEdBQUE7QUFDeEV1VCxnQkFBVXBLLFFBQVF2QztBQUNsQixVQUFJMFAsUUFBUXVILE1BQU10SCxJQUFJLEdBQUc7QUFDdkJoRCxrQkFBVTRDLEtBQUtLLGNBQWNxSCxNQUFNdEgsS0FBS2xZLFNBQVM7O1dBRTlDO0FBQ0xrVixnQkFBVXBLLFFBQVF4Qzs7QUFHcEIsVUFBTSxFQUFDeVEsUUFBUUMsUUFBUUYsVUFBVUQsU0FBUSxJQUFJRixVQUFVLE1BQU16RCxRQUFRdlQsVUFBVTBVLEtBQUFBO0FBRS9Fc1IsZUFBVzVWLEtBQUt5TixNQUFNdEgsTUFBTSxHQUFHLEdBQUdKLE1BQU07TUFDdENtTSxPQUFPekUsTUFBTXlFO01BQ2JuTDtNQUNBRDtNQUNBK0wsV0FBV25NLFdBQVdwQyxPQUFPMVUsVUFBVWhCLE9BQUFBO01BQ3ZDb2tCLGNBQWM7TUFDZGUsYUFBYTtRQUFDL007UUFBUUM7TUFBTztJQUMvQixDQUFBO0VBQ0Y7RUFFQTVOLEtBQUsxSCxXQUFXO0FBQ2QsUUFBSSxDQUFDLEtBQUtxYixXQUFVLEdBQUk7QUFDdEI7O0FBR0YsU0FBS2lILGVBQWM7QUFDbkIsU0FBS1MsU0FBUy9pQixTQUFBQTtBQUNkLFNBQUsyakIsV0FBVTtBQUNmLFNBQUtRLFVBQVM7QUFDZCxTQUFLTixXQUFXN2pCLFNBQUFBO0VBQ2xCO0VBTUF3SCxVQUFVO0FBQ1IsVUFBTXNiLE9BQU8sS0FBS25vQjtBQUNsQixVQUFNeXBCLEtBQUt0QixLQUFLMVMsU0FBUzBTLEtBQUsxUyxNQUFNM0ksS0FBSztBQUN6QyxVQUFNNGMsS0FBSzlSLGVBQWV1USxLQUFLakgsUUFBUWlILEtBQUtqSCxLQUFLcFUsR0FBRyxFQUFDO0FBQ3JELFVBQU02YyxLQUFLL1IsZUFBZXVRLEtBQUs3RCxVQUFVNkQsS0FBSzdELE9BQU94WCxHQUFHLENBQUE7QUFFeEQsUUFBSSxDQUFDLEtBQUs0VCxXQUFVLEtBQU0sS0FBSzNULFNBQVNpTyxPQUFNM2EsVUFBVTBNLE1BQU07QUFFNUQsYUFBTztRQUFDO1VBQ05ELEdBQUcyYztVQUNIMWMsTUFBTSxDQUFDMUgsY0FBYztBQUNuQixpQkFBSzBILEtBQUsxSCxTQUFBQTtVQUNaO1FBQ0Y7TUFBRTs7QUFHSixXQUFPO01BQUM7UUFDTnlILEdBQUc0YztRQUNIM2MsTUFBTSxDQUFDMUgsY0FBYztBQUNuQixlQUFLc2lCLGVBQWM7QUFDbkIsZUFBS1MsU0FBUy9pQixTQUFBQTtBQUNkLGVBQUtta0IsVUFBUztRQUNoQjtNQUNGO01BQUc7UUFDRDFjLEdBQUc2YztRQUNINWMsTUFBTSxNQUFNO0FBQ1YsZUFBS2ljLFdBQVU7UUFDakI7TUFDRjtNQUFHO1FBQ0RsYyxHQUFHMmM7UUFDSDFjLE1BQU0sQ0FBQzFILGNBQWM7QUFDbkIsZUFBSzZqQixXQUFXN2pCLFNBQUFBO1FBQ2xCO01BQ0Y7SUFBRTtFQUNKO0VBT0FnWSx3QkFBd0IvTyxNQUFNO0FBQzVCLFVBQU04TyxRQUFRLEtBQUsvWixNQUFNSSw2QkFBNEI7QUFDckQsVUFBTW1tQixTQUFTLEtBQUszb0IsT0FBTztBQUMzQixVQUFNZSxTQUFTLENBQUE7QUFDZixRQUFJMEIsSUFBR0M7QUFFUCxTQUFLRCxLQUFJLEdBQUdDLE9BQU95WixNQUFNemIsUUFBUStCLEtBQUlDLE1BQU0sRUFBRUQsSUFBRztBQUM5QyxZQUFNdUQsT0FBT21XLE1BQU0xWixFQUFFO0FBQ3JCLFVBQUl1RCxLQUFLMmlCLE1BQU8sTUFBSyxLQUFLMU8sT0FBTyxDQUFDNU0sUUFBUXJILEtBQUtxSCxTQUFTQSxPQUFPO0FBQzdEdE0sZUFBT3VELEtBQUswQixJQUFBQTs7SUFFaEI7QUFDQSxXQUFPakY7RUFDVDtFQU9Ba2hCLHdCQUF3QnRmLE9BQU87QUFDN0IsVUFBTXVrQixPQUFPLEtBQUtub0IsUUFBUXlWLE1BQU0rRyxXQUFXLEtBQUt4TixXQUFXcEwsS0FBQUEsQ0FBQUE7QUFDM0QsV0FBTzhWLE9BQU95TyxLQUFLMU8sSUFBSTtFQUN6QjtFQUtBb1EsYUFBYTtBQUNYLFVBQU1DLFdBQVcsS0FBSzVHLHdCQUF3QixDQUFBLEVBQUdwSjtBQUNqRCxZQUFRLEtBQUtyUixhQUFZLElBQUssS0FBS2lCLFFBQVEsS0FBS0UsVUFBVWtnQjtFQUM1RDtBQUNGO0FDdHFEZSxJQUFNQyxnQkFBTixNQUFNQTtFQUNuQmhxQixZQUFZdU8sTUFBTTBiLE9BQU8vcEIsVUFBVTtBQUNqQyxTQUFLcU8sT0FBT0E7QUFDWixTQUFLMGIsUUFBUUE7QUFDYixTQUFLL3BCLFdBQVdBO0FBQ2hCLFNBQUsrRSxRQUFRN0UsdUJBQU84cEIsT0FBTyxJQUFJO0VBQ2pDO0VBRUFDLFVBQVU1YixNQUFNO0FBQ2QsV0FBT25PLE9BQU9FLFVBQVU4cEIsY0FBY3JNLEtBQUssS0FBS3hQLEtBQUtqTyxXQUFXaU8sS0FBS2pPLFNBQVM7RUFDaEY7RUFNQStwQixTQUFTeGQsTUFBTTtBQUNiLFVBQU15ZCxRQUFRbHFCLE9BQU9tcUIsZUFBZTFkLElBQUFBO0FBQ3BDLFFBQUkyZDtBQUVKLFFBQUlDLGtCQUFrQkgsS0FBUSxHQUFBO0FBRTVCRSxvQkFBYyxLQUFLSCxTQUFTQyxLQUFBQTs7QUFHOUIsVUFBTXJsQixRQUFRLEtBQUtBO0FBQ25CLFVBQU1rVyxLQUFLdE8sS0FBS3NPO0FBQ2hCLFVBQU04TyxRQUFRLEtBQUtBLFFBQVEsTUFBTTlPO0FBRWpDLFFBQUksQ0FBQ0EsSUFBSTtBQUNQLFlBQU0sSUFBSXJiLE1BQU0sNkJBQTZCK00sSUFBTTs7QUFHckQsUUFBSXNPLE1BQU1sVyxPQUFPO0FBRWYsYUFBT2dsQjs7QUFHVGhsQixVQUFNa1csRUFBQUEsSUFBTXRPO0FBQ1o2ZCxxQkFBaUI3ZCxNQUFNb2QsT0FBT08sV0FBQUE7QUFDOUIsUUFBSSxLQUFLdHFCLFVBQVU7QUFDakJvVixNQUFBQSxVQUFTcFYsU0FBUzJNLEtBQUtzTyxJQUFJdE8sS0FBSzhkLFNBQVM7O0FBRzNDLFdBQU9WO0VBQ1Q7RUFNQVcsSUFBSXpQLElBQUk7QUFDTixXQUFPLEtBQUtsVyxNQUFNa1csRUFBRztFQUN2QjtFQUtBMFAsV0FBV2hlLE1BQU07QUFDZixVQUFNNUgsUUFBUSxLQUFLQTtBQUNuQixVQUFNa1csS0FBS3RPLEtBQUtzTztBQUNoQixVQUFNOE8sUUFBUSxLQUFLQTtBQUVuQixRQUFJOU8sTUFBTWxXLE9BQU87QUFDZixhQUFPQSxNQUFNa1csRUFBRzs7QUFHbEIsUUFBSThPLFNBQVM5TyxNQUFNN0YsVUFBUzJVLEtBQUFBLEdBQVE7QUFDbEMsYUFBTzNVLFVBQVMyVSxLQUFNLEVBQUM5TyxFQUFHO0FBQzFCLFVBQUksS0FBS2piLFVBQVU7QUFDakIsZUFBT3lxQixVQUFVeFAsRUFBRzs7O0VBRzFCO0FBQ0Y7QUFFQSxTQUFTdVAsaUJBQWlCN2QsTUFBTW9kLE9BQU9PLGFBQWE7QUFFbEQsUUFBTU0sZUFBZUMsTUFBTTNxQix1QkFBTzhwQixPQUFPLElBQUksR0FBRztJQUM5Q00sY0FBY2xWLFVBQVNzVixJQUFJSixXQUFBQSxJQUFlLENBQUE7SUFDMUNsVixVQUFTc1YsSUFBSVgsS0FBQUE7SUFDYnBkLEtBQUt5STtFQUNOLENBQUE7QUFFREEsRUFBQUEsVUFBU3pDLElBQUlvWCxPQUFPYSxZQUFBQTtBQUVwQixNQUFJamUsS0FBSzBJLGVBQWU7QUFDdEJ5VixrQkFBY2YsT0FBT3BkLEtBQUswSSxhQUFhOztBQUd6QyxNQUFJMUksS0FBS29lLGFBQWE7QUFDcEIzVixJQUFBQSxVQUFTNFYsU0FBU2pCLE9BQU9wZCxLQUFLb2UsV0FBVzs7QUFFN0M7QUFFQSxTQUFTRCxjQUFjZixPQUFPa0IsUUFBUTtBQUNwQy9xQixTQUFPNFQsS0FBS21YLE1BQUFBLEVBQVFsa0IsUUFBUW1rQixDQUFBQSxhQUFZO0FBQ3RDLFVBQU1DLGdCQUFnQkQsU0FBU0UsTUFBTSxHQUFBO0FBQ3JDLFVBQU1DLGFBQWFGLGNBQWNHLElBQUc7QUFDcEMsVUFBTUMsY0FBYztNQUFDeEI7SUFBTSxFQUFDMWYsT0FBTzhnQixhQUFlSyxFQUFBQSxLQUFLLEdBQUE7QUFDdkQsVUFBTUMsUUFBUVIsT0FBT0MsUUFBUyxFQUFDRSxNQUFNLEdBQUE7QUFDckMsVUFBTU0sYUFBYUQsTUFBTUgsSUFBRztBQUM1QixVQUFNSyxjQUFjRixNQUFNRCxLQUFLLEdBQUE7QUFDL0JwVyxJQUFBQSxVQUFTd1csTUFBTUwsYUFBYUYsWUFBWU0sYUFBYUQsVUFBQUE7RUFDdkQsQ0FBQTtBQUNGO0FBRUEsU0FBU25CLGtCQUFrQkgsT0FBTztBQUNoQyxTQUFPLFFBQVFBLFNBQVMsY0FBY0E7QUFDeEM7QUMxR08sSUFBTXlCLFdBQU4sTUFBTUE7RUFDWC9yQixjQUFjO0FBQ1osU0FBS2dzQixjQUFjLElBQUloQyxjQUFjaUMsbUJBQW1CLFlBQVksSUFBSTtBQUN4RSxTQUFLamxCLFdBQVcsSUFBSWdqQixjQUFjclYsU0FBUyxVQUFBO0FBQzNDLFNBQUt1WCxVQUFVLElBQUlsQyxjQUFjNXBCLFFBQVEsU0FBQTtBQUN6QyxTQUFLb2EsU0FBUyxJQUFJd1AsY0FBYy9PLE9BQU8sUUFBQTtBQUd2QyxTQUFLa1IsbUJBQW1CO01BQUMsS0FBS0g7TUFBYSxLQUFLeFI7TUFBUSxLQUFLeFQ7SUFBUztFQUN4RTtFQUtBckcsT0FBT3lyQixNQUFNO0FBQ1gsU0FBS0MsTUFBTSxZQUFZRCxJQUFBQTtFQUN6QjtFQUVBRSxVQUFVRixNQUFNO0FBQ2QsU0FBS0MsTUFBTSxjQUFjRCxJQUFBQTtFQUMzQjtFQUtBRyxrQkFBa0JILE1BQU07QUFDdEIsU0FBS0MsTUFBTSxZQUFZRCxNQUFNLEtBQUtKLFdBQVc7RUFDL0M7RUFLQVEsZUFBZUosTUFBTTtBQUNuQixTQUFLQyxNQUFNLFlBQVlELE1BQU0sS0FBS3BsQixRQUFRO0VBQzVDO0VBS0F5bEIsY0FBY0wsTUFBTTtBQUNsQixTQUFLQyxNQUFNLFlBQVlELE1BQU0sS0FBS0YsT0FBTztFQUMzQztFQUtBUSxhQUFhTixNQUFNO0FBQ2pCLFNBQUtDLE1BQU0sWUFBWUQsTUFBTSxLQUFLNVIsTUFBTTtFQUMxQztFQU1BbVMsY0FBY3hSLElBQUk7QUFDaEIsV0FBTyxLQUFLeVIsS0FBS3pSLElBQUksS0FBSzZRLGFBQWEsWUFBQTtFQUN6QztFQU1BYSxXQUFXMVIsSUFBSTtBQUNiLFdBQU8sS0FBS3lSLEtBQUt6UixJQUFJLEtBQUtuVSxVQUFVLFNBQUE7RUFDdEM7RUFNQThsQixVQUFVM1IsSUFBSTtBQUNaLFdBQU8sS0FBS3lSLEtBQUt6UixJQUFJLEtBQUsrUSxTQUFTLFFBQUE7RUFDckM7RUFNQWEsU0FBUzVSLElBQUk7QUFDWCxXQUFPLEtBQUt5UixLQUFLelIsSUFBSSxLQUFLWCxRQUFRLE9BQUE7RUFDcEM7RUFLQXdTLHFCQUFxQlosTUFBTTtBQUN6QixTQUFLQyxNQUFNLGNBQWNELE1BQU0sS0FBS0osV0FBVztFQUNqRDtFQUtBaUIsa0JBQWtCYixNQUFNO0FBQ3RCLFNBQUtDLE1BQU0sY0FBY0QsTUFBTSxLQUFLcGxCLFFBQVE7RUFDOUM7RUFLQWttQixpQkFBaUJkLE1BQU07QUFDckIsU0FBS0MsTUFBTSxjQUFjRCxNQUFNLEtBQUtGLE9BQU87RUFDN0M7RUFLQWlCLGdCQUFnQmYsTUFBTTtBQUNwQixTQUFLQyxNQUFNLGNBQWNELE1BQU0sS0FBSzVSLE1BQU07RUFDNUM7RUFLQTZSLE1BQU1lLFFBQVFoQixNQUFNaUIsZUFBZTtBQUNqQztNQUFJakIsR0FBQUE7TUFBTW5sQixRQUFRcW1CLENBQUFBLFFBQU87QUFDdkIsWUFBTUMsTUFBTUYsaUJBQWlCLEtBQUtHLG9CQUFvQkYsR0FBQUE7QUFDdEQsVUFBSUQsaUJBQWlCRSxJQUFJcEQsVUFBVW1ELEdBQVNDLEtBQUFBLFFBQVEsS0FBS3JCLFdBQVdvQixJQUFJblMsSUFBSztBQUMzRSxhQUFLc1MsTUFBTUwsUUFBUUcsS0FBS0QsR0FBQUE7YUFDbkI7QUFLTDdmLGFBQUs2ZixLQUFLemdCLENBQUFBLFNBQVE7QUFPaEIsZ0JBQU02Z0IsVUFBVUwsaUJBQWlCLEtBQUtHLG9CQUFvQjNnQixJQUFBQTtBQUMxRCxlQUFLNGdCLE1BQU1MLFFBQVFNLFNBQVM3Z0IsSUFBQUE7UUFDOUIsQ0FBQTs7SUFFSixDQUFBO0VBQ0Y7RUFLQTRnQixNQUFNTCxRQUFRTyxXQUFVQyxXQUFXO0FBQ2pDLFVBQU1DLGNBQWNDLFlBQVlWLE1BQUFBO0FBQ2hDclAsYUFBSzZQLFVBQVUsV0FBV0MsV0FBQUEsR0FBYyxDQUFBLEdBQUlELFNBQUFBO0FBQzVDRCxJQUFBQSxVQUFTUCxNQUFBQSxFQUFRUSxTQUFBQTtBQUNqQjdQLGFBQUs2UCxVQUFVLFVBQVVDLFdBQUFBLEdBQWMsQ0FBQSxHQUFJRCxTQUFBQTtFQUM3QztFQUtBSixvQkFBb0JqZixNQUFNO0FBQ3hCLGFBQVM1SyxLQUFJLEdBQUdBLEtBQUksS0FBS3dvQixpQkFBaUJ2cUIsUUFBUStCLE1BQUs7QUFDckQsWUFBTTRwQixNQUFNLEtBQUtwQixpQkFBaUJ4b0IsRUFBRTtBQUNwQyxVQUFJNHBCLElBQUlwRCxVQUFVNWIsSUFBTyxHQUFBO0FBQ3ZCLGVBQU9nZjs7SUFFWDtBQUVBLFdBQU8sS0FBS3JCO0VBQ2Q7RUFLQVUsS0FBS3pSLElBQUlrUyxlQUFlOWUsTUFBTTtBQUM1QixVQUFNMUIsT0FBT3dnQixjQUFjekMsSUFBSXpQLEVBQUFBO0FBQy9CLFFBQUl0TyxTQUFTMkQsUUFBVztBQUN0QixZQUFNLElBQUkxUSxNQUFNLE1BQU1xYixLQUFLLDJCQUEyQjVNLE9BQU8sR0FBSzs7QUFFcEUsV0FBTzFCO0VBQ1Q7QUFFRjtBQUdBLElBQUEsV0FBK0Isb0JBQUlrZixTQUFXO0FDdEsvQixJQUFNZ0MsZ0JBQU4sTUFBTUE7RUFDbkIvdEIsY0FBYztBQUNaLFNBQUtndUIsUUFBUXhkO0VBQ2Y7RUFZQXlkLE9BQU8zcUIsT0FBTzRxQixNQUFNOUIsTUFBTTVrQixTQUFRO0FBQ2hDLFFBQUkwbUIsU0FBUyxjQUFjO0FBQ3pCLFdBQUtGLFFBQVEsS0FBS0csbUJBQW1CN3FCLE9BQU8sSUFBSTtBQUNoRCxXQUFLOHFCLFFBQVEsS0FBS0osT0FBTzFxQixPQUFPLFNBQUE7O0FBR2xDLFFBQUksS0FBSzBxQixVQUFVeGQsUUFBVztBQUM1Qjs7QUFHRixVQUFNeWEsZUFBY3pqQixVQUFTLEtBQUs2bUIsYUFBYS9xQixLQUFBQSxFQUFPa0UsT0FBT0EsT0FBVSxJQUFBLEtBQUs2bUIsYUFBYS9xQixLQUFNO0FBQy9GLFVBQU1yQixTQUFTLEtBQUttc0IsUUFBUW5ELGNBQWEzbkIsT0FBTzRxQixNQUFNOUIsSUFBQUE7QUFFdEQsUUFBSThCLFNBQVMsZ0JBQWdCO0FBQzNCLFdBQUtFLFFBQVFuRCxjQUFhM25CLE9BQU8sTUFBQTtBQUNqQyxXQUFLOHFCLFFBQVEsS0FBS0osT0FBTzFxQixPQUFPLFdBQUE7QUFDaEMsV0FBSzBxQixRQUFReGQ7O0FBRWYsV0FBT3ZPO0VBQ1Q7RUFLQW1zQixRQUFRbkQsY0FBYTNuQixPQUFPNHFCLE1BQU05QixNQUFNO0FBQ3RDQSxXQUFPQSxRQUFRLENBQUE7QUFDZixlQUFXa0MsY0FBY3JELGNBQWE7QUFDcEMsWUFBTXNELFNBQVNELFdBQVdDO0FBQzFCLFlBQU1uQixTQUFTbUIsT0FBT0wsSUFBSztBQUMzQixZQUFNN2tCLFNBQVM7UUFBQy9GO1FBQU84b0I7UUFBTWtDLFdBQVdydUI7TUFBUTtBQUNoRCxVQUFJdXVCLFNBQWFwQixRQUFRL2pCLFFBQVFrbEIsTUFBQUEsTUFBWSxTQUFTbkMsS0FBS3FDLFlBQVk7QUFDckUsZUFBTzs7SUFFWDtBQUVBLFdBQU87RUFDVDtFQUVBQyxhQUFhO0FBTVgsUUFBSSxDQUFDaHNCLGNBQWMsS0FBSzRaLE1BQU0sR0FBRztBQUMvQixXQUFLcVMsWUFBWSxLQUFLclM7QUFDdEIsV0FBS0EsU0FBUzlMOztFQUVsQjtFQU1BNmQsYUFBYS9xQixPQUFPO0FBQ2xCLFFBQUksS0FBS2daLFFBQVE7QUFDZixhQUFPLEtBQUtBOztBQUdkLFVBQU0yTyxlQUFjLEtBQUszTyxTQUFTLEtBQUs2UixtQkFBbUI3cUIsS0FBQUE7QUFFMUQsU0FBS3NyQixvQkFBb0J0ckIsS0FBQUE7QUFFekIsV0FBTzJuQjtFQUNUO0VBRUFrRCxtQkFBbUI3cUIsT0FBT3VyQixLQUFLO0FBQzdCLFVBQU05ZixTQUFTekwsU0FBU0EsTUFBTXlMO0FBQzlCLFVBQU05TyxVQUFVNFgsZUFBZTlJLE9BQU85TyxXQUFXOE8sT0FBTzlPLFFBQVFpc0IsU0FBUyxDQUFBLENBQUM7QUFDMUUsVUFBTUEsVUFBVTRDLFdBQVcvZixNQUFBQTtBQUUzQixXQUFPOU8sWUFBWSxTQUFTLENBQUM0dUIsTUFBTSxDQUFBLElBQUtFLGtCQUFrQnpyQixPQUFPNG9CLFNBQVNqc0IsU0FBUzR1QixHQUFJO0VBQ3pGO0VBTUFELG9CQUFvQnRyQixPQUFPO0FBQ3pCLFVBQU0wckIsc0JBQXNCLEtBQUtMLGFBQWEsQ0FBQTtBQUM5QyxVQUFNMUQsZUFBYyxLQUFLM087QUFDekIsVUFBTTFiLE9BQU8sQ0FBQ21ILElBQUdDLE9BQU1ELEdBQUVQLE9BQU8vQyxDQUFBQSxPQUFLLENBQUN1RCxHQUFFaW5CLEtBQUt0cUIsQ0FBQUEsT0FBS0YsR0FBRThwQixPQUFPcFQsT0FBT3hXLEdBQUU0cEIsT0FBT3BULEVBQUUsQ0FBQTtBQUM3RSxTQUFLaVQsUUFBUXh0QixLQUFLb3VCLHFCQUFxQi9ELFlBQUFBLEdBQWMzbkIsT0FBTyxNQUFBO0FBQzVELFNBQUs4cUIsUUFBUXh0QixLQUFLcXFCLGNBQWErRCxtQkFBQUEsR0FBc0IxckIsT0FBTyxPQUFBO0VBQzlEO0FBQ0Y7QUFLQSxTQUFTd3JCLFdBQVcvZixRQUFRO0FBQzFCLFFBQU1tZ0IsV0FBVyxDQUFBO0FBQ2pCLFFBQU1oRCxVQUFVLENBQUE7QUFDaEIsUUFBTWxZLE9BQU81VCxPQUFPNFQsS0FBSzJaLFNBQVN6QixRQUFRam5CLEtBQUs7QUFDL0MsV0FBU3RCLEtBQUksR0FBR0EsS0FBSXFRLEtBQUtwUyxRQUFRK0IsTUFBSztBQUNwQ3VvQixZQUFRMW1CLEtBQUttb0IsU0FBU2IsVUFBVTlZLEtBQUtyUSxFQUFFLENBQUEsQ0FBQTtFQUN6QztBQUVBLFFBQU13ckIsUUFBUXBnQixPQUFPbWQsV0FBVyxDQUFBO0FBQ2hDLFdBQVN2b0IsS0FBSSxHQUFHQSxLQUFJd3JCLE1BQU12dEIsUUFBUStCLE1BQUs7QUFDckMsVUFBTTRxQixTQUFTWSxNQUFNeHJCLEVBQUU7QUFFdkIsUUFBSXVvQixRQUFRL25CLFFBQVFvcUIsTUFBQUEsTUFBWSxJQUFJO0FBQ2xDckMsY0FBUTFtQixLQUFLK29CLE1BQUFBO0FBQ2JXLGVBQVNYLE9BQU9wVCxFQUFFLElBQUk7O0VBRTFCO0FBRUEsU0FBTztJQUFDK1E7SUFBU2dEO0VBQVE7QUFDM0I7QUFFQSxTQUFTRSxRQUFRbnZCLFNBQVM0dUIsS0FBSztBQUM3QixNQUFJLENBQUNBLE9BQU81dUIsWUFBWSxPQUFPO0FBQzdCLFdBQU87O0FBRVQsTUFBSUEsWUFBWSxNQUFNO0FBQ3BCLFdBQU8sQ0FBQTs7QUFFVCxTQUFPQTtBQUNUO0FBRUEsU0FBUzh1QixrQkFBa0J6ckIsT0FBTyxFQUFDNG9CLFNBQVNnRCxTQUFRLEdBQUdqdkIsU0FBUzR1QixLQUFLO0FBQ25FLFFBQU01c0IsU0FBUyxDQUFBO0FBQ2YsUUFBTW9NLFVBQVUvSyxNQUFNMkwsV0FBVTtBQUVoQyxhQUFXc2YsVUFBVXJDLFNBQVM7QUFDNUIsVUFBTS9RLEtBQUtvVCxPQUFPcFQ7QUFDbEIsVUFBTWlOLE9BQU9nSCxRQUFRbnZCLFFBQVFrYixFQUFBQSxHQUFLMFQsR0FBQUE7QUFDbEMsUUFBSXpHLFNBQVMsTUFBTTtBQUNqQjs7QUFFRm5tQixXQUFPdUQsS0FBSztNQUNWK29CO01BQ0F0dUIsU0FBU292QixXQUFXL3JCLE1BQU15TCxRQUFRO1FBQUN3ZjtRQUFRWSxPQUFPRCxTQUFTL1QsRUFBRztNQUFBLEdBQUdpTixNQUFNL1osT0FBQUE7SUFDekUsQ0FBQTtFQUNGO0FBRUEsU0FBT3BNO0FBQ1Q7QUFFQSxTQUFTb3RCLFdBQVd0Z0IsUUFBUSxFQUFDd2YsUUFBUVksTUFBSyxHQUFHL0csTUFBTS9aLFNBQVM7QUFDMUQsUUFBTTJGLE9BQU9qRixPQUFPdWdCLGdCQUFnQmYsTUFBQUE7QUFDcEMsUUFBTWdCLFNBQVN4Z0IsT0FBT3lnQixnQkFBZ0JwSCxNQUFNcFUsSUFBQUE7QUFDNUMsTUFBSW1iLFNBQVNaLE9BQU9qWixVQUFVO0FBRTVCaWEsV0FBTy9wQixLQUFLK29CLE9BQU9qWixRQUFROztBQUU3QixTQUFPdkcsT0FBTzBnQixlQUFlRixRQUFRbGhCLFNBQVM7SUFBQztLQUFLO0lBRWxEcWhCLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxTQUFTO0VBQ1gsQ0FBQTtBQUNGO0FDdkxPLFNBQVNDLGFBQWF0aEIsTUFBTXRPLFNBQVM7QUFDMUMsUUFBTTZ2QixrQkFBa0J4YSxVQUFTeWEsU0FBU3hoQixJQUFBQSxLQUFTLENBQUE7QUFDbkQsUUFBTXloQixrQkFBa0IvdkIsUUFBUTh2QixZQUFZLENBQUEsR0FBSXhoQixJQUFLLEtBQUksQ0FBQTtBQUN6RCxTQUFPeWhCLGVBQWVDLGFBQWFod0IsUUFBUWd3QixhQUFhSCxnQkFBZ0JHLGFBQWE7QUFDdkY7QUFFQSxTQUFTQywwQkFBMEIvVSxJQUFJOFUsV0FBVztBQUNoRCxNQUFJL3VCLE9BQU9pYTtBQUNYLE1BQUlBLE9BQU8sV0FBVztBQUNwQmphLFdBQU8rdUI7YUFDRTlVLE9BQU8sV0FBVztBQUMzQmphLFdBQU8rdUIsY0FBYyxNQUFNLE1BQU07O0FBRW5DLFNBQU8vdUI7QUFDVDtBQUVBLFNBQVNpdkIsMEJBQTBCanZCLE1BQU0rdUIsV0FBVztBQUNsRCxTQUFPL3VCLFNBQVMrdUIsWUFBWSxZQUFZO0FBQzFDO0FBRUEsU0FBU0csY0FBY2pWLElBQUk7QUFDekIsTUFBSUEsT0FBTyxPQUFPQSxPQUFPLE9BQU9BLE9BQU8sS0FBSztBQUMxQyxXQUFPQTs7QUFFWDtBQUVBLFNBQVNrVixpQkFBaUI5c0IsVUFBVTtBQUNsQyxNQUFJQSxhQUFhLFNBQVNBLGFBQWEsVUFBVTtBQUMvQyxXQUFPOztBQUVULE1BQUlBLGFBQWEsVUFBVUEsYUFBYSxTQUFTO0FBQy9DLFdBQU87O0FBRVg7QUFFTyxTQUFTK3NCLGNBQWNuVixPQUFPb1YsY0FBYztBQUNqRCxNQUFJSCxjQUFjalYsRUFBSyxHQUFBO0FBQ3JCLFdBQU9BOztBQUVULGFBQVdpTixRQUFRbUksY0FBYztBQUMvQixVQUFNcnZCLE9BQU9rbkIsS0FBS2xuQixRQUNibXZCLGlCQUFpQmpJLEtBQUs3a0IsUUFBUSxLQUM5QjRYLEdBQUd2WixTQUFTLEtBQUt3dUIsY0FBY2pWLEdBQUcsQ0FBQSxFQUFHcVYsWUFBVyxDQUFBO0FBQ3JELFFBQUl0dkIsTUFBTTtBQUNSLGFBQU9BOztFQUVYO0FBQ0EsUUFBTSxJQUFJcEIsTUFBTSw2QkFBNkJxYixFQUFHLHFEQUFvRDtBQUN0RztBQUVBLFNBQVNzVixtQkFBbUJ0VixJQUFJamEsTUFBTVMsU0FBUztBQUM3QyxNQUFJQSxRQUFRVCxPQUFPLFFBQUEsTUFBY2lhLElBQUk7QUFDbkMsV0FBTztNQUFDamE7SUFBSTs7QUFFaEI7QUFFQSxTQUFTd3ZCLHlCQUF5QnZWLElBQUlwTSxRQUFRO0FBQzVDLE1BQUlBLE9BQU96TixRQUFReU4sT0FBT3pOLEtBQUt5dUIsVUFBVTtBQUN2QyxVQUFNWSxVQUFVNWhCLE9BQU96TixLQUFLeXVCLFNBQVN2b0IsT0FBTyxDQUFDb3BCLE9BQU1BLEdBQUVDLFlBQVkxVixNQUFNeVYsR0FBRUUsWUFBWTNWLEVBQUFBO0FBQ3JGLFFBQUl3VixRQUFRL3VCLFFBQVE7QUFDbEIsYUFBTzZ1QixtQkFBbUJ0VixJQUFJLEtBQUt3VixRQUFRLENBQUEsQ0FBRSxLQUFLRixtQkFBbUJ0VixJQUFJLEtBQUt3VixRQUFRLENBQUUsQ0FBQTs7O0FBRzVGLFNBQU8sQ0FBQTtBQUNUO0FBRUEsU0FBU0ksaUJBQWlCaGlCLFFBQVE5TyxTQUFTO0FBQ3pDLFFBQU0rd0IsZ0JBQWdCckcsVUFBVTViLE9BQU9SLElBQUksS0FBSztJQUFDaU0sUUFBUSxDQUFBO0VBQUU7QUFDM0QsUUFBTXlXLGVBQWVoeEIsUUFBUXVhLFVBQVUsQ0FBQTtBQUN2QyxRQUFNMFcsaUJBQWlCckIsYUFBYTlnQixPQUFPUixNQUFNdE8sT0FBQUE7QUFDakQsUUFBTXVhLFNBQVNwYSx1QkFBTzhwQixPQUFPLElBQUk7QUFHakM5cEIsU0FBTzRULEtBQUtpZCxZQUFBQSxFQUFjaHFCLFFBQVFrVSxDQUFBQSxPQUFNO0FBQ3RDLFVBQU1nVyxZQUFZRixhQUFhOVYsRUFBRztBQUNsQyxRQUFJLENBQUNwUSxTQUFTb21CLFNBQVksR0FBQTtBQUN4QixhQUFPQyxRQUFRQyxNQUFNLDBDQUEwQ2xXLEVBQUFBLEVBQUk7O0FBRXJFLFFBQUlnVyxVQUFVRyxRQUFRO0FBQ3BCLGFBQU9GLFFBQVFHLEtBQUssa0RBQWtEcFcsRUFBQUEsRUFBSTs7QUFFNUUsVUFBTWphLE9BQU9vdkIsY0FBY25WLElBQUlnVyxXQUFXVCx5QkFBeUJ2VixJQUFJcE0sTUFBU3VHLEdBQUFBLFVBQVNrRixPQUFPMlcsVUFBVTVpQixJQUFJLENBQUM7QUFDL0csVUFBTWlqQixZQUFZckIsMEJBQTBCanZCLE1BQU1nd0IsY0FBQUE7QUFDbEQsVUFBTU8sc0JBQXNCVCxjQUFjeFcsVUFBVSxDQUFBO0FBQ3BEQSxXQUFPVyxFQUFBQSxJQUFNdVcsUUFBUXR4Qix1QkFBTzhwQixPQUFPLElBQUksR0FBRztNQUFDO1FBQUNocEI7TUFBSTtNQUFHaXdCO01BQVdNLG9CQUFvQnZ3QixJQUFLO01BQUV1d0Isb0JBQW9CRCxTQUFVO0lBQUMsQ0FBQTtFQUMxSCxDQUFBO0FBR0F6aUIsU0FBT3pOLEtBQUt5dUIsU0FBUzlvQixRQUFRdEYsQ0FBQUEsWUFBVztBQUN0QyxVQUFNNE0sT0FBTzVNLFFBQVE0TSxRQUFRUSxPQUFPUjtBQUNwQyxVQUFNMGhCLFlBQVl0dUIsUUFBUXN1QixhQUFhSixhQUFhdGhCLE1BQU10TyxPQUFBQTtBQUMxRCxVQUFNNnZCLGtCQUFrQm5GLFVBQVVwYyxJQUFBQSxLQUFTLENBQUE7QUFDM0MsVUFBTWtqQixzQkFBc0IzQixnQkFBZ0J0VixVQUFVLENBQUE7QUFDdERwYSxXQUFPNFQsS0FBS3lkLG1CQUFBQSxFQUFxQnhxQixRQUFRMHFCLENBQUFBLGNBQWE7QUFDcEQsWUFBTXp3QixPQUFPZ3ZCLDBCQUEwQnlCLFdBQVcxQixTQUFBQTtBQUNsRCxZQUFNOVUsS0FBS3haLFFBQVFULE9BQU8sUUFBQSxLQUFhQTtBQUN2Q3NaLGFBQU9XLEVBQUcsSUFBR1gsT0FBT1csRUFBQUEsS0FBTy9hLHVCQUFPOHBCLE9BQU8sSUFBSTtBQUM3Q3dILGNBQVFsWCxPQUFPVyxFQUFBQSxHQUFLO1FBQUM7VUFBQ2phO1FBQUk7UUFBRyt2QixhQUFhOVYsRUFBRztRQUFFc1csb0JBQW9CRSxTQUFVO01BQUMsQ0FBQTtJQUNoRixDQUFBO0VBQ0YsQ0FBQTtBQUdBdnhCLFNBQU80VCxLQUFLd0csTUFBQUEsRUFBUXZULFFBQVFnTixDQUFBQSxRQUFPO0FBQ2pDLFVBQU13QixRQUFRK0UsT0FBT3ZHLEdBQUk7QUFDekJ5ZCxZQUFRamMsT0FBTztNQUFDSCxVQUFTa0YsT0FBTy9FLE1BQU1sSCxJQUFJO01BQUcrRyxVQUFTRztJQUFNLENBQUE7RUFDOUQsQ0FBQTtBQUVBLFNBQU8rRTtBQUNUO0FBRUEsU0FBU29YLFlBQVk3aUIsUUFBUTtBQUMzQixRQUFNOU8sVUFBVThPLE9BQU85TyxZQUFZOE8sT0FBTzlPLFVBQVUsQ0FBQTtBQUVwREEsVUFBUWlzQixVQUFVclUsZUFBZTVYLFFBQVFpc0IsU0FBUyxDQUFBLENBQUM7QUFDbkRqc0IsVUFBUXVhLFNBQVN1VyxpQkFBaUJoaUIsUUFBUTlPLE9BQUFBO0FBQzVDO0FBRUEsU0FBUzR4QixTQUFTdndCLE1BQU07QUFDdEJBLFNBQU9BLFFBQVEsQ0FBQTtBQUNmQSxPQUFLeXVCLFdBQVd6dUIsS0FBS3l1QixZQUFZLENBQUE7QUFDakN6dUIsT0FBS21jLFNBQVNuYyxLQUFLbWMsVUFBVSxDQUFBO0FBQzdCLFNBQU9uYztBQUNUO0FBRUEsU0FBU3d3QixXQUFXL2lCLFFBQVE7QUFDMUJBLFdBQVNBLFVBQVUsQ0FBQTtBQUNuQkEsU0FBT3pOLE9BQU91d0IsU0FBUzlpQixPQUFPek4sSUFBSTtBQUVsQ3N3QixjQUFZN2lCLE1BQUFBO0FBRVosU0FBT0E7QUFDVDtBQUVBLElBQU1nakIsV0FBVyxvQkFBSTNmLElBQUFBO0FBQ3JCLElBQU00ZixhQUFhLG9CQUFJQyxJQUFBQTtBQUV2QixTQUFTQyxXQUFXQyxVQUFVQyxVQUFVO0FBQ3RDLE1BQUlwZSxPQUFPK2QsU0FBU25ILElBQUl1SCxRQUFBQTtBQUN4QixNQUFJLENBQUNuZSxNQUFNO0FBQ1RBLFdBQU9vZSxTQUFBQTtBQUNQTCxhQUFTbGYsSUFBSXNmLFVBQVVuZSxJQUFBQTtBQUN2QmdlLGVBQVdyeEIsSUFBSXFULElBQUFBOztBQUVqQixTQUFPQTtBQUNUO0FBRUEsSUFBTXFlLGFBQWEsQ0FBQ3hmLE1BQUt5ZixLQUFLcmUsUUFBUTtBQUNwQyxRQUFNbVUsT0FBT21LLGlCQUFpQkQsS0FBS3JlLEdBQUFBO0FBQ25DLE1BQUltVSxTQUFTNVgsUUFBVztBQUN0QnFDLElBQUFBLEtBQUlsUyxJQUFJeW5CLElBQUFBOztBQUVaO0FBRWUsSUFBTW9LLFNBQU4sTUFBTUE7RUFDbkJ4eUIsWUFBWStPLFFBQVE7QUFDbEIsU0FBSzBqQixVQUFVWCxXQUFXL2lCLE1BQUFBO0FBQzFCLFNBQUsyakIsY0FBYyxvQkFBSXRnQixJQUFBQTtBQUN2QixTQUFLdWdCLGlCQUFpQixvQkFBSXZnQixJQUFBQTtFQUM1QjtFQUVBLElBQUl3Z0IsV0FBVztBQUNiLFdBQU8sS0FBS0gsUUFBUUc7RUFDdEI7RUFFQSxJQUFJcmtCLE9BQU87QUFDVCxXQUFPLEtBQUtra0IsUUFBUWxrQjtFQUN0QjtFQUVBLElBQUlBLEtBQUtBLE1BQU07QUFDYixTQUFLa2tCLFFBQVFsa0IsT0FBT0E7RUFDdEI7RUFFQSxJQUFJak4sT0FBTztBQUNULFdBQU8sS0FBS214QixRQUFRbnhCO0VBQ3RCO0VBRUEsSUFBSUEsS0FBS0EsTUFBTTtBQUNiLFNBQUtteEIsUUFBUW54QixPQUFPdXdCLFNBQVN2d0IsSUFBQUE7RUFDL0I7RUFFQSxJQUFJckIsVUFBVTtBQUNaLFdBQU8sS0FBS3d5QixRQUFReHlCO0VBQ3RCO0VBRUEsSUFBSUEsUUFBUUEsU0FBUztBQUNuQixTQUFLd3lCLFFBQVF4eUIsVUFBVUE7RUFDekI7RUFFQSxJQUFJaXNCLFVBQVU7QUFDWixXQUFPLEtBQUt1RyxRQUFRdkc7RUFDdEI7RUFFQTVmLFNBQVM7QUFDUCxVQUFNeUMsU0FBUyxLQUFLMGpCO0FBQ3BCLFNBQUtJLFdBQVU7QUFDZmpCLGdCQUFZN2lCLE1BQUFBO0VBQ2Q7RUFFQThqQixhQUFhO0FBQ1gsU0FBS0gsWUFBWUksTUFBSztBQUN0QixTQUFLSCxlQUFlRyxNQUFLO0VBQzNCO0VBUUFDLGlCQUFpQkMsYUFBYTtBQUM1QixXQUFPZCxXQUFXYyxhQUNoQixNQUFNO01BQUM7UUFDTCxZQUFZQSxXQUFBQTtRQUNaO01BQ0Q7SUFBQyxDQUFBO0VBQ047RUFTQUMsMEJBQTBCRCxhQUFhRSxZQUFZO0FBQ2pELFdBQU9oQixXQUFXLEdBQUdjLFdBQUFBLGVBQTBCRSxVQUFBQSxJQUM3QyxNQUFNO01BQ0o7UUFDRSxZQUFZRixXQUFBQSxnQkFBMkJFLFVBQUFBO1FBQ3ZDLGVBQWVBLFVBQUFBO01BQ2hCO01BRUQ7UUFDRSxZQUFZRixXQUFBQTtRQUNaO01BQ0Q7SUFDRixDQUFBO0VBQ0w7RUFVQUcsd0JBQXdCSCxhQUFhSSxhQUFhO0FBQ2hELFdBQU9sQixXQUFXLEdBQUdjLFdBQUFBLElBQWVJLFdBQUFBLElBQ2xDLE1BQU07TUFBQztRQUNMLFlBQVlKLFdBQUFBLGFBQXdCSSxXQUFBQTtRQUNwQyxZQUFZSixXQUFBQTtRQUNaLFlBQVlJLFdBQUFBO1FBQ1o7TUFDRDtJQUFDLENBQUE7RUFDTjtFQU9BOUQsZ0JBQWdCZixRQUFRO0FBQ3RCLFVBQU1wVCxLQUFLb1QsT0FBT3BUO0FBQ2xCLFVBQU01TSxPQUFPLEtBQUtBO0FBQ2xCLFdBQU8yakIsV0FBVyxHQUFHM2pCLElBQUFBLFdBQWU0TSxFQUFBQSxJQUNsQyxNQUFNO01BQUM7UUFDTCxXQUFXQSxFQUFBQTtXQUNSb1QsT0FBTzhFLDBCQUEwQixDQUFBO01BQ3JDO0lBQUMsQ0FBQTtFQUNOO0VBS0FDLGNBQWNDLFdBQVdDLFlBQVk7QUFDbkMsVUFBTWQsY0FBYyxLQUFLQTtBQUN6QixRQUFJdlosUUFBUXVaLFlBQVk5SCxJQUFJMkksU0FBQUE7QUFDNUIsUUFBSSxDQUFDcGEsU0FBU3FhLFlBQVk7QUFDeEJyYSxjQUFRLG9CQUFJL0csSUFBQUE7QUFDWnNnQixrQkFBWTdmLElBQUkwZ0IsV0FBV3BhLEtBQUFBOztBQUU3QixXQUFPQTtFQUNUO0VBUUFxVyxnQkFBZ0IrRCxXQUFXRSxVQUFVRCxZQUFZO0FBQy9DLFVBQU0sRUFBQ3Z6QixTQUFTc08sS0FBSSxJQUFJO0FBQ3hCLFVBQU00SyxRQUFRLEtBQUttYSxjQUFjQyxXQUFXQyxVQUFBQTtBQUM1QyxVQUFNRSxTQUFTdmEsTUFBTXlSLElBQUk2SSxRQUFBQTtBQUN6QixRQUFJQyxRQUFRO0FBQ1YsYUFBT0E7O0FBR1QsVUFBTW5FLFNBQVMsb0JBQUkwQyxJQUFBQTtBQUVuQndCLGFBQVN4c0IsUUFBUStNLENBQUFBLFNBQVE7QUFDdkIsVUFBSXVmLFdBQVc7QUFDYmhFLGVBQU81dUIsSUFBSTR5QixTQUFBQTtBQUNYdmYsYUFBSy9NLFFBQVFnTixDQUFBQSxRQUFPb2UsV0FBVzlDLFFBQVFnRSxXQUFXdGYsR0FBQUEsQ0FBQUE7O0FBRXBERCxXQUFLL00sUUFBUWdOLENBQUFBLFFBQU9vZSxXQUFXOUMsUUFBUXR2QixTQUFTZ1UsR0FBQUEsQ0FBQUE7QUFDaERELFdBQUsvTSxRQUFRZ04sQ0FBQUEsUUFBT29lLFdBQVc5QyxRQUFRNUUsVUFBVXBjLElBQUFBLEtBQVMsQ0FBQSxHQUFJMEYsR0FBQUEsQ0FBQUE7QUFDOURELFdBQUsvTSxRQUFRZ04sQ0FBQUEsUUFBT29lLFdBQVc5QyxRQUFRamEsV0FBVXJCLEdBQUFBLENBQUFBO0FBQ2pERCxXQUFLL00sUUFBUWdOLENBQUFBLFFBQU9vZSxXQUFXOUMsUUFBUXRFLGFBQWFoWCxHQUFBQSxDQUFBQTtJQUN0RCxDQUFBO0FBRUEsVUFBTTFNLFFBQVFvc0IsTUFBTUMsS0FBS3JFLE1BQUFBO0FBQ3pCLFFBQUlob0IsTUFBTTNGLFdBQVcsR0FBRztBQUN0QjJGLFlBQU0vQixLQUFLcEYsdUJBQU84cEIsT0FBTyxJQUFJLENBQUE7O0FBRS9CLFFBQUk4SCxXQUFXNkIsSUFBSUosUUFBVyxHQUFBO0FBQzVCdGEsWUFBTXRHLElBQUk0Z0IsVUFBVWxzQixLQUFBQTs7QUFFdEIsV0FBT0E7RUFDVDtFQU1BdXNCLG9CQUFvQjtBQUNsQixVQUFNLEVBQUM3ekIsU0FBU3NPLEtBQUksSUFBSTtBQUV4QixXQUFPO01BQ0x0TztNQUNBMHFCLFVBQVVwYyxJQUFLLEtBQUksQ0FBQTtNQUNuQitHLFVBQVN5YSxTQUFTeGhCLElBQUssS0FBSSxDQUFBO01BQzNCO1FBQUNBO01BQUk7TUFDTCtHO01BQ0EyVjtJQUNEO0VBQ0g7RUFTQThJLG9CQUFvQnhFLFFBQVF5RSxRQUFPM2xCLFNBQVM0bEIsV0FBVztJQUFDO0tBQUs7QUFDM0QsVUFBTWh5QixTQUFTO01BQUNpeUIsU0FBUztJQUFJO0FBQzdCLFVBQU0sRUFBQ0MsVUFBVUMsWUFBVyxJQUFJQyxZQUFZLEtBQUsxQixnQkFBZ0JwRCxRQUFRMEUsUUFBQUE7QUFDekUsUUFBSWgwQixVQUFVazBCO0FBQ2QsUUFBSUcsWUFBWUgsVUFBVUgsTUFBUSxHQUFBO0FBQ2hDL3hCLGFBQU9peUIsVUFBVTtBQUNqQjdsQixnQkFBVWttQixXQUFXbG1CLE9BQVdBLElBQUFBLFFBQUFBLElBQVlBO0FBRTVDLFlBQU1tbUIsY0FBYyxLQUFLL0UsZUFBZUYsUUFBUWxoQixTQUFTK2xCLFdBQUFBO0FBQ3pEbjBCLGdCQUFVdzBCLGVBQWVOLFVBQVU5bEIsU0FBU21tQixXQUFBQTs7QUFHOUMsZUFBVzNnQixRQUFRbWdCLFFBQU87QUFDeEIveEIsYUFBTzRSLElBQUFBLElBQVE1VCxRQUFRNFQsSUFBSztJQUM5QjtBQUNBLFdBQU81UjtFQUNUO0VBUUF3dEIsZUFBZUYsUUFBUWxoQixTQUFTNGxCLFdBQVc7SUFBQztFQUFHLEdBQUVTLG9CQUFvQjtBQUNuRSxVQUFNLEVBQUNQLFNBQUFBLElBQVlFLFlBQVksS0FBSzFCLGdCQUFnQnBELFFBQVEwRSxRQUFBQTtBQUM1RCxXQUFPbHBCLFNBQVNzRCxPQUNab21CLElBQUFBLGVBQWVOLFVBQVU5bEIsU0FBU21DLFFBQVdra0Isa0JBQUFBLElBQzdDUDtFQUNOO0FBQ0Y7QUFFQSxTQUFTRSxZQUFZTSxlQUFlcEYsUUFBUTBFLFVBQVU7QUFDcEQsTUFBSTlhLFFBQVF3YixjQUFjL0osSUFBSTJFLE1BQUFBO0FBQzlCLE1BQUksQ0FBQ3BXLE9BQU87QUFDVkEsWUFBUSxvQkFBSS9HLElBQUFBO0FBQ1p1aUIsa0JBQWM5aEIsSUFBSTBjLFFBQVFwVyxLQUFBQTs7QUFFNUIsUUFBTWdaLFdBQVc4QixTQUFTdkksS0FBSTtBQUM5QixNQUFJZ0ksU0FBU3ZhLE1BQU15UixJQUFJdUgsUUFBQUE7QUFDdkIsTUFBSSxDQUFDdUIsUUFBUTtBQUNYLFVBQU1TLFdBQVdTLGdCQUFnQnJGLFFBQVEwRSxRQUFBQTtBQUN6Q1AsYUFBUztNQUNQUztNQUNBQyxhQUFhSCxTQUFTenNCLE9BQU9xdEIsQ0FBQUEsT0FBSyxDQUFDQSxHQUFFckUsWUFBVyxFQUFHem5CLFNBQVMsT0FBQSxDQUFBO0lBQzlEO0FBQ0FvUSxVQUFNdEcsSUFBSXNmLFVBQVV1QixNQUFBQTs7QUFFdEIsU0FBT0E7QUFDVDtBQUVBLElBQU1vQixjQUFjM3pCLENBQUFBLFVBQVM0SixTQUFTNUosS0FBQUEsS0FDakNmLE9BQU8yMEIsb0JBQW9CNXpCLEtBQU84dEIsRUFBQUEsS0FBSyxDQUFDaGIsUUFBUXNnQixXQUFXcHpCLE1BQU04UyxHQUFJLENBQUEsQ0FBQTtBQUUxRSxTQUFTcWdCLFlBQVk1Z0IsT0FBT3NnQixRQUFPO0FBQ2pDLFFBQU0sRUFBQ2dCLGNBQWNDLFlBQVcsSUFBSTVHLGFBQWEzYSxLQUFBQTtBQUVqRCxhQUFXRyxRQUFRbWdCLFFBQU87QUFDeEIsVUFBTXRFLGFBQWFzRixhQUFhbmhCLElBQUFBO0FBQ2hDLFVBQU04YixZQUFZc0YsWUFBWXBoQixJQUFBQTtBQUM5QixVQUFNMVMsU0FBU3d1QixhQUFhRCxlQUFlaGMsTUFBTUcsSUFBSztBQUN0RCxRQUFLNmIsZUFBZTZFLFdBQVdwekIsS0FBQUEsS0FBVTJ6QixZQUFZM3pCLEtBQUssTUFDcER3dUIsYUFBYTlWLFFBQVExWSxLQUFTLEdBQUE7QUFDbEMsYUFBTzs7RUFFWDtBQUNBLFNBQU87QUFDVDs7QUM5WUEsSUFBTSt6QixrQkFBa0I7RUFBQztFQUFPO0VBQVU7RUFBUTtFQUFTO0FBQVk7QUFDdkUsU0FBU0MscUJBQXFCNXhCLFVBQVVyQyxNQUFNO0FBQzVDLFNBQU9xQyxhQUFhLFNBQVNBLGFBQWEsWUFBYTJ4QixnQkFBZ0Ivd0IsUUFBUVosUUFBQUEsTUFBYyxNQUFNckMsU0FBUztBQUM5RztBQUVBLFNBQVNrMEIsY0FBY0MsSUFBSUMsSUFBSTtBQUM3QixTQUFPLFNBQVN2dEIsSUFBR0MsSUFBRztBQUNwQixXQUFPRCxHQUFFc3RCLEVBQUcsTUFBS3J0QixHQUFFcXRCLEVBQUFBLElBQ2Z0dEIsR0FBRXV0QixFQUFBQSxJQUFNdHRCLEdBQUVzdEIsRUFBQUEsSUFDVnZ0QixHQUFFc3RCLEVBQUcsSUFBR3J0QixHQUFFcXRCLEVBQUc7RUFDbkI7QUFDRjtBQUVBLFNBQVNFLHFCQUFxQmxuQixTQUFTO0FBQ3JDLFFBQU0vSyxRQUFRK0ssUUFBUS9LO0FBQ3RCLFFBQU1reUIsbUJBQW1CbHlCLE1BQU1yRCxRQUFRaVA7QUFFdkM1TCxRQUFNMGMsY0FBYyxhQUFBO0FBQ3BCd08sV0FBYWdILG9CQUFvQkEsaUJBQWlCQyxZQUFZO0lBQUNwbkI7S0FBVS9LLEtBQUFBO0FBQzNFO0FBRUEsU0FBU295QixvQkFBb0JybkIsU0FBUztBQUNwQyxRQUFNL0ssUUFBUStLLFFBQVEvSztBQUN0QixRQUFNa3lCLG1CQUFtQmx5QixNQUFNckQsUUFBUWlQO0FBQ3ZDc2YsV0FBYWdILG9CQUFvQkEsaUJBQWlCRyxZQUFZO0lBQUN0bkI7S0FBVS9LLEtBQUFBO0FBQzNFO0FBTUEsU0FBU3N5QixVQUFVL29CLE1BQU07QUFDdkIsTUFBSTRILGdCQUFBQSxLQUFxQixPQUFPNUgsU0FBUyxVQUFVO0FBQ2pEQSxXQUFPa0YsU0FBUzhqQixlQUFlaHBCLElBQUFBO0VBQ2pDLFdBQVdBLFFBQVFBLEtBQUtqTCxRQUFRO0FBRTlCaUwsV0FBT0EsS0FBSyxDQUFFOztBQUdoQixNQUFJQSxRQUFRQSxLQUFLcUIsUUFBUTtBQUV2QnJCLFdBQU9BLEtBQUtxQjs7QUFFZCxTQUFPckI7QUFDVDtBQUVBLElBQU1pcEIsWUFBWSxDQUFBO0FBQ2xCLElBQU1DLFdBQVcsQ0FBQzloQixRQUFRO0FBQ3hCLFFBQU0vRixTQUFTMG5CLFVBQVUzaEIsR0FBQUE7QUFDekIsU0FBTzdULE9BQU80MUIsT0FBT0YsU0FBQUEsRUFBV3R1QixPQUFPLENBQUN5dUIsT0FBTUEsR0FBRS9uQixXQUFXQSxNQUFBQSxFQUFRc2QsSUFBRztBQUN4RTtBQUVBLFNBQVMwSyxnQkFBZ0I1RCxLQUFLbnZCLE9BQU9nekIsTUFBTTtBQUN6QyxRQUFNbmlCLE9BQU81VCxPQUFPNFQsS0FBS3NlLEdBQUFBO0FBQ3pCLGFBQVdyZSxPQUFPRCxNQUFNO0FBQ3RCLFVBQU1vaUIsU0FBUyxDQUFDbmlCO0FBQ2hCLFFBQUltaUIsVUFBVWp6QixPQUFPO0FBQ25CLFlBQU1oQyxRQUFRbXhCLElBQUlyZSxHQUFJO0FBQ3RCLGFBQU9xZSxJQUFJcmUsR0FBSTtBQUNmLFVBQUlraUIsT0FBTyxLQUFLQyxTQUFTanpCLE9BQU87QUFDOUJtdkIsWUFBSThELFNBQVNELElBQUFBLElBQVFoMUI7OztFQUczQjtBQUNGO0FBU0EsU0FBU2sxQixtQkFBbUJ2dkIsSUFBR3d2QixXQUFXQyxhQUFhQyxTQUFTO0FBQzlELE1BQUksQ0FBQ0QsZUFBZXp2QixHQUFFeUgsU0FBUyxZQUFZO0FBQ3pDLFdBQU87O0FBRVQsTUFBSWlvQixTQUFTO0FBQ1gsV0FBT0Y7O0FBRVQsU0FBT3h2QjtBQUNUO0FBRUEsSUFBTTJ2QixRQUFOLE1BQU1BO0VBU0osT0FBT3BNLFlBQVlwbEIsT0FBTztBQUN4QjBvQixhQUFTaHRCLElBQU9zRSxHQUFBQSxLQUFBQTtBQUNoQnl4QixzQkFBQUE7RUFDRjtFQUVBLE9BQU83TCxjQUFjNWxCLE9BQU87QUFDMUIwb0IsYUFBU3JCLE9BQVVybkIsR0FBQUEsS0FBQUE7QUFDbkJ5eEIsc0JBQUFBO0VBQ0Y7RUFHQTEyQixZQUFZNk0sTUFBTThwQixZQUFZO0FBQzVCLFVBQU01bkIsU0FBUyxLQUFLQSxTQUFTLElBQUl5akIsT0FBT21FLFVBQUFBO0FBQ3hDLFVBQU1DLGdCQUFnQmhCLFVBQVUvb0IsSUFBQUE7QUFDaEMsVUFBTWdxQixnQkFBZ0JkLFNBQVNhLGFBQUFBO0FBQy9CLFFBQUlDLGVBQWU7QUFDakIsWUFBTSxJQUFJLzJCLE1BQ1IsOENBQStDKzJCLGNBQWMxYixLQUFLLG9EQUNsQjBiLGNBQWMzb0IsT0FBT2lOLEtBQUssa0JBQzFFOztBQUdKLFVBQU1sYixVQUFVOE8sT0FBTzBnQixlQUFlMWdCLE9BQU8ra0Isa0JBQWlCLEdBQUksS0FBSzdrQixXQUFVLENBQUE7QUFFakYsU0FBSzJqQixXQUFXLEtBQUs3akIsT0FBTzZqQixZQUFZcGUsZ0JBQWdCb2lCLGFBQWEsR0FBQTtBQUNyRSxTQUFLaEUsU0FBUzlqQixhQUFhQyxNQUFBQTtBQUUzQixVQUFNVixVQUFVLEtBQUt1a0IsU0FBUzNrQixlQUFlMm9CLGVBQWUzMkIsUUFBUWtPLFdBQVc7QUFDL0UsVUFBTUQsU0FBU0csV0FBV0EsUUFBUUg7QUFDbEMsVUFBTXJFLFNBQVNxRSxVQUFVQSxPQUFPckU7QUFDaEMsVUFBTUYsUUFBUXVFLFVBQVVBLE9BQU92RTtBQUUvQixTQUFLd1IsS0FBSzJiLElBQUFBO0FBQ1YsU0FBS25qQixNQUFNdEY7QUFDWCxTQUFLSCxTQUFTQTtBQUNkLFNBQUt2RSxRQUFRQTtBQUNiLFNBQUtFLFNBQVNBO0FBQ2QsU0FBS2t0QixXQUFXOTJCO0FBSWhCLFNBQUsrMkIsZUFBZSxLQUFLN29CO0FBQ3pCLFNBQUtyQixVQUFVLENBQUE7QUFDZixTQUFLbXFCLFlBQVksQ0FBQTtBQUNqQixTQUFLQyxVQUFVMW1CO0FBQ2YsU0FBS25JLFFBQVEsQ0FBQTtBQUNiLFNBQUtzSywwQkFBMEJuQztBQUMvQixTQUFLbEwsWUFBWWtMO0FBQ2pCLFNBQUsybUIsVUFBVSxDQUFBO0FBQ2YsU0FBS0MsYUFBYTVtQjtBQUNsQixTQUFLNm1CLGFBQWEsQ0FBQTtBQUVsQixTQUFLQyx1QkFBdUI5bUI7QUFDNUIsU0FBSyttQixrQkFBa0IsQ0FBQTtBQUN2QixTQUFLL2MsU0FBUyxDQUFBO0FBQ2QsU0FBS2dkLFdBQVcsSUFBSXpKLGNBQUFBO0FBQ3BCLFNBQUs1WixXQUFXLENBQUE7QUFDaEIsU0FBS3NqQixpQkFBaUIsQ0FBQTtBQUN0QixTQUFLQyxXQUFXO0FBQ2hCLFNBQUtDLHNCQUFzQm5uQjtBQUMzQixTQUFLZ00sV0FBV2hNO0FBQ2hCLFNBQUtvbkIsWUFBWUMsU0FBU0MsQ0FBQUEsU0FBUSxLQUFLeHJCLE9BQU93ckIsSUFBTzczQixHQUFBQSxRQUFRODNCLGVBQWUsQ0FBQTtBQUM1RSxTQUFLQyxlQUFlLENBQUE7QUFHcEJsQyxjQUFVLEtBQUszYSxFQUFFLElBQUk7QUFFckIsUUFBSSxDQUFDOU0sV0FBVyxDQUFDSCxRQUFRO0FBS3ZCa2pCLGNBQVFDLE1BQU0sbUVBQUE7QUFDZDs7QUFHRjRHLGFBQVNDLE9BQU8sTUFBTSxZQUFZM0Msb0JBQUFBO0FBQ2xDMEMsYUFBU0MsT0FBTyxNQUFNLFlBQVl4QyxtQkFBQUE7QUFFbEMsU0FBS3lDLFlBQVc7QUFDaEIsUUFBSSxLQUFLVCxVQUFVO0FBQ2pCLFdBQUtwckIsT0FBTTs7RUFFZjtFQUVBLElBQUk2QixjQUFjO0FBQ2hCLFVBQU0sRUFBQ2xPLFNBQVMsRUFBQ2tPLGFBQWFpcUIsb0JBQUFBLEdBQXNCenVCLE9BQU9FLFFBQVFtdEIsYUFBWSxJQUFJO0FBQ25GLFFBQUksQ0FBQ3QwQixjQUFjeUwsV0FBYyxHQUFBO0FBRS9CLGFBQU9BOztBQUdULFFBQUlpcUIsdUJBQXVCcEIsY0FBYztBQUV2QyxhQUFPQTs7QUFJVCxXQUFPbnRCLFNBQVNGLFFBQVFFLFNBQVM7RUFDbkM7RUFFQSxJQUFJdkksT0FBTztBQUNULFdBQU8sS0FBS3lOLE9BQU96TjtFQUNyQjtFQUVBLElBQUlBLEtBQUtBLE1BQU07QUFDYixTQUFLeU4sT0FBT3pOLE9BQU9BO0VBQ3JCO0VBRUEsSUFBSXJCLFVBQVU7QUFDWixXQUFPLEtBQUs4MkI7RUFDZDtFQUVBLElBQUk5MkIsUUFBUUEsU0FBUztBQUNuQixTQUFLOE8sT0FBTzlPLFVBQVVBO0VBQ3hCO0VBRUEsSUFBSTB0QixXQUFXO0FBQ2IsV0FBT0E7RUFDVDtFQUtBd0ssY0FBYztBQUVaLFNBQUtuWSxjQUFjLFlBQUE7QUFFbkIsUUFBSSxLQUFLL2YsUUFBUW80QixZQUFZO0FBQzNCLFdBQUszbEIsT0FBTTtXQUNOO0FBQ0w0bEIsa0JBQVksTUFBTSxLQUFLcjRCLFFBQVF3UyxnQkFBZ0I7O0FBR2pELFNBQUs4bEIsV0FBVTtBQUdmLFNBQUt2WSxjQUFjLFdBQUE7QUFFbkIsV0FBTztFQUNUO0VBRUE4UyxRQUFRO0FBQ04wRixnQkFBWSxLQUFLdHFCLFFBQVEsS0FBS3lGLEdBQUc7QUFDakMsV0FBTztFQUNUO0VBRUE4a0IsT0FBTztBQUNMUixhQUFTUSxLQUFLLElBQUk7QUFDbEIsV0FBTztFQUNUO0VBT0EvbEIsT0FBTy9JLE9BQU9FLFFBQVE7QUFDcEIsUUFBSSxDQUFDb3VCLFNBQVNTLFFBQVEsSUFBSSxHQUFHO0FBQzNCLFdBQUtDLFFBQVFodkIsT0FBT0UsTUFBQUE7V0FDZjtBQUNMLFdBQUsrdUIsb0JBQW9CO1FBQUNqdkI7UUFBT0U7TUFBTTs7RUFFM0M7RUFFQTh1QixRQUFRaHZCLE9BQU9FLFFBQVE7QUFDckIsVUFBTTVKLFVBQVUsS0FBS0E7QUFDckIsVUFBTWlPLFNBQVMsS0FBS0E7QUFDcEIsVUFBTUMsY0FBY2xPLFFBQVFtNEIsdUJBQXVCLEtBQUtqcUI7QUFDeEQsVUFBTTBxQixVQUFVLEtBQUtqRyxTQUFTamtCLGVBQWVULFFBQVF2RSxPQUFPRSxRQUFRc0UsV0FBQUE7QUFDcEUsVUFBTTJxQixXQUFXNzRCLFFBQVF3UyxvQkFBb0IsS0FBS21nQixTQUFTbGtCLG9CQUFtQjtBQUM5RSxVQUFNb3BCLE9BQU8sS0FBS251QixRQUFRLFdBQVc7QUFFckMsU0FBS0EsUUFBUWt2QixRQUFRbHZCO0FBQ3JCLFNBQUtFLFNBQVNndkIsUUFBUWh2QjtBQUN0QixTQUFLbXRCLGVBQWUsS0FBSzdvQjtBQUN6QixRQUFJLENBQUNtcUIsWUFBWSxNQUFNUSxVQUFVLElBQUksR0FBRztBQUN0Qzs7QUFHRixTQUFLOVksY0FBYyxVQUFVO01BQUM3VyxNQUFNMHZCO0lBQU8sQ0FBQTtBQUUzQ3JLLGFBQWF2dUIsUUFBUTg0QixVQUFVO01BQUM7TUFBTUY7SUFBUSxHQUFFLElBQUk7QUFFcEQsUUFBSSxLQUFLbkIsVUFBVTtBQUNqQixVQUFJLEtBQUtFLFVBQVVFLElBQU8sR0FBQTtBQUV4QixhQUFLa0IsT0FBTTs7O0VBR2pCO0VBRUFDLHNCQUFzQjtBQUNwQixVQUFNaDVCLFVBQVUsS0FBS0E7QUFDckIsVUFBTWk1QixnQkFBZ0JqNUIsUUFBUXVhLFVBQVUsQ0FBQTtBQUV4Qy9NLFNBQUt5ckIsZUFBZSxDQUFDQyxhQUFhdFAsV0FBVztBQUMzQ3NQLGtCQUFZaGUsS0FBSzBPO0lBQ25CLENBQUE7RUFDRjtFQUtBdVAsc0JBQXNCO0FBQ3BCLFVBQU1uNUIsVUFBVSxLQUFLQTtBQUNyQixVQUFNbzVCLFlBQVlwNUIsUUFBUXVhO0FBQzFCLFVBQU1BLFNBQVMsS0FBS0E7QUFDcEIsVUFBTThlLFVBQVVsNUIsT0FBTzRULEtBQUt3RyxNQUFBQSxFQUFRNU0sT0FBTyxDQUFDMGtCLEtBQUtuWCxPQUFPO0FBQ3REbVgsVUFBSW5YLEVBQUcsSUFBRztBQUNWLGFBQU9tWDtJQUNULEdBQUcsQ0FBQSxDQUFDO0FBQ0osUUFBSXJ0QixRQUFRLENBQUE7QUFFWixRQUFJbzBCLFdBQVc7QUFDYnAwQixjQUFRQSxNQUFNc0YsT0FDWm5LLE9BQU80VCxLQUFLcWxCLFNBQVdFLEVBQUFBLElBQUksQ0FBQ3BlLE9BQU87QUFDakMsY0FBTW9WLGVBQWU4SSxVQUFVbGUsRUFBRztBQUNsQyxjQUFNamEsT0FBT292QixjQUFjblYsSUFBSW9WLFlBQUFBO0FBQy9CLGNBQU1pSixXQUFXdDRCLFNBQVM7QUFDMUIsY0FBTXdILGVBQWV4SCxTQUFTO0FBQzlCLGVBQU87VUFDTGpCLFNBQVNzd0I7VUFDVGtKLFdBQVdELFdBQVcsY0FBYzl3QixlQUFlLFdBQVc7VUFDOURneEIsT0FBT0YsV0FBVyxpQkFBaUI5d0IsZUFBZSxhQUFhO1FBQ2pFO01BQ0YsQ0FBQSxDQUFBOztBQUlKK0UsU0FBS3hJLE9BQU8sQ0FBQzRILFNBQVM7QUFDcEIsWUFBTTBqQixlQUFlMWpCLEtBQUs1TTtBQUMxQixZQUFNa2IsS0FBS29WLGFBQWFwVjtBQUN4QixZQUFNamEsT0FBT292QixjQUFjblYsSUFBSW9WLFlBQUFBO0FBQy9CLFlBQU1vSixZQUFZOWhCLGVBQWUwWSxhQUFhaGlCLE1BQU0xQixLQUFLNnNCLEtBQUs7QUFFOUQsVUFBSW5KLGFBQWFodEIsYUFBYWlOLFVBQWEya0IscUJBQXFCNUUsYUFBYWh0QixVQUFVckMsSUFBVWkwQixNQUFBQSxxQkFBcUJ0b0IsS0FBSzRzQixTQUFTLEdBQUc7QUFDcklsSixxQkFBYWh0QixXQUFXc0osS0FBSzRzQjs7QUFHL0JILGNBQVFuZSxFQUFHLElBQUc7QUFDZCxVQUFJMUYsUUFBUTtBQUNaLFVBQUkwRixNQUFNWCxVQUFVQSxPQUFPVyxFQUFBQSxFQUFJNU0sU0FBU29yQixXQUFXO0FBQ2pEbGtCLGdCQUFRK0UsT0FBT1csRUFBRzthQUNiO0FBQ0wsY0FBTXllLGFBQWFqTSxTQUFTWixTQUFTNE0sU0FBQUE7QUFDckNsa0IsZ0JBQVEsSUFBSW1rQixXQUFXO1VBQ3JCemU7VUFDQTVNLE1BQU1vckI7VUFDTmhtQixLQUFLLEtBQUtBO1VBQ1ZyUSxPQUFPO1FBQ1QsQ0FBQTtBQUNBa1gsZUFBTy9FLE1BQU0wRixFQUFFLElBQUkxRjs7QUFHckJBLFlBQU1sVixLQUFLZ3dCLGNBQWN0d0IsT0FBQUE7SUFDM0IsQ0FBQTtBQUVBd04sU0FBSzZyQixTQUFTLENBQUNPLFlBQVkxZSxPQUFPO0FBQ2hDLFVBQUksQ0FBQzBlLFlBQVk7QUFDZixlQUFPcmYsT0FBT1csRUFBRzs7SUFFckIsQ0FBQTtBQUVBMU4sU0FBSytNLFFBQVEsQ0FBQy9FLFVBQVU7QUFDdEI3TSxjQUFRd0UsVUFBVSxNQUFNcUksT0FBT0EsTUFBTXhWLE9BQU87QUFDNUMySSxjQUFRZ0UsT0FBTyxNQUFNNkksS0FBQUE7SUFDdkIsQ0FBQTtFQUNGO0VBS0Fxa0Isa0JBQWtCO0FBQ2hCLFVBQU1yMkIsV0FBVyxLQUFLd3pCO0FBQ3RCLFVBQU04QyxVQUFVLEtBQUt6NEIsS0FBS3l1QixTQUFTbnVCO0FBQ25DLFVBQU1vNEIsVUFBVXYyQixTQUFTN0I7QUFFekI2QixhQUFTcUUsS0FBSyxDQUFDQyxJQUFHQyxPQUFNRCxHQUFFbEUsUUFBUW1FLEdBQUVuRSxLQUFLO0FBQ3pDLFFBQUltMkIsVUFBVUQsU0FBUztBQUNyQixlQUFTcDJCLEtBQUlvMkIsU0FBU3AyQixLQUFJcTJCLFNBQVMsRUFBRXIyQixJQUFHO0FBQ3RDLGFBQUtzMkIsb0JBQW9CdDJCLEVBQUFBO01BQzNCO0FBQ0FGLGVBQVMwSixPQUFPNHNCLFNBQVNDLFVBQVVELE9BQUFBOztBQUVyQyxTQUFLeEMsa0JBQWtCOXpCLFNBQVNwQixNQUFNLENBQUd5RixFQUFBQSxLQUFLc3RCLGNBQWMsU0FBUyxPQUFBLENBQUE7RUFDdkU7RUFLQThFLDhCQUE4QjtBQUM1QixVQUFNLEVBQUNqRCxXQUFXeHpCLFVBQVVuQyxNQUFNLEVBQUN5dUIsU0FBQUEsRUFBUyxJQUFJO0FBQ2hELFFBQUl0c0IsU0FBUzdCLFNBQVNtdUIsU0FBU251QixRQUFRO0FBQ3JDLGFBQU8sS0FBS3MxQjs7QUFFZHp6QixhQUFTd0QsUUFBUSxDQUFDQyxNQUFNckQsVUFBVTtBQUNoQyxVQUFJa3NCLFNBQVN2b0IsT0FBTy9DLENBQUFBLE9BQUtBLE9BQU15QyxLQUFLaXpCLFFBQVEsRUFBRXY0QixXQUFXLEdBQUc7QUFDMUQsYUFBS3E0QixvQkFBb0JwMkIsS0FBQUE7O0lBRTdCLENBQUE7RUFDRjtFQUVBdTJCLDJCQUEyQjtBQUN6QixVQUFNQyxpQkFBaUIsQ0FBQTtBQUN2QixVQUFNdEssV0FBVyxLQUFLenVCLEtBQUt5dUI7QUFDM0IsUUFBSXBzQixJQUFHQztBQUVQLFNBQUtzMkIsNEJBQTJCO0FBRWhDLFNBQUt2MkIsS0FBSSxHQUFHQyxPQUFPbXNCLFNBQVNudUIsUUFBUStCLEtBQUlDLE1BQU1ELE1BQUs7QUFDakQsWUFBTWhDLFVBQVVvdUIsU0FBU3BzQixFQUFFO0FBQzNCLFVBQUl1RCxPQUFPLEtBQUtDLGVBQWV4RCxFQUFBQTtBQUMvQixZQUFNNEssT0FBTzVNLFFBQVE0TSxRQUFRLEtBQUtRLE9BQU9SO0FBRXpDLFVBQUlySCxLQUFLcUgsUUFBUXJILEtBQUtxSCxTQUFTQSxNQUFNO0FBQ25DLGFBQUswckIsb0JBQW9CdDJCLEVBQUFBO0FBQ3pCdUQsZUFBTyxLQUFLQyxlQUFleEQsRUFBQUE7O0FBRTdCdUQsV0FBS3FILE9BQU9BO0FBQ1pySCxXQUFLK29CLFlBQVl0dUIsUUFBUXN1QixhQUFhSixhQUFhdGhCLE1BQU0sS0FBS3RPLE9BQU87QUFDckVpSCxXQUFLb3pCLFFBQVEzNEIsUUFBUTI0QixTQUFTO0FBQzlCcHpCLFdBQUtyRCxRQUFRRjtBQUNidUQsV0FBS2laLFFBQVEsS0FBS3hlLFFBQVF3ZTtBQUMxQmpaLFdBQUtxekIsVUFBVSxLQUFLQyxpQkFBaUI3MkIsRUFBQUE7QUFFckMsVUFBSXVELEtBQUs3RixZQUFZO0FBQ25CNkYsYUFBSzdGLFdBQVdvNUIsWUFBWTkyQixFQUFBQTtBQUM1QnVELGFBQUs3RixXQUFXcTVCLFdBQVU7YUFDckI7QUFDTCxjQUFNQyxrQkFBa0JoTixTQUFTaEIsY0FBY3BlLElBQUFBO0FBQy9DLGNBQU0sRUFBQ3FzQixvQkFBb0JDLGdCQUFBQSxJQUFtQnZsQixVQUFTeWEsU0FBU3hoQixJQUFLO0FBQ3JFbk8sZUFBT0MsT0FBT3M2QixpQkFBaUI7VUFDN0JFLGlCQUFpQmxOLFNBQVNkLFdBQVdnTyxlQUFBQTtVQUNyQ0Qsb0JBQW9CQSxzQkFBc0JqTixTQUFTZCxXQUFXK04sa0JBQUFBO1FBQ2hFLENBQUE7QUFDQTF6QixhQUFLN0YsYUFBYSxJQUFJczVCLGdCQUFnQixNQUFNaDNCLEVBQUFBO0FBQzVDMDJCLHVCQUFlNzBCLEtBQUswQixLQUFLN0YsVUFBVTs7SUFFdkM7QUFFQSxTQUFLeTRCLGdCQUFlO0FBQ3BCLFdBQU9PO0VBQ1Q7RUFNQVMsaUJBQWlCO0FBQ2ZydEIsU0FBSyxLQUFLbk0sS0FBS3l1QixVQUFVLENBQUNwdUIsU0FBU3lELGlCQUFpQjtBQUNsRCxXQUFLK0IsZUFBZS9CLFlBQWMvRCxFQUFBQSxXQUFXMDVCLE1BQUs7SUFDcEQsR0FBRyxJQUFJO0VBQ1Q7RUFLQUEsUUFBUTtBQUNOLFNBQUtELGVBQWM7QUFDbkIsU0FBSzlhLGNBQWMsT0FBQTtFQUNyQjtFQUVBMVQsT0FBT3dyQixNQUFNO0FBQ1gsVUFBTS9vQixTQUFTLEtBQUtBO0FBRXBCQSxXQUFPekMsT0FBTTtBQUNiLFVBQU1yTSxVQUFVLEtBQUs4MkIsV0FBV2hvQixPQUFPMGdCLGVBQWUxZ0IsT0FBTytrQixrQkFBaUIsR0FBSSxLQUFLN2tCLFdBQVUsQ0FBQTtBQUNqRyxVQUFNK3JCLGdCQUFnQixLQUFLckQsc0JBQXNCLENBQUMxM0IsUUFBUWlQO0FBRTFELFNBQUsrckIsY0FBYTtBQUNsQixTQUFLQyxvQkFBbUI7QUFDeEIsU0FBS0MscUJBQW9CO0FBSXpCLFNBQUszRCxTQUFTOUksV0FBVTtBQUV4QixRQUFJLEtBQUsxTyxjQUFjLGdCQUFnQjtNQUFDOFg7TUFBTXJKLFlBQVk7SUFBSSxDQUFBLE1BQU8sT0FBTztBQUMxRTs7QUFJRixVQUFNNEwsaUJBQWlCLEtBQUtELHlCQUF3QjtBQUVwRCxTQUFLcGEsY0FBYyxzQkFBQTtBQUduQixRQUFJM1MsYUFBYTtBQUNqQixhQUFTMUosS0FBSSxHQUFHQyxPQUFPLEtBQUt0QyxLQUFLeXVCLFNBQVNudUIsUUFBUStCLEtBQUlDLE1BQU1ELE1BQUs7QUFDL0QsWUFBTSxFQUFDdEMsV0FBVSxJQUFJLEtBQUs4RixlQUFleEQsRUFBQUE7QUFDekMsWUFBTW8zQixTQUFRLENBQUNDLGlCQUFpQlgsZUFBZWwyQixRQUFROUMsVUFBQUEsTUFBZ0I7QUFHdkVBLGlCQUFXKzVCLHNCQUFzQkwsTUFBQUE7QUFDakMxdEIsbUJBQWExSyxLQUFLQyxJQUFJLENBQUN2QixXQUFXZzZCLGVBQWMsR0FBSWh1QixVQUFBQTtJQUN0RDtBQUNBQSxpQkFBYSxLQUFLaXVCLGNBQWNyN0IsUUFBUXVKLE9BQU8reEIsY0FBY2x1QixhQUFhO0FBQzFFLFNBQUttdUIsY0FBY251QixVQUFBQTtBQUduQixRQUFJLENBQUMydEIsZUFBZTtBQUdsQnZ0QixXQUFLNHNCLGdCQUFnQixDQUFDaDVCLGVBQWU7QUFDbkNBLG1CQUFXMDVCLE1BQUs7TUFDbEIsQ0FBQTs7QUFHRixTQUFLVSxnQkFBZ0IzRCxJQUFBQTtBQUdyQixTQUFLOVgsY0FBYyxlQUFlO01BQUM4WDtJQUFJLENBQUE7QUFFdkMsU0FBS2hyQixRQUFRaEYsS0FBS3N0QixjQUFjLEtBQUssTUFBQSxDQUFBO0FBR3JDLFVBQU0sRUFBQytCLFNBQVNDLFdBQVUsSUFBSTtBQUM5QixRQUFJQSxZQUFZO0FBQ2QsV0FBS3NFLGNBQWN0RSxZQUFZLElBQUk7ZUFDMUJELFFBQVF2MUIsUUFBUTtBQUN6QixXQUFLKzVCLG1CQUFtQnhFLFNBQVNBLFNBQVMsSUFBSTs7QUFHaEQsU0FBSzZCLE9BQU07RUFDYjtFQUtBaUMsZ0JBQWdCO0FBQ2R4dEIsU0FBSyxLQUFLK00sUUFBUSxDQUFDL0UsVUFBVTtBQUMzQjdNLGNBQVFxRSxVQUFVLE1BQU13SSxLQUFBQTtJQUMxQixDQUFBO0FBRUEsU0FBS3dqQixvQkFBbUI7QUFDeEIsU0FBS0csb0JBQW1CO0VBQzFCO0VBS0E4QixzQkFBc0I7QUFDcEIsVUFBTWo3QixVQUFVLEtBQUtBO0FBQ3JCLFVBQU0yN0IsaUJBQWlCLElBQUkzSixJQUFJN3hCLE9BQU80VCxLQUFLLEtBQUtxakIsVUFBVSxDQUFBO0FBQzFELFVBQU13RSxZQUFZLElBQUk1SixJQUFJaHlCLFFBQVE2N0IsTUFBTTtBQUV4QyxRQUFJLENBQUNDLFVBQVVILGdCQUFnQkMsU0FBQUEsS0FBYyxDQUFDLENBQUMsS0FBS3ZFLHlCQUF5QnIzQixRQUFRbzRCLFlBQVk7QUFFL0YsV0FBSzJELGFBQVk7QUFDakIsV0FBS3pELFdBQVU7O0VBRW5CO0VBS0E0Qyx1QkFBdUI7QUFDckIsVUFBTSxFQUFDMUQsZUFBQUEsSUFBa0I7QUFDekIsVUFBTXdFLFVBQVUsS0FBS0MsdUJBQXNCLEtBQU0sQ0FBQTtBQUNqRCxlQUFXLEVBQUM5TyxRQUFRanFCLE9BQU84RixNQUFBQSxLQUFVZ3pCLFNBQVM7QUFDNUMsWUFBTTlGLE9BQU8vSSxXQUFXLG9CQUFvQixDQUFDbmtCLFFBQVFBO0FBQ3JEaXRCLHNCQUFnQnVCLGdCQUFnQnQwQixPQUFPZ3pCLElBQUFBO0lBQ3pDO0VBQ0Y7RUFLQStGLHlCQUF5QjtBQUN2QixVQUFNbEUsZUFBZSxLQUFLQTtBQUMxQixRQUFJLENBQUNBLGdCQUFnQixDQUFDQSxhQUFhcDJCLFFBQVE7QUFDekM7O0FBR0YsU0FBS28yQixlQUFlLENBQUE7QUFDcEIsVUFBTW1FLGVBQWUsS0FBSzc2QixLQUFLeXVCLFNBQVNudUI7QUFDeEMsVUFBTXc2QixVQUFVLENBQUM3WSxRQUFRLElBQUkwTyxJQUMzQitGLGFBQ0d4d0IsT0FBT3l1QixDQUFBQSxPQUFLQSxHQUFFLENBQUEsTUFBTzFTLEdBQUFBLEVBQ3JCZ1csSUFBSSxDQUFDdEQsSUFBR3R5QixPQUFNQSxLQUFJLE1BQU1zeUIsR0FBRTlvQixPQUFPLENBQUd1ZSxFQUFBQSxLQUFLLEdBQUEsQ0FBQSxDQUFBO0FBRzlDLFVBQU0yUSxZQUFZRCxRQUFRLENBQUE7QUFDMUIsYUFBU3o0QixLQUFJLEdBQUdBLEtBQUl3NEIsY0FBY3g0QixNQUFLO0FBQ3JDLFVBQUksQ0FBQ280QixVQUFVTSxXQUFXRCxRQUFRejRCLEVBQUssQ0FBQSxHQUFBO0FBQ3JDOztJQUVKO0FBQ0EsV0FBT2d3QixNQUFNQyxLQUFLeUksU0FDZjlDLEVBQUFBLElBQUl0RCxDQUFBQSxPQUFLQSxHQUFFM0ssTUFBTSxHQUNqQmlPLENBQUFBLEVBQUFBLElBQUl4eEIsQ0FBQUEsUUFBTTtNQUFDcWxCLFFBQVFybEIsR0FBRSxDQUFFO01BQUU1RSxPQUFPLENBQUM0RSxHQUFFLENBQUU7TUFBRWtCLE9BQU8sQ0FBQ2xCLEdBQUUsQ0FBRTtNQUFBO0VBQ3hEO0VBT0F5ekIsY0FBY251QixZQUFZO0FBQ3hCLFFBQUksS0FBSzJTLGNBQWMsZ0JBQWdCO01BQUN5TyxZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDcEU7O0FBR0Y3bEIsWUFBUTBELE9BQU8sTUFBTSxLQUFLM0MsT0FBTyxLQUFLRSxRQUFRd0QsVUFBQUE7QUFFOUMsVUFBTStiLE9BQU8sS0FBSzlqQjtBQUNsQixVQUFNZzNCLFNBQVNsVCxLQUFLemYsU0FBUyxLQUFLeWYsS0FBS3ZmLFVBQVU7QUFFakQsU0FBS2lELFVBQVUsQ0FBQTtBQUNmVyxTQUFLLEtBQUtwRixPQUFPLENBQUNULFFBQVE7QUFDeEIsVUFBSTAwQixVQUFVMTBCLElBQUlyRSxhQUFhLGFBQWE7QUFFMUM7O0FBS0YsVUFBSXFFLElBQUl3RixXQUFXO0FBQ2pCeEYsWUFBSXdGLFVBQVM7O0FBRWYsV0FBS04sUUFBUXRILEtBQUksR0FBSW9DLElBQUlrRixRQUFPLENBQUE7SUFDbEMsR0FBRyxJQUFJO0FBRVAsU0FBS0EsUUFBUTdGLFFBQVEsQ0FBQzRGLE1BQU1oSixVQUFVO0FBQ3BDZ0osV0FBSzB2QixPQUFPMTRCO0lBQ2QsQ0FBQTtBQUVBLFNBQUttYyxjQUFjLGFBQUE7RUFDckI7RUFPQXliLGdCQUFnQjNELE1BQU07QUFDcEIsUUFBSSxLQUFLOVgsY0FBYyx3QkFBd0I7TUFBQzhYO01BQU1ySixZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDbEY7O0FBR0YsYUFBUzlxQixLQUFJLEdBQUdDLE9BQU8sS0FBS3RDLEtBQUt5dUIsU0FBU251QixRQUFRK0IsS0FBSUMsTUFBTSxFQUFFRCxJQUFHO0FBQy9ELFdBQUt3RCxlQUFleEQsRUFBR3RDLEVBQUFBLFdBQVcrTCxVQUFTO0lBQzdDO0FBRUEsYUFBU3pKLEtBQUksR0FBR0MsT0FBTyxLQUFLdEMsS0FBS3l1QixTQUFTbnVCLFFBQVErQixLQUFJQyxNQUFNLEVBQUVELElBQUc7QUFDL0QsV0FBSzY0QixlQUFlNzRCLElBQUc0d0IsV0FBV3VELElBQUFBLElBQVFBLEtBQUs7UUFBQzF5QixjQUFjekI7TUFBQyxDQUFBLElBQUttMEIsSUFBSTtJQUMxRTtBQUVBLFNBQUs5WCxjQUFjLHVCQUF1QjtNQUFDOFg7SUFBSSxDQUFBO0VBQ2pEO0VBT0EwRSxlQUFlMzRCLE9BQU9pMEIsTUFBTTtBQUMxQixVQUFNNXdCLE9BQU8sS0FBS0MsZUFBZXRELEtBQUFBO0FBQ2pDLFVBQU11b0IsT0FBTztNQUFDbGxCO01BQU1yRDtNQUFPaTBCO01BQU1ySixZQUFZO0lBQUk7QUFFakQsUUFBSSxLQUFLek8sY0FBYyx1QkFBdUJvTSxJQUFBQSxNQUFVLE9BQU87QUFDN0Q7O0FBR0ZsbEIsU0FBSzdGLFdBQVdvN0IsUUFBUTNFLElBQUFBO0FBRXhCMUwsU0FBS3FDLGFBQWE7QUFDbEIsU0FBS3pPLGNBQWMsc0JBQXNCb00sSUFBQUE7RUFDM0M7RUFFQTRNLFNBQVM7QUFDUCxRQUFJLEtBQUtoWixjQUFjLGdCQUFnQjtNQUFDeU8sWUFBWTtJQUFJLENBQUEsTUFBTyxPQUFPO0FBQ3BFOztBQUdGLFFBQUl3SixTQUFTcEUsSUFBSSxJQUFJLEdBQUc7QUFDdEIsVUFBSSxLQUFLNkQsWUFBWSxDQUFDTyxTQUFTUyxRQUFRLElBQUksR0FBRztBQUM1Q1QsaUJBQVM5MEIsTUFBTSxJQUFJOztXQUVoQjtBQUNMLFdBQUs2SixLQUFJO0FBQ1R1b0IsMkJBQXFCO1FBQUNqeUIsT0FBTztNQUFJLENBQUE7O0VBRXJDO0VBRUEwSixPQUFPO0FBQ0wsUUFBSXJKO0FBQ0osUUFBSSxLQUFLaTFCLG1CQUFtQjtBQUMxQixZQUFNLEVBQUNqdkIsT0FBT0UsT0FBQUEsSUFBVSxLQUFLK3VCO0FBRTdCLFdBQUtBLG9CQUFvQjtBQUN6QixXQUFLRCxRQUFRaHZCLE9BQU9FLE1BQUFBOztBQUV0QixTQUFLaXBCLE1BQUs7QUFFVixRQUFJLEtBQUtucEIsU0FBUyxLQUFLLEtBQUtFLFVBQVUsR0FBRztBQUN2Qzs7QUFHRixRQUFJLEtBQUttVyxjQUFjLGNBQWM7TUFBQ3lPLFlBQVk7SUFBSSxDQUFBLE1BQU8sT0FBTztBQUNsRTs7QUFNRixVQUFNaU8sU0FBUyxLQUFLNXZCO0FBQ3BCLFNBQUtuSixLQUFJLEdBQUdBLEtBQUkrNEIsT0FBTzk2QixVQUFVODZCLE9BQU8vNEIsRUFBQUEsRUFBR29KLEtBQUssR0FBRyxFQUFFcEosSUFBRztBQUN0RCs0QixhQUFPLzRCLEVBQUUsRUFBQ3FKLEtBQUssS0FBSzFILFNBQVM7SUFDL0I7QUFFQSxTQUFLcTNCLGNBQWE7QUFHbEIsV0FBT2g1QixLQUFJKzRCLE9BQU85NkIsUUFBUSxFQUFFK0IsSUFBRztBQUM3Qis0QixhQUFPLzRCLEVBQUUsRUFBQ3FKLEtBQUssS0FBSzFILFNBQVM7SUFDL0I7QUFFQSxTQUFLMGEsY0FBYyxXQUFBO0VBQ3JCO0VBS0E0Yyx1QkFBdUJDLGVBQWU7QUFDcEMsVUFBTXA1QixXQUFXLEtBQUs4ekI7QUFDdEIsVUFBTXQxQixTQUFTLENBQUE7QUFDZixRQUFJMEIsSUFBR0M7QUFFUCxTQUFLRCxLQUFJLEdBQUdDLE9BQU9ILFNBQVM3QixRQUFRK0IsS0FBSUMsTUFBTSxFQUFFRCxJQUFHO0FBQ2pELFlBQU11RCxPQUFPekQsU0FBU0UsRUFBRTtBQUN4QixVQUFJLENBQUNrNUIsaUJBQWlCMzFCLEtBQUtxekIsU0FBUztBQUNsQ3Q0QixlQUFPdUQsS0FBSzBCLElBQUFBOztJQUVoQjtBQUVBLFdBQU9qRjtFQUNUO0VBTUF5QiwrQkFBK0I7QUFDN0IsV0FBTyxLQUFLazVCLHVCQUF1QixJQUFJO0VBQ3pDO0VBT0FELGdCQUFnQjtBQUNkLFFBQUksS0FBSzNjLGNBQWMsc0JBQXNCO01BQUN5TyxZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDMUU7O0FBR0YsVUFBTWhyQixXQUFXLEtBQUtDLDZCQUE0QjtBQUNsRCxhQUFTQyxLQUFJRixTQUFTN0IsU0FBUyxHQUFHK0IsTUFBSyxHQUFHLEVBQUVBLElBQUc7QUFDN0MsV0FBS201QixhQUFhcjVCLFNBQVNFLEVBQUUsQ0FBQTtJQUMvQjtBQUVBLFNBQUtxYyxjQUFjLG1CQUFBO0VBQ3JCO0VBT0E4YyxhQUFhNTFCLE1BQU07QUFDakIsVUFBTXlNLE1BQU0sS0FBS0E7QUFDakIsVUFBTXlZLE9BQU87TUFDWGxsQjtNQUNBckQsT0FBT3FELEtBQUtyRDtNQUNaNHFCLFlBQVk7SUFDZDtBQUVBLFVBQU1zTyxPQUFPQyxtQkFBbUIsTUFBTTkxQixJQUFBQTtBQUV0QyxRQUFJLEtBQUs4WSxjQUFjLHFCQUFxQm9NLElBQUFBLE1BQVUsT0FBTztBQUMzRDs7QUFHRixRQUFJMlEsTUFBTTtBQUNSMVQsZUFBUzFWLEtBQUtvcEIsSUFBQUE7O0FBR2hCNzFCLFNBQUs3RixXQUFXMkwsS0FBSTtBQUVwQixRQUFJK3ZCLE1BQU07QUFDUnZULGlCQUFXN1YsR0FBQUE7O0FBR2J5WSxTQUFLcUMsYUFBYTtBQUNsQixTQUFLek8sY0FBYyxvQkFBb0JvTSxJQUFBQTtFQUN6QztFQU9BbG5CLGNBQWN6QyxPQUFPO0FBQ25CLFdBQU80QyxlQUFlNUMsT0FBTyxLQUFLNkMsV0FBVyxLQUFLZzJCLFdBQVc7RUFDL0Q7RUFFQTJCLDBCQUEwQm4yQixJQUFHZ3hCLE1BQU03M0IsU0FBUzhFLGtCQUFrQjtBQUM1RCxVQUFNcW9CLFNBQVM4UCxZQUFZcjJCLE1BQU1peEIsSUFBSztBQUN0QyxRQUFJLE9BQU8xSyxXQUFXLFlBQVk7QUFDaEMsYUFBT0EsT0FBTyxNQUFNdG1CLElBQUc3RyxTQUFTOEUsZ0JBQUFBOztBQUdsQyxXQUFPLENBQUE7RUFDVDtFQUVBb0MsZUFBZS9CLGNBQWM7QUFDM0IsVUFBTXpELFVBQVUsS0FBS0wsS0FBS3l1QixTQUFTM3FCLFlBQWE7QUFDaEQsVUFBTTNCLFdBQVcsS0FBS3d6QjtBQUN0QixRQUFJL3ZCLE9BQU96RCxTQUFTK0QsT0FBTy9DLENBQUFBLE9BQUtBLE1BQUtBLEdBQUUwMUIsYUFBYXg0QixPQUFBQSxFQUFTNnBCLElBQUc7QUFFaEUsUUFBSSxDQUFDdGtCLE1BQU07QUFDVEEsYUFBTztRQUNMcUgsTUFBTTtRQUNOak4sTUFBTSxDQUFBO1FBQ05LLFNBQVM7UUFDVE4sWUFBWTtRQUNaODdCLFFBQVE7UUFDUnRNLFNBQVM7UUFDVEMsU0FBUztRQUNUd0osT0FBTzM0QixXQUFXQSxRQUFRMjRCLFNBQVM7UUFDbkN6MkIsT0FBT3VCO1FBQ1ArMEIsVUFBVXg0QjtRQUNWUSxTQUFTLENBQUE7UUFDVFosU0FBUztNQUNYO0FBQ0FrQyxlQUFTK0IsS0FBSzBCLElBQUFBOztBQUdoQixXQUFPQTtFQUNUO0VBRUErSCxhQUFhO0FBQ1gsV0FBTyxLQUFLdU4sYUFBYSxLQUFLQSxXQUFXdEMsY0FBYyxNQUFNO01BQUM1VyxPQUFPO01BQU1pTCxNQUFNO0tBQVE7RUFDM0Y7RUFFQTZ1Qix5QkFBeUI7QUFDdkIsV0FBTyxLQUFLMTVCLDZCQUE0QixFQUFHOUI7RUFDN0M7RUFFQTQ0QixpQkFBaUJwMUIsY0FBYztBQUM3QixVQUFNekQsVUFBVSxLQUFLTCxLQUFLeXVCLFNBQVMzcUIsWUFBYTtBQUNoRCxRQUFJLENBQUN6RCxTQUFTO0FBQ1osYUFBTzs7QUFHVCxVQUFNdUYsT0FBTyxLQUFLQyxlQUFlL0IsWUFBQUE7QUFJakMsV0FBTyxPQUFPOEIsS0FBS2kyQixXQUFXLFlBQVksQ0FBQ2oyQixLQUFLaTJCLFNBQVMsQ0FBQ3g3QixRQUFRdzdCO0VBQ3BFO0VBRUFFLHFCQUFxQmo0QixjQUFjbTFCLFNBQVM7QUFDMUMsVUFBTXJ6QixPQUFPLEtBQUtDLGVBQWUvQixZQUFBQTtBQUNqQzhCLFNBQUtpMkIsU0FBUyxDQUFDNUM7RUFDakI7RUFFQStDLHFCQUFxQno1QixPQUFPO0FBQzFCLFNBQUs0ekIsZUFBZTV6QixLQUFNLElBQUcsQ0FBQyxLQUFLNHpCLGVBQWU1ekIsS0FBTTtFQUMxRDtFQUVBMDVCLGtCQUFrQjE1QixPQUFPO0FBQ3ZCLFdBQU8sQ0FBQyxLQUFLNHpCLGVBQWU1ekIsS0FBTTtFQUNwQztFQUtBMjVCLGtCQUFrQnA0QixjQUFjcTRCLFdBQVdsRCxTQUFTO0FBQ2xELFVBQU16QyxPQUFPeUMsVUFBVSxTQUFTO0FBQ2hDLFVBQU1yekIsT0FBTyxLQUFLQyxlQUFlL0IsWUFBQUE7QUFDakMsVUFBTStQLFFBQVFqTyxLQUFLN0YsV0FBV3E4QixtQkFBbUJsdEIsUUFBV3NuQixJQUFBQTtBQUU1RCxRQUFJbnJCLFFBQVE4d0IsU0FBWSxHQUFBO0FBQ3RCdjJCLFdBQUs1RixLQUFLbThCLFNBQUFBLEVBQVdOLFNBQVMsQ0FBQzVDO0FBQy9CLFdBQUtqdUIsT0FBTTtXQUNOO0FBQ0wsV0FBSyt3QixxQkFBcUJqNEIsY0FBY20xQixPQUFBQTtBQUV4Q3BsQixZQUFNN0ksT0FBT3BGLE1BQU07UUFBQ3F6QjtNQUFPLENBQUE7QUFDM0IsV0FBS2p1QixPQUFPLENBQUNxSCxRQUFRQSxJQUFJdk8saUJBQWlCQSxlQUFlMHlCLE9BQU90bkIsTUFBUzs7RUFFN0U7RUFFQW10QixLQUFLdjRCLGNBQWNxNEIsV0FBVztBQUM1QixTQUFLRCxrQkFBa0JwNEIsY0FBY3E0QixXQUFXLEtBQUs7RUFDdkQ7RUFFQUcsS0FBS3g0QixjQUFjcTRCLFdBQVc7QUFDNUIsU0FBS0Qsa0JBQWtCcDRCLGNBQWNxNEIsV0FBVyxJQUFJO0VBQ3REO0VBS0F4RCxvQkFBb0I3MEIsY0FBYztBQUNoQyxVQUFNOEIsT0FBTyxLQUFLK3ZCLFVBQVU3eEIsWUFBYTtBQUN6QyxRQUFJOEIsUUFBUUEsS0FBSzdGLFlBQVk7QUFDM0I2RixXQUFLN0YsV0FBV3c4QixTQUFROztBQUUxQixXQUFPLEtBQUs1RyxVQUFVN3hCLFlBQWE7RUFDckM7RUFFQTA0QixRQUFRO0FBQ04sUUFBSW42QixJQUFHQztBQUNQLFNBQUs2MEIsS0FBSTtBQUNUUixhQUFTM0wsT0FBTyxJQUFJO0FBRXBCLFNBQUszb0IsS0FBSSxHQUFHQyxPQUFPLEtBQUt0QyxLQUFLeXVCLFNBQVNudUIsUUFBUStCLEtBQUlDLE1BQU0sRUFBRUQsSUFBRztBQUMzRCxXQUFLczJCLG9CQUFvQnQyQixFQUFBQTtJQUMzQjtFQUNGO0VBRUFvNkIsVUFBVTtBQUNSLFNBQUsvZCxjQUFjLGVBQUE7QUFDbkIsVUFBTSxFQUFDOVIsUUFBUXlGLElBQUcsSUFBSTtBQUV0QixTQUFLbXFCLE1BQUs7QUFDVixTQUFLL3VCLE9BQU84akIsV0FBVTtBQUV0QixRQUFJM2tCLFFBQVE7QUFDVixXQUFLOHRCLGFBQVk7QUFDakJ4RCxrQkFBWXRxQixRQUFReUYsR0FBQUE7QUFDcEIsV0FBS2lmLFNBQVN4a0IsZUFBZXVGLEdBQUFBO0FBQzdCLFdBQUt6RixTQUFTO0FBQ2QsV0FBS3lGLE1BQU07O0FBR2IsV0FBT21pQixVQUFVLEtBQUszYSxFQUFFO0FBRXhCLFNBQUs2RSxjQUFjLGNBQUE7RUFDckI7RUFFQWdlLGlCQUFpQjVSLE1BQU07QUFDckIsV0FBTyxLQUFLbGUsT0FBTyt2QixVQUFhN1IsR0FBQUEsSUFBQUE7RUFDbEM7RUFLQW1NLGFBQWE7QUFDWCxTQUFLMkYsZUFBYztBQUNuQixRQUFJLEtBQUtqK0IsUUFBUW80QixZQUFZO0FBQzNCLFdBQUs4RixxQkFBb0I7V0FDcEI7QUFDTCxXQUFLekcsV0FBVzs7RUFFcEI7RUFLQXdHLGlCQUFpQjtBQUNmLFVBQU1FLFlBQVksS0FBSy9HO0FBQ3ZCLFVBQU16RSxXQUFXLEtBQUtBO0FBRXRCLFVBQU15TCxPQUFPLENBQUM5dkIsTUFBTUMsY0FBYTtBQUMvQm9rQixlQUFTdGtCLGlCQUFpQixNQUFNQyxNQUFNQyxTQUFBQTtBQUN0QzR2QixnQkFBVTd2QixJQUFBQSxJQUFRQztJQUNwQjtBQUVBLFVBQU1BLFdBQVcsQ0FBQzFILElBQUdyQyxJQUFHRSxPQUFNO0FBQzVCbUMsTUFBQUEsR0FBRXczQixVQUFVNzVCO0FBQ1pxQyxNQUFBQSxHQUFFeTNCLFVBQVU1NUI7QUFDWixXQUFLKzJCLGNBQWM1MEIsRUFBQUE7SUFDckI7QUFFQTJHLFNBQUssS0FBS3hOLFFBQVE2N0IsUUFBUSxDQUFDdnRCLFNBQVM4dkIsS0FBSzl2QixNQUFNQyxRQUFBQSxDQUFBQTtFQUNqRDtFQUtBMnZCLHVCQUF1QjtBQUNyQixRQUFJLENBQUMsS0FBSzdHLHNCQUFzQjtBQUM5QixXQUFLQSx1QkFBdUIsQ0FBQTs7QUFFOUIsVUFBTThHLFlBQVksS0FBSzlHO0FBQ3ZCLFVBQU0xRSxXQUFXLEtBQUtBO0FBRXRCLFVBQU15TCxPQUFPLENBQUM5dkIsTUFBTUMsY0FBYTtBQUMvQm9rQixlQUFTdGtCLGlCQUFpQixNQUFNQyxNQUFNQyxTQUFBQTtBQUN0QzR2QixnQkFBVTd2QixJQUFBQSxJQUFRQztJQUNwQjtBQUNBLFVBQU1nd0IsVUFBVSxDQUFDandCLE1BQU1DLGNBQWE7QUFDbEMsVUFBSTR2QixVQUFVN3ZCLElBQUFBLEdBQU87QUFDbkJxa0IsaUJBQVNua0Isb0JBQW9CLE1BQU1GLE1BQU1DLFNBQUFBO0FBQ3pDLGVBQU80dkIsVUFBVTd2QixJQUFLOztJQUUxQjtBQUVBLFVBQU1DLFdBQVcsQ0FBQzdFLE9BQU9FLFdBQVc7QUFDbEMsVUFBSSxLQUFLcUUsUUFBUTtBQUNmLGFBQUt3RSxPQUFPL0ksT0FBT0UsTUFBQUE7O0lBRXZCO0FBRUEsUUFBSTQwQjtBQUNKLFVBQU0vRyxXQUFXLE1BQU07QUFDckI4RyxjQUFRLFVBQVU5RyxRQUFBQTtBQUVsQixXQUFLQSxXQUFXO0FBQ2hCLFdBQUtobEIsT0FBTTtBQUVYMnJCLFdBQUssVUFBVTd2QixRQUFBQTtBQUNmNnZCLFdBQUssVUFBVUksUUFBQUE7SUFDakI7QUFFQUEsZUFBVyxNQUFNO0FBQ2YsV0FBSy9HLFdBQVc7QUFFaEI4RyxjQUFRLFVBQVVod0IsUUFBQUE7QUFHbEIsV0FBS3N2QixNQUFLO0FBQ1YsV0FBS25GLFFBQVEsR0FBRyxDQUFBO0FBRWhCMEYsV0FBSyxVQUFVM0csUUFBQUE7SUFDakI7QUFFQSxRQUFJOUUsU0FBUy9qQixXQUFXLEtBQUtYLE1BQU0sR0FBRztBQUNwQ3dwQixlQUFBQTtXQUNLO0FBQ0wrRyxlQUFBQTs7RUFFSjtFQUtBekMsZUFBZTtBQUNidnVCLFNBQUssS0FBSzRwQixZQUFZLENBQUM3b0IsVUFBVUQsU0FBUztBQUN4QyxXQUFLcWtCLFNBQVNua0Isb0JBQW9CLE1BQU1GLE1BQU1DLFFBQUFBO0lBQ2hELENBQUE7QUFDQSxTQUFLNm9CLGFBQWEsQ0FBQTtBQUVsQjVwQixTQUFLLEtBQUs2cEIsc0JBQXNCLENBQUM5b0IsVUFBVUQsU0FBUztBQUNsRCxXQUFLcWtCLFNBQVNua0Isb0JBQW9CLE1BQU1GLE1BQU1DLFFBQUFBO0lBQ2hELENBQUE7QUFDQSxTQUFLOG9CLHVCQUF1QjltQjtFQUM5QjtFQUVBa3VCLGlCQUFpQno1QixPQUFPNnlCLE1BQU0zaEIsU0FBUztBQUNyQyxVQUFNd29CLFNBQVN4b0IsVUFBVSxRQUFRO0FBQ2pDLFFBQUlqUCxNQUFNMkYsTUFBTWxKLElBQUdDO0FBRW5CLFFBQUlrMEIsU0FBUyxXQUFXO0FBQ3RCNXdCLGFBQU8sS0FBS0MsZUFBZWxDLE1BQU0sQ0FBQSxFQUFHRyxZQUFZO0FBQ2hEOEIsV0FBSzdGLFdBQVcsTUFBTXM5QixTQUFTLG1CQUFvQixFQUFBOztBQUdyRCxTQUFLaDdCLEtBQUksR0FBR0MsT0FBT3FCLE1BQU1yRCxRQUFRK0IsS0FBSUMsTUFBTSxFQUFFRCxJQUFHO0FBQzlDa0osYUFBTzVILE1BQU10QixFQUFFO0FBQ2YsWUFBTXRDLGFBQWF3TCxRQUFRLEtBQUsxRixlQUFlMEYsS0FBS3pILFlBQVksRUFBRS9EO0FBQ2xFLFVBQUlBLFlBQVk7QUFDZEEsbUJBQVdzOUIsU0FBUyxZQUFBLEVBQWM5eEIsS0FBSzlJLFNBQVM4SSxLQUFLekgsY0FBY3lILEtBQUtoSixLQUFLOztJQUVqRjtFQUNGO0VBTUErNkIsb0JBQW9CO0FBQ2xCLFdBQU8sS0FBS3pILFdBQVcsQ0FBQTtFQUN6QjtFQU1BMEgsa0JBQWtCQyxnQkFBZ0I7QUFDaEMsVUFBTUMsYUFBYSxLQUFLNUgsV0FBVyxDQUFBO0FBQ25DLFVBQU12aUIsU0FBU2txQixlQUFldkYsSUFBSSxDQUFDLEVBQUNuMEIsY0FBY3ZCLE1BQUssTUFBTTtBQUMzRCxZQUFNcUQsT0FBTyxLQUFLQyxlQUFlL0IsWUFBQUE7QUFDakMsVUFBSSxDQUFDOEIsTUFBTTtBQUNULGNBQU0sSUFBSXBILE1BQU0sK0JBQStCc0YsWUFBYzs7QUFHL0QsYUFBTztRQUNMQTtRQUNBckIsU0FBU21ELEtBQUs1RixLQUFLdUMsS0FBTTtRQUN6QkE7TUFDRjtJQUNGLENBQUE7QUFDQSxVQUFNd0ksVUFBVSxDQUFDMnlCLGVBQWVwcUIsUUFBUW1xQixVQUFBQTtBQUV4QyxRQUFJMXlCLFNBQVM7QUFDWCxXQUFLOHFCLFVBQVV2aUI7QUFFZixXQUFLd2lCLGFBQWE7QUFDbEIsV0FBS3VFLG1CQUFtQi9tQixRQUFRbXFCLFVBQUFBOztFQUVwQztFQVdBL2UsY0FBY2tPLE1BQU05QixNQUFNNWtCLFNBQVE7QUFDaEMsV0FBTyxLQUFLZ3dCLFNBQVN2SixPQUFPLE1BQU1DLE1BQU05QixNQUFNNWtCLE9BQUFBO0VBQ2hEO0VBT0F5M0IsZ0JBQWdCQyxVQUFVO0FBQ3hCLFdBQU8sS0FBSzFILFNBQVNsYixPQUFPOVUsT0FBT3F0QixDQUFBQSxPQUFLQSxHQUFFdEcsT0FBT3BULE9BQU8rakIsUUFBQUEsRUFBVXQ5QixXQUFXO0VBQy9FO0VBS0ErNUIsbUJBQW1CL21CLFFBQVFtcUIsWUFBWUksUUFBUTtBQUM3QyxVQUFNQyxlQUFlLEtBQUtuL0IsUUFBUW8vQjtBQUNsQyxVQUFNeitCLE9BQU8sQ0FBQ21ILElBQUdDLE9BQU1ELEdBQUVQLE9BQU8vQyxDQUFBQSxPQUFLLENBQUN1RCxHQUFFaW5CLEtBQUt0cUIsQ0FBQUEsT0FBS0YsR0FBRVcsaUJBQWlCVCxHQUFFUyxnQkFBZ0JYLEdBQUVaLFVBQVVjLEdBQUVkLEtBQUssQ0FBQTtBQUMxRyxVQUFNeTdCLGNBQWMxK0IsS0FBS20rQixZQUFZbnFCLE1BQUFBO0FBQ3JDLFVBQU0ycUIsWUFBWUosU0FBU3ZxQixTQUFTaFUsS0FBS2dVLFFBQVFtcUIsVUFBVztBQUU1RCxRQUFJTyxZQUFZMTlCLFFBQVE7QUFDdEIsV0FBSzg4QixpQkFBaUJZLGFBQWFGLGFBQWF0SCxNQUFNLEtBQUs7O0FBRzdELFFBQUl5SCxVQUFVMzlCLFVBQVV3OUIsYUFBYXRILE1BQU07QUFDekMsV0FBSzRHLGlCQUFpQmEsV0FBV0gsYUFBYXRILE1BQU0sSUFBSTs7RUFFNUQ7RUFLQTRELGNBQWM1MEIsSUFBR3E0QixRQUFRO0FBQ3ZCLFVBQU0vUyxPQUFPO01BQ1huYixPQUFPbks7TUFDUHE0QjtNQUNBMVEsWUFBWTtNQUNaOEgsYUFBYSxLQUFLcnhCLGNBQWM0QixFQUFBQTtJQUNsQztBQUNBLFVBQU0wNEIsY0FBYyxDQUFDalIsWUFBWUEsT0FBT3R1QixRQUFRNjdCLFVBQVUsS0FBSzc3QixRQUFRNjdCLFFBQVEveUIsU0FBU2pDLEdBQUVvSyxPQUFPM0MsSUFBSTtBQUVyRyxRQUFJLEtBQUt5UixjQUFjLGVBQWVvTSxNQUFNb1QsV0FBQUEsTUFBaUIsT0FBTztBQUNsRTs7QUFHRixVQUFNbnpCLFVBQVUsS0FBS296QixhQUFhMzRCLElBQUdxNEIsUUFBUS9TLEtBQUttSyxXQUFXO0FBRTdEbkssU0FBS3FDLGFBQWE7QUFDbEIsU0FBS3pPLGNBQWMsY0FBY29NLE1BQU1vVCxXQUFBQTtBQUV2QyxRQUFJbnpCLFdBQVcrZixLQUFLL2YsU0FBUztBQUMzQixXQUFLMnNCLE9BQU07O0FBR2IsV0FBTztFQUNUO0VBVUF5RyxhQUFhMzRCLElBQUdxNEIsUUFBUTVJLGFBQWE7QUFDbkMsVUFBTSxFQUFDWSxTQUFTNEgsYUFBYSxDQUFBLEdBQUk5K0IsUUFBQUEsSUFBVztBQWU1QyxVQUFNOEUsbUJBQW1CbzZCO0FBQ3pCLFVBQU12cUIsU0FBUyxLQUFLOHFCLG1CQUFtQjU0QixJQUFHaTRCLFlBQVl4SSxhQUFheHhCLGdCQUFBQTtBQUNuRSxVQUFNeXhCLFVBQVVtSixjQUFjNzRCLEVBQUFBO0FBQzlCLFVBQU13dkIsWUFBWUQsbUJBQW1CdnZCLElBQUcsS0FBS3N3QixZQUFZYixhQUFhQyxPQUFBQTtBQUV0RSxRQUFJRCxhQUFhO0FBR2YsV0FBS2EsYUFBYTtBQUdsQjVJLGVBQWF2dUIsUUFBUTIvQixTQUFTO1FBQUM5NEI7UUFBRzhOO1FBQVE7TUFBSyxHQUFFLElBQUk7QUFFckQsVUFBSTRoQixTQUFTO0FBQ1hoSSxpQkFBYXZ1QixRQUFRNC9CLFNBQVM7VUFBQy80QjtVQUFHOE47VUFBUTtRQUFLLEdBQUUsSUFBSTs7O0FBSXpELFVBQU12SSxVQUFVLENBQUMyeUIsZUFBZXBxQixRQUFRbXFCLFVBQUFBO0FBQ3hDLFFBQUkxeUIsV0FBVzh5QixRQUFRO0FBQ3JCLFdBQUtoSSxVQUFVdmlCO0FBQ2YsV0FBSyttQixtQkFBbUIvbUIsUUFBUW1xQixZQUFZSSxNQUFBQTs7QUFHOUMsU0FBSy9ILGFBQWFkO0FBRWxCLFdBQU9qcUI7RUFDVDtFQVVBcXpCLG1CQUFtQjU0QixJQUFHaTRCLFlBQVl4SSxhQUFheHhCLGtCQUFrQjtBQUMvRCxRQUFJK0IsR0FBRXlILFNBQVMsWUFBWTtBQUN6QixhQUFPLENBQUE7O0FBR1QsUUFBSSxDQUFDZ29CLGFBQWE7QUFFaEIsYUFBT3dJOztBQUdULFVBQU1LLGVBQWUsS0FBS24vQixRQUFRby9CO0FBQ2xDLFdBQU8sS0FBS3BDLDBCQUEwQm4yQixJQUFHczRCLGFBQWF0SCxNQUFNc0gsY0FBY3I2QixnQkFBQUE7RUFDNUU7QUFDRjtBQXJvQ0UsY0FGSTB4QixPQUVHbmhCLFlBQVdBO0FBQ2xCLGNBSEltaEIsT0FHR1gsYUFBWUE7QUFDbkIsY0FKSVcsT0FJRzlMLGFBQVlBO0FBQ25CLGNBTEk4TCxPQUtHOUksWUFBV0E7QUFDbEIsY0FOSThJLE9BTUdxSixXQUFVQTtBQUNqQixjQVBJckosT0FPR1YsWUFBV0E7QUFtb0NwQixTQUFTVyxvQkFBb0I7QUFDM0IsU0FBT2pwQixLQUFLZ3BCLE1BQU1YLFdBQVcsQ0FBQ3h5QixVQUFVQSxNQUFNazBCLFNBQVM5SSxXQUFVLENBQUE7QUFDbkU7QUM1dUNBLFNBQVNxUixTQUFTcHNCLEtBQStCNVAsU0FBcUI0QixVQUFrQjtBQUN0RixRQUFNLEVBQUNELFlBQVlqQixHQUFBQSxJQUFHRSxHQUFBQSxJQUFHcTdCLGFBQWFDLGFBQWFoZ0MsUUFBQUEsSUFBVzhEO0FBQzlELFFBQU0sRUFBQ204QixhQUFhQyxnQkFBQUEsSUFBbUJsZ0M7QUFDdkMsUUFBTW1nQyxpQkFBaUJ6OUIsS0FBS29ULElBQUltcUIsY0FBY0YsYUFBYUssZ0JBQWdCMzZCLGFBQWFDLFFBQUFBLENBQUFBO0FBQ3hGZ08sTUFBSWlWLFVBQVM7QUFDYmpWLE1BQUkyc0IsSUFBSTc3QixJQUFHRSxJQUFHcTdCLGNBQWNFLGNBQWMsR0FBR3g2QixhQUFhMDZCLGlCQUFpQixHQUFHejZCLFdBQVd5NkIsaUJBQWlCLENBQUE7QUFFMUcsTUFBSUgsY0FBYyxHQUFHO0FBQ25CLFVBQU1NLGlCQUFpQjU5QixLQUFLb1QsSUFBSW1xQixjQUFjRCxhQUFhSSxnQkFBZ0IzNkIsYUFBYUMsUUFBQUEsQ0FBQUE7QUFDeEZnTyxRQUFJMnNCLElBQUk3N0IsSUFBR0UsSUFBR3M3QixjQUFjQyxjQUFjLEdBQUd2NkIsV0FBVzQ2QixpQkFBaUIsR0FBRzc2QixhQUFhNjZCLGlCQUFpQixHQUFHLElBQUk7U0FDNUc7QUFDTCxVQUFNQyxZQUFZNzlCLEtBQUtvVCxJQUFJbXFCLGNBQWMsR0FBR0YsY0FBY0ssZ0JBQWdCMzZCLGFBQWFDLFFBQUFBLENBQUFBO0FBRXZGLFFBQUl3NkIsb0JBQW9CLFNBQVM7QUFDL0J4c0IsVUFBSTJzQixJQUFJNzdCLElBQUdFLElBQUc2N0IsV0FBVzc2QixXQUFXODZCLEtBQUssR0FBRy82QixhQUFhKzZCLEtBQUssR0FBRyxJQUFJO2VBQzVETixvQkFBb0IsU0FBUztBQUN0QyxZQUFNTyxLQUFJLElBQUlGLFlBQVlBO0FBQzFCLFlBQU1HLE9BQU8sQ0FBQ0QsS0FBSS85QixLQUFLbWYsSUFBSW5jLFdBQVc4NkIsS0FBSyxDQUFLaDhCLElBQUFBO0FBQ2hELFlBQU1tOEIsT0FBTyxDQUFDRixLQUFJLzlCLEtBQUtvZixJQUFJcGMsV0FBVzg2QixLQUFLLENBQUs5N0IsSUFBQUE7QUFDaEQsWUFBTWs4QixTQUFTSCxLQUFJLzlCLEtBQUttZixJQUFJcGMsYUFBYSs2QixLQUFLLENBQUtoOEIsSUFBQUE7QUFDbkQsWUFBTXE4QixTQUFTSixLQUFJLzlCLEtBQUtvZixJQUFJcmMsYUFBYSs2QixLQUFLLENBQUs5N0IsSUFBQUE7QUFDbkRnUCxVQUFJbVYsT0FBTzZYLE1BQU1DLElBQUFBO0FBQ2pCanRCLFVBQUltVixPQUFPK1gsUUFBUUMsTUFBQUE7OztBQUd2Qm50QixNQUFJb3RCLFVBQVM7QUFFYnB0QixNQUFJa1YsT0FBTyxHQUFHLENBQUE7QUFDZGxWLE1BQUlxdEIsS0FBSyxHQUFHLEdBQUdydEIsSUFBSXpGLE9BQU92RSxPQUFPZ0ssSUFBSXpGLE9BQU9yRSxNQUFNO0FBRWxEOEosTUFBSW9wQixLQUFLLFNBQUE7QUFDWDtBQUdBLFNBQVNrRSxRQUFRdHRCLEtBQStCNVAsU0FBcUI0QixVQUFrQjtBQUNyRixRQUFNLEVBQUNELFlBQVl3N0IsYUFBYXo4QixHQUFBQSxJQUFHRSxHQUFBQSxJQUFHcTdCLGFBQWFDLFlBQUFBLElBQWVsOEI7QUFDbEUsTUFBSW85QixjQUFjRCxjQUFjbEI7QUFJaENyc0IsTUFBSWlWLFVBQVM7QUFDYmpWLE1BQUkyc0IsSUFBSTc3QixJQUFHRSxJQUFHcTdCLGFBQWF0NkIsYUFBYXk3QixhQUFheDdCLFdBQVd3N0IsV0FBQUE7QUFDaEUsTUFBSWxCLGNBQWNpQixhQUFhO0FBQzdCQyxrQkFBY0QsY0FBY2pCO0FBQzVCdHNCLFFBQUkyc0IsSUFBSTc3QixJQUFHRSxJQUFHczdCLGFBQWF0NkIsV0FBV3c3QixhQUFhejdCLGFBQWF5N0IsYUFBYSxJQUFJO1NBQzVFO0FBQ0x4dEIsUUFBSTJzQixJQUFJNzdCLElBQUdFLElBQUd1OEIsYUFBYXY3QixXQUFXcVYsU0FBU3RWLGFBQWFzVixPQUFBQTs7QUFFOURySCxNQUFJb3RCLFVBQVM7QUFDYnB0QixNQUFJb3BCLEtBQUk7QUFDVjtBQUVBLFNBQVNxRSxnQkFBZ0JqZ0MsT0FBTztBQUM5QixTQUFPa2dDLGtCQUFrQmxnQyxPQUFPO0lBQUM7SUFBYztJQUFZO0lBQWM7RUFBVyxDQUFBO0FBQ3RGO0FBS0EsU0FBU21nQyxvQkFBa0JoQixLQUFpQkwsYUFBcUJELGFBQXFCdUIsWUFBb0I7QUFDeEcsUUFBTUMsS0FBSUosZ0JBQWdCZCxJQUFJcmdDLFFBQVF3aEMsWUFBWTtBQUNsRCxRQUFNQyxpQkFBaUIxQixjQUFjQyxlQUFlO0FBQ3BELFFBQU0wQixhQUFhaC9CLEtBQUtvVCxJQUFJMnJCLGVBQWVILGFBQWF0QixjQUFjLENBQUE7QUFTdEUsUUFBTTJCLG9CQUFvQixDQUFDQyxRQUFRO0FBQ2pDLFVBQU1DLGlCQUFpQjlCLGNBQWNyOUIsS0FBS29ULElBQUkyckIsZUFBZUcsR0FBRyxLQUFLTixhQUFhO0FBQ2xGLFdBQU9yZ0IsWUFBWTJnQixLQUFLLEdBQUdsL0IsS0FBS29ULElBQUkyckIsZUFBZUksYUFBQUEsQ0FBQUE7RUFDckQ7QUFFQSxTQUFPO0lBQ0xDLFlBQVlILGtCQUFrQkosR0FBRU8sVUFBVTtJQUMxQ0MsVUFBVUosa0JBQWtCSixHQUFFUSxRQUFRO0lBQ3RDQyxZQUFZL2dCLFlBQVlzZ0IsR0FBRVMsWUFBWSxHQUFHTixVQUFBQTtJQUN6Q08sVUFBVWhoQixZQUFZc2dCLEdBQUVVLFVBQVUsR0FBR1AsVUFBQUE7RUFDdkM7QUFDRjtBQUtBLFNBQVNRLFdBQVd6QixJQUFXMEIsT0FBZTM5QixJQUFXRSxJQUFXO0FBQ2xFLFNBQU87SUFDTEYsR0FBR0EsS0FBSWk4QixLQUFJLzlCLEtBQUttZixJQUFJc2dCLEtBQUFBO0lBQ3BCejlCLEdBQUdBLEtBQUkrN0IsS0FBSS85QixLQUFLb2YsSUFBSXFnQixLQUFBQTtFQUN0QjtBQUNGO0FBaUJBLFNBQVNDLFFBQ1AxdUIsS0FDQTVQLFNBQ0ErUyxRQUNBSixTQUNBdFQsS0FDQWsvQixVQUNBO0FBQ0EsUUFBTSxFQUFDNzlCLEdBQUFBLElBQUdFLEdBQUFBLElBQUdlLFlBQVl2QyxPQUFPKzlCLGFBQWFqQixhQUFhc0MsT0FBQUEsSUFBVXgrQjtBQUVwRSxRQUFNaThCLGNBQWNyOUIsS0FBS0MsSUFBSW1CLFFBQVFpOEIsY0FBY3RwQixVQUFVSSxTQUFTb3FCLGFBQWEsQ0FBQTtBQUNuRixRQUFNakIsY0FBY3NDLFNBQVMsSUFBSUEsU0FBUzdyQixVQUFVSSxTQUFTb3FCLGNBQWM7QUFFM0UsTUFBSXNCLGdCQUFnQjtBQUNwQixRQUFNQyxTQUFRci9CLE1BQU1EO0FBRXBCLE1BQUl1VCxTQUFTO0FBSVgsVUFBTWdzQix1QkFBdUJILFNBQVMsSUFBSUEsU0FBUzdyQixVQUFVO0FBQzdELFVBQU1pc0IsdUJBQXVCM0MsY0FBYyxJQUFJQSxjQUFjdHBCLFVBQVU7QUFDdkUsVUFBTWtzQixzQkFBc0JGLHVCQUF1QkMsd0JBQXdCO0FBQzNFLFVBQU1FLGdCQUFnQkQsdUJBQXVCLElBQUlILFNBQVNHLHNCQUF1QkEscUJBQXFCbHNCLFdBQVcrckI7QUFDakhELHFCQUFpQkMsU0FBUUksaUJBQWlCOztBQUc1QyxRQUFNQyxPQUFPbmdDLEtBQUtDLElBQUksTUFBTzYvQixTQUFRekMsY0FBY2xwQixTQUFTMnBCLEVBQU1ULElBQUFBO0FBQ2xFLFFBQU0rQyxlQUFlTixTQUFRSyxRQUFRO0FBQ3JDLFFBQU1wOUIsYUFBYXZDLFFBQVE0L0IsY0FBY1A7QUFDekMsUUFBTTc4QixXQUFXdkMsTUFBTTIvQixjQUFjUDtBQUNyQyxRQUFNLEVBQUNULFlBQVlDLFVBQVVDLFlBQVlDLFNBQVEsSUFBSVosb0JBQWtCdjlCLFNBQVNrOEIsYUFBYUQsYUFBYXI2QixXQUFXRCxVQUFBQTtBQUVySCxRQUFNczlCLDJCQUEyQmhELGNBQWMrQjtBQUMvQyxRQUFNa0IseUJBQXlCakQsY0FBY2dDO0FBQzdDLFFBQU1rQiwwQkFBMEJ4OUIsYUFBYXE4QixhQUFhaUI7QUFDMUQsUUFBTUcsd0JBQXdCeDlCLFdBQVdxOEIsV0FBV2lCO0FBRXBELFFBQU1HLDJCQUEyQm5ELGNBQWNnQztBQUMvQyxRQUFNb0IseUJBQXlCcEQsY0FBY2lDO0FBQzdDLFFBQU1vQiwwQkFBMEI1OUIsYUFBYXU4QixhQUFhbUI7QUFDMUQsUUFBTUcsd0JBQXdCNTlCLFdBQVd1OEIsV0FBV21CO0FBRXBEMXZCLE1BQUlpVixVQUFTO0FBRWIsTUFBSTBaLFVBQVU7QUFFWixVQUFNa0IseUJBQXlCTiwwQkFBMEJDLHlCQUF5QjtBQUNsRnh2QixRQUFJMnNCLElBQUk3N0IsSUFBR0UsSUFBR3E3QixhQUFha0QseUJBQXlCTSxxQkFBQUE7QUFDcEQ3dkIsUUFBSTJzQixJQUFJNzdCLElBQUdFLElBQUdxN0IsYUFBYXdELHVCQUF1QkwscUJBQUFBO0FBR2xELFFBQUluQixXQUFXLEdBQUc7QUFDaEIsWUFBTXlCLFVBQVV0QixXQUFXYyx3QkFBd0JFLHVCQUF1QjErQixJQUFHRSxFQUFBQTtBQUM3RWdQLFVBQUkyc0IsSUFBSW1ELFFBQVFoL0IsR0FBR2cvQixRQUFROStCLEdBQUdxOUIsVUFBVW1CLHVCQUF1Qng5QixXQUFXcVYsT0FBQUE7O0FBSTVFLFVBQU0wb0IsS0FBS3ZCLFdBQVdrQix3QkFBd0IxOUIsVUFBVWxCLElBQUdFLEVBQUFBO0FBQzNEZ1AsUUFBSW1WLE9BQU80YSxHQUFHai9CLEdBQUdpL0IsR0FBRy8rQixDQUFDO0FBR3JCLFFBQUl1OUIsV0FBVyxHQUFHO0FBQ2hCLFlBQU11QixVQUFVdEIsV0FBV2tCLHdCQUF3QkUsdUJBQXVCOStCLElBQUdFLEVBQUFBO0FBQzdFZ1AsVUFBSTJzQixJQUFJbUQsUUFBUWgvQixHQUFHZy9CLFFBQVE5K0IsR0FBR3U5QixVQUFVdjhCLFdBQVdxVixTQUFTdW9CLHdCQUF3QjVnQyxLQUFLODlCLEVBQUU7O0FBSTdGLFVBQU1rRCx5QkFBMEJoK0IsV0FBWXU4QixXQUFXakMsZUFBaUJ2NkIsYUFBY3U4QixhQUFhaEMsZ0JBQWlCO0FBQ3BIdHNCLFFBQUkyc0IsSUFBSTc3QixJQUFHRSxJQUFHczdCLGFBQWF0NkIsV0FBWXU4QixXQUFXakMsYUFBYzBELHVCQUF1QixJQUFJO0FBQzNGaHdCLFFBQUkyc0IsSUFBSTc3QixJQUFHRSxJQUFHczdCLGFBQWEwRCx1QkFBdUJqK0IsYUFBY3U4QixhQUFhaEMsYUFBYyxJQUFJO0FBRy9GLFFBQUlnQyxhQUFhLEdBQUc7QUFDbEIsWUFBTXdCLFVBQVV0QixXQUFXaUIsMEJBQTBCRSx5QkFBeUI3K0IsSUFBR0UsRUFBQUE7QUFDakZnUCxVQUFJMnNCLElBQUltRCxRQUFRaC9CLEdBQUdnL0IsUUFBUTkrQixHQUFHczlCLFlBQVlxQiwwQkFBMEIzZ0MsS0FBSzg5QixJQUFJLzZCLGFBQWFzVixPQUFBQTs7QUFJNUYsVUFBTTRvQixLQUFLekIsV0FBV2EsMEJBQTBCdDlCLFlBQVlqQixJQUFHRSxFQUFBQTtBQUMvRGdQLFFBQUltVixPQUFPOGEsR0FBR24vQixHQUFHbS9CLEdBQUdqL0IsQ0FBQztBQUdyQixRQUFJbzlCLGFBQWEsR0FBRztBQUNsQixZQUFNMEIsVUFBVXRCLFdBQVdhLDBCQUEwQkUseUJBQXlCeitCLElBQUdFLEVBQUFBO0FBQ2pGZ1AsVUFBSTJzQixJQUFJbUQsUUFBUWgvQixHQUFHZy9CLFFBQVE5K0IsR0FBR285QixZQUFZcjhCLGFBQWFzVixTQUFTa29CLHVCQUFBQTs7U0FFN0Q7QUFDTHZ2QixRQUFJa1YsT0FBT3BrQixJQUFHRSxFQUFBQTtBQUVkLFVBQU1rL0IsY0FBY2xoQyxLQUFLbWYsSUFBSW9oQix1QkFBQUEsSUFBMkJsRCxjQUFjdjdCO0FBQ3RFLFVBQU1xL0IsY0FBY25oQyxLQUFLb2YsSUFBSW1oQix1QkFBQUEsSUFBMkJsRCxjQUFjcjdCO0FBQ3RFZ1AsUUFBSW1WLE9BQU8rYSxhQUFhQyxXQUFBQTtBQUV4QixVQUFNQyxZQUFZcGhDLEtBQUttZixJQUFJcWhCLHFCQUFBQSxJQUF5Qm5ELGNBQWN2N0I7QUFDbEUsVUFBTXUvQixZQUFZcmhDLEtBQUtvZixJQUFJb2hCLHFCQUFBQSxJQUF5Qm5ELGNBQWNyN0I7QUFDbEVnUCxRQUFJbVYsT0FBT2liLFdBQVdDLFNBQUFBOztBQUd4QnJ3QixNQUFJb3RCLFVBQVM7QUFDZjtBQUVBLFNBQVNrRCxRQUNQdHdCLEtBQ0E1UCxTQUNBK1MsUUFDQUosU0FDQTRyQixVQUNBO0FBQ0EsUUFBTSxFQUFDNEIsYUFBYXgrQixZQUFZeStCLGNBQUFBLElBQWlCcGdDO0FBQ2pELE1BQUk0QixXQUFXNUIsUUFBUTRCO0FBQ3ZCLE1BQUl1K0IsYUFBYTtBQUNmN0IsWUFBUTF1QixLQUFLNVAsU0FBUytTLFFBQVFKLFNBQVMvUSxVQUFVMjhCLFFBQUFBO0FBQ2pELGFBQVMzK0IsS0FBSSxHQUFHQSxLQUFJdWdDLGFBQWEsRUFBRXZnQyxJQUFHO0FBQ3BDZ1EsVUFBSXl3QixLQUFJO0lBQ1Y7QUFDQSxRQUFJLENBQUNDLE1BQU1GLGFBQWdCLEdBQUE7QUFDekJ4K0IsaUJBQVdELGNBQWN5K0IsZ0JBQWdCRyxPQUFPQTs7O0FBR3BEakMsVUFBUTF1QixLQUFLNVAsU0FBUytTLFFBQVFKLFNBQVMvUSxVQUFVMjhCLFFBQUFBO0FBQ2pEM3VCLE1BQUl5d0IsS0FBSTtBQUNSLFNBQU96K0I7QUFDVDtBQUVBLFNBQVNzakIsV0FDUHRWLEtBQ0E1UCxTQUNBK1MsUUFDQUosU0FDQTRyQixVQUNBO0FBQ0EsUUFBTSxFQUFDNEIsYUFBYXgrQixZQUFZeStCLGVBQWVsa0MsUUFBTyxJQUFJOEQ7QUFDMUQsUUFBTSxFQUFDbThCLGFBQWFDLGlCQUFpQnJhLFlBQVlFLGtCQUFrQnliLGFBQVksSUFBSXhoQztBQUNuRixRQUFNc2tDLFFBQVF0a0MsUUFBUXVrQyxnQkFBZ0I7QUFFdEMsTUFBSSxDQUFDdEUsYUFBYTtBQUNoQjs7QUFHRnZzQixNQUFJK1UsWUFBWTVDLGNBQWMsQ0FBQSxDQUFFO0FBQ2hDblMsTUFBSWdWLGlCQUFpQjNDO0FBRXJCLE1BQUl1ZSxPQUFPO0FBQ1Q1d0IsUUFBSWdTLFlBQVl1YSxjQUFjO0FBQzlCdnNCLFFBQUk4d0IsV0FBV3RFLG1CQUFtQjtTQUM3QjtBQUNMeHNCLFFBQUlnUyxZQUFZdWE7QUFDaEJ2c0IsUUFBSTh3QixXQUFXdEUsbUJBQW1COztBQUdwQyxNQUFJeDZCLFdBQVc1QixRQUFRNEI7QUFDdkIsTUFBSXUrQixhQUFhO0FBQ2Y3QixZQUFRMXVCLEtBQUs1UCxTQUFTK1MsUUFBUUosU0FBUy9RLFVBQVUyOEIsUUFBQUE7QUFDakQsYUFBUzMrQixLQUFJLEdBQUdBLEtBQUl1Z0MsYUFBYSxFQUFFdmdDLElBQUc7QUFDcENnUSxVQUFJb1YsT0FBTTtJQUNaO0FBQ0EsUUFBSSxDQUFDc2IsTUFBTUYsYUFBZ0IsR0FBQTtBQUN6QngrQixpQkFBV0QsY0FBY3krQixnQkFBZ0JHLE9BQU9BOzs7QUFJcEQsTUFBSUMsT0FBTztBQUNUdEQsWUFBUXR0QixLQUFLNVAsU0FBUzRCLFFBQUFBOztBQUd4QixNQUFJMUYsUUFBUXlrQyxZQUFZLytCLFdBQVdELGNBQWMrNkIsTUFBTWdCLGlCQUFpQixLQUFLdEIsb0JBQW9CLFNBQVM7QUFDeEdKLGFBQVNwc0IsS0FBSzVQLFNBQVM0QixRQUFBQTs7QUFHekIsTUFBSSxDQUFDdStCLGFBQWE7QUFDaEI3QixZQUFRMXVCLEtBQUs1UCxTQUFTK1MsUUFBUUosU0FBUy9RLFVBQVUyOEIsUUFBQUE7QUFDakQzdUIsUUFBSW9WLE9BQU07O0FBRWQ7QUFVZSxJQUFNNGIsYUFBTixjQUF5Qmh3QixRQUFBQTtFQW9DdEMzVSxZQUFZa2IsS0FBSztBQUNmLFVBQUs7QUFUUGlwQjtBQUNBeCtCO0FBQ0F1K0I7QUFDQWpFO0FBQ0FEO0FBQ0FrQjtBQUNBeDdCO0FBS0UsU0FBS3pGLFVBQVV1UTtBQUNmLFNBQUsyekIsZ0JBQWdCM3pCO0FBQ3JCLFNBQUs5SyxhQUFhOEs7QUFDbEIsU0FBSzdLLFdBQVc2SztBQUNoQixTQUFLeXZCLGNBQWN6dkI7QUFDbkIsU0FBS3d2QixjQUFjeHZCO0FBQ25CLFNBQUswd0IsY0FBYztBQUNuQixTQUFLZ0QsY0FBYztBQUVuQixRQUFJaHBCLEtBQUs7QUFDUDlhLGFBQU9DLE9BQU8sTUFBTTZhLEdBQUFBOztFQUV4QjtFQUVBM1YsUUFBUXEvQixRQUFnQkMsUUFBZ0I5L0Isa0JBQTJCO0FBQ2pFLFVBQU10QyxRQUFRLEtBQUttRCxTQUFTO01BQUM7TUFBSztPQUFNYixnQkFBQUE7QUFDeEMsVUFBTSxFQUFDYyxPQUFPVyxTQUFBQSxJQUFZVixrQkFBa0JyRCxPQUFPO01BQUNnQyxHQUFHbWdDO01BQVFqZ0MsR0FBR2tnQztJQUFNLENBQUE7QUFDeEUsVUFBTSxFQUFDbi9CLFlBQVlDLFVBQVVzNkIsYUFBYUQsYUFBYW1FLGNBQUFBLElBQWlCLEtBQUt2K0IsU0FBUztNQUNwRjtNQUNBO01BQ0E7TUFDQTtNQUNBO09BQ0NiLGdCQUFBQTtBQUNILFVBQU0rL0IsV0FBVyxLQUFLN2tDLFFBQVF5VyxVQUFVLEtBQUt6VyxRQUFRaWdDLGVBQWU7QUFDcEUsVUFBTTZFLGlCQUFpQmx0QixlQUFlc3NCLGVBQWV4K0IsV0FBV0QsVUFBQUE7QUFDaEUsVUFBTXMvQixpQkFBaUJqL0IsY0FBY0YsT0FBT0gsWUFBWUMsUUFBQUEsS0FBYUQsZUFBZUM7QUFDcEYsVUFBTXMvQixnQkFBZ0JGLGtCQUFrQlQsT0FBT1U7QUFDL0MsVUFBTUUsZUFBZUMsV0FBVzMrQixVQUFVeTVCLGNBQWM2RSxTQUFTOUUsY0FBYzhFLE9BQUFBO0FBRS9FLFdBQVFHLGlCQUFpQkM7RUFDM0I7RUFFQTUrQixlQUFldkIsa0JBQTJCO0FBQ3hDLFVBQU0sRUFBQ04sR0FBQUEsSUFBR0UsR0FBQUEsSUFBR2UsWUFBWUMsVUFBVXM2QixhQUFhRCxZQUFXLElBQUksS0FBS3A2QixTQUFTO01BQzNFO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtPQUNDYixnQkFBQUE7QUFDSCxVQUFNLEVBQUMrUixRQUFRSixRQUFBQSxJQUFXLEtBQUt6VztBQUMvQixVQUFNbWxDLGFBQWExL0IsYUFBYUMsWUFBWTtBQUM1QyxVQUFNMC9CLGNBQWNwRixjQUFjRCxjQUFjdHBCLFVBQVVJLFVBQVU7QUFDcEUsV0FBTztNQUNMclMsR0FBR0EsS0FBSTlCLEtBQUttZixJQUFJc2pCLFNBQWFDLElBQUFBO01BQzdCMWdDLEdBQUdBLEtBQUloQyxLQUFLb2YsSUFBSXFqQixTQUFhQyxJQUFBQTtJQUMvQjtFQUNGO0VBRUF2d0IsZ0JBQWdCL1Asa0JBQTJCO0FBQ3pDLFdBQU8sS0FBS3VCLGVBQWV2QixnQkFBQUE7RUFDN0I7RUFFQWlJLEtBQUsyRyxLQUErQjtBQUNsQyxVQUFNLEVBQUMxVCxTQUFTa2tDLGNBQWEsSUFBSTtBQUNqQyxVQUFNcnRCLFVBQVU3VyxRQUFRNlcsVUFBVSxLQUFLO0FBQ3ZDLFVBQU1KLFdBQVd6VyxRQUFReVcsV0FBVyxLQUFLO0FBQ3pDLFVBQU00ckIsV0FBV3JpQyxRQUFRcWlDO0FBQ3pCLFNBQUtwQixjQUFlamhDLFFBQVF1a0MsZ0JBQWdCLFVBQVcsT0FBTztBQUM5RCxTQUFLTixjQUFjQyxnQkFBZ0JHLE1BQU0zaEMsS0FBS2lNLE1BQU11MUIsZ0JBQWdCRyxHQUFBQSxJQUFPO0FBRTNFLFFBQUlILGtCQUFrQixLQUFLLEtBQUtsRSxjQUFjLEtBQUssS0FBS0QsY0FBYyxHQUFHO0FBQ3ZFOztBQUdGcnNCLFFBQUltVSxLQUFJO0FBRVIsVUFBTXNkLGFBQWEsS0FBSzEvQixhQUFhLEtBQUtDLFlBQVk7QUFDdERnTyxRQUFJMnhCLFVBQVUzaUMsS0FBS21mLElBQUlzakIsU0FBQUEsSUFBYXR1QixRQUFRblUsS0FBS29mLElBQUlxakIsU0FBYXR1QixJQUFBQSxNQUFBQTtBQUNsRSxVQUFNeXVCLE1BQU0sSUFBSTVpQyxLQUFLb2YsSUFBSXBmLEtBQUtvVCxJQUFJMHFCLElBQUkwRCxpQkFBaUIsQ0FBQSxDQUFBO0FBQ3ZELFVBQU1xQixlQUFlMXVCLFNBQVN5dUI7QUFFOUI1eEIsUUFBSW9VLFlBQVk5bkIsUUFBUTRuQjtBQUN4QmxVLFFBQUk4VSxjQUFjeG9CLFFBQVF3bEM7QUFFMUJ4QixZQUFRdHdCLEtBQUssTUFBTTZ4QixjQUFjOXVCLFNBQVM0ckIsUUFBQUE7QUFDMUNyWixlQUFXdFYsS0FBSyxNQUFNNnhCLGNBQWM5dUIsU0FBUzRyQixRQUFBQTtBQUU3QzN1QixRQUFJc1UsUUFBTztFQUNiO0FBQ0Y7QUF2SEUsY0FGbUIwYyxZQUVaeHBCLE1BQUs7QUFFWixjQUptQndwQixZQUlacnZCLFlBQVc7RUFDaEJrdkIsYUFBYTtFQUNiaUIsYUFBYTtFQUNiM2YsWUFBWSxDQUFBO0VBQ1pFLGtCQUFrQjtFQUNsQm1hLGlCQUFpQjN2QjtFQUNqQml4QixjQUFjO0VBQ2R2QixhQUFhO0VBQ2JwcEIsUUFBUTtFQUNSSixTQUFTO0VBQ1Q3USxPQUFPMks7RUFDUDh4QixVQUFVO0VBQ1ZvQyxVQUFVOztBQUdaLGNBbkJtQkMsWUFtQlpwdkIsaUJBQWdCO0VBQ3JCc1MsaUJBQWlCOztBQUduQixjQXZCbUI4YyxZQXVCWjFaLGVBQWM7RUFDbkJ5YSxhQUFhO0VBQ2JDLFlBQVksQ0FBQzVsQixTQUFTQSxTQUFTOztBR3RUbkMsU0FBUzZsQixhQUFhQyxLQUFLQyxrQkFBa0I7QUFDM0MsUUFBTSxFQUFDQyxHQUFBQSxJQUFHQyxHQUFBQSxJQUFHQyxNQUFNQyxPQUFPQyxPQUFBQSxJQUFtQ04sSUFBSU8sU0FBUztJQUFDO0lBQUs7SUFBSztJQUFRO0lBQVM7S0FBV04sZ0JBQUFBO0FBRWpILE1BQUlPLE1BQU1DLE9BQU9DLEtBQUtDLFFBQVFDO0FBRTlCLE1BQUlaLElBQUlhLFlBQVk7QUFDbEJELFdBQU9OLFNBQVM7QUFDaEJFLFdBQU9NLEtBQUtDLElBQUliLElBQUdFLElBQUFBO0FBQ25CSyxZQUFRSyxLQUFLRSxJQUFJZCxJQUFHRSxJQUFBQTtBQUNwQk0sVUFBTVAsS0FBSVM7QUFDVkQsYUFBU1IsS0FBSVM7U0FDUjtBQUNMQSxXQUFPUCxRQUFRO0FBQ2ZHLFdBQU9OLEtBQUlVO0FBQ1hILFlBQVFQLEtBQUlVO0FBQ1pGLFVBQU1JLEtBQUtDLElBQUlaLElBQUdDLElBQUFBO0FBQ2xCTyxhQUFTRyxLQUFLRSxJQUFJYixJQUFHQyxJQUFBQTs7QUFHdkIsU0FBTztJQUFDSTtJQUFNRTtJQUFLRDtJQUFPRTtFQUFNO0FBQ2xDO0FBRUEsU0FBU00sWUFBWUMsT0FBTUMsT0FBT0osS0FBS0MsS0FBSztBQUMxQyxTQUFPRSxRQUFPLElBQUlFLFlBQVlELE9BQU9KLEtBQUtDLEdBQUk7QUFDaEQ7QUFFQSxTQUFTSyxpQkFBaUJyQixLQUFLc0IsTUFBTUMsTUFBTTtBQUN6QyxRQUFNSixRQUFRbkIsSUFBSXdCLFFBQVFDO0FBQzFCLFFBQU1QLFFBQU9sQixJQUFJMEI7QUFDakIsUUFBTUMsS0FBSUMsT0FBT1QsS0FBQUE7QUFFakIsU0FBTztJQUNMVSxHQUFHWixZQUFZQyxNQUFLUixLQUFLaUIsR0FBRWpCLEtBQUssR0FBR2EsSUFBQUE7SUFDbkNPLEdBQUdiLFlBQVlDLE1BQUtULE9BQU9rQixHQUFFbEIsT0FBTyxHQUFHYSxJQUFBQTtJQUN2Q1MsR0FBR2QsWUFBWUMsTUFBS1AsUUFBUWdCLEdBQUVoQixRQUFRLEdBQUdZLElBQUFBO0lBQ3pDUyxHQUFHZixZQUFZQyxNQUFLVixNQUFNbUIsR0FBRW5CLE1BQU0sR0FBR2MsSUFBQUE7RUFDdkM7QUFDRjtBQUVBLFNBQVNXLGtCQUFrQmpDLEtBQUtzQixNQUFNQyxNQUFNO0FBQzFDLFFBQU0sRUFBQ1csbUJBQWtCLElBQUlsQyxJQUFJTyxTQUFTO0lBQUM7RUFBcUIsQ0FBQTtBQUNoRSxRQUFNWSxRQUFRbkIsSUFBSXdCLFFBQVFXO0FBQzFCLFFBQU1SLEtBQUlTLGNBQWNqQixLQUFBQTtBQUN4QixRQUFNa0IsT0FBT3ZCLEtBQUtDLElBQUlPLE1BQU1DLElBQUFBO0FBQzVCLFFBQU1MLFFBQU9sQixJQUFJMEI7QUFJakIsUUFBTVksZUFBZUosc0JBQXNCSyxTQUFTcEIsS0FBQUE7QUFFcEQsU0FBTztJQUNMcUIsU0FBU3ZCLFlBQVksQ0FBQ3FCLGdCQUFnQnBCLE1BQUtSLE9BQU9RLE1BQUtWLE1BQU1tQixHQUFFYSxTQUFTLEdBQUdILElBQUFBO0lBQzNFSSxVQUFVeEIsWUFBWSxDQUFDcUIsZ0JBQWdCcEIsTUFBS1IsT0FBT1EsTUFBS1QsT0FBT2tCLEdBQUVjLFVBQVUsR0FBR0osSUFBQUE7SUFDOUVLLFlBQVl6QixZQUFZLENBQUNxQixnQkFBZ0JwQixNQUFLUCxVQUFVTyxNQUFLVixNQUFNbUIsR0FBRWUsWUFBWSxHQUFHTCxJQUFBQTtJQUNwRk0sYUFBYTFCLFlBQVksQ0FBQ3FCLGdCQUFnQnBCLE1BQUtQLFVBQVVPLE1BQUtULE9BQU9rQixHQUFFZ0IsYUFBYSxHQUFHTixJQUFBQTtFQUN6RjtBQUNGO0FBRUEsU0FBU08sY0FBYzVDLEtBQUs7QUFDMUIsUUFBTTZDLFNBQVM5QyxhQUFhQyxHQUFBQTtBQUM1QixRQUFNSyxRQUFRd0MsT0FBT3BDLFFBQVFvQyxPQUFPckM7QUFDcEMsUUFBTUYsU0FBU3VDLE9BQU9sQyxTQUFTa0MsT0FBT25DO0FBQ3RDLFFBQU1vQyxTQUFTekIsaUJBQWlCckIsS0FBS0ssUUFBUSxHQUFHQyxTQUFTLENBQUE7QUFDekQsUUFBTXlDLFNBQVNkLGtCQUFrQmpDLEtBQUtLLFFBQVEsR0FBR0MsU0FBUyxDQUFBO0FBRTFELFNBQU87SUFDTDBDLE9BQU87TUFDTDlDLEdBQUcyQyxPQUFPckM7TUFDVkwsR0FBRzBDLE9BQU9uQztNQUNWdUMsR0FBRzVDO01BQ0g2QyxHQUFHNUM7TUFDSHlDO0lBQ0Y7SUFDQUksT0FBTztNQUNMakQsR0FBRzJDLE9BQU9yQyxPQUFPc0MsT0FBT2Q7TUFDeEI3QixHQUFHMEMsT0FBT25DLE1BQU1vQyxPQUFPakI7TUFDdkJvQixHQUFHNUMsUUFBUXlDLE9BQU9kLElBQUljLE9BQU9oQjtNQUM3Qm9CLEdBQUc1QyxTQUFTd0MsT0FBT2pCLElBQUlpQixPQUFPZjtNQUM5QmdCLFFBQVE7UUFDTlAsU0FBUzFCLEtBQUtFLElBQUksR0FBRytCLE9BQU9QLFVBQVUxQixLQUFLRSxJQUFJOEIsT0FBT2pCLEdBQUdpQixPQUFPZCxDQUFDLENBQUE7UUFDakVTLFVBQVUzQixLQUFLRSxJQUFJLEdBQUcrQixPQUFPTixXQUFXM0IsS0FBS0UsSUFBSThCLE9BQU9qQixHQUFHaUIsT0FBT2hCLENBQUMsQ0FBQTtRQUNuRVksWUFBWTVCLEtBQUtFLElBQUksR0FBRytCLE9BQU9MLGFBQWE1QixLQUFLRSxJQUFJOEIsT0FBT2YsR0FBR2UsT0FBT2QsQ0FBQyxDQUFBO1FBQ3ZFVyxhQUFhN0IsS0FBS0UsSUFBSSxHQUFHK0IsT0FBT0osY0FBYzdCLEtBQUtFLElBQUk4QixPQUFPZixHQUFHZSxPQUFPaEIsQ0FBQyxDQUFBO01BQzNFO0lBQ0Y7RUFDRjtBQUNGO0FBRUEsU0FBU3NCLFFBQVFwRCxLQUFLRSxJQUFHQyxJQUFHRixrQkFBa0I7QUFDNUMsUUFBTW9ELFFBQVFuRCxPQUFNO0FBQ3BCLFFBQU1vRCxRQUFRbkQsT0FBTTtBQUNwQixRQUFNb0QsV0FBV0YsU0FBU0M7QUFDMUIsUUFBTVQsU0FBUzdDLE9BQU8sQ0FBQ3VELFlBQVl4RCxhQUFhQyxLQUFLQyxnQkFBQUE7QUFFckQsU0FBTzRDLFdBQ0hRLFNBQVNHLFdBQVd0RCxJQUFHMkMsT0FBT3JDLE1BQU1xQyxPQUFPcEMsS0FBSyxPQUNoRDZDLFNBQVNFLFdBQVdyRCxJQUFHMEMsT0FBT25DLEtBQUttQyxPQUFPbEMsTUFBTTtBQUN0RDtBQUVBLFNBQVM4QyxVQUFVVixRQUFRO0FBQ3pCLFNBQU9BLE9BQU9QLFdBQVdPLE9BQU9OLFlBQVlNLE9BQU9MLGNBQWNLLE9BQU9KO0FBQzFFO0FBT0EsU0FBU2Usa0JBQWtCQyxLQUFLQyxNQUFNO0FBQ3BDRCxNQUFJQyxLQUFLQSxLQUFLMUQsR0FBRzBELEtBQUt6RCxHQUFHeUQsS0FBS1gsR0FBR1csS0FBS1YsQ0FBQztBQUN6QztBQUVBLFNBQVNXLFlBQVlELE1BQU1FLFFBQVFDLFVBQVUsQ0FBQSxHQUFJO0FBQy9DLFFBQU03RCxLQUFJMEQsS0FBSzFELE1BQU02RCxRQUFRN0QsSUFBSSxDQUFDNEQsU0FBUztBQUMzQyxRQUFNM0QsS0FBSXlELEtBQUt6RCxNQUFNNEQsUUFBUTVELElBQUksQ0FBQzJELFNBQVM7QUFDM0MsUUFBTWIsTUFBS1csS0FBSzFELElBQUkwRCxLQUFLWCxNQUFNYyxRQUFRN0QsSUFBSTZELFFBQVFkLElBQUlhLFNBQVMsS0FBSzVEO0FBQ3JFLFFBQU1nRCxNQUFLVSxLQUFLekQsSUFBSXlELEtBQUtWLE1BQU1hLFFBQVE1RCxJQUFJNEQsUUFBUWIsSUFBSVksU0FBUyxLQUFLM0Q7QUFDckUsU0FBTztJQUNMRCxHQUFHMEQsS0FBSzFELElBQUlBO0lBQ1pDLEdBQUd5RCxLQUFLekQsSUFBSUE7SUFDWjhDLEdBQUdXLEtBQUtYLElBQUlBO0lBQ1pDLEdBQUdVLEtBQUtWLElBQUlBO0lBQ1pILFFBQVFhLEtBQUtiO0VBQ2Y7QUFDRjtBQUVlLElBQU1pQixhQUFOLGNBQXlCQyxRQUFBQTtFQXVCdENDLFlBQVlDLEtBQUs7QUFDZixVQUFLO0FBRUwsU0FBSzNDLFVBQVU0QztBQUNmLFNBQUt2RCxhQUFhdUQ7QUFDbEIsU0FBS2hFLE9BQU9nRTtBQUNaLFNBQUsvRCxRQUFRK0Q7QUFDYixTQUFLOUQsU0FBUzhEO0FBQ2QsU0FBS0MsZ0JBQWdCRDtBQUVyQixRQUFJRCxLQUFLO0FBQ1BHLGFBQU9DLE9BQU8sTUFBTUosR0FBQUE7O0VBRXhCO0VBRUFLLEtBQUtiLEtBQUs7QUFDUixVQUFNLEVBQUNVLGVBQWU3QyxTQUFTLEVBQUNpRCxhQUFhQyxnQkFBQUEsRUFBZ0IsSUFBSTtBQUNqRSxVQUFNLEVBQUN2QixPQUFPSCxNQUFBQSxJQUFTSixjQUFjLElBQUk7QUFDekMsVUFBTStCLGNBQWNsQixVQUFVVCxNQUFNRCxNQUFNLElBQUk2QixxQkFBcUJsQjtBQUVuRUMsUUFBSWtCLEtBQUk7QUFFUixRQUFJN0IsTUFBTUMsTUFBTUUsTUFBTUYsS0FBS0QsTUFBTUUsTUFBTUMsTUFBTUQsR0FBRztBQUM5Q1MsVUFBSW1CLFVBQVM7QUFDYkgsa0JBQVloQixLQUFLRSxZQUFZYixPQUFPcUIsZUFBZWxCLEtBQUFBLENBQUFBO0FBQ25EUSxVQUFJb0IsS0FBSTtBQUNSSixrQkFBWWhCLEtBQUtFLFlBQVlWLE9BQU8sQ0FBQ2tCLGVBQWVyQixLQUFBQSxDQUFBQTtBQUNwRFcsVUFBSXFCLFlBQVlQO0FBQ2hCZCxVQUFJc0IsS0FBSyxTQUFBOztBQUdYdEIsUUFBSW1CLFVBQVM7QUFDYkgsZ0JBQVloQixLQUFLRSxZQUFZVixPQUFPa0IsYUFBQUEsQ0FBQUE7QUFDcENWLFFBQUlxQixZQUFZTjtBQUNoQmYsUUFBSXNCLEtBQUk7QUFFUnRCLFFBQUl1QixRQUFPO0VBQ2I7RUFFQTlCLFFBQVErQixRQUFRQyxRQUFRbkYsa0JBQWtCO0FBQ3hDLFdBQU9tRCxRQUFRLE1BQU0rQixRQUFRQyxRQUFRbkYsZ0JBQUFBO0VBQ3ZDO0VBRUFvRixTQUFTRixRQUFRbEYsa0JBQWtCO0FBQ2pDLFdBQU9tRCxRQUFRLE1BQU0rQixRQUFRLE1BQU1sRixnQkFBQUE7RUFDckM7RUFFQXFGLFNBQVNGLFFBQVFuRixrQkFBa0I7QUFDakMsV0FBT21ELFFBQVEsTUFBTSxNQUFNZ0MsUUFBUW5GLGdCQUFBQTtFQUNyQztFQUVBc0YsZUFBZXRGLGtCQUFrQjtBQUMvQixVQUFNLEVBQUNDLEdBQUFBLElBQUdDLEdBQUFBLElBQUdDLE1BQU1TLFdBQVUsSUFBNkIsS0FBS04sU0FBUztNQUFDO01BQUs7TUFBSztNQUFRO09BQWVOLGdCQUFBQTtBQUMxRyxXQUFPO01BQ0xDLEdBQUdXLGNBQWNYLEtBQUlFLFFBQVEsSUFBSUY7TUFDakNDLEdBQUdVLGFBQWFWLE1BQUtBLEtBQUlDLFFBQVE7SUFDbkM7RUFDRjtFQUVBb0YsU0FBU0MsTUFBTTtBQUNiLFdBQU9BLFNBQVMsTUFBTSxLQUFLcEYsUUFBUSxJQUFJLEtBQUtDLFNBQVM7RUFDdkQ7QUFDRjtBQW5GRSxjQUZtQjBELFlBRVowQixNQUFLO0FBS1osY0FQbUIxQixZQU9aMkIsWUFBVztFQUNoQmpFLGVBQWU7RUFDZkQsYUFBYTtFQUNiVSxjQUFjO0VBQ2RrQyxlQUFlO0VBQ2Z1QixZQUFZeEI7O0FBTWQsY0FsQm1CSixZQWtCWjZCLGlCQUFnQjtFQUNyQm5CLGlCQUFpQjtFQUNqQkQsYUFBYTs7QVd6SWpCLElBQU1xQixhQUFhLENBQUNDLFdBQVdDLGFBQWE7QUFDMUMsTUFBSSxFQUFDQyxZQUFZRCxVQUFVRSxXQUFXRixTQUFBQSxJQUFZRDtBQUVsRCxNQUFJQSxVQUFVSSxlQUFlO0FBQzNCRixnQkFBWUcsS0FBS0MsSUFBSUosV0FBV0QsUUFBQUE7QUFDaENFLGVBQVdILFVBQVVPLG1CQUFtQkYsS0FBS0MsSUFBSUgsVUFBVUYsUUFBQUE7O0FBRzdELFNBQU87SUFDTEU7SUFDQUQ7SUFDQU0sWUFBWUgsS0FBS0ksSUFBSVIsVUFBVUMsU0FBQUE7RUFDakM7QUFDRjtBQUVBLElBQU1RLGFBQWEsQ0FBQ0MsSUFBR0MsT0FBTUQsT0FBTSxRQUFRQyxPQUFNLFFBQVFELEdBQUVFLGlCQUFpQkQsR0FBRUMsZ0JBQWdCRixHQUFFRyxVQUFVRixHQUFFRTtBQUVyRyxJQUFNQyxTQUFOLGNBQXFCQyxRQUFBQTtFQUsxQkMsWUFBWUMsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS0MsU0FBUztBQUdkLFNBQUtDLGlCQUFpQixDQUFBO0FBS3RCLFNBQUtDLGVBQWU7QUFHcEIsU0FBS0MsZUFBZTtBQUVwQixTQUFLQyxRQUFRTCxPQUFPSztBQUNwQixTQUFLQyxVQUFVTixPQUFPTTtBQUN0QixTQUFLQyxNQUFNUCxPQUFPTztBQUNsQixTQUFLQyxjQUFjQztBQUNuQixTQUFLQyxjQUFjRDtBQUNuQixTQUFLRSxhQUFhRjtBQUNsQixTQUFLRyxZQUFZSDtBQUNqQixTQUFLSSxXQUFXSjtBQUNoQixTQUFLSyxNQUFNTDtBQUNYLFNBQUtNLFNBQVNOO0FBQ2QsU0FBS08sT0FBT1A7QUFDWixTQUFLUSxRQUFRUjtBQUNiLFNBQUtTLFNBQVNUO0FBQ2QsU0FBS1UsUUFBUVY7QUFDYixTQUFLVyxXQUFXWDtBQUNoQixTQUFLWSxXQUFXWjtBQUNoQixTQUFLYSxTQUFTYjtBQUNkLFNBQUtjLFdBQVdkO0VBQ2xCO0VBRUFlLE9BQU9YLFVBQVVELFdBQVdhLFNBQVM7QUFDbkMsU0FBS1osV0FBV0E7QUFDaEIsU0FBS0QsWUFBWUE7QUFDakIsU0FBS1EsV0FBV0s7QUFFaEIsU0FBS0MsY0FBYTtBQUNsQixTQUFLQyxZQUFXO0FBQ2hCLFNBQUtDLElBQUc7RUFDVjtFQUVBRixnQkFBZ0I7QUFDZCxRQUFJLEtBQUtHLGFBQVksR0FBSTtBQUN2QixXQUFLVixRQUFRLEtBQUtOO0FBQ2xCLFdBQUtHLE9BQU8sS0FBS0ksU0FBU0o7QUFDMUIsV0FBS0MsUUFBUSxLQUFLRTtXQUNiO0FBQ0wsV0FBS0QsU0FBUyxLQUFLTjtBQUNuQixXQUFLRSxNQUFNLEtBQUtNLFNBQVNOO0FBQ3pCLFdBQUtDLFNBQVMsS0FBS0c7O0VBRXZCO0VBRUFTLGNBQWM7QUFDWixVQUFNN0MsWUFBWSxLQUFLd0IsUUFBUXdCLFVBQVUsQ0FBQTtBQUN6QyxRQUFJdEIsY0FBY3VCLFNBQUtqRCxVQUFVa0QsZ0JBQWdCO01BQUMsS0FBSzNCO09BQVEsSUFBSSxLQUFLLENBQUE7QUFFeEUsUUFBSXZCLFVBQVVtRCxRQUFRO0FBQ3BCekIsb0JBQWNBLFlBQVl5QixPQUFPLENBQUNDLFNBQVNwRCxVQUFVbUQsT0FBT0MsTUFBTSxLQUFLN0IsTUFBTThCLElBQUksQ0FBQTs7QUFHbkYsUUFBSXJELFVBQVVzRCxNQUFNO0FBQ2xCNUIsb0JBQWNBLFlBQVk0QixLQUFLLENBQUMzQyxJQUFHQyxPQUFNWixVQUFVc0QsS0FBSzNDLElBQUdDLElBQUcsS0FBS1csTUFBTThCLElBQUksQ0FBQTs7QUFHL0UsUUFBSSxLQUFLN0IsUUFBUStCLFNBQVM7QUFDeEI3QixrQkFBWTZCLFFBQU87O0FBR3JCLFNBQUs3QixjQUFjQTtFQUNyQjtFQUVBb0IsTUFBTTtBQUNKLFVBQU0sRUFBQ3RCLFNBQVNDLElBQUcsSUFBSTtBQU12QixRQUFJLENBQUNELFFBQVFnQyxTQUFTO0FBQ3BCLFdBQUtuQixRQUFRLEtBQUtELFNBQVM7QUFDM0I7O0FBR0YsVUFBTXBDLFlBQVl3QixRQUFRd0I7QUFDMUIsVUFBTVMsWUFBWUMsT0FBTzFELFVBQVUyRCxJQUFJO0FBQ3ZDLFVBQU0xRCxXQUFXd0QsVUFBVUc7QUFDM0IsVUFBTUMsY0FBYyxLQUFLQyxvQkFBbUI7QUFDNUMsVUFBTSxFQUFDM0QsVUFBVUssV0FBQUEsSUFBY1QsV0FBV0MsV0FBV0MsUUFBQUE7QUFFckQsUUFBSW9DLE9BQU9EO0FBRVhYLFFBQUlrQyxPQUFPRixVQUFVTTtBQUVyQixRQUFJLEtBQUtoQixhQUFZLEdBQUk7QUFDdkJWLGNBQVEsS0FBS047QUFDYkssZUFBUyxLQUFLNEIsU0FBU0gsYUFBYTVELFVBQVVFLFVBQVVLLFVBQWMsSUFBQTtXQUNqRTtBQUNMNEIsZUFBUyxLQUFLTjtBQUNkTyxjQUFRLEtBQUs0QixTQUFTSixhQUFhSixXQUFXdEQsVUFBVUssVUFBYyxJQUFBOztBQUd4RSxTQUFLNkIsUUFBUWhDLEtBQUtDLElBQUkrQixPQUFPYixRQUFRTyxZQUFZLEtBQUtBLFFBQVE7QUFDOUQsU0FBS0ssU0FBUy9CLEtBQUtDLElBQUk4QixRQUFRWixRQUFRTSxhQUFhLEtBQUtBLFNBQVM7RUFDcEU7RUFLQWtDLFNBQVNILGFBQWE1RCxVQUFVRSxVQUFVSyxZQUFZO0FBQ3BELFVBQU0sRUFBQ2lCLEtBQUtNLFVBQVVQLFNBQVMsRUFBQ3dCLFFBQVEsRUFBQ2tCLFFBQUFBLEVBQVEsRUFBQyxJQUFJO0FBQ3RELFVBQU1DLFdBQVcsS0FBSy9DLGlCQUFpQixDQUFBO0FBRXZDLFVBQU1TLGFBQWEsS0FBS0EsYUFBYTtNQUFDO0lBQUU7QUFDeEMsVUFBTXVDLGFBQWE1RCxhQUFhMEQ7QUFDaEMsUUFBSUcsY0FBY1I7QUFFbEJwQyxRQUFJNkMsWUFBWTtBQUNoQjdDLFFBQUk4QyxlQUFlO0FBRW5CLFFBQUlDLE1BQU07QUFDVixRQUFJeEMsTUFBTSxDQUFDb0M7QUFDWCxTQUFLMUMsWUFBWStDLFFBQVEsQ0FBQ0MsWUFBWUMsT0FBTTtBQUMxQyxZQUFNQyxZQUFZekUsV0FBWUYsV0FBVyxJQUFLd0IsSUFBSW9ELFlBQVlILFdBQVdJLElBQUksRUFBRXpDO0FBRS9FLFVBQUlzQyxPQUFNLEtBQUs5QyxXQUFXQSxXQUFXa0QsU0FBUyxDQUFBLElBQUtILFlBQVksSUFBSVYsVUFBVW5DLFVBQVU7QUFDckZzQyx1QkFBZUQ7QUFDZnZDLG1CQUFXQSxXQUFXa0QsVUFBVUosS0FBSSxJQUFJLElBQUksRUFBQSxJQUFNO0FBQ2xEM0MsZUFBT29DO0FBQ1BJOztBQUdGTCxlQUFTUSxFQUFBQSxJQUFLO1FBQUN6QyxNQUFNO1FBQUdGO1FBQUt3QztRQUFLbkMsT0FBT3VDO1FBQVd4QyxRQUFRNUI7TUFBVTtBQUV0RXFCLGlCQUFXQSxXQUFXa0QsU0FBUyxDQUFBLEtBQU1ILFlBQVlWO0lBQ25ELENBQUE7QUFFQSxXQUFPRztFQUNUO0VBRUFKLFNBQVNKLGFBQWFKLFdBQVd0RCxVQUFVNkUsYUFBYTtBQUN0RCxVQUFNLEVBQUN2RCxLQUFLSyxXQUFXTixTQUFTLEVBQUN3QixRQUFRLEVBQUNrQixRQUFBQSxFQUFRLEVBQUMsSUFBSTtBQUN2RCxVQUFNQyxXQUFXLEtBQUsvQyxpQkFBaUIsQ0FBQTtBQUN2QyxVQUFNUSxjQUFjLEtBQUtBLGNBQWMsQ0FBQTtBQUN2QyxVQUFNcUQsY0FBY25ELFlBQVkrQjtBQUVoQyxRQUFJcUIsYUFBYWhCO0FBQ2pCLFFBQUlpQixrQkFBa0I7QUFDdEIsUUFBSUMsbUJBQW1CO0FBRXZCLFFBQUlsRCxPQUFPO0FBQ1gsUUFBSW1ELE1BQU07QUFFVixTQUFLM0QsWUFBWStDLFFBQVEsQ0FBQ0MsWUFBWUMsT0FBTTtBQUMxQyxZQUFNLEVBQUNDLFdBQVdwRSxXQUFVLElBQUk4RSxrQkFBa0JuRixVQUFVc0QsV0FBV2hDLEtBQUtpRCxZQUFZTSxXQUFBQTtBQUd4RixVQUFJTCxLQUFJLEtBQUtTLG1CQUFtQjVFLGFBQWEsSUFBSTBELFVBQVVlLGFBQWE7QUFDdEVDLHNCQUFjQyxrQkFBa0JqQjtBQUNoQ3RDLG9CQUFZMkQsS0FBSztVQUFDbEQsT0FBTzhDO1VBQWlCL0MsUUFBUWdEO1FBQWdCLENBQUE7QUFDbEVsRCxnQkFBUWlELGtCQUFrQmpCO0FBQzFCbUI7QUFDQUYsMEJBQWtCQyxtQkFBbUI7O0FBSXZDakIsZUFBU1EsRUFBQUEsSUFBSztRQUFDekM7UUFBTUYsS0FBS29EO1FBQWtCQztRQUFLaEQsT0FBT3VDO1FBQVd4QyxRQUFRNUI7TUFBVTtBQUdyRjJFLHdCQUFrQjlFLEtBQUtJLElBQUkwRSxpQkFBaUJQLFNBQUFBO0FBQzVDUSwwQkFBb0I1RSxhQUFhMEQ7SUFDbkMsQ0FBQTtBQUVBZ0Isa0JBQWNDO0FBQ2R2RCxnQkFBWTJELEtBQUs7TUFBQ2xELE9BQU84QztNQUFpQi9DLFFBQVFnRDtJQUFnQixDQUFBO0FBRWxFLFdBQU9GO0VBQ1Q7RUFFQU0saUJBQWlCO0FBQ2YsUUFBSSxDQUFDLEtBQUtoRSxRQUFRZ0MsU0FBUztBQUN6Qjs7QUFFRixVQUFNSyxjQUFjLEtBQUtDLG9CQUFtQjtBQUM1QyxVQUFNLEVBQUMxQyxnQkFBZ0IrQyxVQUFVM0MsU0FBUyxFQUFDaUUsT0FBT3pDLFFBQVEsRUFBQ2tCLFFBQU8sR0FBR3dCLElBQUFBLEVBQUksSUFBSTtBQUM3RSxVQUFNQyxZQUFZQyxjQUFjRixLQUFLLEtBQUt4RCxNQUFNLEtBQUtHLEtBQUs7QUFDMUQsUUFBSSxLQUFLVSxhQUFZLEdBQUk7QUFDdkIsVUFBSXlCLE1BQU07QUFDVixVQUFJdEMsT0FBTzJELGVBQWVKLE9BQU8sS0FBS3ZELE9BQU9nQyxTQUFTLEtBQUsvQixRQUFRLEtBQUtOLFdBQVcyQyxHQUFJLENBQUE7QUFDdkYsaUJBQVdzQixVQUFVM0IsVUFBVTtBQUM3QixZQUFJSyxRQUFRc0IsT0FBT3RCLEtBQUs7QUFDdEJBLGdCQUFNc0IsT0FBT3RCO0FBQ2J0QyxpQkFBTzJELGVBQWVKLE9BQU8sS0FBS3ZELE9BQU9nQyxTQUFTLEtBQUsvQixRQUFRLEtBQUtOLFdBQVcyQyxHQUFJLENBQUE7O0FBRXJGc0IsZUFBTzlELE9BQU8sS0FBS0EsTUFBTTZCLGNBQWNLO0FBQ3ZDNEIsZUFBTzVELE9BQU95RCxVQUFVSSxXQUFXSixVQUFVSyxFQUFFOUQsSUFBTzRELEdBQUFBLE9BQU96RCxLQUFLO0FBQ2xFSCxnQkFBUTRELE9BQU96RCxRQUFRNkI7TUFDekI7V0FDSztBQUNMLFVBQUltQixNQUFNO0FBQ1YsVUFBSXJELE1BQU02RCxlQUFlSixPQUFPLEtBQUt6RCxNQUFNNkIsY0FBY0ssU0FBUyxLQUFLakMsU0FBUyxLQUFLTCxZQUFZeUQsR0FBQUEsRUFBS2pELE1BQU07QUFDNUcsaUJBQVcwRCxVQUFVM0IsVUFBVTtBQUM3QixZQUFJMkIsT0FBT1QsUUFBUUEsS0FBSztBQUN0QkEsZ0JBQU1TLE9BQU9UO0FBQ2JyRCxnQkFBTTZELGVBQWVKLE9BQU8sS0FBS3pELE1BQU02QixjQUFjSyxTQUFTLEtBQUtqQyxTQUFTLEtBQUtMLFlBQVl5RCxHQUFBQSxFQUFLakQsTUFBTTs7QUFFMUcwRCxlQUFPOUQsTUFBTUE7QUFDYjhELGVBQU81RCxRQUFRLEtBQUtBLE9BQU9nQztBQUMzQjRCLGVBQU81RCxPQUFPeUQsVUFBVUksV0FBV0osVUFBVUssRUFBRUYsT0FBTzVELElBQUksR0FBRzRELE9BQU96RCxLQUFLO0FBQ3pFTCxlQUFPOEQsT0FBTzFELFNBQVM4QjtNQUN6Qjs7RUFFSjtFQUVBbkIsZUFBZTtBQUNiLFdBQU8sS0FBS3ZCLFFBQVFlLGFBQWEsU0FBUyxLQUFLZixRQUFRZSxhQUFhO0VBQ3RFO0VBRUEwRCxPQUFPO0FBQ0wsUUFBSSxLQUFLekUsUUFBUWdDLFNBQVM7QUFDeEIsWUFBTS9CLE1BQU0sS0FBS0E7QUFDakJ5RSxlQUFTekUsS0FBSyxJQUFJO0FBRWxCLFdBQUswRSxNQUFLO0FBRVZDLGlCQUFXM0UsR0FBQUE7O0VBRWY7RUFLQTBFLFFBQVE7QUFDTixVQUFNLEVBQUMzRSxTQUFTNkUsTUFBTXpFLGFBQWFDLFlBQVlKLElBQUFBLElBQU87QUFDdEQsVUFBTSxFQUFDZ0UsT0FBT3pDLFFBQVFoRCxVQUFBQSxJQUFhcUc7QUFDbkMsVUFBTUMsZUFBZUMsVUFBU0M7QUFDOUIsVUFBTWIsWUFBWUMsY0FBY1MsS0FBS1gsS0FBSyxLQUFLeEQsTUFBTSxLQUFLRyxLQUFLO0FBQy9ELFVBQU1vQixZQUFZQyxPQUFPMUQsVUFBVTJELElBQUk7QUFDdkMsVUFBTSxFQUFDTyxRQUFPLElBQUlsRTtBQUNsQixVQUFNQyxXQUFXd0QsVUFBVUc7QUFDM0IsVUFBTTZDLGVBQWV4RyxXQUFXO0FBQ2hDLFFBQUl5RztBQUVKLFNBQUtDLFVBQVM7QUFHZGxGLFFBQUk2QyxZQUFZcUIsVUFBVXJCLFVBQVUsTUFBQTtBQUNwQzdDLFFBQUk4QyxlQUFlO0FBQ25COUMsUUFBSW1GLFlBQVk7QUFDaEJuRixRQUFJa0MsT0FBT0YsVUFBVU07QUFFckIsVUFBTSxFQUFDNUQsVUFBVUQsV0FBV00sV0FBVSxJQUFJVCxXQUFXQyxXQUFXQyxRQUFBQTtBQUdoRSxVQUFNNEcsZ0JBQWdCLFNBQVNiLElBQUdjLElBQUdwQyxZQUFZO0FBQy9DLFVBQUlxQyxNQUFNNUcsUUFBYUEsS0FBQUEsWUFBWSxLQUFLNEcsTUFBTTdHLFNBQUFBLEtBQWNBLFlBQVksR0FBRztBQUN6RTs7QUFJRnVCLFVBQUl1RixLQUFJO0FBRVIsWUFBTUosWUFBWUssZUFBZXZDLFdBQVdrQyxXQUFXLENBQUE7QUFDdkRuRixVQUFJeUYsWUFBWUQsZUFBZXZDLFdBQVd3QyxXQUFXWixZQUFBQTtBQUNyRDdFLFVBQUkwRixVQUFVRixlQUFldkMsV0FBV3lDLFNBQVMsTUFBQTtBQUNqRDFGLFVBQUkyRixpQkFBaUJILGVBQWV2QyxXQUFXMEMsZ0JBQWdCLENBQUE7QUFDL0QzRixVQUFJNEYsV0FBV0osZUFBZXZDLFdBQVcyQyxVQUFVLE9BQUE7QUFDbkQ1RixVQUFJbUYsWUFBWUE7QUFDaEJuRixVQUFJNkYsY0FBY0wsZUFBZXZDLFdBQVc0QyxhQUFhaEIsWUFBQUE7QUFFekQ3RSxVQUFJOEYsWUFBWU4sZUFBZXZDLFdBQVc4QyxVQUFVLENBQUEsQ0FBRSxDQUFBO0FBRXRELFVBQUl4SCxVQUFVSSxlQUFlO0FBRzNCLGNBQU1xSCxjQUFjO1VBQ2xCQyxRQUFReEgsWUFBWUcsS0FBS3NILFFBQVE7VUFDakNDLFlBQVlsRCxXQUFXa0Q7VUFDdkJDLFVBQVVuRCxXQUFXbUQ7VUFDckJDLGFBQWFsQjtRQUNmO0FBQ0EsY0FBTW1CLFVBQVVwQyxVQUFVcUMsTUFBTWhDLElBQUc3RixXQUFXLENBQUE7QUFDOUMsY0FBTThILFVBQVVuQixLQUFJTDtBQUdwQnlCLHdCQUFnQnpHLEtBQUtnRyxhQUFhTSxTQUFTRSxTQUFTakksVUFBVU8sbUJBQW1CSixRQUFBQTthQUM1RTtBQUdMLGNBQU1nSSxVQUFVckIsS0FBSXpHLEtBQUtJLEtBQUtSLFdBQVdDLGFBQWEsR0FBRyxDQUFBO0FBQ3pELGNBQU1rSSxXQUFXekMsVUFBVUksV0FBV0MsSUFBRzdGLFFBQUFBO0FBQ3pDLGNBQU1rSSxlQUFlQyxjQUFjNUQsV0FBVzJELFlBQVk7QUFFMUQ1RyxZQUFJOEcsVUFBUztBQUViLFlBQUlDLE9BQU9DLE9BQU9KLFlBQUFBLEVBQWNLLEtBQUtDLENBQUFBLE9BQUtBLE9BQU0sQ0FBSSxHQUFBO0FBQ2xEQyw2QkFBbUJuSCxLQUFLO1lBQ3RCdUUsR0FBR29DO1lBQ0h0QixHQUFHcUI7WUFDSFUsR0FBRzFJO1lBQ0gySSxHQUFHNUk7WUFDSHdILFFBQVFXO1VBQ1YsQ0FBQTtlQUNLO0FBQ0w1RyxjQUFJc0gsS0FBS1gsVUFBVUQsU0FBU2hJLFVBQVVELFNBQUFBOztBQUd4Q3VCLFlBQUl1SCxLQUFJO0FBQ1IsWUFBSXBDLGNBQWMsR0FBRztBQUNuQm5GLGNBQUl3SCxPQUFNOzs7QUFJZHhILFVBQUl5SCxRQUFPO0lBQ2I7QUFFQSxVQUFNQyxXQUFXLFNBQVNuRCxJQUFHYyxJQUFHcEMsWUFBWTtBQUMxQzBFLGlCQUFXM0gsS0FBS2lELFdBQVdJLE1BQU1rQixJQUFHYyxLQUFLdEcsYUFBYSxHQUFJaUQsV0FBVztRQUNuRTRGLGVBQWUzRSxXQUFXNEU7UUFDMUJoRixXQUFXcUIsVUFBVXJCLFVBQVVJLFdBQVdKLFNBQVM7TUFDckQsQ0FBQTtJQUNGO0FBR0EsVUFBTXZCLGVBQWUsS0FBS0EsYUFBWTtBQUN0QyxVQUFNYyxjQUFjLEtBQUtDLG9CQUFtQjtBQUM1QyxRQUFJZixjQUFjO0FBQ2hCMkQsZUFBUztRQUNQVixHQUFHSCxlQUFlSixPQUFPLEtBQUt2RCxPQUFPZ0MsU0FBUyxLQUFLL0IsUUFBUU4sV0FBVyxDQUFFLENBQUE7UUFDeEVpRixHQUFHLEtBQUs5RSxNQUFNa0MsVUFBVUw7UUFDeEIwRixNQUFNO01BQ1I7V0FDSztBQUNMN0MsZUFBUztRQUNQVixHQUFHLEtBQUs5RCxPQUFPZ0M7UUFDZjRDLEdBQUdqQixlQUFlSixPQUFPLEtBQUt6RCxNQUFNNkIsY0FBY0ssU0FBUyxLQUFLakMsU0FBU0wsWUFBWSxDQUFBLEVBQUdRLE1BQU07UUFDOUZtSCxNQUFNO01BQ1I7O0FBR0ZDLDBCQUFzQixLQUFLL0gsS0FBSzRFLEtBQUtvRCxhQUFhO0FBRWxELFVBQU1yRixhQUFhNUQsYUFBYTBEO0FBQ2hDLFNBQUt4QyxZQUFZK0MsUUFBUSxDQUFDQyxZQUFZQyxPQUFNO0FBQzFDbEQsVUFBSTZGLGNBQWM1QyxXQUFXZ0Y7QUFDN0JqSSxVQUFJeUYsWUFBWXhDLFdBQVdnRjtBQUUzQixZQUFNQyxZQUFZbEksSUFBSW9ELFlBQVlILFdBQVdJLElBQUksRUFBRXpDO0FBQ25ELFlBQU1pQyxZQUFZcUIsVUFBVXJCLFVBQVVJLFdBQVdKLGNBQWNJLFdBQVdKLFlBQVl0RSxVQUFVc0UsVUFBUTtBQUN4RyxZQUFNakMsUUFBUWxDLFdBQVdzRyxlQUFla0Q7QUFDeEMsVUFBSTNELEtBQUlVLE9BQU9WO0FBQ2YsVUFBSWMsS0FBSUosT0FBT0k7QUFFZm5CLGdCQUFVaUUsU0FBUyxLQUFLdkgsS0FBSztBQUU3QixVQUFJVSxjQUFjO0FBQ2hCLFlBQUk0QixLQUFJLEtBQUtxQixLQUFJM0QsUUFBUTZCLFVBQVUsS0FBSy9CLE9BQU87QUFDN0MyRSxVQUFBQSxLQUFJSixPQUFPSSxLQUFLMUM7QUFDaEJzQyxpQkFBTzZDO0FBQ1B2RCxVQUFBQSxLQUFJVSxPQUFPVixJQUFJSCxlQUFlSixPQUFPLEtBQUt2RCxPQUFPZ0MsU0FBUyxLQUFLL0IsUUFBUU4sV0FBVzZFLE9BQU82QyxJQUFJLENBQUM7O2lCQUV2RjVFLEtBQUksS0FBS21DLEtBQUkxQyxhQUFhLEtBQUtuQyxRQUFRO0FBQ2hEK0QsUUFBQUEsS0FBSVUsT0FBT1YsSUFBSUEsS0FBSXBFLFlBQVk4RSxPQUFPNkMsSUFBSSxFQUFFbEgsUUFBUTZCO0FBQ3BEd0MsZUFBTzZDO0FBQ1B6QyxRQUFBQSxLQUFJSixPQUFPSSxJQUFJakIsZUFBZUosT0FBTyxLQUFLekQsTUFBTTZCLGNBQWNLLFNBQVMsS0FBS2pDLFNBQVNMLFlBQVk4RSxPQUFPNkMsSUFBSSxFQUFFbkgsTUFBTTs7QUFHdEgsWUFBTXlILFFBQVFsRSxVQUFVSyxFQUFFQSxFQUFBQTtBQUUxQmEsb0JBQWNnRCxPQUFPL0MsSUFBR3BDLFVBQUFBO0FBRXhCc0IsTUFBQUEsS0FBSThELE9BQU94RixXQUFXMEIsS0FBSTdGLFdBQVdzRyxjQUFjMUQsZUFBZWlELEtBQUkzRCxRQUFRLEtBQUtGLE9BQU9rRSxLQUFLWCxHQUFHO0FBR2xHeUQsZUFBU3hELFVBQVVLLEVBQUVBLEVBQUFBLEdBQUljLElBQUdwQyxVQUFBQTtBQUU1QixVQUFJM0IsY0FBYztBQUNoQjJELGVBQU9WLEtBQUszRCxRQUFRNkI7TUFDdEIsV0FBVyxPQUFPUSxXQUFXSSxTQUFTLFVBQVU7QUFDOUMsY0FBTWlGLGlCQUFpQnRHLFVBQVVXO0FBQ2pDc0MsZUFBT0ksS0FBS2tELDBCQUEwQnRGLFlBQVlxRixjQUFrQjdGLElBQUFBO2FBQy9EO0FBQ0x3QyxlQUFPSSxLQUFLMUM7O0lBRWhCLENBQUE7QUFFQTZGLHlCQUFxQixLQUFLeEksS0FBSzRFLEtBQUtvRCxhQUFhO0VBQ25EO0VBS0E5QyxZQUFZO0FBQ1YsVUFBTU4sT0FBTyxLQUFLN0U7QUFDbEIsVUFBTTBJLFlBQVk3RCxLQUFLOEQ7QUFDdkIsVUFBTUMsWUFBWTFHLE9BQU93RyxVQUFVdkcsSUFBSTtBQUN2QyxVQUFNMEcsZUFBZUMsVUFBVUosVUFBVWhHLE9BQU87QUFFaEQsUUFBSSxDQUFDZ0csVUFBVTFHLFNBQVM7QUFDdEI7O0FBR0YsVUFBTW1DLFlBQVlDLGNBQWNTLEtBQUtYLEtBQUssS0FBS3hELE1BQU0sS0FBS0csS0FBSztBQUMvRCxVQUFNWixNQUFNLEtBQUtBO0FBQ2pCLFVBQU1jLFdBQVcySCxVQUFVM0g7QUFDM0IsVUFBTWtFLGVBQWUyRCxVQUFVeEcsT0FBTztBQUN0QyxVQUFNMkcsNkJBQTZCRixhQUFhckksTUFBTXlFO0FBQ3RELFFBQUlLO0FBSUosUUFBSTVFLE9BQU8sS0FBS0E7QUFDaEIsUUFBSUgsV0FBVyxLQUFLTTtBQUVwQixRQUFJLEtBQUtVLGFBQVksR0FBSTtBQUV2QmhCLGlCQUFXMUIsS0FBS0ksSUFBTyxHQUFBLEtBQUtvQixVQUFVO0FBQ3RDaUYsTUFBQUEsS0FBSSxLQUFLOUUsTUFBTXVJO0FBQ2ZySSxhQUFPMkQsZUFBZVEsS0FBS1osT0FBT3ZELE1BQU0sS0FBS0MsUUFBUUosUUFBQUE7V0FDaEQ7QUFFTCxZQUFNRCxZQUFZLEtBQUtGLFlBQVk0SSxPQUFPLENBQUNDLEtBQUs3RyxTQUFTdkQsS0FBS0ksSUFBSWdLLEtBQUs3RyxLQUFLeEIsTUFBTSxHQUFHLENBQUE7QUFDckYwRSxNQUFBQSxLQUFJeUQsNkJBQTZCMUUsZUFBZVEsS0FBS1osT0FBTyxLQUFLekQsS0FBSyxLQUFLQyxTQUFTSCxZQUFZdUUsS0FBS3JELE9BQU9rQixVQUFVLEtBQUtKLG9CQUFtQixDQUFBOztBQUtoSixVQUFNa0MsS0FBSUgsZUFBZXRELFVBQVVMLE1BQU1BLE9BQU9ILFFBQUFBO0FBR2hETixRQUFJNkMsWUFBWXFCLFVBQVVyQixVQUFVb0csbUJBQW1CbkksUUFBQUEsQ0FBQUE7QUFDdkRkLFFBQUk4QyxlQUFlO0FBQ25COUMsUUFBSTZGLGNBQWM0QyxVQUFVMUQ7QUFDNUIvRSxRQUFJeUYsWUFBWWdELFVBQVUxRDtBQUMxQi9FLFFBQUlrQyxPQUFPeUcsVUFBVXJHO0FBRXJCcUYsZUFBVzNILEtBQUt5SSxVQUFVcEYsTUFBTWtCLElBQUdjLElBQUdzRCxTQUFBQTtFQUN4QztFQUtBdEcsc0JBQXNCO0FBQ3BCLFVBQU1vRyxZQUFZLEtBQUsxSSxRQUFRMkk7QUFDL0IsVUFBTUMsWUFBWTFHLE9BQU93RyxVQUFVdkcsSUFBSTtBQUN2QyxVQUFNMEcsZUFBZUMsVUFBVUosVUFBVWhHLE9BQU87QUFDaEQsV0FBT2dHLFVBQVUxRyxVQUFVNEcsVUFBVWhHLGFBQWFpRyxhQUFhakksU0FBUztFQUMxRTtFQUtBdUksaUJBQWlCM0UsSUFBR2MsSUFBRztBQUNyQixRQUFJbkMsSUFBR2lHLFFBQVFDO0FBRWYsUUFBSUMsV0FBVzlFLElBQUcsS0FBSzlELE1BQU0sS0FBS0MsS0FBSyxLQUNsQzJJLFdBQVdoRSxJQUFHLEtBQUs5RSxLQUFLLEtBQUtDLE1BQU0sR0FBRztBQUV6QzRJLFdBQUssS0FBS3pKO0FBQ1YsV0FBS3VELEtBQUksR0FBR0EsS0FBSWtHLEdBQUc5RixRQUFRLEVBQUVKLElBQUc7QUFDOUJpRyxpQkFBU0MsR0FBR2xHLEVBQUU7QUFFZCxZQUFJbUcsV0FBVzlFLElBQUc0RSxPQUFPMUksTUFBTTBJLE9BQU8xSSxPQUFPMEksT0FBT3ZJLEtBQUssS0FDcER5SSxXQUFXaEUsSUFBRzhELE9BQU81SSxLQUFLNEksT0FBTzVJLE1BQU00SSxPQUFPeEksTUFBTSxHQUFHO0FBRTFELGlCQUFPLEtBQUtWLFlBQVlpRCxFQUFFOztNQUU5Qjs7QUFHRixXQUFPO0VBQ1Q7RUFNQW9HLFlBQVlDLElBQUc7QUFDYixVQUFNM0UsT0FBTyxLQUFLN0U7QUFDbEIsUUFBSSxDQUFDeUosV0FBV0QsR0FBRUUsTUFBTTdFLElBQU8sR0FBQTtBQUM3Qjs7QUFJRixVQUFNOEUsY0FBYyxLQUFLUixpQkFBaUJLLEdBQUVoRixHQUFHZ0YsR0FBRWxFLENBQUM7QUFFbEQsUUFBSWtFLEdBQUVFLFNBQVMsZUFBZUYsR0FBRUUsU0FBUyxZQUFZO0FBQ25ELFlBQU1FLFdBQVcsS0FBSy9KO0FBQ3RCLFlBQU1nSyxXQUFXM0ssV0FBVzBLLFVBQVVELFdBQUFBO0FBQ3RDLFVBQUlDLFlBQVksQ0FBQ0MsVUFBVTtBQUN6QnBJLGlCQUFLb0QsS0FBS2lGLFNBQVM7VUFBQ047VUFBR0k7VUFBVTtRQUFLLEdBQUUsSUFBSTs7QUFHOUMsV0FBSy9KLGVBQWU4SjtBQUVwQixVQUFJQSxlQUFlLENBQUNFLFVBQVU7QUFDNUJwSSxpQkFBS29ELEtBQUtrRixTQUFTO1VBQUNQO1VBQUdHO1VBQWE7UUFBSyxHQUFFLElBQUk7O0lBRW5ELFdBQVdBLGFBQWE7QUFDdEJsSSxlQUFLb0QsS0FBS21GLFNBQVM7UUFBQ1I7UUFBR0c7UUFBYTtNQUFLLEdBQUUsSUFBSTs7RUFFbkQ7QUFDRjtBQUVBLFNBQVM3RixrQkFBa0JuRixVQUFVc0QsV0FBV2hDLEtBQUtpRCxZQUFZTSxhQUFhO0FBQzVFLFFBQU1KLFlBQVk2RyxtQkFBbUIvRyxZQUFZdkUsVUFBVXNELFdBQVdoQyxHQUFBQTtBQUN0RSxRQUFNakIsYUFBYWtMLG9CQUFvQjFHLGFBQWFOLFlBQVlqQixVQUFVVyxVQUFVO0FBQ3BGLFNBQU87SUFBQ1E7SUFBV3BFO0VBQVU7QUFDL0I7QUFFQSxTQUFTaUwsbUJBQW1CL0csWUFBWXZFLFVBQVVzRCxXQUFXaEMsS0FBSztBQUNoRSxNQUFJa0ssaUJBQWlCakgsV0FBV0k7QUFDaEMsTUFBSTZHLGtCQUFrQixPQUFPQSxtQkFBbUIsVUFBVTtBQUN4REEscUJBQWlCQSxlQUFlbkIsT0FBTyxDQUFDN0osSUFBR0MsT0FBTUQsR0FBRW9FLFNBQVNuRSxHQUFFbUUsU0FBU3BFLEtBQUlDLEVBQUM7O0FBRTlFLFNBQU9ULFdBQVlzRCxVQUFVRyxPQUFPLElBQUtuQyxJQUFJb0QsWUFBWThHLGNBQUFBLEVBQWdCdEo7QUFDM0U7QUFFQSxTQUFTcUosb0JBQW9CMUcsYUFBYU4sWUFBWXFGLGdCQUFnQjtBQUNwRSxNQUFJdkosYUFBYXdFO0FBQ2pCLE1BQUksT0FBT04sV0FBV0ksU0FBUyxVQUFVO0FBQ3ZDdEUsaUJBQWF3SiwwQkFBMEJ0RixZQUFZcUYsY0FBQUE7O0FBRXJELFNBQU92SjtBQUNUO0FBRUEsU0FBU3dKLDBCQUEwQnRGLFlBQVlxRixnQkFBZ0I7QUFDN0QsUUFBTTZCLGNBQWNsSCxXQUFXSSxPQUFPSixXQUFXSSxLQUFLQyxTQUFTO0FBQy9ELFNBQU9nRixpQkFBaUI2QjtBQUMxQjtBQUVBLFNBQVNYLFdBQVdDLE1BQU03RSxNQUFNO0FBQzlCLE9BQUs2RSxTQUFTLGVBQWVBLFNBQVMsZ0JBQWdCN0UsS0FBS2tGLFdBQVdsRixLQUFLaUYsVUFBVTtBQUNuRixXQUFPOztBQUVULE1BQUlqRixLQUFLbUYsWUFBWU4sU0FBUyxXQUFXQSxTQUFTLFlBQVk7QUFDNUQsV0FBTzs7QUFFVCxTQUFPO0FBQ1Q7QUFFQSxJQUFBLGdCQUFlO0VBQ2JXLElBQUk7RUFNSkMsVUFBVS9LO0VBRVZnTCxNQUFNeEssT0FBT3lLLE9BQU94SyxTQUFTO0FBQzNCLFVBQU15SyxTQUFTMUssTUFBTTBLLFNBQVMsSUFBSWxMLE9BQU87TUFBQ1UsS0FBS0YsTUFBTUU7TUFBS0Q7TUFBU0Q7SUFBSyxDQUFBO0FBQ3hFMkssWUFBUUMsVUFBVTVLLE9BQU8wSyxRQUFRekssT0FBQUE7QUFDakMwSyxZQUFRRSxPQUFPN0ssT0FBTzBLLE1BQUFBO0VBQ3hCO0VBRUFJLEtBQUs5SyxPQUFPO0FBQ1YySyxZQUFRSSxVQUFVL0ssT0FBT0EsTUFBTTBLLE1BQU07QUFDckMsV0FBTzFLLE1BQU0wSztFQUNmO0VBS0FNLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsVUFBTXlLLFNBQVMxSyxNQUFNMEs7QUFDckJDLFlBQVFDLFVBQVU1SyxPQUFPMEssUUFBUXpLLE9BQUFBO0FBQ2pDeUssV0FBT3pLLFVBQVVBO0VBQ25CO0VBSUFnTCxZQUFZakwsT0FBTztBQUNqQixVQUFNMEssU0FBUzFLLE1BQU0wSztBQUNyQkEsV0FBT3BKLFlBQVc7QUFDbEJvSixXQUFPekcsZUFBYztFQUN2QjtFQUdBaUgsV0FBV2xMLE9BQU9tTCxNQUFNO0FBQ3RCLFFBQUksQ0FBQ0EsS0FBS0MsUUFBUTtBQUNoQnBMLFlBQU0wSyxPQUFPbEIsWUFBWTJCLEtBQUtFLEtBQUs7O0VBRXZDO0VBRUFyRyxVQUFVO0lBQ1IvQyxTQUFTO0lBQ1RqQixVQUFVO0lBQ1ZrRCxPQUFPO0lBQ1BoRCxVQUFVO0lBQ1ZjLFNBQVM7SUFDVGYsUUFBUTtJQUdSZ0osUUFBUVIsSUFBR3RHLFlBQVl1SCxRQUFRO0FBQzdCLFlBQU1uTCxRQUFRNEQsV0FBVzdEO0FBQ3pCLFlBQU1nTSxLQUFLWixPQUFPMUs7QUFDbEIsVUFBSXNMLEdBQUdDLGlCQUFpQmhNLEtBQVEsR0FBQTtBQUM5QitMLFdBQUdFLEtBQUtqTSxLQUFBQTtBQUNSNEQsbUJBQVc0RSxTQUFTO2FBQ2Y7QUFDTHVELFdBQUdHLEtBQUtsTSxLQUFBQTtBQUNSNEQsbUJBQVc0RSxTQUFTOztJQUV4QjtJQUVBaUMsU0FBUztJQUNURCxTQUFTO0lBRVR0SSxRQUFRO01BQ053RCxPQUFPLENBQUMvRSxRQUFRQSxJQUFJRixNQUFNQyxRQUFRZ0Y7TUFDbENyRyxVQUFVO01BQ1YrRCxTQUFTO01BWVRoQixlQUFlM0IsT0FBTztBQUNwQixjQUFNMEwsV0FBVzFMLE1BQU04QixLQUFLNEo7QUFDNUIsY0FBTSxFQUFDakssUUFBUSxFQUFDNUMsZUFBZXdILFlBQVl0RCxXQUFXa0MsT0FBQUEsUUFBTzBHLGlCQUFpQjdFLGFBQUFBLEVBQWEsSUFBSTlHLE1BQU0wSyxPQUFPeks7QUFFNUcsZUFBT0QsTUFBTTRMLHVCQUFzQixFQUFHQyxJQUFJLENBQUNDLFNBQVM7QUFDbEQsZ0JBQU1DLFFBQVFELEtBQUtFLFdBQVdDLFNBQVNwTixnQkFBZ0IsSUFBSXVCLE1BQVM7QUFDcEUsZ0JBQU1tRyxjQUFjd0MsVUFBVWdELE1BQU14RixXQUFXO0FBRS9DLGlCQUFPO1lBQ0xoRCxNQUFNbUksU0FBU0ksS0FBS3ZNLEtBQUssRUFBRTJNO1lBQzNCdkcsV0FBV29HLE1BQU1JO1lBQ2pCaEUsV0FBV2xEO1lBQ1g4QyxRQUFRLENBQUMrRCxLQUFLTTtZQUNkeEcsU0FBU21HLE1BQU1NO1lBQ2ZwRyxVQUFVOEYsTUFBTU87WUFDaEJ6RyxnQkFBZ0JrRyxNQUFNUTtZQUN0QnpHLFVBQVVpRyxNQUFNUztZQUNoQm5ILFlBQVlrQixZQUFZekYsUUFBUXlGLFlBQVkxRixVQUFVO1lBQ3REa0YsYUFBYWdHLE1BQU1VO1lBQ25CcEcsWUFBWUEsY0FBYzBGLE1BQU0xRjtZQUNoQ0MsVUFBVXlGLE1BQU16RjtZQUNoQnZELFdBQVdBLGFBQWFnSixNQUFNaEo7WUFDOUIrRCxjQUFjNkUsb0JBQW9CN0UsZ0JBQWdCaUYsTUFBTWpGO1lBR3hEeEgsY0FBY3dNLEtBQUt2TTtVQUNyQjtRQUNGLEdBQUcsSUFBSTtNQUNUO0lBQ0Y7SUFFQXFKLE9BQU87TUFDTDNELE9BQU8sQ0FBQy9FLFFBQVFBLElBQUlGLE1BQU1DLFFBQVFnRjtNQUNsQ2hELFNBQVM7TUFDVGpCLFVBQVU7TUFDVnVDLE1BQU07SUFDUjtFQUNGO0VBRUFtSixhQUFhO0lBQ1hDLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDQSxLQUFLQyxXQUFXLElBQUE7SUFDeENwTCxRQUFRO01BQ05rTCxhQUFhLENBQUNDLFNBQVMsQ0FBQztRQUFDO1FBQWtCO1FBQVU7TUFBTyxFQUFDRSxTQUFTRixJQUFBQTtJQUN4RTtFQUNGO0FBQ0Y7QUN6c0JPLElBQU1HLFFBQU4sY0FBb0J0TixRQUFBQTtFQUl6QkMsWUFBWUMsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS0ssUUFBUUwsT0FBT0s7QUFDcEIsU0FBS0MsVUFBVU4sT0FBT007QUFDdEIsU0FBS0MsTUFBTVAsT0FBT087QUFDbEIsU0FBSzhNLFdBQVc1TTtBQUNoQixTQUFLSyxNQUFNTDtBQUNYLFNBQUtNLFNBQVNOO0FBQ2QsU0FBS08sT0FBT1A7QUFDWixTQUFLUSxRQUFRUjtBQUNiLFNBQUtVLFFBQVFWO0FBQ2IsU0FBS1MsU0FBU1Q7QUFDZCxTQUFLWSxXQUFXWjtBQUNoQixTQUFLYSxTQUFTYjtBQUNkLFNBQUtjLFdBQVdkO0VBQ2xCO0VBRUFlLE9BQU9YLFVBQVVELFdBQVc7QUFDMUIsVUFBTXVFLE9BQU8sS0FBSzdFO0FBRWxCLFNBQUtVLE9BQU87QUFDWixTQUFLRixNQUFNO0FBRVgsUUFBSSxDQUFDcUUsS0FBSzdDLFNBQVM7QUFDakIsV0FBS25CLFFBQVEsS0FBS0QsU0FBUyxLQUFLRCxRQUFRLEtBQUtGLFNBQVM7QUFDdEQ7O0FBR0YsU0FBS0ksUUFBUSxLQUFLRixRQUFRSjtBQUMxQixTQUFLSyxTQUFTLEtBQUtILFNBQVNIO0FBRTVCLFVBQU0wTSxZQUFZQyxRQUFRcEksS0FBS3ZCLElBQUksSUFBSXVCLEtBQUt2QixLQUFLQyxTQUFTO0FBQzFELFNBQUt3SixXQUFXakUsVUFBVWpFLEtBQUtuQyxPQUFPO0FBQ3RDLFVBQU13SyxXQUFXRixZQUFZOUssT0FBTzJDLEtBQUsxQyxJQUFJLEVBQUVTLGFBQWEsS0FBS21LLFNBQVNuTTtBQUUxRSxRQUFJLEtBQUtXLGFBQVksR0FBSTtBQUN2QixXQUFLWCxTQUFTc007V0FDVDtBQUNMLFdBQUtyTSxRQUFRcU07O0VBRWpCO0VBRUEzTCxlQUFlO0FBQ2IsVUFBTTRMLE1BQU0sS0FBS25OLFFBQVFlO0FBQ3pCLFdBQU9vTSxRQUFRLFNBQVNBLFFBQVE7RUFDbEM7RUFFQUMsVUFBVUMsUUFBUTtBQUNoQixVQUFNLEVBQUM3TSxLQUFLRSxNQUFNRCxRQUFRRSxPQUFPWCxRQUFBQSxJQUFXO0FBQzVDLFVBQU1pRSxRQUFRakUsUUFBUWlFO0FBQ3RCLFFBQUlvQyxXQUFXO0FBQ2YsUUFBSTlGLFVBQVUrTSxRQUFRQztBQUV0QixRQUFJLEtBQUtoTSxhQUFZLEdBQUk7QUFDdkIrTCxlQUFTakosZUFBZUosT0FBT3ZELE1BQU1DLEtBQUFBO0FBQ3JDNE0sZUFBUy9NLE1BQU02TTtBQUNmOU0saUJBQVdJLFFBQVFEO1dBQ2Q7QUFDTCxVQUFJVixRQUFRZSxhQUFhLFFBQVE7QUFDL0J1TSxpQkFBUzVNLE9BQU8yTTtBQUNoQkUsaUJBQVNsSixlQUFlSixPQUFPeEQsUUFBUUQsR0FBQUE7QUFDdkM2RixtQkFBV21ILEtBQUs7YUFDWDtBQUNMRixpQkFBUzNNLFFBQVEwTTtBQUNqQkUsaUJBQVNsSixlQUFlSixPQUFPekQsS0FBS0MsTUFBQUE7QUFDcEM0RixtQkFBV21ILEtBQUs7O0FBRWxCak4saUJBQVdFLFNBQVNEOztBQUV0QixXQUFPO01BQUM4TTtNQUFRQztNQUFRaE47TUFBVThGO0lBQVE7RUFDNUM7RUFFQTVCLE9BQU87QUFDTCxVQUFNeEUsTUFBTSxLQUFLQTtBQUNqQixVQUFNNEUsT0FBTyxLQUFLN0U7QUFFbEIsUUFBSSxDQUFDNkUsS0FBSzdDLFNBQVM7QUFDakI7O0FBR0YsVUFBTXlMLFdBQVd2TCxPQUFPMkMsS0FBSzFDLElBQUk7QUFDakMsVUFBTVMsYUFBYTZLLFNBQVM3SztBQUM1QixVQUFNeUssU0FBU3pLLGFBQWEsSUFBSSxLQUFLbUssU0FBU3ZNO0FBQzlDLFVBQU0sRUFBQzhNLFFBQVFDLFFBQVFoTixVQUFVOEYsU0FBQUEsSUFBWSxLQUFLK0csVUFBVUMsTUFBQUE7QUFFNUR6RixlQUFXM0gsS0FBSzRFLEtBQUt2QixNQUFNLEdBQUcsR0FBR21LLFVBQVU7TUFDekN6SSxPQUFPSCxLQUFLRztNQUNaekU7TUFDQThGO01BQ0F2RCxXQUFXb0csbUJBQW1CckUsS0FBS1osS0FBSztNQUN4Q2xCLGNBQWM7TUFDZDJLLGFBQWE7UUFBQ0o7UUFBUUM7TUFBTztJQUMvQixDQUFBO0VBQ0Y7QUFDRjtBQUVBLFNBQVNJLFlBQVk1TixPQUFPMkksV0FBVztBQUNyQyxRQUFNQyxRQUFRLElBQUltRSxNQUFNO0lBQ3RCN00sS0FBS0YsTUFBTUU7SUFDWEQsU0FBUzBJO0lBQ1QzSTtFQUNGLENBQUE7QUFFQTJLLFVBQVFDLFVBQVU1SyxPQUFPNEksT0FBT0QsU0FBQUE7QUFDaENnQyxVQUFRRSxPQUFPN0ssT0FBTzRJLEtBQUFBO0FBQ3RCNUksUUFBTTZOLGFBQWFqRjtBQUNyQjtBQUVBLElBQUEsZUFBZTtFQUNiMEIsSUFBSTtFQU1KQyxVQUFVd0M7RUFFVnZDLE1BQU14SyxPQUFPeUssT0FBT3hLLFNBQVM7QUFDM0IyTixnQkFBWTVOLE9BQU9DLE9BQUFBO0VBQ3JCO0VBRUE2SyxLQUFLOUssT0FBTztBQUNWLFVBQU02TixhQUFhN04sTUFBTTZOO0FBQ3pCbEQsWUFBUUksVUFBVS9LLE9BQU82TixVQUFBQTtBQUN6QixXQUFPN04sTUFBTTZOO0VBQ2Y7RUFFQTdDLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsVUFBTTJJLFFBQVE1SSxNQUFNNk47QUFDcEJsRCxZQUFRQyxVQUFVNUssT0FBTzRJLE9BQU8zSSxPQUFBQTtBQUNoQzJJLFVBQU0zSSxVQUFVQTtFQUNsQjtFQUVBK0UsVUFBVTtJQUNSZCxPQUFPO0lBQ1BqQyxTQUFTO0lBQ1RHLE1BQU07TUFDSm5CLFFBQVE7SUFDVjtJQUNBQyxVQUFVO0lBQ1Z5QixTQUFTO0lBQ1QzQixVQUFVO0lBQ1Z1QyxNQUFNO0lBQ050QyxRQUFRO0VBQ1Y7RUFFQTZNLGVBQWU7SUFDYjdJLE9BQU87RUFDVDtFQUVBeUgsYUFBYTtJQUNYQyxhQUFhO0lBQ2JvQixZQUFZO0VBQ2Q7QUFDRjtBQ2xLQSxJQUFNbEMsT0FBTSxvQkFBSW1DLFFBQUFBO0FBRWhCLElBQUEsa0JBQWU7RUFDYjFELElBQUk7RUFFSkUsTUFBTXhLLE9BQU95SyxPQUFPeEssU0FBUztBQUMzQixVQUFNMkksUUFBUSxJQUFJbUUsTUFBTTtNQUN0QjdNLEtBQUtGLE1BQU1FO01BQ1hEO01BQ0FEO0lBQ0YsQ0FBQTtBQUVBMkssWUFBUUMsVUFBVTVLLE9BQU80SSxPQUFPM0ksT0FBQUE7QUFDaEMwSyxZQUFRRSxPQUFPN0ssT0FBTzRJLEtBQUFBO0FBQ3RCaUQsSUFBQUEsS0FBSW9DLElBQUlqTyxPQUFPNEksS0FBQUE7RUFDakI7RUFFQWtDLEtBQUs5SyxPQUFPO0FBQ1YySyxZQUFRSSxVQUFVL0ssT0FBTzZMLEtBQUlxQyxJQUFJbE8sS0FBQUEsQ0FBQUE7QUFDakM2TCxJQUFBQSxLQUFJc0MsT0FBT25PLEtBQUFBO0VBQ2I7RUFFQWdMLGFBQWFoTCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDbEMsVUFBTTJJLFFBQVFpRCxLQUFJcUMsSUFBSWxPLEtBQUFBO0FBQ3RCMkssWUFBUUMsVUFBVTVLLE9BQU80SSxPQUFPM0ksT0FBQUE7QUFDaEMySSxVQUFNM0ksVUFBVUE7RUFDbEI7RUFFQStFLFVBQVU7SUFDUmQsT0FBTztJQUNQakMsU0FBUztJQUNURyxNQUFNO01BQ0puQixRQUFRO0lBQ1Y7SUFDQUMsVUFBVTtJQUNWeUIsU0FBUztJQUNUM0IsVUFBVTtJQUNWdUMsTUFBTTtJQUNOdEMsUUFBUTtFQUNWO0VBRUE2TSxlQUFlO0lBQ2I3SSxPQUFPO0VBQ1Q7RUFFQXlILGFBQWE7SUFDWEMsYUFBYTtJQUNib0IsWUFBWTtFQUNkO0FBQ0Y7QUNwQ0EsSUFBTUssY0FBYztFQUlsQkMsUUFBUUMsT0FBTztBQUNiLFFBQUksQ0FBQ0EsTUFBTTlLLFFBQVE7QUFDakIsYUFBTzs7QUFHVCxRQUFJSixJQUFHbUw7QUFDUCxRQUFJQyxPQUFPLG9CQUFJQyxJQUFBQTtBQUNmLFFBQUlsSixLQUFJO0FBQ1IsUUFBSW1KLFFBQVE7QUFFWixTQUFLdEwsS0FBSSxHQUFHbUwsTUFBTUQsTUFBTTlLLFFBQVFKLEtBQUltTCxLQUFLLEVBQUVuTCxJQUFHO0FBQzVDLFlBQU11TCxLQUFLTCxNQUFNbEwsRUFBQUEsRUFBR3dMO0FBQ3BCLFVBQUlELE1BQU1BLEdBQUdFLFNBQVEsR0FBSTtBQUN2QixjQUFNekIsTUFBTXVCLEdBQUdHLGdCQUFlO0FBQzlCTixhQUFLTyxJQUFJM0IsSUFBSTNJLENBQUM7QUFDZGMsUUFBQUEsTUFBSzZILElBQUk3SDtBQUNULFVBQUVtSjs7SUFFTjtBQUdBLFFBQUlBLFVBQVUsS0FBS0YsS0FBS25NLFNBQVMsR0FBRztBQUNsQyxhQUFPOztBQUdULFVBQU0yTSxXQUFXO01BQUlSLEdBQUFBO01BQU12RixPQUFPLENBQUM3SixJQUFHQyxPQUFNRCxLQUFJQyxFQUFBQSxJQUFLbVAsS0FBS25NO0FBRTFELFdBQU87TUFDTG9DLEdBQUd1SztNQUNIekosR0FBR0EsS0FBSW1KO0lBQ1Q7RUFDRjtFQUtBTyxRQUFRWCxPQUFPWSxlQUFlO0FBQzVCLFFBQUksQ0FBQ1osTUFBTTlLLFFBQVE7QUFDakIsYUFBTzs7QUFHVCxRQUFJaUIsS0FBSXlLLGNBQWN6SztBQUN0QixRQUFJYyxLQUFJMkosY0FBYzNKO0FBQ3RCLFFBQUk0SixjQUFjQyxPQUFPQztBQUN6QixRQUFJak0sSUFBR21MLEtBQUtlO0FBRVosU0FBS2xNLEtBQUksR0FBR21MLE1BQU1ELE1BQU05SyxRQUFRSixLQUFJbUwsS0FBSyxFQUFFbkwsSUFBRztBQUM1QyxZQUFNdUwsS0FBS0wsTUFBTWxMLEVBQUFBLEVBQUd3TDtBQUNwQixVQUFJRCxNQUFNQSxHQUFHRSxTQUFRLEdBQUk7QUFDdkIsY0FBTVUsU0FBU1osR0FBR2EsZUFBYztBQUNoQyxjQUFNQyxLQUFJQyxzQkFBc0JSLGVBQWVLLE1BQUFBO0FBRS9DLFlBQUlFLEtBQUlOLGFBQWE7QUFDbkJBLHdCQUFjTTtBQUNkSCwyQkFBaUJYOzs7SUFHdkI7QUFFQSxRQUFJVyxnQkFBZ0I7QUFDbEIsWUFBTUssS0FBS0wsZUFBZVIsZ0JBQWU7QUFDekNySyxNQUFBQSxLQUFJa0wsR0FBR2xMO0FBQ1BjLE1BQUFBLEtBQUlvSyxHQUFHcEs7O0FBR1QsV0FBTztNQUNMZCxHQUFBQTtNQUNBYyxHQUFBQTtJQUNGO0VBQ0Y7QUFDRjtBQUdBLFNBQVNxSyxhQUFhQyxNQUFNQyxRQUFRO0FBQ2xDLE1BQUlBLFFBQVE7QUFDVixRQUFJNUMsUUFBUTRDLE1BQVMsR0FBQTtBQUVuQkMsWUFBTUMsVUFBVWhNLEtBQUtpTSxNQUFNSixNQUFNQyxNQUFBQTtXQUM1QjtBQUNMRCxXQUFLN0wsS0FBSzhMLE1BQUFBOzs7QUFJZCxTQUFPRDtBQUNUO0FBUUEsU0FBU0ssY0FBY0MsS0FBSztBQUMxQixPQUFLLE9BQU9BLFFBQVEsWUFBWUEsZUFBZUMsV0FBV0QsSUFBSUUsUUFBUSxJQUFBLElBQVEsSUFBSTtBQUNoRixXQUFPRixJQUFJRyxNQUFNLElBQUE7O0FBRW5CLFNBQU9IO0FBQ1Q7QUFTQSxTQUFTSSxrQkFBa0J2USxPQUFPNkIsTUFBTTtBQUN0QyxRQUFNLEVBQUMrTSxTQUFTdFAsY0FBY0MsTUFBQUEsSUFBU3NDO0FBQ3ZDLFFBQU1tSyxhQUFhaE0sTUFBTXdRLGVBQWVsUixZQUFBQSxFQUFjME07QUFDdEQsUUFBTSxFQUFDRSxPQUFPdUUsTUFBQUEsSUFBU3pFLFdBQVcwRSxpQkFBaUJuUixLQUFBQTtBQUVuRCxTQUFPO0lBQ0xTO0lBQ0FrTTtJQUNBeUUsUUFBUTNFLFdBQVc0RSxVQUFVclIsS0FBQUE7SUFDN0JzUixLQUFLN1EsTUFBTThCLEtBQUs0SixTQUFTcE0sWUFBYSxFQUFDd0MsS0FBS3ZDLEtBQU07SUFDbER1UixnQkFBZ0JMO0lBQ2hCTSxTQUFTL0UsV0FBV2dGLFdBQVU7SUFDOUJDLFdBQVcxUjtJQUNYRDtJQUNBc1A7RUFDRjtBQUNGO0FBS0EsU0FBU3NDLGVBQWVDLFNBQVNsUixTQUFTO0FBQ3hDLFFBQU1DLE1BQU1pUixRQUFRblIsTUFBTUU7QUFDMUIsUUFBTSxFQUFDa1IsTUFBTUMsUUFBUXpJLE1BQUFBLElBQVN1STtBQUM5QixRQUFNLEVBQUN2UyxVQUFVRCxVQUFBQSxJQUFhc0I7QUFDOUIsUUFBTXFSLFdBQVduUCxPQUFPbEMsUUFBUXFSLFFBQVE7QUFDeEMsUUFBTXpJLFlBQVkxRyxPQUFPbEMsUUFBUTRJLFNBQVM7QUFDMUMsUUFBTTBJLGFBQWFwUCxPQUFPbEMsUUFBUXNSLFVBQVU7QUFDNUMsUUFBTUMsaUJBQWlCNUksTUFBTXBGO0FBQzdCLFFBQU1pTyxrQkFBa0JKLE9BQU83TjtBQUMvQixRQUFNa08sb0JBQW9CTixLQUFLNU47QUFFL0IsUUFBTWIsVUFBVW9HLFVBQVU5SSxRQUFRMEMsT0FBTztBQUN6QyxNQUFJOUIsU0FBUzhCLFFBQVE5QjtBQUNyQixNQUFJQyxRQUFRO0FBR1osTUFBSTZRLHFCQUFxQlAsS0FBS25JLE9BQU8sQ0FBQ3lGLE9BQU9rRCxhQUFhbEQsUUFBUWtELFNBQVNDLE9BQU9yTyxTQUFTb08sU0FBU0UsTUFBTXRPLFNBQVNvTyxTQUFTRyxNQUFNdk8sUUFBUSxDQUFBO0FBQzFJbU8sd0JBQXNCUixRQUFRYSxXQUFXeE8sU0FBUzJOLFFBQVFjLFVBQVV6TztBQUVwRSxNQUFJZ08sZ0JBQWdCO0FBQ2xCM1EsY0FBVTJRLGlCQUFpQjNJLFVBQVVoRyxjQUNuQzJPLGlCQUFpQixLQUFLdlIsUUFBUWlTLGVBQy9CalMsUUFBUWtTOztBQUVYLE1BQUlSLG9CQUFvQjtBQUV0QixVQUFNUyxpQkFBaUJuUyxRQUFRb1MsZ0JBQWdCdlQsS0FBS0ksSUFBSVAsV0FBVzJTLFNBQVN6TyxVQUFVLElBQUl5TyxTQUFTek87QUFDbkdoQyxjQUFVNlEsb0JBQW9CVSxrQkFDNUJULHFCQUFxQkQscUJBQXFCSixTQUFTek8sY0FDbkQ4TyxxQkFBcUIsS0FBSzFSLFFBQVFxUzs7QUFFdEMsTUFBSWIsaUJBQWlCO0FBQ25CNVEsY0FBVVosUUFBUXNTLGtCQUNqQmQsa0JBQWtCRixXQUFXMU8sY0FDNUI0TyxrQkFBa0IsS0FBS3hSLFFBQVF1Uzs7QUFJbkMsTUFBSUMsZUFBZTtBQUNuQixRQUFNQyxlQUFlLFNBQVMxSyxNQUFNO0FBQ2xDbEgsWUFBUWhDLEtBQUtJLElBQUk0QixPQUFPWixJQUFJb0QsWUFBWTBFLElBQU1sSCxFQUFBQSxRQUFRMlIsWUFBQUE7RUFDeEQ7QUFFQXZTLE1BQUl1RixLQUFJO0FBRVJ2RixNQUFJa0MsT0FBT3lHLFVBQVVyRztBQUNyQm1RLE9BQUt4QixRQUFRdkksT0FBTzhKLFlBQUFBO0FBR3BCeFMsTUFBSWtDLE9BQU9rUCxTQUFTOU87QUFDcEJtUSxPQUFLeEIsUUFBUWEsV0FBV1ksT0FBT3pCLFFBQVFjLFNBQVMsR0FBR1MsWUFBQUE7QUFHbkRELGlCQUFleFMsUUFBUW9TLGdCQUFpQnpULFdBQVcsSUFBSXFCLFFBQVE0UyxhQUFjO0FBQzdFRixPQUFLdkIsTUFBTSxDQUFDUSxhQUFhO0FBQ3ZCZSxTQUFLZixTQUFTQyxRQUFRYSxZQUFBQTtBQUN0QkMsU0FBS2YsU0FBU0UsT0FBT1ksWUFBQUE7QUFDckJDLFNBQUtmLFNBQVNHLE9BQU9XLFlBQUFBO0VBQ3ZCLENBQUE7QUFHQUQsaUJBQWU7QUFHZnZTLE1BQUlrQyxPQUFPbVAsV0FBVy9PO0FBQ3RCbVEsT0FBS3hCLFFBQVFFLFFBQVFxQixZQUFBQTtBQUVyQnhTLE1BQUl5SCxRQUFPO0FBR1g3RyxXQUFTNkIsUUFBUTdCO0FBRWpCLFNBQU87SUFBQ0E7SUFBT0Q7RUFBTTtBQUN2QjtBQUVBLFNBQVNpUyxnQkFBZ0I5UyxPQUFPcUMsTUFBTTtBQUNwQyxRQUFNLEVBQUNrRCxHQUFBQSxJQUFHMUUsT0FBQUEsSUFBVXdCO0FBRXBCLE1BQUlrRCxLQUFJMUUsU0FBUyxHQUFHO0FBQ2xCLFdBQU87RUFDVCxXQUFXMEUsS0FBS3ZGLE1BQU1hLFNBQVNBLFNBQVMsR0FBSTtBQUMxQyxXQUFPOztBQUVULFNBQU87QUFDVDtBQUVBLFNBQVNrUyxvQkFBb0JDLFFBQVFoVCxPQUFPQyxTQUFTb0MsTUFBTTtBQUN6RCxRQUFNLEVBQUNvQyxHQUFBQSxJQUFHM0QsTUFBQUEsSUFBU3VCO0FBQ25CLFFBQU00USxRQUFRaFQsUUFBUWlULFlBQVlqVCxRQUFRa1Q7QUFDMUMsTUFBSUgsV0FBVyxVQUFVdk8sS0FBSTNELFFBQVFtUyxRQUFRalQsTUFBTWMsT0FBTztBQUN4RCxXQUFPOztBQUdULE1BQUlrUyxXQUFXLFdBQVd2TyxLQUFJM0QsUUFBUW1TLFFBQVEsR0FBRztBQUMvQyxXQUFPOztBQUVYO0FBRUEsU0FBU0csZ0JBQWdCcFQsT0FBT0MsU0FBU29DLE1BQU1nUixRQUFRO0FBQ3JELFFBQU0sRUFBQzVPLEdBQUFBLElBQUczRCxNQUFBQSxJQUFTdUI7QUFDbkIsUUFBTSxFQUFDdkIsT0FBT3dTLFlBQVlDLFdBQVcsRUFBQzVTLE1BQU1DLE1BQUssRUFBQyxJQUFJWjtBQUN0RCxNQUFJZ1QsU0FBUztBQUViLE1BQUlLLFdBQVcsVUFBVTtBQUN2QkwsYUFBU3ZPLE9BQU05RCxPQUFPQyxTQUFTLElBQUksU0FBUzthQUNuQzZELE1BQUszRCxRQUFRLEdBQUc7QUFDekJrUyxhQUFTO0VBQ1gsV0FBV3ZPLE1BQUs2TyxhQUFheFMsUUFBUSxHQUFHO0FBQ3RDa1MsYUFBUzs7QUFHWCxNQUFJRCxvQkFBb0JDLFFBQVFoVCxPQUFPQyxTQUFTb0MsSUFBTyxHQUFBO0FBQ3JEMlEsYUFBUzs7QUFHWCxTQUFPQTtBQUNUO0FBS0EsU0FBU1EsbUJBQW1CeFQsT0FBT0MsU0FBU29DLE1BQU07QUFDaEQsUUFBTWdSLFNBQVNoUixLQUFLZ1IsVUFBVXBULFFBQVFvVCxVQUFVUCxnQkFBZ0I5UyxPQUFPcUMsSUFBQUE7QUFFdkUsU0FBTztJQUNMMlEsUUFBUTNRLEtBQUsyUSxVQUFVL1MsUUFBUStTLFVBQVVJLGdCQUFnQnBULE9BQU9DLFNBQVNvQyxNQUFNZ1IsTUFBQUE7SUFDL0VBO0VBQ0Y7QUFDRjtBQUVBLFNBQVNJLE9BQU9wUixNQUFNMlEsUUFBUTtBQUM1QixNQUFJLEVBQUN2TyxHQUFBQSxJQUFHM0QsTUFBQUEsSUFBU3VCO0FBQ2pCLE1BQUkyUSxXQUFXLFNBQVM7QUFDdEJ2TyxJQUFBQSxNQUFLM0Q7YUFDSWtTLFdBQVcsVUFBVTtBQUM5QnZPLElBQUFBLE1BQU0zRCxRQUFROztBQUVoQixTQUFPMkQ7QUFDVDtBQUVBLFNBQVNpUCxPQUFPclIsTUFBTWdSLFFBQVFNLGdCQUFnQjtBQUU1QyxNQUFJLEVBQUNwTyxHQUFBQSxJQUFHMUUsT0FBQUEsSUFBVXdCO0FBQ2xCLE1BQUlnUixXQUFXLE9BQU87QUFDcEI5TixJQUFBQSxNQUFLb087YUFDSU4sV0FBVyxVQUFVO0FBQzlCOU4sSUFBQUEsTUFBSzFFLFNBQVM4UztTQUNUO0FBQ0xwTyxJQUFBQSxNQUFNMUUsU0FBUzs7QUFFakIsU0FBTzBFO0FBQ1Q7QUFLQSxTQUFTcU8sbUJBQW1CM1QsU0FBU29DLE1BQU13UixXQUFXN1QsT0FBTztBQUMzRCxRQUFNLEVBQUNrVCxXQUFXQyxjQUFjVyxhQUFBQSxJQUFnQjdUO0FBQ2hELFFBQU0sRUFBQytTLFFBQVFLLE9BQUFBLElBQVVRO0FBQ3pCLFFBQU1GLGlCQUFpQlQsWUFBWUM7QUFDbkMsUUFBTSxFQUFDWSxTQUFTQyxVQUFVQyxZQUFZQyxZQUFBQSxJQUFlbk4sY0FBYytNLFlBQUFBO0FBRW5FLE1BQUlyUCxLQUFJZ1AsT0FBT3BSLE1BQU0yUSxNQUFBQTtBQUNyQixRQUFNek4sS0FBSW1PLE9BQU9yUixNQUFNZ1IsUUFBUU0sY0FBQUE7QUFFL0IsTUFBSU4sV0FBVyxVQUFVO0FBQ3ZCLFFBQUlMLFdBQVcsUUFBUTtBQUNyQnZPLE1BQUFBLE1BQUtrUDtlQUNJWCxXQUFXLFNBQVM7QUFDN0J2TyxNQUFBQSxNQUFLa1A7O2FBRUVYLFdBQVcsUUFBUTtBQUM1QnZPLElBQUFBLE1BQUszRixLQUFLSSxJQUFJNlUsU0FBU0UsVUFBY2YsSUFBQUE7YUFDNUJGLFdBQVcsU0FBUztBQUM3QnZPLElBQUFBLE1BQUszRixLQUFLSSxJQUFJOFUsVUFBVUUsV0FBZWhCLElBQUFBOztBQUd6QyxTQUFPO0lBQ0x6TyxHQUFHMFAsWUFBWTFQLElBQUcsR0FBR3pFLE1BQU1jLFFBQVF1QixLQUFLdkIsS0FBSztJQUM3Q3lFLEdBQUc0TyxZQUFZNU8sSUFBRyxHQUFHdkYsTUFBTWEsU0FBU3dCLEtBQUt4QixNQUFNO0VBQ2pEO0FBQ0Y7QUFFQSxTQUFTdVQsWUFBWWpELFNBQVNqTixPQUFPakUsU0FBUztBQUM1QyxRQUFNMEMsVUFBVW9HLFVBQVU5SSxRQUFRMEMsT0FBTztBQUV6QyxTQUFPdUIsVUFBVSxXQUNiaU4sUUFBUTFNLElBQUkwTSxRQUFRclEsUUFBUSxJQUM1Qm9ELFVBQVUsVUFDUmlOLFFBQVExTSxJQUFJME0sUUFBUXJRLFFBQVE2QixRQUFRL0IsUUFDcEN1USxRQUFRMU0sSUFBSTlCLFFBQVFoQztBQUM1QjtBQUtBLFNBQVMwVCx3QkFBd0JDLFdBQVU7QUFDekMsU0FBTzFFLGFBQWEsQ0FBQSxHQUFJTSxjQUFjb0UsU0FBQUEsQ0FBQUE7QUFDeEM7QUFFQSxTQUFTQyxxQkFBcUJDLFFBQVFyRCxTQUFTc0QsY0FBYztBQUMzRCxTQUFPQyxjQUFjRixRQUFRO0lBQzNCckQ7SUFDQXNEO0lBQ0E5SyxNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRUEsU0FBU2dMLGtCQUFrQkMsV0FBV0MsU0FBUztBQUM3QyxRQUFNQyxXQUFXRCxXQUFXQSxRQUFROUQsV0FBVzhELFFBQVE5RCxRQUFRSSxXQUFXMEQsUUFBUTlELFFBQVFJLFFBQVF5RDtBQUNsRyxTQUFPRSxXQUFXRixVQUFVRSxTQUFTQSxRQUFBQSxJQUFZRjtBQUNuRDtBQUVBLElBQU1HLG1CQUFtQjtFQUV2QkMsYUFBYUM7RUFDYnJNLE1BQU02TCxjQUFjO0FBQ2xCLFFBQUlBLGFBQWFqUixTQUFTLEdBQUc7QUFDM0IsWUFBTTNCLE9BQU80UyxhQUFhLENBQUU7QUFDNUIsWUFBTWhULFNBQVNJLEtBQUs3QixNQUFNOEIsS0FBS0w7QUFDL0IsWUFBTXlULGFBQWF6VCxTQUFTQSxPQUFPK0IsU0FBUztBQUU1QyxVQUFJLFFBQVEsS0FBS3ZELFdBQVcsS0FBS0EsUUFBUWtWLFNBQVMsV0FBVztBQUMzRCxlQUFPdFQsS0FBS2tQLFFBQVE3RSxTQUFTO2lCQUNwQnJLLEtBQUtxSyxPQUFPO0FBQ3JCLGVBQU9ySyxLQUFLcUs7TUFDZCxXQUFXZ0osYUFBYSxLQUFLclQsS0FBS29QLFlBQVlpRSxZQUFZO0FBQ3hELGVBQU96VCxPQUFPSSxLQUFLb1AsU0FBUzs7O0FBSWhDLFdBQU87RUFDVDtFQUNBbUUsWUFBWUg7RUFHWmpELFlBQVlpRDtFQUdaSSxhQUFhSjtFQUNiL0ksTUFBTW9KLGFBQWE7QUFDakIsUUFBSSxRQUFRLEtBQUtyVixXQUFXLEtBQUtBLFFBQVFrVixTQUFTLFdBQVc7QUFDM0QsYUFBT0csWUFBWXBKLFFBQVEsT0FBT29KLFlBQVl4RSxrQkFBa0J3RSxZQUFZeEU7O0FBRzlFLFFBQUk1RSxRQUFRb0osWUFBWXZFLFFBQVE3RSxTQUFTO0FBRXpDLFFBQUlBLE9BQU87QUFDVEEsZUFBUzs7QUFFWCxVQUFNdUUsUUFBUTZFLFlBQVl4RTtBQUMxQixRQUFJLENBQUN5RSxjQUFjOUUsS0FBUSxHQUFBO0FBQ3pCdkUsZUFBU3VFOztBQUVYLFdBQU92RTtFQUNUO0VBQ0FzSixXQUFXRixhQUFhO0FBQ3RCLFVBQU14SixPQUFPd0osWUFBWXRWLE1BQU13USxlQUFlOEUsWUFBWWhXLFlBQVk7QUFDdEUsVUFBTVcsVUFBVTZMLEtBQUtFLFdBQVdDLFNBQVNxSixZQUFZckUsU0FBUztBQUM5RCxXQUFPO01BQ0x4RSxhQUFheE0sUUFBUXdNO01BQ3JCTixpQkFBaUJsTSxRQUFRa007TUFDekI1RixhQUFhdEcsUUFBUXNHO01BQ3JCK0YsWUFBWXJNLFFBQVFxTTtNQUNwQkMsa0JBQWtCdE0sUUFBUXNNO01BQzFCekYsY0FBYztJQUNoQjtFQUNGO0VBQ0EyTyxpQkFBaUI7QUFDZixXQUFPLEtBQUt4VixRQUFReVY7RUFDdEI7RUFDQUMsZ0JBQWdCTCxhQUFhO0FBQzNCLFVBQU14SixPQUFPd0osWUFBWXRWLE1BQU13USxlQUFlOEUsWUFBWWhXLFlBQVk7QUFDdEUsVUFBTVcsVUFBVTZMLEtBQUtFLFdBQVdDLFNBQVNxSixZQUFZckUsU0FBUztBQUM5RCxXQUFPO01BQ0w1SyxZQUFZcEcsUUFBUW9HO01BQ3BCQyxVQUFVckcsUUFBUXFHO0lBQ3BCO0VBQ0Y7RUFDQXNQLFlBQVlYO0VBR1poRCxXQUFXZ0Q7RUFHWFksY0FBY1o7RUFDZDVELFFBQVE0RDtFQUNSYSxhQUFhYjtBQUNmO0FBV0EsU0FBU2MsMkJBQTJCbkIsV0FBV2hJLE1BQU0xTSxLQUFLOFYsS0FBSztBQUM3RCxRQUFNQyxTQUFTckIsVUFBVWhJLElBQUFBLEVBQU1sTCxLQUFLeEIsS0FBSzhWLEdBQUFBO0FBRXpDLE1BQUksT0FBT0MsV0FBVyxhQUFhO0FBQ2pDLFdBQU9sQixpQkFBaUJuSSxJQUFBQSxFQUFNbEwsS0FBS3hCLEtBQUs4VixHQUFBQTs7QUFHMUMsU0FBT0M7QUFDVDtBQUVPLElBQU1DLFVBQU4sY0FBc0J6VyxRQUFBQTtFQU8zQkMsWUFBWUMsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS3dXLFVBQVU7QUFDZixTQUFLQyxVQUFVLENBQUE7QUFDZixTQUFLQyxpQkFBaUJqVztBQUN0QixTQUFLa1csUUFBUWxXO0FBQ2IsU0FBS21XLG9CQUFvQm5XO0FBQ3pCLFNBQUtvVyxnQkFBZ0IsQ0FBQTtBQUNyQixTQUFLQyxjQUFjclc7QUFDbkIsU0FBS3NXLFdBQVd0VztBQUNoQixTQUFLSixRQUFRTCxPQUFPSztBQUNwQixTQUFLQyxVQUFVTixPQUFPTTtBQUN0QixTQUFLMFcsYUFBYXZXO0FBQ2xCLFNBQUt3SSxRQUFReEk7QUFDYixTQUFLNFIsYUFBYTVSO0FBQ2xCLFNBQUtnUixPQUFPaFI7QUFDWixTQUFLNlIsWUFBWTdSO0FBQ2pCLFNBQUtpUixTQUFTalI7QUFDZCxTQUFLNFMsU0FBUzVTO0FBQ2QsU0FBS2lULFNBQVNqVDtBQUNkLFNBQUtxRSxJQUFJckU7QUFDVCxTQUFLbUYsSUFBSW5GO0FBQ1QsU0FBS1MsU0FBU1Q7QUFDZCxTQUFLVSxRQUFRVjtBQUNiLFNBQUt3VyxTQUFTeFc7QUFDZCxTQUFLeVcsU0FBU3pXO0FBR2QsU0FBSzBXLGNBQWMxVztBQUNuQixTQUFLMlcsbUJBQW1CM1c7QUFDeEIsU0FBSzRXLGtCQUFrQjVXO0VBQ3pCO0VBRUE2VyxXQUFXaFgsU0FBUztBQUNsQixTQUFLQSxVQUFVQTtBQUNmLFNBQUtzVyxvQkFBb0JuVztBQUN6QixTQUFLc1csV0FBV3RXO0VBQ2xCO0VBS0E4VyxxQkFBcUI7QUFDbkIsVUFBTUMsU0FBUyxLQUFLWjtBQUVwQixRQUFJWSxRQUFRO0FBQ1YsYUFBT0E7O0FBR1QsVUFBTW5YLFFBQVEsS0FBS0E7QUFDbkIsVUFBTUMsVUFBVSxLQUFLQSxRQUFRbVgsV0FBVyxLQUFLQyxXQUFVLENBQUE7QUFDdkQsVUFBTXZTLE9BQU83RSxRQUFRcVgsV0FBV3RYLE1BQU1DLFFBQVFzWCxhQUFhdFgsUUFBUXVYO0FBQ25FLFVBQU1BLGFBQWEsSUFBSUMsV0FBVyxLQUFLelgsT0FBTzhFLElBQUFBO0FBQzlDLFFBQUlBLEtBQUs0UyxZQUFZO0FBQ25CLFdBQUtuQixvQkFBb0J0UCxPQUFPMFEsT0FBT0gsVUFBQUE7O0FBR3pDLFdBQU9BO0VBQ1Q7RUFLQUgsYUFBYTtBQUNYLFdBQU8sS0FBS1gsYUFDWixLQUFLQSxXQUFXbkMscUJBQXFCLEtBQUt2VSxNQUFNcVgsV0FBVSxHQUFJLE1BQU0sS0FBS2IsYUFBYTtFQUN4RjtFQUVBb0IsU0FBUy9DLFNBQVM1VSxTQUFTO0FBQ3pCLFVBQU0sRUFBQzJVLFVBQVMsSUFBSTNVO0FBRXBCLFVBQU0rVSxjQUFjZSwyQkFBMkJuQixXQUFXLGVBQWUsTUFBTUMsT0FBQUE7QUFDL0UsVUFBTWpNLFFBQVFtTiwyQkFBMkJuQixXQUFXLFNBQVMsTUFBTUMsT0FBQUE7QUFDbkUsVUFBTU8sYUFBYVcsMkJBQTJCbkIsV0FBVyxjQUFjLE1BQU1DLE9BQUFBO0FBRTdFLFFBQUkvQyxRQUFRLENBQUE7QUFDWkEsWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBYzhFLFdBQUFBLENBQUFBO0FBQzFDbEQsWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBY3RILEtBQUFBLENBQUFBO0FBQzFDa0osWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBY2tGLFVBQUFBLENBQUFBO0FBRTFDLFdBQU90RDtFQUNUO0VBRUErRixjQUFjcEQsY0FBY3hVLFNBQVM7QUFDbkMsV0FBT29VLHdCQUNMMEIsMkJBQTJCOVYsUUFBUTJVLFdBQVcsY0FBYyxNQUFNSCxZQUFBQSxDQUFBQTtFQUV0RTtFQUVBcUQsUUFBUXJELGNBQWN4VSxTQUFTO0FBQzdCLFVBQU0sRUFBQzJVLFVBQVMsSUFBSTNVO0FBQ3BCLFVBQU04WCxZQUFZLENBQUE7QUFFbEJwRixTQUFLOEIsY0FBYyxDQUFDSSxZQUFZO0FBQzlCLFlBQU1qRCxXQUFXO1FBQ2ZDLFFBQVEsQ0FBQTtRQUNSQyxPQUFPLENBQUE7UUFDUEMsT0FBTyxDQUFBO01BQ1Q7QUFDQSxZQUFNaUcsU0FBU3JELGtCQUFrQkMsV0FBV0MsT0FBQUE7QUFDNUNqRixtQkFBYWdDLFNBQVNDLFFBQVEzQixjQUFjNkYsMkJBQTJCaUMsUUFBUSxlQUFlLE1BQU1uRCxPQUFBQSxDQUFBQSxDQUFBQTtBQUNwR2pGLG1CQUFhZ0MsU0FBU0UsT0FBT2lFLDJCQUEyQmlDLFFBQVEsU0FBUyxNQUFNbkQsT0FBQUEsQ0FBQUE7QUFDL0VqRixtQkFBYWdDLFNBQVNHLE9BQU83QixjQUFjNkYsMkJBQTJCaUMsUUFBUSxjQUFjLE1BQU1uRCxPQUFBQSxDQUFBQSxDQUFBQTtBQUVsR2tELGdCQUFVL1QsS0FBSzROLFFBQUFBO0lBQ2pCLENBQUE7QUFFQSxXQUFPbUc7RUFDVDtFQUVBRSxhQUFheEQsY0FBY3hVLFNBQVM7QUFDbEMsV0FBT29VLHdCQUNMMEIsMkJBQTJCOVYsUUFBUTJVLFdBQVcsYUFBYSxNQUFNSCxZQUFBQSxDQUFBQTtFQUVyRTtFQUdBeUQsVUFBVXpELGNBQWN4VSxTQUFTO0FBQy9CLFVBQU0sRUFBQzJVLFVBQVMsSUFBSTNVO0FBRXBCLFVBQU00VixlQUFlRSwyQkFBMkJuQixXQUFXLGdCQUFnQixNQUFNSCxZQUFBQTtBQUNqRixVQUFNcEQsU0FBUzBFLDJCQUEyQm5CLFdBQVcsVUFBVSxNQUFNSCxZQUFBQTtBQUNyRSxVQUFNcUIsY0FBY0MsMkJBQTJCbkIsV0FBVyxlQUFlLE1BQU1ILFlBQUFBO0FBRS9FLFFBQUkzQyxRQUFRLENBQUE7QUFDWkEsWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBYzJGLFlBQUFBLENBQUFBO0FBQzFDL0QsWUFBUWxDLGFBQWFrQyxPQUFPNUIsY0FBY21CLE1BQUFBLENBQUFBO0FBQzFDUyxZQUFRbEMsYUFBYWtDLE9BQU81QixjQUFjNEYsV0FBQUEsQ0FBQUE7QUFFMUMsV0FBT2hFO0VBQ1Q7RUFLQXFHLGFBQWFsWSxTQUFTO0FBQ3BCLFVBQU1tWSxTQUFTLEtBQUtoQztBQUNwQixVQUFNdFUsT0FBTyxLQUFLOUIsTUFBTThCO0FBQ3hCLFVBQU1nVixjQUFjLENBQUE7QUFDcEIsVUFBTUMsbUJBQW1CLENBQUE7QUFDekIsVUFBTUMsa0JBQWtCLENBQUE7QUFDeEIsUUFBSXZDLGVBQWUsQ0FBQTtBQUNuQixRQUFJclIsSUFBR21MO0FBRVAsU0FBS25MLEtBQUksR0FBR21MLE1BQU02SixPQUFPNVUsUUFBUUosS0FBSW1MLEtBQUssRUFBRW5MLElBQUc7QUFDN0NxUixtQkFBYXpRLEtBQUt1TSxrQkFBa0IsS0FBS3ZRLE9BQU9vWSxPQUFPaFYsRUFBRSxDQUFBLENBQUE7SUFDM0Q7QUFHQSxRQUFJbkQsUUFBUTJCLFFBQVE7QUFDbEI2UyxxQkFBZUEsYUFBYTdTLE9BQU8sQ0FBQ2dOLFNBQVNyUCxPQUFPOFksVUFBVXBZLFFBQVEyQixPQUFPZ04sU0FBU3JQLE9BQU84WSxPQUFPdlcsSUFBQUEsQ0FBQUE7O0FBSXRHLFFBQUk3QixRQUFRcVksVUFBVTtBQUNwQjdELHFCQUFlQSxhQUFhMVMsS0FBSyxDQUFDM0MsSUFBR0MsT0FBTVksUUFBUXFZLFNBQVNsWixJQUFHQyxJQUFHeUMsSUFBQUEsQ0FBQUE7O0FBSXBFNlEsU0FBSzhCLGNBQWMsQ0FBQ0ksWUFBWTtBQUM5QixZQUFNbUQsU0FBU3JELGtCQUFrQjFVLFFBQVEyVSxXQUFXQyxPQUFBQTtBQUNwRGlDLGtCQUFZOVMsS0FBSytSLDJCQUEyQmlDLFFBQVEsY0FBYyxNQUFNbkQsT0FBQUEsQ0FBQUE7QUFDeEVrQyx1QkFBaUIvUyxLQUFLK1IsMkJBQTJCaUMsUUFBUSxtQkFBbUIsTUFBTW5ELE9BQUFBLENBQUFBO0FBQ2xGbUMsc0JBQWdCaFQsS0FBSytSLDJCQUEyQmlDLFFBQVEsa0JBQWtCLE1BQU1uRCxPQUFBQSxDQUFBQTtJQUNsRixDQUFBO0FBRUEsU0FBS2lDLGNBQWNBO0FBQ25CLFNBQUtDLG1CQUFtQkE7QUFDeEIsU0FBS0Msa0JBQWtCQTtBQUN2QixTQUFLTCxhQUFhbEM7QUFDbEIsV0FBT0E7RUFDVDtFQUVBdFQsT0FBT29YLFNBQVNuTixRQUFRO0FBQ3RCLFVBQU1uTCxVQUFVLEtBQUtBLFFBQVFtWCxXQUFXLEtBQUtDLFdBQVUsQ0FBQTtBQUN2RCxVQUFNZSxTQUFTLEtBQUtoQztBQUNwQixRQUFJb0M7QUFDSixRQUFJL0QsZUFBZSxDQUFBO0FBRW5CLFFBQUksQ0FBQzJELE9BQU81VSxRQUFRO0FBQ2xCLFVBQUksS0FBSzJTLFlBQVksR0FBRztBQUN0QnFDLHFCQUFhO1VBQ1hyQyxTQUFTO1FBQ1g7O1dBRUc7QUFDTCxZQUFNblYsV0FBV29OLFlBQVluTyxRQUFRZSxRQUFRLEVBQUVVLEtBQUssTUFBTTBXLFFBQVEsS0FBSy9CLGNBQWM7QUFDckY1QixxQkFBZSxLQUFLMEQsYUFBYWxZLE9BQUFBO0FBRWpDLFdBQUsySSxRQUFRLEtBQUtnUCxTQUFTbkQsY0FBY3hVLE9BQUFBO0FBQ3pDLFdBQUsrUixhQUFhLEtBQUs2RixjQUFjcEQsY0FBY3hVLE9BQUFBO0FBQ25ELFdBQUttUixPQUFPLEtBQUswRyxRQUFRckQsY0FBY3hVLE9BQUFBO0FBQ3ZDLFdBQUtnUyxZQUFZLEtBQUtnRyxhQUFheEQsY0FBY3hVLE9BQUFBO0FBQ2pELFdBQUtvUixTQUFTLEtBQUs2RyxVQUFVekQsY0FBY3hVLE9BQUFBO0FBRTNDLFlBQU1vQyxPQUFPLEtBQUtpVSxRQUFRcEYsZUFBZSxNQUFNalIsT0FBQUE7QUFDL0MsWUFBTXdZLGtCQUFrQnhSLE9BQU95UixPQUFPLENBQUEsR0FBSTFYLFVBQVVxQixJQUFBQTtBQUNwRCxZQUFNd1IsWUFBWUwsbUJBQW1CLEtBQUt4VCxPQUFPQyxTQUFTd1ksZUFBQUE7QUFDMUQsWUFBTUUsa0JBQWtCL0UsbUJBQW1CM1QsU0FBU3dZLGlCQUFpQjVFLFdBQVcsS0FBSzdULEtBQUs7QUFFMUYsV0FBS2dULFNBQVNhLFVBQVViO0FBQ3hCLFdBQUtLLFNBQVNRLFVBQVVSO0FBRXhCbUYsbUJBQWE7UUFDWHJDLFNBQVM7UUFDVDFSLEdBQUdrVSxnQkFBZ0JsVTtRQUNuQmMsR0FBR29ULGdCQUFnQnBUO1FBQ25CekUsT0FBT3VCLEtBQUt2QjtRQUNaRCxRQUFRd0IsS0FBS3hCO1FBQ2IrVixRQUFRNVYsU0FBU3lEO1FBQ2pCb1MsUUFBUTdWLFNBQVN1RTtNQUNuQjs7QUFHRixTQUFLaVIsZ0JBQWdCL0I7QUFDckIsU0FBS2lDLFdBQVd0VztBQUVoQixRQUFJb1ksWUFBWTtBQUNkLFdBQUt0QixtQkFBa0IsRUFBRy9WLE9BQU8sTUFBTXFYLFVBQUFBOztBQUd6QyxRQUFJRCxXQUFXdFksUUFBUTJZLFVBQVU7QUFDL0IzWSxjQUFRMlksU0FBU2xYLEtBQUssTUFBTTtRQUFDMUIsT0FBTyxLQUFLQTtRQUFPbVIsU0FBUztRQUFNL0Y7TUFBTSxDQUFBOztFQUV6RTtFQUVBeU4sVUFBVUMsY0FBYzVZLEtBQUttQyxNQUFNcEMsU0FBUztBQUMxQyxVQUFNOFksZ0JBQWdCLEtBQUtDLGlCQUFpQkYsY0FBY3pXLE1BQU1wQyxPQUFBQTtBQUVoRUMsUUFBSStZLE9BQU9GLGNBQWNHLElBQUlILGNBQWNJLEVBQUU7QUFDN0NqWixRQUFJK1ksT0FBT0YsY0FBY0ssSUFBSUwsY0FBY00sRUFBRTtBQUM3Q25aLFFBQUkrWSxPQUFPRixjQUFjTyxJQUFJUCxjQUFjUSxFQUFFO0VBQy9DO0VBRUFQLGlCQUFpQkYsY0FBY3pXLE1BQU1wQyxTQUFTO0FBQzVDLFVBQU0sRUFBQytTLFFBQVFLLE9BQU0sSUFBSTtBQUN6QixVQUFNLEVBQUNILFdBQVdZLGFBQUFBLElBQWdCN1Q7QUFDbEMsVUFBTSxFQUFDOFQsU0FBU0MsVUFBVUMsWUFBWUMsWUFBQUEsSUFBZW5OLGNBQWMrTSxZQUFBQTtBQUNuRSxVQUFNLEVBQUNyUCxHQUFHK1UsS0FBS2pVLEdBQUdrVSxJQUFBQSxJQUFPWDtBQUN6QixVQUFNLEVBQUNoWSxPQUFPRCxPQUFBQSxJQUFVd0I7QUFDeEIsUUFBSTZXLElBQUlFLElBQUlFLElBQUlILElBQUlFLElBQUlFO0FBRXhCLFFBQUlsRyxXQUFXLFVBQVU7QUFDdkJnRyxXQUFLSSxNQUFPNVksU0FBUztBQUVyQixVQUFJbVMsV0FBVyxRQUFRO0FBQ3JCa0csYUFBS007QUFDTEosYUFBS0YsS0FBS2hHO0FBR1ZpRyxhQUFLRSxLQUFLbkc7QUFDVnFHLGFBQUtGLEtBQUtuRzthQUNMO0FBQ0xnRyxhQUFLTSxNQUFNMVk7QUFDWHNZLGFBQUtGLEtBQUtoRztBQUdWaUcsYUFBS0UsS0FBS25HO0FBQ1ZxRyxhQUFLRixLQUFLbkc7O0FBR1pvRyxXQUFLSjtXQUNBO0FBQ0wsVUFBSWxHLFdBQVcsUUFBUTtBQUNyQm9HLGFBQUtJLE1BQU0xYSxLQUFLSSxJQUFJNlUsU0FBU0UsVUFBZWYsSUFBQUE7aUJBQ25DRixXQUFXLFNBQVM7QUFDN0JvRyxhQUFLSSxNQUFNMVksUUFBUWhDLEtBQUtJLElBQUk4VSxVQUFVRSxXQUFlaEIsSUFBQUE7YUFDaEQ7QUFDTGtHLGFBQUssS0FBS3hDOztBQUdaLFVBQUl2RCxXQUFXLE9BQU87QUFDcEI4RixhQUFLTTtBQUNMSixhQUFLRixLQUFLakc7QUFHVmdHLGFBQUtFLEtBQUtsRztBQUNWb0csYUFBS0YsS0FBS2xHO2FBQ0w7QUFDTGlHLGFBQUtNLE1BQU01WTtBQUNYd1ksYUFBS0YsS0FBS2pHO0FBR1ZnRyxhQUFLRSxLQUFLbEc7QUFDVm9HLGFBQUtGLEtBQUtsRzs7QUFFWnFHLFdBQUtKOztBQUVQLFdBQU87TUFBQ0Q7TUFBSUU7TUFBSUU7TUFBSUg7TUFBSUU7TUFBSUU7SUFBRTtFQUNoQztFQUVBblUsVUFBVXNVLEtBQUl4WixLQUFLRCxTQUFTO0FBQzFCLFVBQU0ySSxRQUFRLEtBQUtBO0FBQ25CLFVBQU1wRixTQUFTb0YsTUFBTXBGO0FBQ3JCLFFBQUlxRixXQUFXcUosY0FBYzlPO0FBRTdCLFFBQUlJLFFBQVE7QUFDVixZQUFNWSxZQUFZQyxjQUFjcEUsUUFBUWtFLEtBQUssS0FBS00sR0FBRyxLQUFLM0QsS0FBSztBQUUvRDRZLE1BQUFBLElBQUdqVixJQUFJMlAsWUFBWSxNQUFNblUsUUFBUTBaLFlBQVkxWixPQUFBQTtBQUU3Q0MsVUFBSTZDLFlBQVlxQixVQUFVckIsVUFBVTlDLFFBQVEwWixVQUFVO0FBQ3REelosVUFBSThDLGVBQWU7QUFFbkI2RixrQkFBWTFHLE9BQU9sQyxRQUFRNEksU0FBUztBQUNwQ3FKLHFCQUFlalMsUUFBUWlTO0FBRXZCaFMsVUFBSXlGLFlBQVkxRixRQUFRMlo7QUFDeEIxWixVQUFJa0MsT0FBT3lHLFVBQVVyRztBQUVyQixXQUFLWSxLQUFJLEdBQUdBLEtBQUlJLFFBQVEsRUFBRUosSUFBRztBQUMzQmxELFlBQUkwSCxTQUFTZ0IsTUFBTXhGLEVBQUFBLEdBQUlnQixVQUFVSyxFQUFFaVYsSUFBR2pWLENBQUMsR0FBR2lWLElBQUduVSxJQUFJc0QsVUFBVWhHLGFBQWEsQ0FBQTtBQUN4RTZXLFFBQUFBLElBQUduVSxLQUFLc0QsVUFBVWhHLGFBQWFxUDtBQUUvQixZQUFJOU8sS0FBSSxNQUFNSSxRQUFRO0FBQ3BCa1csVUFBQUEsSUFBR25VLEtBQUt0RixRQUFRa1Msb0JBQW9CRDs7TUFFeEM7O0VBRUo7RUFLQTJILGNBQWMzWixLQUFLd1osS0FBSXRXLElBQUdnQixXQUFXbkUsU0FBUztBQUM1QyxVQUFNdVYsYUFBYSxLQUFLc0IsWUFBWTFULEVBQUU7QUFDdEMsVUFBTXVTLGtCQUFrQixLQUFLb0IsaUJBQWlCM1QsRUFBRTtBQUNoRCxVQUFNLEVBQUN6RSxXQUFXQyxTQUFBQSxJQUFZcUI7QUFDOUIsVUFBTXFSLFdBQVduUCxPQUFPbEMsUUFBUXFSLFFBQVE7QUFDeEMsVUFBTXdJLFNBQVMxRixZQUFZLE1BQU0sUUFBUW5VLE9BQUFBO0FBQ3pDLFVBQU04WixZQUFZM1YsVUFBVUssRUFBRXFWLE1BQUFBO0FBQzlCLFVBQU1FLFVBQVVyYixZQUFZMlMsU0FBU3pPLGNBQWN5TyxTQUFTek8sYUFBYWxFLGFBQWEsSUFBSTtBQUMxRixVQUFNc2IsU0FBU1AsSUFBR25VLElBQUl5VTtBQUV0QixRQUFJL1osUUFBUXBCLGVBQWU7QUFDekIsWUFBTXFILGNBQWM7UUFDbEJDLFFBQVFySCxLQUFLQyxJQUFJSCxVQUFVRCxTQUFhLElBQUE7UUFDeEMwSCxZQUFZc1AsZ0JBQWdCdFA7UUFDNUJDLFVBQVVxUCxnQkFBZ0JyUDtRQUMxQkMsYUFBYTtNQUNmO0FBR0EsWUFBTUMsVUFBVXBDLFVBQVVJLFdBQVd1VixXQUFXbmIsUUFBQUEsSUFBWUEsV0FBVztBQUN2RSxZQUFNOEgsVUFBVXVULFNBQVN0YixZQUFZO0FBR3JDdUIsVUFBSTZGLGNBQWM5RixRQUFRaWE7QUFDMUJoYSxVQUFJeUYsWUFBWTFGLFFBQVFpYTtBQUN4QkMsZ0JBQVVqYSxLQUFLZ0csYUFBYU0sU0FBU0UsT0FBQUE7QUFHckN4RyxVQUFJNkYsY0FBY3lQLFdBQVcvSTtBQUM3QnZNLFVBQUl5RixZQUFZNlAsV0FBV3JKO0FBQzNCZ08sZ0JBQVVqYSxLQUFLZ0csYUFBYU0sU0FBU0UsT0FBQUE7V0FDaEM7QUFFTHhHLFVBQUltRixZQUFZK1UsU0FBUzVFLFdBQVdqUCxXQUFXLElBQUl6SCxLQUFLSSxJQUFPK0gsR0FBQUEsT0FBT0MsT0FBT3NPLFdBQVdqUCxXQUFXLENBQU1pUCxJQUFBQSxXQUFXalAsZUFBZTtBQUNuSXJHLFVBQUk2RixjQUFjeVAsV0FBVy9JO0FBQzdCdk0sVUFBSThGLFlBQVl3UCxXQUFXbEosY0FBYyxDQUFBLENBQUU7QUFDM0NwTSxVQUFJMkYsaUJBQWlCMlAsV0FBV2pKLG9CQUFvQjtBQUdwRCxZQUFNOE4sU0FBU2pXLFVBQVVJLFdBQVd1VixXQUFXbmIsUUFBQUE7QUFDL0MsWUFBTTBiLFNBQVNsVyxVQUFVSSxXQUFXSixVQUFVcUMsTUFBTXNULFdBQVcsQ0FBQSxHQUFJbmIsV0FBVyxDQUFBO0FBQzlFLFlBQU1rSSxlQUFlQyxjQUFjeU8sV0FBVzFPLFlBQVk7QUFFMUQsVUFBSUcsT0FBT0MsT0FBT0osWUFBQUEsRUFBY0ssS0FBS0MsQ0FBQUEsT0FBS0EsT0FBTSxDQUFJLEdBQUE7QUFDbERsSCxZQUFJOEcsVUFBUztBQUNiOUcsWUFBSXlGLFlBQVkxRixRQUFRaWE7QUFDeEI3UywyQkFBbUJuSCxLQUFLO1VBQ3RCdUUsR0FBRzRWO1VBQ0g5VSxHQUFHMFU7VUFDSDNTLEdBQUcxSTtVQUNIMkksR0FBRzVJO1VBQ0h3SCxRQUFRVztRQUNWLENBQUE7QUFDQTVHLFlBQUl1SCxLQUFJO0FBQ1J2SCxZQUFJd0gsT0FBTTtBQUdWeEgsWUFBSXlGLFlBQVk2UCxXQUFXcko7QUFDM0JqTSxZQUFJOEcsVUFBUztBQUNiSywyQkFBbUJuSCxLQUFLO1VBQ3RCdUUsR0FBRzZWO1VBQ0gvVSxHQUFHMFUsU0FBUztVQUNaM1MsR0FBRzFJLFdBQVc7VUFDZDJJLEdBQUc1SSxZQUFZO1VBQ2Z3SCxRQUFRVztRQUNWLENBQUE7QUFDQTVHLFlBQUl1SCxLQUFJO2FBQ0g7QUFFTHZILFlBQUl5RixZQUFZMUYsUUFBUWlhO0FBQ3hCaGEsWUFBSXFhLFNBQVNGLFFBQVFKLFFBQVFyYixVQUFVRCxTQUFBQTtBQUN2Q3VCLFlBQUlzYSxXQUFXSCxRQUFRSixRQUFRcmIsVUFBVUQsU0FBQUE7QUFFekN1QixZQUFJeUYsWUFBWTZQLFdBQVdySjtBQUMzQmpNLFlBQUlxYSxTQUFTRCxRQUFRTCxTQUFTLEdBQUdyYixXQUFXLEdBQUdELFlBQVksQ0FBQTs7O0FBSy9EdUIsUUFBSXlGLFlBQVksS0FBS3FSLGdCQUFnQjVULEVBQUU7RUFDekM7RUFFQXFYLFNBQVNmLEtBQUl4WixLQUFLRCxTQUFTO0FBQ3pCLFVBQU0sRUFBQ21SLEtBQUFBLElBQVE7QUFDZixVQUFNLEVBQUNrQixhQUFhb0ksV0FBV3JJLGVBQWUxVCxXQUFXQyxVQUFVaVUsV0FBQUEsSUFBYzVTO0FBQ2pGLFVBQU1xUixXQUFXblAsT0FBT2xDLFFBQVFxUixRQUFRO0FBQ3hDLFFBQUljLGlCQUFpQmQsU0FBU3pPO0FBQzlCLFFBQUk4WCxlQUFlO0FBRW5CLFVBQU12VyxZQUFZQyxjQUFjcEUsUUFBUWtFLEtBQUssS0FBS00sR0FBRyxLQUFLM0QsS0FBSztBQUUvRCxVQUFNOFosaUJBQWlCLFNBQVM1UyxNQUFNO0FBQ3BDOUgsVUFBSTBILFNBQVNJLE1BQU01RCxVQUFVSyxFQUFFaVYsSUFBR2pWLElBQUlrVyxZQUFBQSxHQUFlakIsSUFBR25VLElBQUk2TSxpQkFBaUIsQ0FBQTtBQUM3RXNILE1BQUFBLElBQUduVSxLQUFLNk0saUJBQWlCRTtJQUMzQjtBQUVBLFVBQU11SSwwQkFBMEJ6VyxVQUFVckIsVUFBVTJYLFNBQUFBO0FBQ3BELFFBQUk5SSxVQUFVa0osV0FBV2hKLE9BQU8xTyxJQUFHMlgsSUFBR0MsTUFBTUM7QUFFNUMvYSxRQUFJNkMsWUFBWTJYO0FBQ2hCeGEsUUFBSThDLGVBQWU7QUFDbkI5QyxRQUFJa0MsT0FBT2tQLFNBQVM5TztBQUVwQmtYLElBQUFBLElBQUdqVixJQUFJMlAsWUFBWSxNQUFNeUcseUJBQXlCNWEsT0FBQUE7QUFHbERDLFFBQUl5RixZQUFZMUYsUUFBUXlWO0FBQ3hCL0MsU0FBSyxLQUFLWCxZQUFZNEksY0FBQUE7QUFFdEJELG1CQUFldEksaUJBQWlCd0ksNEJBQTRCLFVBQ3hESCxjQUFjLFdBQVk5YixXQUFXLElBQUlpVSxhQUFlalUsV0FBVyxJQUFJaVUsYUFDdkU7QUFHSixTQUFLelAsS0FBSSxHQUFHNFgsT0FBTzVKLEtBQUs1TixRQUFRSixLQUFJNFgsTUFBTSxFQUFFNVgsSUFBRztBQUM3Q3dPLGlCQUFXUixLQUFLaE8sRUFBRTtBQUNsQjBYLGtCQUFZLEtBQUs5RCxnQkFBZ0I1VCxFQUFFO0FBRW5DbEQsVUFBSXlGLFlBQVltVjtBQUNoQm5JLFdBQUtmLFNBQVNDLFFBQVErSSxjQUFBQTtBQUV0QjlJLGNBQVFGLFNBQVNFO0FBRWpCLFVBQUlPLGlCQUFpQlAsTUFBTXRPLFFBQVE7QUFDakMsYUFBS3FXLGNBQWMzWixLQUFLd1osS0FBSXRXLElBQUdnQixXQUFXbkUsT0FBQUE7QUFDMUNtUyx5QkFBaUJ0VCxLQUFLSSxJQUFJb1MsU0FBU3pPLFlBQVlsRSxTQUFBQTs7QUFHakQsV0FBS29jLEtBQUksR0FBR0UsT0FBT25KLE1BQU10TyxRQUFRdVgsS0FBSUUsTUFBTSxFQUFFRixJQUFHO0FBQzlDSCx1QkFBZTlJLE1BQU1pSixFQUFFLENBQUE7QUFFdkIzSSx5QkFBaUJkLFNBQVN6TztNQUM1QjtBQUVBOFAsV0FBS2YsU0FBU0csT0FBTzZJLGNBQUFBO0lBQ3ZCO0FBR0FELG1CQUFlO0FBQ2Z2SSxxQkFBaUJkLFNBQVN6TztBQUcxQjhQLFNBQUssS0FBS1YsV0FBVzJJLGNBQUFBO0FBQ3JCbEIsSUFBQUEsSUFBR25VLEtBQUsrTTtFQUNWO0VBRUE0SSxXQUFXeEIsS0FBSXhaLEtBQUtELFNBQVM7QUFDM0IsVUFBTW9SLFNBQVMsS0FBS0E7QUFDcEIsVUFBTTdOLFNBQVM2TixPQUFPN047QUFDdEIsUUFBSStOLFlBQVluTztBQUVoQixRQUFJSSxRQUFRO0FBQ1YsWUFBTVksWUFBWUMsY0FBY3BFLFFBQVFrRSxLQUFLLEtBQUtNLEdBQUcsS0FBSzNELEtBQUs7QUFFL0Q0WSxNQUFBQSxJQUFHalYsSUFBSTJQLFlBQVksTUFBTW5VLFFBQVFrYixhQUFhbGIsT0FBQUE7QUFDOUN5WixNQUFBQSxJQUFHblUsS0FBS3RGLFFBQVFzUztBQUVoQnJTLFVBQUk2QyxZQUFZcUIsVUFBVXJCLFVBQVU5QyxRQUFRa2IsV0FBVztBQUN2RGpiLFVBQUk4QyxlQUFlO0FBRW5CdU8sbUJBQWFwUCxPQUFPbEMsUUFBUXNSLFVBQVU7QUFFdENyUixVQUFJeUYsWUFBWTFGLFFBQVFtYjtBQUN4QmxiLFVBQUlrQyxPQUFPbVAsV0FBVy9PO0FBRXRCLFdBQUtZLEtBQUksR0FBR0EsS0FBSUksUUFBUSxFQUFFSixJQUFHO0FBQzNCbEQsWUFBSTBILFNBQVN5SixPQUFPak8sRUFBQUEsR0FBSWdCLFVBQVVLLEVBQUVpVixJQUFHalYsQ0FBQyxHQUFHaVYsSUFBR25VLElBQUlnTSxXQUFXMU8sYUFBYSxDQUFBO0FBQzFFNlcsUUFBQUEsSUFBR25VLEtBQUtnTSxXQUFXMU8sYUFBYTVDLFFBQVF1UztNQUMxQzs7RUFFSjtFQUVBNkksZUFBZTNCLEtBQUl4WixLQUFLb2IsYUFBYXJiLFNBQVM7QUFDNUMsVUFBTSxFQUFDK1MsUUFBUUssT0FBTSxJQUFJO0FBQ3pCLFVBQU0sRUFBQzVPLEdBQUFBLElBQUdjLEdBQUFBLEdBQUFBLElBQUttVTtBQUNmLFVBQU0sRUFBQzVZLE9BQU9ELE9BQUFBLElBQVV5YTtBQUN4QixVQUFNLEVBQUN2SCxTQUFTQyxVQUFVQyxZQUFZQyxZQUFBQSxJQUFlbk4sY0FBYzlHLFFBQVE2VCxZQUFZO0FBRXZGNVQsUUFBSXlGLFlBQVkxRixRQUFRa007QUFDeEJqTSxRQUFJNkYsY0FBYzlGLFFBQVF3TTtBQUMxQnZNLFFBQUltRixZQUFZcEYsUUFBUXNHO0FBRXhCckcsUUFBSThHLFVBQVM7QUFDYjlHLFFBQUlxYixPQUFPOVcsS0FBSXNQLFNBQVN4TyxFQUFBQTtBQUN4QixRQUFJOE4sV0FBVyxPQUFPO0FBQ3BCLFdBQUt3RixVQUFVYSxLQUFJeFosS0FBS29iLGFBQWFyYixPQUFBQTs7QUFFdkNDLFFBQUkrWSxPQUFPeFUsS0FBSTNELFFBQVFrVCxVQUFVek8sRUFBQUE7QUFDakNyRixRQUFJc2IsaUJBQWlCL1csS0FBSTNELE9BQU95RSxJQUFHZCxLQUFJM0QsT0FBT3lFLEtBQUl5TyxRQUFBQTtBQUNsRCxRQUFJWCxXQUFXLFlBQVlMLFdBQVcsU0FBUztBQUM3QyxXQUFLNkYsVUFBVWEsS0FBSXhaLEtBQUtvYixhQUFhcmIsT0FBQUE7O0FBRXZDQyxRQUFJK1ksT0FBT3hVLEtBQUkzRCxPQUFPeUUsS0FBSTFFLFNBQVNxVCxXQUFBQTtBQUNuQ2hVLFFBQUlzYixpQkFBaUIvVyxLQUFJM0QsT0FBT3lFLEtBQUkxRSxRQUFRNEQsS0FBSTNELFFBQVFvVCxhQUFhM08sS0FBSTFFLE1BQUFBO0FBQ3pFLFFBQUl3UyxXQUFXLFVBQVU7QUFDdkIsV0FBS3dGLFVBQVVhLEtBQUl4WixLQUFLb2IsYUFBYXJiLE9BQUFBOztBQUV2Q0MsUUFBSStZLE9BQU94VSxLQUFJd1AsWUFBWTFPLEtBQUkxRSxNQUFBQTtBQUMvQlgsUUFBSXNiLGlCQUFpQi9XLElBQUdjLEtBQUkxRSxRQUFRNEQsSUFBR2MsS0FBSTFFLFNBQVNvVCxVQUFBQTtBQUNwRCxRQUFJWixXQUFXLFlBQVlMLFdBQVcsUUFBUTtBQUM1QyxXQUFLNkYsVUFBVWEsS0FBSXhaLEtBQUtvYixhQUFhcmIsT0FBQUE7O0FBRXZDQyxRQUFJK1ksT0FBT3hVLElBQUdjLEtBQUl3TyxPQUFBQTtBQUNsQjdULFFBQUlzYixpQkFBaUIvVyxJQUFHYyxJQUFHZCxLQUFJc1AsU0FBU3hPLEVBQUFBO0FBQ3hDckYsUUFBSXViLFVBQVM7QUFFYnZiLFFBQUl1SCxLQUFJO0FBRVIsUUFBSXhILFFBQVFzRyxjQUFjLEdBQUc7QUFDM0JyRyxVQUFJd0gsT0FBTTs7RUFFZDtFQU1BZ1UsdUJBQXVCemIsU0FBUztBQUM5QixVQUFNRCxRQUFRLEtBQUtBO0FBQ25CLFVBQU0yYixRQUFRLEtBQUtsRjtBQUNuQixVQUFNbUYsUUFBUUQsU0FBU0EsTUFBTWxYO0FBQzdCLFVBQU1vWCxRQUFRRixTQUFTQSxNQUFNcFc7QUFDN0IsUUFBSXFXLFNBQVNDLE9BQU87QUFDbEIsWUFBTTdhLFdBQVdvTixZQUFZbk8sUUFBUWUsUUFBUSxFQUFFVSxLQUFLLE1BQU0sS0FBSzBVLFNBQVMsS0FBS0MsY0FBYztBQUMzRixVQUFJLENBQUNyVixVQUFVO0FBQ2I7O0FBRUYsWUFBTXFCLE9BQU8sS0FBS2lVLFFBQVFwRixlQUFlLE1BQU1qUixPQUFBQTtBQUMvQyxZQUFNd1ksa0JBQWtCeFIsT0FBT3lSLE9BQU8sQ0FBQSxHQUFJMVgsVUFBVSxLQUFLc1YsS0FBSztBQUM5RCxZQUFNekMsWUFBWUwsbUJBQW1CeFQsT0FBT0MsU0FBU3dZLGVBQUFBO0FBQ3JELFlBQU1xRCxRQUFRbEksbUJBQW1CM1QsU0FBU3dZLGlCQUFpQjVFLFdBQVc3VCxLQUFBQTtBQUN0RSxVQUFJNGIsTUFBTUcsUUFBUUQsTUFBTXJYLEtBQUtvWCxNQUFNRSxRQUFRRCxNQUFNdlcsR0FBRztBQUNsRCxhQUFLeU4sU0FBU2EsVUFBVWI7QUFDeEIsYUFBS0ssU0FBU1EsVUFBVVI7QUFDeEIsYUFBS3ZTLFFBQVF1QixLQUFLdkI7QUFDbEIsYUFBS0QsU0FBU3dCLEtBQUt4QjtBQUNuQixhQUFLK1YsU0FBUzVWLFNBQVN5RDtBQUN2QixhQUFLb1MsU0FBUzdWLFNBQVN1RTtBQUN2QixhQUFLMlIsbUJBQWtCLEVBQUcvVixPQUFPLE1BQU0yYSxLQUFBQTs7O0VBRzdDO0VBTUFFLGNBQWM7QUFDWixXQUFPLENBQUMsQ0FBQyxLQUFLN0Y7RUFDaEI7RUFFQXpSLEtBQUt4RSxLQUFLO0FBQ1IsVUFBTUQsVUFBVSxLQUFLQSxRQUFRbVgsV0FBVyxLQUFLQyxXQUFVLENBQUE7QUFDdkQsUUFBSWxCLFVBQVUsS0FBS0E7QUFFbkIsUUFBSSxDQUFDQSxTQUFTO0FBQ1o7O0FBR0YsU0FBS3VGLHVCQUF1QnpiLE9BQUFBO0FBRTVCLFVBQU1xYixjQUFjO01BQ2xCeGEsT0FBTyxLQUFLQTtNQUNaRCxRQUFRLEtBQUtBO0lBQ2Y7QUFDQSxVQUFNNlksTUFBSztNQUNUalYsR0FBRyxLQUFLQTtNQUNSYyxHQUFHLEtBQUtBO0lBQ1Y7QUFHQTRRLGNBQVVyWCxLQUFLbWQsSUFBSTlGLE9BQVcsSUFBQSxPQUFPLElBQUlBO0FBRXpDLFVBQU14VCxVQUFVb0csVUFBVTlJLFFBQVEwQyxPQUFPO0FBR3pDLFVBQU11WixvQkFBb0IsS0FBS3RULE1BQU1wRixVQUFVLEtBQUt3TyxXQUFXeE8sVUFBVSxLQUFLNE4sS0FBSzVOLFVBQVUsS0FBS3lPLFVBQVV6TyxVQUFVLEtBQUs2TixPQUFPN047QUFFbEksUUFBSXZELFFBQVFxWCxXQUFXNEUsbUJBQW1CO0FBQ3hDaGMsVUFBSXVGLEtBQUk7QUFDUnZGLFVBQUlpYyxjQUFjaEc7QUFHbEIsV0FBS2tGLGVBQWUzQixLQUFJeFosS0FBS29iLGFBQWFyYixPQUFBQTtBQUUxQ2dJLDRCQUFzQi9ILEtBQUtELFFBQVFpSSxhQUFhO0FBRWhEd1IsTUFBQUEsSUFBR25VLEtBQUs1QyxRQUFRbEM7QUFHaEIsV0FBSzJFLFVBQVVzVSxLQUFJeFosS0FBS0QsT0FBQUE7QUFHeEIsV0FBS3dhLFNBQVNmLEtBQUl4WixLQUFLRCxPQUFBQTtBQUd2QixXQUFLaWIsV0FBV3hCLEtBQUl4WixLQUFLRCxPQUFBQTtBQUV6QnlJLDJCQUFxQnhJLEtBQUtELFFBQVFpSSxhQUFhO0FBRS9DaEksVUFBSXlILFFBQU87O0VBRWY7RUFNQXlVLG9CQUFvQjtBQUNsQixXQUFPLEtBQUtoRyxXQUFXLENBQUE7RUFDekI7RUFPQWlHLGtCQUFrQkMsZ0JBQWdCcE4sZUFBZTtBQUMvQyxVQUFNcU4sYUFBYSxLQUFLbkc7QUFDeEIsVUFBTWdDLFNBQVNrRSxlQUFlelEsSUFBSSxDQUFDLEVBQUN2TSxjQUFjQyxNQUFLLE1BQU07QUFDM0QsWUFBTXVNLE9BQU8sS0FBSzlMLE1BQU13USxlQUFlbFIsWUFBQUE7QUFFdkMsVUFBSSxDQUFDd00sTUFBTTtBQUNULGNBQU0sSUFBSTBRLE1BQU0sb0NBQW9DbGQsWUFBYzs7QUFHcEUsYUFBTztRQUNMQTtRQUNBc1AsU0FBUzlDLEtBQUtoSyxLQUFLdkMsS0FBTTtRQUN6QkE7TUFDRjtJQUNGLENBQUE7QUFDQSxVQUFNZ1osVUFBVSxDQUFDa0UsZUFBZUYsWUFBWW5FLE1BQUFBO0FBQzVDLFVBQU1zRSxrQkFBa0IsS0FBS0MsaUJBQWlCdkUsUUFBUWxKLGFBQUFBO0FBRXRELFFBQUlxSixXQUFXbUUsaUJBQWlCO0FBQzlCLFdBQUt0RyxVQUFVZ0M7QUFDZixXQUFLL0IsaUJBQWlCbkg7QUFDdEIsV0FBSzBOLHNCQUFzQjtBQUMzQixXQUFLemIsT0FBTyxJQUFJOztFQUVwQjtFQVNBcUksWUFBWUMsSUFBRzJCLFFBQVF5UixjQUFjLE1BQU07QUFDekMsUUFBSXpSLFVBQVUsS0FBS3dSLHFCQUFxQjtBQUN0QyxhQUFPOztBQUVULFNBQUtBLHNCQUFzQjtBQUUzQixVQUFNM2MsVUFBVSxLQUFLQTtBQUNyQixVQUFNc2MsYUFBYSxLQUFLbkcsV0FBVyxDQUFBO0FBQ25DLFVBQU1nQyxTQUFTLEtBQUswRSxtQkFBbUJyVCxJQUFHOFMsWUFBWW5SLFFBQVF5UixXQUFBQTtBQUs5RCxVQUFNSCxrQkFBa0IsS0FBS0MsaUJBQWlCdkUsUUFBUTNPLEVBQUFBO0FBR3RELFVBQU04TyxVQUFVbk4sVUFBVSxDQUFDcVIsZUFBZXJFLFFBQVFtRSxVQUFlRyxLQUFBQTtBQUdqRSxRQUFJbkUsU0FBUztBQUNYLFdBQUtuQyxVQUFVZ0M7QUFFZixVQUFJblksUUFBUXFYLFdBQVdyWCxRQUFRMlksVUFBVTtBQUN2QyxhQUFLdkMsaUJBQWlCO1VBQ3BCNVIsR0FBR2dGLEdBQUVoRjtVQUNMYyxHQUFHa0UsR0FBRWxFO1FBQ1A7QUFFQSxhQUFLcEUsT0FBTyxNQUFNaUssTUFBQUE7OztBQUl0QixXQUFPbU47RUFDVDtFQVdBdUUsbUJBQW1CclQsSUFBRzhTLFlBQVluUixRQUFReVIsYUFBYTtBQUNyRCxVQUFNNWMsVUFBVSxLQUFLQTtBQUVyQixRQUFJd0osR0FBRUUsU0FBUyxZQUFZO0FBQ3pCLGFBQU8sQ0FBQTs7QUFHVCxRQUFJLENBQUNrVCxhQUFhO0FBR2hCLGFBQU9OLFdBQVczYSxPQUFPd0IsQ0FBQUEsT0FDdkIsS0FBS3BELE1BQU04QixLQUFLNEosU0FBU3RJLEdBQUU5RCxZQUFZLEtBQ3ZDLEtBQUtVLE1BQU13USxlQUFlcE4sR0FBRTlELFlBQVksRUFBRTBNLFdBQVc0RSxVQUFVeE4sR0FBRTdELEtBQUssTUFBTWEsTUFBQUE7O0FBS2hGLFVBQU1nWSxTQUFTLEtBQUtwWSxNQUFNK2MsMEJBQTBCdFQsSUFBR3hKLFFBQVFrVixNQUFNbFYsU0FBU21MLE1BQUFBO0FBRTlFLFFBQUluTCxRQUFRK0IsU0FBUztBQUNuQm9XLGFBQU9wVyxRQUFPOztBQUdoQixXQUFPb1c7RUFDVDtFQVNBdUUsaUJBQWlCdkUsUUFBUTNPLElBQUc7QUFDMUIsVUFBTSxFQUFDbU4sUUFBUUMsUUFBUTVXLFFBQU8sSUFBSTtBQUNsQyxVQUFNZSxXQUFXb04sWUFBWW5PLFFBQVFlLFFBQVEsRUFBRVUsS0FBSyxNQUFNMFcsUUFBUTNPLEVBQUFBO0FBQ2xFLFdBQU96SSxhQUFhLFVBQVU0VixXQUFXNVYsU0FBU3lELEtBQUtvUyxXQUFXN1YsU0FBU3VFO0VBQzdFO0FBQ0Y7QUF2dkJFLGNBTFcyUSxTQUtKOUgsZUFBY0E7QUF5dkJ2QixJQUFBLGlCQUFlO0VBQ2I5RCxJQUFJO0VBQ0pDLFVBQVUyTDtFQUNWOUg7RUFFQTRPLFVBQVVoZCxPQUFPeUssT0FBT3hLLFNBQVM7QUFDL0IsUUFBSUEsU0FBUztBQUNYRCxZQUFNbVIsVUFBVSxJQUFJK0UsUUFBUTtRQUFDbFc7UUFBT0M7TUFBTyxDQUFBOztFQUUvQztFQUVBK0ssYUFBYWhMLE9BQU95SyxPQUFPeEssU0FBUztBQUNsQyxRQUFJRCxNQUFNbVIsU0FBUztBQUNqQm5SLFlBQU1tUixRQUFROEYsV0FBV2hYLE9BQUFBOztFQUU3QjtFQUVBZ2QsTUFBTWpkLE9BQU95SyxPQUFPeEssU0FBUztBQUMzQixRQUFJRCxNQUFNbVIsU0FBUztBQUNqQm5SLFlBQU1tUixRQUFROEYsV0FBV2hYLE9BQUFBOztFQUU3QjtFQUVBaWQsVUFBVWxkLE9BQU87QUFDZixVQUFNbVIsVUFBVW5SLE1BQU1tUjtBQUV0QixRQUFJQSxXQUFXQSxRQUFRNkssWUFBVyxHQUFJO0FBQ3BDLFlBQU03USxPQUFPO1FBQ1hnRztNQUNGO0FBRUEsVUFBSW5SLE1BQU1tZCxjQUFjLHFCQUFxQjtRQUFDLEdBQUdoUztRQUFNaVMsWUFBWTtNQUFJLENBQUEsTUFBTyxPQUFPO0FBQ25GOztBQUdGak0sY0FBUXpNLEtBQUsxRSxNQUFNRSxHQUFHO0FBRXRCRixZQUFNbWQsY0FBYyxvQkFBb0JoUyxJQUFBQTs7RUFFNUM7RUFFQUQsV0FBV2xMLE9BQU9tTCxNQUFNO0FBQ3RCLFFBQUluTCxNQUFNbVIsU0FBUztBQUVqQixZQUFNa00sbUJBQW1CbFMsS0FBS0M7QUFDOUIsVUFBSXBMLE1BQU1tUixRQUFRM0gsWUFBWTJCLEtBQUtFLE9BQU9nUyxrQkFBa0JsUyxLQUFLMFIsV0FBVyxHQUFHO0FBRTdFMVIsYUFBS29OLFVBQVU7OztFQUdyQjtFQUVBdlQsVUFBVTtJQUNSc1MsU0FBUztJQUNUc0IsVUFBVTtJQUNWNVgsVUFBVTtJQUNWbUwsaUJBQWlCO0lBQ2pCeU4sWUFBWTtJQUNaL1EsV0FBVztNQUNUNUgsUUFBUTtJQUNWO0lBQ0FpUixjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQndILFlBQVk7SUFDWmpFLFdBQVc7SUFDWHBELGFBQWE7SUFDYmhCLFVBQVUsQ0FBQTtJQUVWb0osV0FBVztJQUNYVSxhQUFhO0lBQ2I1SSxlQUFlO0lBQ2ZELGlCQUFpQjtJQUNqQmhCLFlBQVk7TUFDVnRRLFFBQVE7SUFDVjtJQUNBa2EsYUFBYTtJQUNieFksU0FBUztJQUNUd1EsY0FBYztJQUNkRCxXQUFXO0lBQ1hZLGNBQWM7SUFDZG5WLFdBQVcsQ0FBQ3VCLEtBQUs0RSxTQUFTQSxLQUFLd00sU0FBU2pQO0lBQ3hDekQsVUFBVSxDQUFDc0IsS0FBSzRFLFNBQVNBLEtBQUt3TSxTQUFTalA7SUFDdkM2WCxvQkFBb0I7SUFDcEI3SCxlQUFlO0lBQ2ZRLFlBQVk7SUFDWnBHLGFBQWE7SUFDYmxHLGFBQWE7SUFDYmdSLFdBQVc7TUFDVCtGLFVBQVU7TUFDVkMsUUFBUTtJQUNWO0lBQ0EvRixZQUFZO01BQ1ZnRyxTQUFTO1FBQ1A3VCxNQUFNO1FBQ042TyxZQUFZO1VBQUM7VUFBSztVQUFLO1VBQVM7VUFBVTtVQUFVO1FBQVM7TUFDL0Q7TUFDQXJDLFNBQVM7UUFDUG9ILFFBQVE7UUFDUkQsVUFBVTtNQUNaO0lBQ0Y7SUFDQTFJLFdBQVdHO0VBQ2I7RUFFQWpILGVBQWU7SUFDYndELFVBQVU7SUFDVkMsWUFBWTtJQUNaMUksV0FBVztFQUNiO0VBRUE2RCxhQUFhO0lBQ1hDLGFBQWEsQ0FBQ0MsU0FBU0EsU0FBUyxZQUFZQSxTQUFTLGNBQWNBLFNBQVM7SUFDNUVtQixZQUFZO0lBQ1o2RyxXQUFXO01BQ1RqSSxhQUFhO01BQ2JvQixZQUFZO0lBQ2Q7SUFDQXdKLFdBQVc7TUFDVGtHLFdBQVc7SUFDYjtJQUNBakcsWUFBWTtNQUNWaUcsV0FBVztJQUNiO0VBQ0Y7RUFHQUMsd0JBQXdCO0lBQUM7RUFBYztBQUN6QztBQ2wwQ0EsSUFBTUMsY0FBYyxDQUFDQyxRQUFRQyxLQUFLQyxPQUFPQyxnQkFBZ0I7QUFDdkQsTUFBSSxPQUFPRixRQUFRLFVBQVU7QUFDM0JDLFlBQVFGLE9BQU9JLEtBQUtILEdBQU8sSUFBQTtBQUMzQkUsZ0JBQVlFLFFBQVE7TUFBQ0g7TUFBT0ksT0FBT0w7SUFBRyxDQUFBO2FBQzdCTSxNQUFNTixHQUFNLEdBQUE7QUFDckJDLFlBQVE7O0FBRVYsU0FBT0E7QUFDVDtBQUVBLFNBQVNNLGVBQWVSLFFBQVFDLEtBQUtDLE9BQU9DLGFBQWE7QUFDdkQsUUFBTU0sUUFBUVQsT0FBT1UsUUFBUVQsR0FBQUE7QUFDN0IsTUFBSVEsVUFBVSxJQUFJO0FBQ2hCLFdBQU9WLFlBQVlDLFFBQVFDLEtBQUtDLE9BQU9DLFdBQUFBOztBQUV6QyxRQUFNUSxPQUFPWCxPQUFPWSxZQUFZWCxHQUFBQTtBQUNoQyxTQUFPUSxVQUFVRSxPQUFPVCxRQUFRTztBQUNsQztBQUVBLElBQU1JLGFBQWEsQ0FBQ1gsT0FBT1ksUUFBUVosVUFBVSxPQUFPLE9BQU9hLFlBQVlDLEtBQUtDLE1BQU1mLEtBQUFBLEdBQVEsR0FBR1ksR0FBSTtBQUVqRyxTQUFTSSxrQkFBa0JDLE9BQU87QUFDaEMsUUFBTW5CLFNBQVMsS0FBS29CLFVBQVM7QUFFN0IsTUFBSUQsU0FBUyxLQUFLQSxRQUFRbkIsT0FBT3FCLFFBQVE7QUFDdkMsV0FBT3JCLE9BQU9tQixLQUFNOztBQUV0QixTQUFPQTtBQUNUO0FBRWUsSUFBTUcsZ0JBQU4sY0FBNEJDLE1BQUFBO0VBYXpDQyxZQUFZQyxLQUFLO0FBQ2YsVUFBTUEsR0FBQUE7QUFHTixTQUFLQyxjQUFjQztBQUNuQixTQUFLQyxjQUFjO0FBQ25CLFNBQUtDLGVBQWUsQ0FBQTtFQUN0QjtFQUVBQyxLQUFLQyxjQUFjO0FBQ2pCLFVBQU1DLFFBQVEsS0FBS0g7QUFDbkIsUUFBSUcsTUFBTVgsUUFBUTtBQUNoQixZQUFNckIsU0FBUyxLQUFLb0IsVUFBUztBQUM3QixpQkFBVyxFQUFDbEIsT0FBT0ksTUFBSyxLQUFLMEIsT0FBTztBQUNsQyxZQUFJaEMsT0FBT0UsS0FBTSxNQUFLSSxPQUFPO0FBQzNCTixpQkFBT2lDLE9BQU8vQixPQUFPLENBQUE7O01BRXpCO0FBQ0EsV0FBSzJCLGVBQWUsQ0FBQTs7QUFFdEIsVUFBTUMsS0FBS0MsWUFBQUE7RUFDYjtFQUVBRyxNQUFNakMsS0FBS0MsT0FBTztBQUNoQixRQUFJaUMsY0FBY2xDLEdBQU0sR0FBQTtBQUN0QixhQUFPOztBQUVULFVBQU1ELFNBQVMsS0FBS29CLFVBQVM7QUFDN0JsQixZQUFRa0MsU0FBU2xDLEtBQVVGLEtBQUFBLE9BQU9FLEtBQUFBLE1BQVdELE1BQU1DLFFBQy9DTSxlQUFlUixRQUFRQyxLQUFLb0MsZUFBZW5DLE9BQU9ELEdBQUFBLEdBQU0sS0FBSzRCLFlBQVk7QUFDN0UsV0FBT2hCLFdBQVdYLE9BQU9GLE9BQU9xQixTQUFTLENBQUE7RUFDM0M7RUFFQWlCLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNDLFlBQVlDLFdBQUFBLElBQWMsS0FBS0MsY0FBYTtBQUNuRCxRQUFJLEVBQUNDLEtBQUs1QixJQUFHLElBQUksS0FBSzZCLFVBQVUsSUFBSTtBQUVwQyxRQUFJLEtBQUtDLFFBQVFDLFdBQVcsU0FBUztBQUNuQyxVQUFJLENBQUNOLFlBQVk7QUFDZkcsY0FBTTs7QUFFUixVQUFJLENBQUNGLFlBQVk7QUFDZjFCLGNBQU0sS0FBS00sVUFBUyxFQUFHQyxTQUFTOzs7QUFJcEMsU0FBS3FCLE1BQU1BO0FBQ1gsU0FBSzVCLE1BQU1BO0VBQ2I7RUFFQWdDLGFBQWE7QUFDWCxVQUFNSixNQUFNLEtBQUtBO0FBQ2pCLFVBQU01QixNQUFNLEtBQUtBO0FBQ2pCLFVBQU1pQyxTQUFTLEtBQUtILFFBQVFHO0FBQzVCLFVBQU1DLFFBQVEsQ0FBQTtBQUNkLFFBQUloRCxTQUFTLEtBQUtvQixVQUFTO0FBRzNCcEIsYUFBUyxRQUFTLEtBQUtjLFFBQVFkLE9BQU9xQixTQUFTLElBQUtyQixTQUFTQSxPQUFPaUQsTUFBTVAsS0FBSzVCLE1BQU0sQ0FBRTtBQUV2RixTQUFLYyxjQUFjWixLQUFLRixJQUFJZCxPQUFPcUIsVUFBVTBCLFNBQVMsSUFBSSxJQUFJLENBQUE7QUFDOUQsU0FBS3JCLGNBQWMsS0FBS2dCLE9BQU9LLFNBQVMsTUFBTTtBQUU5QyxhQUFTNUIsUUFBUXVCLEtBQUt2QixTQUFTTCxLQUFLSyxTQUFTO0FBQzNDNkIsWUFBTTVDLEtBQUs7UUFBQ2U7TUFBSyxDQUFBO0lBQ25CO0FBQ0EsV0FBTzZCO0VBQ1Q7RUFFQUUsaUJBQWlCL0IsT0FBTztBQUN0QixXQUFPRCxrQkFBa0JpQyxLQUFLLE1BQU1oQyxLQUFBQTtFQUN0QztFQUtBaUMsWUFBWTtBQUNWLFVBQU1BLFVBQVM7QUFFZixRQUFJLENBQUMsS0FBS0MsYUFBWSxHQUFJO0FBRXhCLFdBQUtDLGlCQUFpQixDQUFDLEtBQUtBOztFQUVoQztFQUdBQyxpQkFBaUJwQyxPQUFPO0FBQ3RCLFFBQUksT0FBT0EsVUFBVSxVQUFVO0FBQzdCQSxjQUFRLEtBQUtlLE1BQU1mLEtBQUFBOztBQUdyQixXQUFPQSxVQUFVLE9BQU9xQyxNQUFNLEtBQUtDLG9CQUFvQnRDLFFBQVEsS0FBS08sZUFBZSxLQUFLRSxXQUFXO0VBQ3JHO0VBSUE4QixnQkFBZ0J4RCxPQUFPO0FBQ3JCLFVBQU04QyxRQUFRLEtBQUtBO0FBQ25CLFFBQUk5QyxRQUFRLEtBQUtBLFFBQVE4QyxNQUFNM0IsU0FBUyxHQUFHO0FBQ3pDLGFBQU87O0FBRVQsV0FBTyxLQUFLa0MsaUJBQWlCUCxNQUFNOUMsS0FBQUEsRUFBT2lCLEtBQUs7RUFDakQ7RUFFQXdDLGlCQUFpQkMsT0FBTztBQUN0QixXQUFPNUMsS0FBS0MsTUFBTSxLQUFLUyxjQUFjLEtBQUttQyxtQkFBbUJELEtBQVMsSUFBQSxLQUFLaEMsV0FBVztFQUN4RjtFQUVBa0MsZUFBZTtBQUNiLFdBQU8sS0FBS0M7RUFDZDtBQUNGO0FBMUhFLGNBRm1CekMsZUFFWjBDLE1BQUs7QUFLWixjQVBtQjFDLGVBT1oyQyxZQUFXO0VBQ2hCakIsT0FBTztJQUNMa0IsVUFBVWhEO0VBQ1o7O0FDbkJKLFNBQVNpRCxnQkFBY0MsbUJBQW1CQyxXQUFXO0FBQ25ELFFBQU1yQixRQUFRLENBQUE7QUFLZCxRQUFNc0IsY0FBYztBQUNwQixRQUFNLEVBQUN6QixRQUFRMEIsTUFBTTdCLEtBQUs1QixLQUFLMEQsV0FBV0MsT0FBT0MsVUFBVUMsV0FBV0MsY0FBQUEsSUFBaUJSO0FBQ3ZGLFFBQU1TLE9BQU9OLFFBQVE7QUFDckIsUUFBTU8sWUFBWUosV0FBVztBQUM3QixRQUFNLEVBQUNoQyxLQUFLcUMsTUFBTWpFLEtBQUtrRSxLQUFBQSxJQUFRWDtBQUMvQixRQUFNOUIsYUFBYSxDQUFDSixjQUFjTyxHQUFBQTtBQUNsQyxRQUFNRixhQUFhLENBQUNMLGNBQWNyQixHQUFBQTtBQUNsQyxRQUFNbUUsZUFBZSxDQUFDOUMsY0FBY3NDLEtBQUFBO0FBQ3BDLFFBQU1TLGNBQWNGLE9BQU9ELFNBQVNKLFlBQVk7QUFDaEQsTUFBSVEsVUFBVUMsU0FBU0osT0FBT0QsUUFBUUQsWUFBWUQsSUFBUUEsSUFBQUE7QUFDMUQsTUFBSVEsUUFBUUMsU0FBU0MsU0FBU0M7QUFJOUIsTUFBSUwsVUFBVWIsZUFBZSxDQUFDL0IsY0FBYyxDQUFDQyxZQUFZO0FBQ3ZELFdBQU87TUFBQztRQUFDckIsT0FBTzREO01BQUk7TUFBRztRQUFDNUQsT0FBTzZEO01BQUk7SUFBRTs7QUFHdkNRLGNBQVl4RSxLQUFLeUUsS0FBS1QsT0FBT0csT0FBQUEsSUFBV25FLEtBQUswRSxNQUFNWCxPQUFPSSxPQUFBQTtBQUMxRCxNQUFJSyxZQUFZVixXQUFXO0FBRXpCSyxjQUFVQyxRQUFRSSxZQUFZTCxVQUFVTCxZQUFZRCxJQUFRQSxJQUFBQTs7QUFHOUQsTUFBSSxDQUFDMUMsY0FBY3FDLFNBQVksR0FBQTtBQUU3QmEsYUFBU3JFLEtBQUsyRSxJQUFJLElBQUluQixTQUFBQTtBQUN0QlcsY0FBVW5FLEtBQUt5RSxLQUFLTixVQUFVRSxNQUFVQSxJQUFBQTs7QUFHMUMsTUFBSXhDLFdBQVcsU0FBUztBQUN0QnlDLGNBQVV0RSxLQUFLMEUsTUFBTVgsT0FBT0ksT0FBV0EsSUFBQUE7QUFDdkNJLGNBQVV2RSxLQUFLeUUsS0FBS1QsT0FBT0csT0FBV0EsSUFBQUE7U0FDakM7QUFDTEcsY0FBVVA7QUFDVlEsY0FBVVA7O0FBR1osTUFBSXpDLGNBQWNDLGNBQWMrQixRQUFRcUIsYUFBYTlFLE1BQU00QixPQUFPNkIsTUFBTVksVUFBVSxHQUFPLEdBQUE7QUFLdkZLLGdCQUFZeEUsS0FBS0MsTUFBTUQsS0FBSzBCLEtBQUs1QixNQUFNNEIsT0FBT3lDLFNBQVNULFFBQUFBLENBQUFBO0FBQ3ZEUyxlQUFXckUsTUFBTTRCLE9BQU84QztBQUN4QkYsY0FBVTVDO0FBQ1Y2QyxjQUFVekU7RUFDWixXQUFXbUUsY0FBYztBQUl2QkssY0FBVS9DLGFBQWFHLE1BQU00QztBQUM3QkMsY0FBVS9DLGFBQWExQixNQUFNeUU7QUFDN0JDLGdCQUFZZixRQUFRO0FBQ3BCVSxlQUFXSSxVQUFVRCxXQUFXRTtTQUMzQjtBQUVMQSxpQkFBYUQsVUFBVUQsV0FBV0g7QUFHbEMsUUFBSVUsYUFBYUwsV0FBV3hFLEtBQUtDLE1BQU11RSxTQUFBQSxHQUFZTCxVQUFVLEdBQU8sR0FBQTtBQUNsRUssa0JBQVl4RSxLQUFLQyxNQUFNdUUsU0FBQUE7V0FDbEI7QUFDTEEsa0JBQVl4RSxLQUFLeUUsS0FBS0QsU0FBQUE7OztBQU0xQixRQUFNTSxnQkFBZ0I5RSxLQUFLRixJQUN6QmlGLGVBQWVaLE9BQUFBLEdBQ2ZZLGVBQWVULE9BQUFBLENBQUFBO0FBRWpCRCxXQUFTckUsS0FBSzJFLElBQUksSUFBSXhELGNBQWNxQyxTQUFBQSxJQUFhc0IsZ0JBQWdCdEIsU0FBUztBQUMxRWMsWUFBVXRFLEtBQUtDLE1BQU1xRSxVQUFVRCxNQUFVQSxJQUFBQTtBQUN6Q0UsWUFBVXZFLEtBQUtDLE1BQU1zRSxVQUFVRixNQUFVQSxJQUFBQTtBQUV6QyxNQUFJVyxLQUFJO0FBQ1IsTUFBSXpELFlBQVk7QUFDZCxRQUFJcUMsaUJBQWlCVSxZQUFZNUMsS0FBSztBQUNwQ00sWUFBTTVDLEtBQUs7UUFBQ2UsT0FBT3VCO01BQUcsQ0FBQTtBQUV0QixVQUFJNEMsVUFBVTVDLEtBQUs7QUFDakJzRCxRQUFBQTs7QUFHRixVQUFJSCxhQUFhN0UsS0FBS0MsT0FBT3FFLFVBQVVVLEtBQUliLFdBQVdFLE1BQUFBLElBQVVBLFFBQVEzQyxLQUFLdUQsa0JBQWtCdkQsS0FBS3dDLFlBQVlkLGlCQUFxQixDQUFBLEdBQUE7QUFDbkk0QixRQUFBQTs7ZUFFT1YsVUFBVTVDLEtBQUs7QUFDeEJzRCxNQUFBQTs7O0FBSUosU0FBT0EsS0FBSVIsV0FBVyxFQUFFUSxJQUFHO0FBQ3pCLFVBQU1FLFlBQVlsRixLQUFLQyxPQUFPcUUsVUFBVVUsS0FBSWIsV0FBV0UsTUFBVUEsSUFBQUE7QUFDakUsUUFBSTdDLGNBQWMwRCxZQUFZcEYsS0FBSztBQUNqQzs7QUFFRmtDLFVBQU01QyxLQUFLO01BQUNlLE9BQU8rRTtJQUFTLENBQUE7RUFDOUI7QUFFQSxNQUFJMUQsY0FBY29DLGlCQUFpQlcsWUFBWXpFLEtBQUs7QUFFbEQsUUFBSWtDLE1BQU0zQixVQUFVd0UsYUFBYTdDLE1BQU1BLE1BQU0zQixTQUFTLENBQUEsRUFBR0YsT0FBT0wsS0FBS21GLGtCQUFrQm5GLEtBQUtvRSxZQUFZZCxpQkFBcUIsQ0FBQSxHQUFBO0FBQzNIcEIsWUFBTUEsTUFBTTNCLFNBQVMsQ0FBRSxFQUFDRixRQUFRTDtXQUMzQjtBQUNMa0MsWUFBTTVDLEtBQUs7UUFBQ2UsT0FBT0w7TUFBRyxDQUFBOztFQUUxQixXQUFXLENBQUMwQixjQUFjK0MsWUFBWXpFLEtBQUs7QUFDekNrQyxVQUFNNUMsS0FBSztNQUFDZSxPQUFPb0U7SUFBTyxDQUFBOztBQUc1QixTQUFPdkM7QUFDVDtBQUVBLFNBQVNpRCxrQkFBa0I5RSxPQUFPK0QsWUFBWSxFQUFDaUIsWUFBWUMsWUFBVyxHQUFHO0FBQ3ZFLFFBQU1DLE1BQU1DLFVBQVVGLFdBQUFBO0FBQ3RCLFFBQU1HLFNBQVNKLGFBQWFuRixLQUFLd0YsSUFBSUgsR0FBQUEsSUFBT3JGLEtBQUt5RixJQUFJSixHQUFBQSxNQUFTO0FBQzlELFFBQU1oRixTQUFTLE9BQU82RCxjQUFjLEtBQUsvRCxPQUFPRTtBQUNoRCxTQUFPTCxLQUFLMEIsSUFBSXdDLGFBQWFxQixPQUFPbEYsTUFBQUE7QUFDdEM7QUFFZSxJQUFNcUYsa0JBQU4sY0FBOEJuRixNQUFBQTtFQUUzQ0MsWUFBWUMsS0FBSztBQUNmLFVBQU1BLEdBQUFBO0FBR04sU0FBS2tGLFFBQVFoRjtBQUViLFNBQUtpRixNQUFNakY7QUFFWCxTQUFLRCxjQUFjQztBQUVuQixTQUFLa0YsWUFBWWxGO0FBQ2pCLFNBQUtDLGNBQWM7RUFDckI7RUFFQU0sTUFBTWpDLEtBQUtDLE9BQU87QUFDaEIsUUFBSWlDLGNBQWNsQyxHQUFNLEdBQUE7QUFDdEIsYUFBTzs7QUFFVCxTQUFLLE9BQU9BLFFBQVEsWUFBWUEsZUFBZTZHLFdBQVcsQ0FBQzFFLFNBQVMsQ0FBQ25DLEdBQU0sR0FBQTtBQUN6RSxhQUFPOztBQUdULFdBQU8sQ0FBQ0E7RUFDVjtFQUVBOEcseUJBQXlCO0FBQ3ZCLFVBQU0sRUFBQ0MsWUFBVyxJQUFJLEtBQUtwRTtBQUMzQixVQUFNLEVBQUNMLFlBQVlDLFdBQUFBLElBQWMsS0FBS0MsY0FBYTtBQUNuRCxRQUFJLEVBQUNDLEtBQUs1QixJQUFHLElBQUk7QUFFakIsVUFBTW1HLFNBQVNDLENBQUFBLE9BQU14RSxNQUFNSCxhQUFhRyxNQUFNd0U7QUFDOUMsVUFBTUMsU0FBU0QsQ0FBQUEsT0FBTXBHLE1BQU0wQixhQUFhMUIsTUFBTW9HO0FBRTlDLFFBQUlGLGFBQWE7QUFDZixZQUFNSSxVQUFVQyxLQUFLM0UsR0FBQUE7QUFDckIsWUFBTTRFLFVBQVVELEtBQUt2RyxHQUFBQTtBQUVyQixVQUFJc0csVUFBVSxLQUFLRSxVQUFVLEdBQUc7QUFDOUJILGVBQU8sQ0FBQTtNQUNULFdBQVdDLFVBQVUsS0FBS0UsVUFBVSxHQUFHO0FBQ3JDTCxlQUFPLENBQUE7OztBQUlYLFFBQUl2RSxRQUFRNUIsS0FBSztBQUNmLFVBQUlpQyxTQUFTakMsUUFBUSxJQUFJLElBQUlFLEtBQUt1RyxJQUFJekcsTUFBTSxJQUFLO0FBRWpEcUcsYUFBT3JHLE1BQU1pQyxNQUFBQTtBQUViLFVBQUksQ0FBQ2lFLGFBQWE7QUFDaEJDLGVBQU92RSxNQUFNSyxNQUFBQTs7O0FBR2pCLFNBQUtMLE1BQU1BO0FBQ1gsU0FBSzVCLE1BQU1BO0VBQ2I7RUFFQTBHLGVBQWU7QUFDYixVQUFNQyxXQUFXLEtBQUs3RSxRQUFRSTtBQUU5QixRQUFJLEVBQUMwRSxlQUFlQyxTQUFBQSxJQUFZRjtBQUNoQyxRQUFJL0M7QUFFSixRQUFJaUQsVUFBVTtBQUNaakQsaUJBQVcxRCxLQUFLeUUsS0FBSyxLQUFLM0UsTUFBTTZHLFFBQVkzRyxJQUFBQSxLQUFLMEUsTUFBTSxLQUFLaEQsTUFBTWlGLFFBQVksSUFBQTtBQUM5RSxVQUFJakQsV0FBVyxLQUFNO0FBQ25Ca0QsZ0JBQVFDLEtBQUssVUFBVSxLQUFLN0QsRUFBRSxvQkFBb0IyRCxRQUFTLGtDQUFpQ2pELFFBQUFBLDJCQUFtQztBQUMvSEEsbUJBQVc7O1dBRVI7QUFDTEEsaUJBQVcsS0FBS29ELGlCQUFnQjtBQUNoQ0osc0JBQWdCQSxpQkFBaUI7O0FBR25DLFFBQUlBLGVBQWU7QUFDakJoRCxpQkFBVzFELEtBQUswQixJQUFJZ0YsZUFBZWhELFFBQUFBOztBQUdyQyxXQUFPQTtFQUNUO0VBS0FvRCxtQkFBbUI7QUFDakIsV0FBT2hCLE9BQU9pQjtFQUNoQjtFQUVBakYsYUFBYTtBQUNYLFVBQU1rRixPQUFPLEtBQUtwRjtBQUNsQixVQUFNNkUsV0FBV08sS0FBS2hGO0FBTXRCLFFBQUkwQixXQUFXLEtBQUs4QyxhQUFZO0FBQ2hDOUMsZUFBVzFELEtBQUtGLElBQUksR0FBRzRELFFBQUFBO0FBRXZCLFVBQU11RCwwQkFBMEI7TUFDOUJ2RDtNQUNBN0IsUUFBUW1GLEtBQUtuRjtNQUNiSCxLQUFLc0YsS0FBS3RGO01BQ1Y1QixLQUFLa0gsS0FBS2xIO01BQ1YwRCxXQUFXaUQsU0FBU2pEO01BQ3BCRCxNQUFNa0QsU0FBU0U7TUFDZmxELE9BQU9nRCxTQUFTaEQ7TUFDaEJFLFdBQVcsS0FBS3VELFdBQVU7TUFDMUIvQixZQUFZLEtBQUs5QyxhQUFZO01BQzdCK0MsYUFBYXFCLFNBQVNyQixlQUFlO01BQ3JDeEIsZUFBZTZDLFNBQVM3QyxrQkFBa0I7SUFDNUM7QUFDQSxVQUFNUCxZQUFZLEtBQUs4RCxVQUFVO0FBQ2pDLFVBQU1uRixRQUFRbUIsZ0JBQWM4RCx5QkFBeUI1RCxTQUFBQTtBQUlyRCxRQUFJMkQsS0FBS25GLFdBQVcsU0FBUztBQUMzQnVGLHlCQUFtQnBGLE9BQU8sTUFBTSxPQUFBOztBQUdsQyxRQUFJZ0YsS0FBS0ssU0FBUztBQUNoQnJGLFlBQU1xRixRQUFPO0FBRWIsV0FBSzFCLFFBQVEsS0FBSzdGO0FBQ2xCLFdBQUs4RixNQUFNLEtBQUtsRTtXQUNYO0FBQ0wsV0FBS2lFLFFBQVEsS0FBS2pFO0FBQ2xCLFdBQUtrRSxNQUFNLEtBQUs5Rjs7QUFHbEIsV0FBT2tDO0VBQ1Q7RUFLQUksWUFBWTtBQUNWLFVBQU1KLFFBQVEsS0FBS0E7QUFDbkIsUUFBSTJELFFBQVEsS0FBS2pFO0FBQ2pCLFFBQUlrRSxNQUFNLEtBQUs5RjtBQUVmLFVBQU1zQyxVQUFTO0FBRWYsUUFBSSxLQUFLUixRQUFRRyxVQUFVQyxNQUFNM0IsUUFBUTtBQUN2QyxZQUFNMEIsVUFBVTZELE1BQU1ELFNBQVMzRixLQUFLRixJQUFJa0MsTUFBTTNCLFNBQVMsR0FBRyxDQUFLLElBQUE7QUFDL0RzRixlQUFTNUQ7QUFDVDZELGFBQU83RDs7QUFFVCxTQUFLckIsY0FBY2lGO0FBQ25CLFNBQUtFLFlBQVlEO0FBQ2pCLFNBQUtoRixjQUFjZ0YsTUFBTUQ7RUFDM0I7RUFFQXpELGlCQUFpQi9CLE9BQU87QUFDdEIsV0FBT21ILGFBQWFuSCxPQUFPLEtBQUtvSCxNQUFNM0YsUUFBUTRGLFFBQVEsS0FBSzVGLFFBQVFJLE1BQU15RixNQUFNO0VBQ2pGO0FBQ0Y7QUNuVGUsSUFBTUMsY0FBTixjQUEwQmhDLGdCQUFBQTtFQWN2Q3BFLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNJLEtBQUs1QixJQUFHLElBQUksS0FBSzZCLFVBQVUsSUFBSTtBQUV0QyxTQUFLRCxNQUFNTixlQUFTTSxHQUFBQSxJQUFPQSxNQUFNO0FBQ2pDLFNBQUs1QixNQUFNc0IsZUFBU3RCLEdBQUFBLElBQU9BLE1BQU07QUFHakMsU0FBS2lHLHVCQUFzQjtFQUM3QjtFQU1BZSxtQkFBbUI7QUFDakIsVUFBTTNCLGFBQWEsS0FBSzlDLGFBQVk7QUFDcEMsVUFBTWhDLFNBQVM4RSxhQUFhLEtBQUt3QyxRQUFRLEtBQUtDO0FBQzlDLFVBQU14QyxjQUFjRSxVQUFVLEtBQUsxRCxRQUFRSSxNQUFNb0QsV0FBVztBQUM1RCxVQUFNRyxTQUFTSixhQUFhbkYsS0FBS3dGLElBQUlKLFdBQUFBLElBQWVwRixLQUFLeUYsSUFBSUwsV0FBQUEsTUFBaUI7QUFDOUUsVUFBTXlDLFdBQVcsS0FBS0Msd0JBQXdCLENBQUE7QUFDOUMsV0FBTzlILEtBQUt5RSxLQUFLcEUsU0FBU0wsS0FBSzBCLElBQUksSUFBSW1HLFNBQVNFLGFBQWF4QyxLQUFBQSxDQUFBQTtFQUMvRDtFQUdBaEQsaUJBQWlCcEMsT0FBTztBQUN0QixXQUFPQSxVQUFVLE9BQU9xQyxNQUFNLEtBQUtDLG9CQUFvQnRDLFFBQVEsS0FBS08sZUFBZSxLQUFLRSxXQUFXO0VBQ3JHO0VBRUErQixpQkFBaUJDLE9BQU87QUFDdEIsV0FBTyxLQUFLbEMsY0FBYyxLQUFLbUMsbUJBQW1CRCxLQUFBQSxJQUFTLEtBQUtoQztFQUNsRTtBQUNGO0FBM0NFLGNBRm1COEcsYUFFWjFFLE1BQUs7QUFLWixjQVBtQjBFLGFBT1p6RSxZQUFXO0VBQ2hCakIsT0FBTztJQUNMa0IsVUFBVThFLE1BQU1DLFdBQVdDO0VBQzdCOztBQ1JKLElBQU1DLGFBQWFqQyxDQUFBQSxPQUFLbEcsS0FBSzBFLE1BQU0wRCxNQUFNbEMsRUFBQUEsQ0FBQUE7QUFDekMsSUFBTW1DLGlCQUFpQixDQUFDbkMsSUFBR29DLE9BQU10SSxLQUFLMkUsSUFBSSxJQUFJd0QsV0FBV2pDLEVBQUtvQyxJQUFBQSxFQUFBQTtBQUU5RCxTQUFTQyxRQUFRQyxTQUFTO0FBQ3hCLFFBQU1DLFNBQVNELFVBQVd4SSxLQUFLMkUsSUFBSSxJQUFJd0QsV0FBV0ssT0FBQUEsQ0FBQUE7QUFDbEQsU0FBT0MsV0FBVztBQUNwQjtBQUVBLFNBQVNDLE1BQU1oSCxLQUFLNUIsS0FBSzZJLFVBQVU7QUFDakMsUUFBTUMsWUFBWTVJLEtBQUsyRSxJQUFJLElBQUlnRSxRQUFBQTtBQUMvQixRQUFNaEQsUUFBUTNGLEtBQUswRSxNQUFNaEQsTUFBTWtILFNBQUFBO0FBQy9CLFFBQU1oRCxNQUFNNUYsS0FBS3lFLEtBQUszRSxNQUFNOEksU0FBQUE7QUFDNUIsU0FBT2hELE1BQU1EO0FBQ2Y7QUFFQSxTQUFTa0QsU0FBU25ILEtBQUs1QixLQUFLO0FBQzFCLFFBQU1nSixTQUFRaEosTUFBTTRCO0FBQ3BCLE1BQUlpSCxXQUFXUixXQUFXVyxNQUFBQTtBQUMxQixTQUFPSixNQUFNaEgsS0FBSzVCLEtBQUs2SSxRQUFBQSxJQUFZLElBQUk7QUFDckNBO0VBQ0Y7QUFDQSxTQUFPRCxNQUFNaEgsS0FBSzVCLEtBQUs2SSxRQUFBQSxJQUFZLElBQUk7QUFDckNBO0VBQ0Y7QUFDQSxTQUFPM0ksS0FBSzBCLElBQUlpSCxVQUFVUixXQUFXekcsR0FBQUEsQ0FBQUE7QUFDdkM7QUFTQSxTQUFTeUIsY0FBY0MsbUJBQW1CLEVBQUMxQixLQUFLNUIsSUFBRyxHQUFHO0FBQ3BENEIsUUFBTXFILGdCQUFnQjNGLGtCQUFrQjFCLEtBQUtBLEdBQUFBO0FBQzdDLFFBQU1NLFFBQVEsQ0FBQTtBQUNkLFFBQU1nSCxTQUFTYixXQUFXekcsR0FBQUE7QUFDMUIsTUFBSXVILE1BQU1KLFNBQVNuSCxLQUFLNUIsR0FBQUE7QUFDeEIsTUFBSTBELFlBQVl5RixNQUFNLElBQUlqSixLQUFLMkUsSUFBSSxJQUFJM0UsS0FBS3VHLElBQUkwQyxHQUFBQSxDQUFBQSxJQUFRO0FBQ3hELFFBQU10QyxXQUFXM0csS0FBSzJFLElBQUksSUFBSXNFLEdBQUFBO0FBQzlCLFFBQU1DLE9BQU9GLFNBQVNDLE1BQU1qSixLQUFLMkUsSUFBSSxJQUFJcUUsTUFBQUEsSUFBVTtBQUNuRCxRQUFNckQsUUFBUTNGLEtBQUtDLE9BQU95QixNQUFNd0gsUUFBUTFGLFNBQWFBLElBQUFBO0FBQ3JELFFBQU16QixTQUFTL0IsS0FBSzBFLE9BQU9oRCxNQUFNd0gsUUFBUXZDLFdBQVcsRUFBQSxJQUFNQSxXQUFXO0FBQ3JFLE1BQUl3QyxjQUFjbkosS0FBSzBFLE9BQU9pQixRQUFRNUQsVUFBVS9CLEtBQUsyRSxJQUFJLElBQUlzRSxHQUFBQSxDQUFBQTtBQUM3RCxNQUFJOUksUUFBUTRJLGdCQUFnQjNGLGtCQUFrQjFCLEtBQUsxQixLQUFLQyxPQUFPaUosT0FBT25ILFNBQVNvSCxjQUFjbkosS0FBSzJFLElBQUksSUFBSXNFLEdBQUFBLEtBQVF6RixTQUFhQSxJQUFBQSxTQUFBQTtBQUMvSCxTQUFPckQsUUFBUUwsS0FBSztBQUNsQmtDLFVBQU01QyxLQUFLO01BQUNlO01BQU9pSixPQUFPYixRQUFRcEksS0FBQUE7TUFBUWdKO0lBQVcsQ0FBQTtBQUNyRCxRQUFJQSxlQUFlLElBQUk7QUFDckJBLG9CQUFjQSxjQUFjLEtBQUssS0FBSztXQUNqQztBQUNMQTs7QUFFRixRQUFJQSxlQUFlLElBQUk7QUFDckJGO0FBQ0FFLG9CQUFjO0FBQ2QzRixrQkFBWXlGLE9BQU8sSUFBSSxJQUFJekY7O0FBRTdCckQsWUFBUUgsS0FBS0MsT0FBT2lKLE9BQU9uSCxTQUFTb0gsY0FBY25KLEtBQUsyRSxJQUFJLElBQUlzRSxHQUFBQSxLQUFRekYsU0FBYUEsSUFBQUE7RUFDdEY7QUFDQSxRQUFNNkYsV0FBV04sZ0JBQWdCM0Ysa0JBQWtCdEQsS0FBS0ssS0FBQUE7QUFDeEQ2QixRQUFNNUMsS0FBSztJQUFDZSxPQUFPa0o7SUFBVUQsT0FBT2IsUUFBUWMsUUFBQUE7SUFBV0Y7RUFBVyxDQUFBO0FBRWxFLFNBQU9uSDtBQUNUO0FBRWUsSUFBTXNILG1CQUFOLGNBQStCL0ksTUFBQUE7RUFpQjVDQyxZQUFZQyxLQUFLO0FBQ2YsVUFBTUEsR0FBQUE7QUFHTixTQUFLa0YsUUFBUWhGO0FBRWIsU0FBS2lGLE1BQU1qRjtBQUVYLFNBQUtELGNBQWNDO0FBQ25CLFNBQUtDLGNBQWM7RUFDckI7RUFFQU0sTUFBTWpDLEtBQUtDLE9BQU87QUFDaEIsVUFBTWlCLFFBQVF1RixnQkFBZ0I2RCxVQUFVckksTUFBTXNJLE1BQU0sTUFBTTtNQUFDdks7TUFBS0M7SUFBTSxDQUFBO0FBQ3RFLFFBQUlpQixVQUFVLEdBQUc7QUFDZixXQUFLc0osUUFBUTtBQUNiLGFBQU85STs7QUFFVCxXQUFPUyxlQUFTakIsS0FBQUEsS0FBVUEsUUFBUSxJQUFJQSxRQUFRO0VBQ2hEO0VBRUFtQixzQkFBc0I7QUFDcEIsVUFBTSxFQUFDSSxLQUFLNUIsSUFBRyxJQUFJLEtBQUs2QixVQUFVLElBQUk7QUFFdEMsU0FBS0QsTUFBTU4sZUFBU00sR0FBQUEsSUFBTzFCLEtBQUtGLElBQUksR0FBRzRCLEdBQUFBLElBQU87QUFDOUMsU0FBSzVCLE1BQU1zQixlQUFTdEIsR0FBQUEsSUFBT0UsS0FBS0YsSUFBSSxHQUFHQSxHQUFBQSxJQUFPO0FBRTlDLFFBQUksS0FBSzhCLFFBQVFvRSxhQUFhO0FBQzVCLFdBQUt5RCxRQUFROztBQUtmLFFBQUksS0FBS0EsU0FBUyxLQUFLL0gsUUFBUSxLQUFLZ0ksaUJBQWlCLENBQUN0SSxlQUFTLEtBQUt1SSxRQUFRLEdBQUc7QUFDN0UsV0FBS2pJLE1BQU1BLFFBQVEyRyxlQUFlLEtBQUszRyxLQUFLLENBQUsyRyxJQUFBQSxlQUFlLEtBQUszRyxLQUFLLEVBQUMsSUFBSzJHLGVBQWUsS0FBSzNHLEtBQUssQ0FBRTs7QUFHN0csU0FBS3FFLHVCQUFzQjtFQUM3QjtFQUVBQSx5QkFBeUI7QUFDdkIsVUFBTSxFQUFDeEUsWUFBWUMsV0FBQUEsSUFBYyxLQUFLQyxjQUFhO0FBQ25ELFFBQUlDLE1BQU0sS0FBS0E7QUFDZixRQUFJNUIsTUFBTSxLQUFLQTtBQUVmLFVBQU1tRyxTQUFTQyxDQUFBQSxPQUFNeEUsTUFBTUgsYUFBYUcsTUFBTXdFO0FBQzlDLFVBQU1DLFNBQVNELENBQUFBLE9BQU1wRyxNQUFNMEIsYUFBYTFCLE1BQU1vRztBQUU5QyxRQUFJeEUsUUFBUTVCLEtBQUs7QUFDZixVQUFJNEIsT0FBTyxHQUFHO0FBQ1p1RSxlQUFPLENBQUE7QUFDUEUsZUFBTyxFQUFBO2FBQ0Y7QUFDTEYsZUFBT29DLGVBQWUzRyxLQUFLLEVBQUMsQ0FBQTtBQUM1QnlFLGVBQU9rQyxlQUFldkksS0FBSyxDQUFDLENBQUE7OztBQUdoQyxRQUFJNEIsT0FBTyxHQUFHO0FBQ1p1RSxhQUFPb0MsZUFBZXZJLEtBQUssRUFBQyxDQUFBOztBQUU5QixRQUFJQSxPQUFPLEdBQUc7QUFFWnFHLGFBQU9rQyxlQUFlM0csS0FBSyxDQUFDLENBQUE7O0FBRzlCLFNBQUtBLE1BQU1BO0FBQ1gsU0FBSzVCLE1BQU1BO0VBQ2I7RUFFQWdDLGFBQWE7QUFDWCxVQUFNa0YsT0FBTyxLQUFLcEY7QUFFbEIsVUFBTXdCLG9CQUFvQjtNQUN4QjFCLEtBQUssS0FBS2lJO01BQ1Y3SixLQUFLLEtBQUs4SjtJQUNaO0FBQ0EsVUFBTTVILFFBQVFtQixjQUFjQyxtQkFBbUIsSUFBSTtBQUluRCxRQUFJNEQsS0FBS25GLFdBQVcsU0FBUztBQUMzQnVGLHlCQUFtQnBGLE9BQU8sTUFBTSxPQUFBOztBQUdsQyxRQUFJZ0YsS0FBS0ssU0FBUztBQUNoQnJGLFlBQU1xRixRQUFPO0FBRWIsV0FBSzFCLFFBQVEsS0FBSzdGO0FBQ2xCLFdBQUs4RixNQUFNLEtBQUtsRTtXQUNYO0FBQ0wsV0FBS2lFLFFBQVEsS0FBS2pFO0FBQ2xCLFdBQUtrRSxNQUFNLEtBQUs5Rjs7QUFHbEIsV0FBT2tDO0VBQ1Q7RUFNQUUsaUJBQWlCL0IsT0FBTztBQUN0QixXQUFPQSxVQUFVUSxTQUNiLE1BQ0EyRyxhQUFhbkgsT0FBTyxLQUFLb0gsTUFBTTNGLFFBQVE0RixRQUFRLEtBQUs1RixRQUFRSSxNQUFNeUYsTUFBTTtFQUM5RTtFQUtBckYsWUFBWTtBQUNWLFVBQU11RCxRQUFRLEtBQUtqRTtBQUVuQixVQUFNVSxVQUFTO0FBRWYsU0FBSzFCLGNBQWMwSCxNQUFNekMsS0FBQUE7QUFDekIsU0FBSy9FLGNBQWN3SCxNQUFNLEtBQUt0SSxHQUFHLElBQUlzSSxNQUFNekMsS0FBQUE7RUFDN0M7RUFFQXBELGlCQUFpQnBDLE9BQU87QUFDdEIsUUFBSUEsVUFBVVEsVUFBYVIsVUFBVSxHQUFHO0FBQ3RDQSxjQUFRLEtBQUt1Qjs7QUFFZixRQUFJdkIsVUFBVSxRQUFRWixNQUFNWSxLQUFRLEdBQUE7QUFDbEMsYUFBT3FDOztBQUVULFdBQU8sS0FBS0MsbUJBQW1CdEMsVUFBVSxLQUFLdUIsTUFDMUMsS0FDQzBHLE1BQU1qSSxLQUFBQSxJQUFTLEtBQUtPLGVBQWUsS0FBS0UsV0FBVztFQUMxRDtFQUVBK0IsaUJBQWlCQyxPQUFPO0FBQ3RCLFVBQU1pSCxVQUFVLEtBQUtoSCxtQkFBbUJELEtBQUFBO0FBQ3hDLFdBQU81QyxLQUFLMkUsSUFBSSxJQUFJLEtBQUtqRSxjQUFjbUosVUFBVSxLQUFLakosV0FBVztFQUNuRTtBQUNGO0FBdEpFLGNBRm1CMEksa0JBRVp0RyxNQUFLO0FBS1osY0FQbUJzRyxrQkFPWnJHLFlBQVc7RUFDaEJqQixPQUFPO0lBQ0xrQixVQUFVOEUsTUFBTUMsV0FBVzZCO0lBQzNCVixPQUFPO01BQ0xXLFNBQVM7SUFDWDtFQUNGOztBQzlFSixTQUFTQyxzQkFBc0JoRCxNQUFNO0FBQ25DLFFBQU1QLFdBQVdPLEtBQUtoRjtBQUV0QixNQUFJeUUsU0FBU3dELFdBQVdqRCxLQUFLaUQsU0FBUztBQUNwQyxVQUFNQyxVQUFVQyxVQUFVMUQsU0FBUzJELGVBQWU7QUFDbEQsV0FBTy9JLGVBQWVvRixTQUFTNEQsUUFBUTVELFNBQVM0RCxLQUFLQyxNQUFNckgsVUFBU29ILEtBQUtDLElBQUksSUFBSUosUUFBUXRDOztBQUUzRixTQUFPO0FBQ1Q7QUFFQSxTQUFTMkMsaUJBQWlCQyxLQUFLSCxNQUFNL0ssT0FBTztBQUMxQ0EsVUFBUW1MLFFBQVFuTCxLQUFBQSxJQUFTQSxRQUFRO0lBQUNBO0VBQU07QUFDeEMsU0FBTztJQUNMb0wsR0FBR0MsYUFBYUgsS0FBS0gsS0FBS08sUUFBUXRMLEtBQUFBO0lBQ2xDdUwsR0FBR3ZMLE1BQU1lLFNBQVNnSyxLQUFLdEM7RUFDekI7QUFDRjtBQUVBLFNBQVMrQyxnQkFBZ0JDLE9BQU9DLEtBQUtWLE1BQU01SSxLQUFLNUIsS0FBSztBQUNuRCxNQUFJaUwsVUFBVXJKLE9BQU9xSixVQUFVakwsS0FBSztBQUNsQyxXQUFPO01BQ0w2RixPQUFPcUYsTUFBT1YsT0FBTztNQUNyQjFFLEtBQUtvRixNQUFPVixPQUFPO0lBQ3JCO0VBQ0YsV0FBV1MsUUFBUXJKLE9BQU9xSixRQUFRakwsS0FBSztBQUNyQyxXQUFPO01BQ0w2RixPQUFPcUYsTUFBTVY7TUFDYjFFLEtBQUtvRjtJQUNQOztBQUdGLFNBQU87SUFDTHJGLE9BQU9xRjtJQUNQcEYsS0FBS29GLE1BQU1WO0VBQ2I7QUFDRjtBQUtBLFNBQVNXLG1CQUFtQkMsT0FBTztBQThCakMsUUFBTUMsT0FBTztJQUNYQyxHQUFHRixNQUFNRyxPQUFPSCxNQUFNSSxTQUFTRDtJQUMvQkUsR0FBR0wsTUFBTU0sUUFBUU4sTUFBTUksU0FBU0U7SUFDaENDLEdBQUdQLE1BQU1RLE1BQU1SLE1BQU1JLFNBQVNJO0lBQzlCQyxHQUFHVCxNQUFNbkksU0FBU21JLE1BQU1JLFNBQVN2STtFQUNuQztBQUNBLFFBQU02SSxTQUFTQyxPQUFPQyxPQUFPLENBQUEsR0FBSVgsSUFBQUE7QUFDakMsUUFBTVksYUFBYSxDQUFBO0FBQ25CLFFBQU03QixVQUFVLENBQUE7QUFDaEIsUUFBTThCLGFBQWFkLE1BQU1lLGFBQWE1TDtBQUN0QyxRQUFNNkwsaUJBQWlCaEIsTUFBTXRKLFFBQVF1SztBQUNyQyxRQUFNQyxrQkFBa0JGLGVBQWVHLG9CQUFvQkMsS0FBS04sYUFBYTtBQUU3RSxXQUFTTyxLQUFJLEdBQUdBLEtBQUlQLFlBQVlPLE1BQUs7QUFDbkMsVUFBTXZGLE9BQU9rRixlQUFlTSxXQUFXdEIsTUFBTXVCLHFCQUFxQkYsRUFBQUEsQ0FBQUE7QUFDbEVyQyxZQUFRcUMsRUFBQUEsSUFBS3ZGLEtBQUtrRDtBQUNsQixVQUFNd0MsZ0JBQWdCeEIsTUFBTXlCLGlCQUFpQkosSUFBR3JCLE1BQU0wQixjQUFjMUMsUUFBUXFDLEVBQUFBLEdBQUlILGVBQUFBO0FBQ2hGLFVBQU1TLFNBQVNDLE9BQU85RixLQUFLcUQsSUFBSTtBQUMvQixVQUFNMEMsV0FBV3hDLGlCQUFpQlcsTUFBTVYsS0FBS3FDLFFBQVEzQixNQUFNZSxhQUFhTSxFQUFFLENBQUE7QUFDMUVSLGVBQVdRLEVBQUFBLElBQUtRO0FBRWhCLFVBQU1DLGVBQWVDLGdCQUFnQi9CLE1BQU1nQyxjQUFjWCxFQUFLSCxJQUFBQSxlQUFBQTtBQUM5RCxVQUFNckIsUUFBUS9LLEtBQUtDLE1BQU1rTixVQUFVSCxZQUFBQSxDQUFBQTtBQUNuQyxVQUFNSSxVQUFVdEMsZ0JBQWdCQyxPQUFPMkIsY0FBY1csR0FBR04sU0FBU3JDLEdBQUcsR0FBRyxHQUFBO0FBQ3ZFLFVBQU00QyxVQUFVeEMsZ0JBQWdCQyxPQUFPMkIsY0FBY2EsR0FBR1IsU0FBU2xDLEdBQUcsSUFBSSxHQUFBO0FBQ3hFMkMsaUJBQWE1QixRQUFRVCxNQUFNNkIsY0FBY0ksU0FBU0UsT0FBQUE7RUFDcEQ7QUFFQXBDLFFBQU11QyxlQUNKdEMsS0FBS0MsSUFBSVEsT0FBT1IsR0FDaEJRLE9BQU9MLElBQUlKLEtBQUtJLEdBQ2hCSixLQUFLTSxJQUFJRyxPQUFPSCxHQUNoQkcsT0FBT0QsSUFBSVIsS0FBS1EsQ0FBQztBQUluQlQsUUFBTXdDLG1CQUFtQkMscUJBQXFCekMsT0FBT2EsWUFBWTdCLE9BQUFBO0FBQ25FO0FBRUEsU0FBU3NELGFBQWE1QixRQUFRVCxNQUFNSixPQUFPcUMsU0FBU0UsU0FBUztBQUMzRCxRQUFNOUgsTUFBTXhGLEtBQUt1RyxJQUFJdkcsS0FBS3dGLElBQUl1RixLQUFBQSxDQUFBQTtBQUM5QixRQUFNdEYsTUFBTXpGLEtBQUt1RyxJQUFJdkcsS0FBS3lGLElBQUlzRixLQUFBQSxDQUFBQTtBQUM5QixNQUFJc0MsS0FBSTtBQUNSLE1BQUlFLEtBQUk7QUFDUixNQUFJSCxRQUFRekgsUUFBUXdGLEtBQUtDLEdBQUc7QUFDMUJpQyxJQUFBQSxNQUFLbEMsS0FBS0MsSUFBSWdDLFFBQVF6SCxTQUFTSDtBQUMvQm9HLFdBQU9SLElBQUlwTCxLQUFLMEIsSUFBSWtLLE9BQU9SLEdBQUdELEtBQUtDLElBQUlpQyxFQUFBQTtFQUN6QyxXQUFXRCxRQUFReEgsTUFBTXVGLEtBQUtJLEdBQUc7QUFDL0I4QixJQUFBQSxNQUFLRCxRQUFReEgsTUFBTXVGLEtBQUtJLEtBQUsvRjtBQUM3Qm9HLFdBQU9MLElBQUl2TCxLQUFLRixJQUFJOEwsT0FBT0wsR0FBR0osS0FBS0ksSUFBSThCLEVBQUFBOztBQUV6QyxNQUFJQyxRQUFRM0gsUUFBUXdGLEtBQUtNLEdBQUc7QUFDMUI4QixJQUFBQSxNQUFLcEMsS0FBS00sSUFBSTZCLFFBQVEzSCxTQUFTRjtBQUMvQm1HLFdBQU9ILElBQUl6TCxLQUFLMEIsSUFBSWtLLE9BQU9ILEdBQUdOLEtBQUtNLElBQUk4QixFQUFBQTtFQUN6QyxXQUFXRCxRQUFRMUgsTUFBTXVGLEtBQUtRLEdBQUc7QUFDL0I0QixJQUFBQSxNQUFLRCxRQUFRMUgsTUFBTXVGLEtBQUtRLEtBQUtsRztBQUM3Qm1HLFdBQU9ELElBQUkzTCxLQUFLRixJQUFJOEwsT0FBT0QsR0FBR1IsS0FBS1EsSUFBSTRCLEVBQUFBOztBQUUzQztBQUVBLFNBQVNLLHFCQUFxQjFDLE9BQU9oTSxPQUFPMk8sVUFBVTtBQUNwRCxRQUFNQyxnQkFBZ0I1QyxNQUFNMEI7QUFDNUIsUUFBTSxFQUFDbUIsT0FBTzNCLGlCQUFpQmxDLFNBQVNJLEtBQUksSUFBSXVEO0FBQ2hELFFBQU1HLHFCQUFxQjlDLE1BQU15QixpQkFBaUJ6TixPQUFPNE8sZ0JBQWdCQyxRQUFRN0QsU0FBU2tDLGVBQUFBO0FBQzFGLFFBQU1yQixRQUFRL0ssS0FBS0MsTUFBTWtOLFVBQVVGLGdCQUFnQmUsbUJBQW1CakQsUUFBUWtELE9BQUFBLENBQUFBLENBQUFBO0FBQzlFLFFBQU1WLEtBQUlXLFVBQVVGLG1CQUFtQlQsR0FBR2pELEtBQUtPLEdBQUdFLEtBQUFBO0FBQ2xELFFBQU1vRCxZQUFZQyxxQkFBcUJyRCxLQUFBQTtBQUN2QyxRQUFNTSxPQUFPZ0QsaUJBQWlCTCxtQkFBbUJYLEdBQUcvQyxLQUFLSSxHQUFHeUQsU0FBQUE7QUFDNUQsU0FBTztJQUVMRyxTQUFTO0lBR1RqQixHQUFHVyxtQkFBbUJYO0lBQ3RCRSxHQUFBQTtJQUdBWTtJQUdBOUM7SUFDQUssS0FBSzZCO0lBQ0wvQixPQUFPSCxPQUFPZixLQUFLSTtJQUNuQjNILFFBQVF3SyxLQUFJakQsS0FBS087RUFDbkI7QUFDRjtBQUVBLFNBQVMwRCxnQkFBZ0JDLE1BQU1DLE1BQU07QUFDbkMsTUFBSSxDQUFDQSxNQUFNO0FBQ1QsV0FBTzs7QUFFVCxRQUFNLEVBQUNwRCxNQUFNSyxLQUFLRixPQUFPekksT0FBTSxJQUFJeUw7QUFDbkMsUUFBTUUsZUFBZUMsZUFBZTtJQUFDdEIsR0FBR2hDO0lBQU1rQyxHQUFHN0I7RUFBRyxHQUFHK0MsSUFBQUEsS0FBU0UsZUFBZTtJQUFDdEIsR0FBR2hDO0lBQU1rQyxHQUFHeEs7RUFBTSxHQUFHMEwsSUFBQUEsS0FDbkdFLGVBQWU7SUFBQ3RCLEdBQUc3QjtJQUFPK0IsR0FBRzdCO0VBQUcsR0FBRytDLElBQUFBLEtBQVNFLGVBQWU7SUFBQ3RCLEdBQUc3QjtJQUFPK0IsR0FBR3hLO0tBQVMwTCxJQUFBQTtBQUNwRixTQUFPLENBQUNDO0FBQ1Y7QUFFQSxTQUFTZixxQkFBcUJ6QyxPQUFPYSxZQUFZN0IsU0FBUztBQUN4RCxRQUFNMEUsUUFBUSxDQUFBO0FBQ2QsUUFBTTVDLGFBQWFkLE1BQU1lLGFBQWE1TDtBQUN0QyxRQUFNMkcsT0FBT2tFLE1BQU10SjtBQUNuQixRQUFNLEVBQUN5SyxtQkFBbUJwQyxRQUFBQSxJQUFXakQsS0FBS21GO0FBQzFDLFFBQU0wQixXQUFXO0lBQ2ZFLE9BQU8vRCxzQkFBc0JoRCxJQUFRLElBQUE7SUFDckNvRixpQkFBaUJDLG9CQUFvQkMsS0FBS04sYUFBYTtFQUN6RDtBQUNBLE1BQUl5QztBQUVKLFdBQVNsQyxLQUFJLEdBQUdBLEtBQUlQLFlBQVlPLE1BQUs7QUFDbkNzQixhQUFTM0QsVUFBVUEsUUFBUXFDLEVBQUU7QUFDN0JzQixhQUFTdkQsT0FBT3lCLFdBQVdRLEVBQUU7QUFFN0IsVUFBTWlDLE9BQU9aLHFCQUFxQjFDLE9BQU9xQixJQUFHc0IsUUFBQUE7QUFDNUNlLFVBQU14UCxLQUFLb1AsSUFBQUE7QUFDWCxRQUFJdkUsWUFBWSxRQUFRO0FBQ3RCdUUsV0FBS0YsVUFBVUMsZ0JBQWdCQyxNQUFNQyxJQUFBQTtBQUNyQyxVQUFJRCxLQUFLRixTQUFTO0FBQ2hCRyxlQUFPRDs7O0VBR2I7QUFDQSxTQUFPSTtBQUNUO0FBRUEsU0FBU1IscUJBQXFCckQsT0FBTztBQUNuQyxNQUFJQSxVQUFVLEtBQUtBLFVBQVUsS0FBSztBQUNoQyxXQUFPO2FBQ0VBLFFBQVEsS0FBSztBQUN0QixXQUFPOztBQUdULFNBQU87QUFDVDtBQUVBLFNBQVNzRCxpQkFBaUJoQixJQUFHM0MsSUFBR21FLE9BQU87QUFDckMsTUFBSUEsVUFBVSxTQUFTO0FBQ3JCeEIsSUFBQUEsTUFBSzNDO2FBQ0ltRSxVQUFVLFVBQVU7QUFDN0J4QixJQUFBQSxNQUFNM0MsS0FBSTs7QUFFWixTQUFPMkM7QUFDVDtBQUVBLFNBQVNhLFVBQVVYLElBQUcxQyxJQUFHRSxPQUFPO0FBQzlCLE1BQUlBLFVBQVUsTUFBTUEsVUFBVSxLQUFLO0FBQ2pDd0MsSUFBQUEsTUFBTTFDLEtBQUk7RUFDWixXQUFXRSxRQUFRLE9BQU9BLFFBQVEsSUFBSTtBQUNwQ3dDLElBQUFBLE1BQUsxQzs7QUFFUCxTQUFPMEM7QUFDVDtBQUVBLFNBQVN1QixrQkFBa0J0RSxLQUFLeEQsTUFBTXdILE1BQU07QUFDMUMsUUFBTSxFQUFDbkQsTUFBTUssS0FBS0YsT0FBT3pJLE9BQU0sSUFBSXlMO0FBQ25DLFFBQU0sRUFBQ08sY0FBYSxJQUFJL0g7QUFFeEIsTUFBSSxDQUFDN0YsY0FBYzROLGFBQWdCLEdBQUE7QUFDakMsVUFBTUMsZUFBZUMsY0FBY2pJLEtBQUtnSSxZQUFZO0FBQ3BELFVBQU05RSxVQUFVQyxVQUFVbkQsS0FBS29ELGVBQWU7QUFDOUNJLFFBQUkwRSxZQUFZSDtBQUVoQixVQUFNSSxlQUFlOUQsT0FBT25CLFFBQVFtQjtBQUNwQyxVQUFNK0QsY0FBYzFELE1BQU14QixRQUFRd0I7QUFDbEMsVUFBTTJELGdCQUFnQjdELFFBQVFILE9BQU9uQixRQUFRdkM7QUFDN0MsVUFBTTJILGlCQUFpQnZNLFNBQVMySSxNQUFNeEIsUUFBUXRDO0FBRTlDLFFBQUlpRSxPQUFPMEQsT0FBT1AsWUFBQUEsRUFBY1EsS0FBS3RKLENBQUFBLE9BQUtBLE9BQU0sQ0FBSSxHQUFBO0FBQ2xEc0UsVUFBSWlGLFVBQVM7QUFDYkMseUJBQW1CbEYsS0FBSztRQUN0QjZDLEdBQUc4QjtRQUNINUIsR0FBRzZCO1FBQ0gxRSxHQUFHMkU7UUFDSHhFLEdBQUd5RTtRQUNISyxRQUFRWDtNQUNWLENBQUE7QUFDQXhFLFVBQUlvRixLQUFJO1dBQ0g7QUFDTHBGLFVBQUlxRixTQUFTVixjQUFjQyxhQUFhQyxlQUFlQyxjQUFBQTs7O0FBRzdEO0FBRUEsU0FBU1EsZ0JBQWdCNUUsT0FBTzZFLFlBQVk7QUFDMUMsUUFBTSxFQUFDdkYsS0FBSzVJLFNBQVMsRUFBQ3VLLFlBQVcsRUFBQyxJQUFJakI7QUFFdEMsV0FBU3FCLEtBQUl3RCxhQUFhLEdBQUd4RCxNQUFLLEdBQUdBLE1BQUs7QUFDeEMsVUFBTWlDLE9BQU90RCxNQUFNd0MsaUJBQWlCbkIsRUFBRTtBQUN0QyxRQUFJLENBQUNpQyxLQUFLRixTQUFTO0FBRWpCOztBQUVGLFVBQU0wQixjQUFjN0QsWUFBWUssV0FBV3RCLE1BQU11QixxQkFBcUJGLEVBQUFBLENBQUFBO0FBQ3RFdUMsc0JBQWtCdEUsS0FBS3dGLGFBQWF4QixJQUFBQTtBQUNwQyxVQUFNM0IsU0FBU0MsT0FBT2tELFlBQVkzRixJQUFJO0FBQ3RDLFVBQU0sRUFBQ2dELEdBQUFBLElBQUdFLEdBQUFBLElBQUdZLFVBQUFBLElBQWFLO0FBRTFCeUIsZUFDRXpGLEtBQ0FVLE1BQU1lLGFBQWFNLEVBQUUsR0FDckJjLElBQ0FFLEtBQUtWLE9BQU85RSxhQUFhLEdBQ3pCOEUsUUFDQTtNQUNFcUQsT0FBT0YsWUFBWUU7TUFDbkIvQjtNQUNBZ0MsY0FBYztJQUNoQixDQUFBO0VBRUo7QUFDRjtBQUVBLFNBQVNDLGVBQWVsRixPQUFPeUUsUUFBUVUsVUFBVU4sWUFBWTtBQUMzRCxRQUFNLEVBQUN2RixJQUFHLElBQUlVO0FBQ2QsTUFBSW1GLFVBQVU7QUFFWjdGLFFBQUk4RixJQUFJcEYsTUFBTXFGLFNBQVNyRixNQUFNc0YsU0FBU2IsUUFBUSxHQUFHYyxHQUFBQTtTQUM1QztBQUVMLFFBQUkvRCxnQkFBZ0J4QixNQUFNeUIsaUJBQWlCLEdBQUdnRCxNQUFBQTtBQUM5Q25GLFFBQUlrRyxPQUFPaEUsY0FBY1csR0FBR1gsY0FBY2EsQ0FBQztBQUUzQyxhQUFTaEIsS0FBSSxHQUFHQSxLQUFJd0QsWUFBWXhELE1BQUs7QUFDbkNHLHNCQUFnQnhCLE1BQU15QixpQkFBaUJKLElBQUdvRCxNQUFBQTtBQUMxQ25GLFVBQUltRyxPQUFPakUsY0FBY1csR0FBR1gsY0FBY2EsQ0FBQztJQUM3Qzs7QUFFSjtBQUVBLFNBQVNxRCxlQUFlMUYsT0FBTzJGLGNBQWNsQixRQUFRSSxZQUFZZSxZQUFZO0FBQzNFLFFBQU10RyxNQUFNVSxNQUFNVjtBQUNsQixRQUFNNkYsV0FBV1EsYUFBYVI7QUFFOUIsUUFBTSxFQUFDSCxPQUFBQSxRQUFPYSxVQUFBQSxJQUFhRjtBQUUzQixNQUFLLENBQUNSLFlBQVksQ0FBQ04sY0FBZSxDQUFDRyxVQUFTLENBQUNhLGFBQWFwQixTQUFTLEdBQUc7QUFDcEU7O0FBR0ZuRixNQUFJd0csS0FBSTtBQUNSeEcsTUFBSXlHLGNBQWNmO0FBQ2xCMUYsTUFBSXVHLFlBQVlBO0FBQ2hCdkcsTUFBSTBHLFlBQVlKLFdBQVdLLFFBQVEsQ0FBQSxDQUFFO0FBQ3JDM0csTUFBSTRHLGlCQUFpQk4sV0FBV087QUFFaEM3RyxNQUFJaUYsVUFBUztBQUNiVyxpQkFBZWxGLE9BQU95RSxRQUFRVSxVQUFVTixVQUFBQTtBQUN4Q3ZGLE1BQUk4RyxVQUFTO0FBQ2I5RyxNQUFJK0csT0FBTTtBQUNWL0csTUFBSWdILFFBQU87QUFDYjtBQUVBLFNBQVNDLHdCQUF3QkMsUUFBUXhTLE9BQU9JLE9BQU87QUFDckQsU0FBT3FTLGNBQWNELFFBQVE7SUFDM0JwUztJQUNBSjtJQUNBMFMsTUFBTTtFQUNSLENBQUE7QUFDRjtBQUVlLElBQU1DLG9CQUFOLGNBQWdDbk0sZ0JBQUFBO0VBMEU3Q2xGLFlBQVlDLEtBQUs7QUFDZixVQUFNQSxHQUFBQTtBQUdOLFNBQUs4UCxVQUFVNVA7QUFFZixTQUFLNlAsVUFBVTdQO0FBRWYsU0FBS2lNLGNBQWNqTTtBQUVuQixTQUFLc0wsZUFBZSxDQUFBO0FBQ3BCLFNBQUt5QixtQkFBbUIsQ0FBQTtFQUMxQjtFQUVBb0UsZ0JBQWdCO0FBRWQsVUFBTTVILFVBQVUsS0FBS29CLFdBQVduQixVQUFVSCxzQkFBc0IsS0FBS3BJLE9BQU8sSUFBSSxDQUFBO0FBQ2hGLFVBQU04SSxLQUFJLEtBQUsvQyxRQUFRLEtBQUtvSyxXQUFXN0gsUUFBUXZDO0FBQy9DLFVBQU1rRCxLQUFJLEtBQUtqRCxTQUFTLEtBQUtvSyxZQUFZOUgsUUFBUXRDO0FBQ2pELFNBQUsySSxVQUFVdlEsS0FBSzBFLE1BQU0sS0FBSzJHLE9BQU9YLEtBQUksSUFBSVIsUUFBUW1CLElBQUk7QUFDMUQsU0FBS21GLFVBQVV4USxLQUFLMEUsTUFBTSxLQUFLZ0gsTUFBTWIsS0FBSSxJQUFJWCxRQUFRd0IsR0FBRztBQUN4RCxTQUFLa0IsY0FBYzVNLEtBQUswRSxNQUFNMUUsS0FBSzBCLElBQUlnSixJQUFHRyxFQUFLLElBQUEsQ0FBQTtFQUNqRDtFQUVBdkosc0JBQXNCO0FBQ3BCLFVBQU0sRUFBQ0ksS0FBSzVCLElBQUcsSUFBSSxLQUFLNkIsVUFBVSxLQUFLO0FBRXZDLFNBQUtELE1BQU1OLGVBQVNNLEdBQUFBLEtBQVEsQ0FBQ25DLE1BQU1tQyxHQUFPQSxJQUFBQSxNQUFNO0FBQ2hELFNBQUs1QixNQUFNc0IsZUFBU3RCLEdBQUFBLEtBQVEsQ0FBQ1AsTUFBTU8sR0FBT0EsSUFBQUEsTUFBTTtBQUdoRCxTQUFLaUcsdUJBQXNCO0VBQzdCO0VBTUFlLG1CQUFtQjtBQUNqQixXQUFPOUcsS0FBS3lFLEtBQUssS0FBS21JLGNBQWM1QyxzQkFBc0IsS0FBS3BJLE9BQU8sQ0FBQTtFQUN4RTtFQUVBcVEsbUJBQW1CalEsT0FBTztBQUN4QjBELG9CQUFnQjZELFVBQVUwSSxtQkFBbUI5UCxLQUFLLE1BQU1ILEtBQUFBO0FBR3hELFNBQUtpSyxlQUFlLEtBQUs3TCxVQUFTLEVBQy9COFIsSUFBSSxDQUFDL1IsT0FBT2pCLFVBQVU7QUFDckIsWUFBTUksUUFBUTZTLFNBQWEsS0FBS3ZRLFFBQVF1SyxZQUFZakosVUFBVTtRQUFDL0M7UUFBT2pCO01BQU0sR0FBRSxJQUFJO0FBQ2xGLGFBQU9JLFNBQVNBLFVBQVUsSUFBSUEsUUFBUTtLQUV2QzhTLEVBQUFBLE9BQU8sQ0FBQ2xNLElBQUdxRyxPQUFNLEtBQUtoRixNQUFNOEssa0JBQWtCOUYsRUFBQUEsQ0FBQUE7RUFDbkQ7RUFFQStGLE1BQU07QUFDSixVQUFNdEwsT0FBTyxLQUFLcEY7QUFFbEIsUUFBSW9GLEtBQUtpRCxXQUFXakQsS0FBS21GLFlBQVlsQyxTQUFTO0FBQzVDZ0IseUJBQW1CLElBQUk7V0FDbEI7QUFDTCxXQUFLd0MsZUFBZSxHQUFHLEdBQUcsR0FBRyxDQUFBOztFQUVqQztFQUVBQSxlQUFlOEUsY0FBY0MsZUFBZUMsYUFBYUMsZ0JBQWdCO0FBQ3ZFLFNBQUtuQyxXQUFXdlEsS0FBSzBFLE9BQU82TixlQUFlQyxpQkFBaUIsQ0FBQTtBQUM1RCxTQUFLaEMsV0FBV3hRLEtBQUswRSxPQUFPK04sY0FBY0Msa0JBQWtCLENBQUE7QUFDNUQsU0FBSzlGLGVBQWU1TSxLQUFLMEIsSUFBSSxLQUFLa0wsY0FBYyxHQUFHNU0sS0FBS0YsSUFBSXlTLGNBQWNDLGVBQWVDLGFBQWFDLGNBQUFBLENBQUFBO0VBQ3hHO0VBRUF4RixjQUFjaE8sT0FBTztBQUNuQixVQUFNeVQsa0JBQWtCbEMsT0FBTyxLQUFLeEUsYUFBYTVMLFVBQVU7QUFDM0QsVUFBTXVTLGFBQWEsS0FBS2hSLFFBQVFnUixjQUFjO0FBRTlDLFdBQU8zRixnQkFBZ0IvTixRQUFReVQsa0JBQWtCck4sVUFBVXNOLFVBQUFBLENBQUFBO0VBQzdEO0VBRUFDLDhCQUE4QjFTLE9BQU87QUFDbkMsUUFBSWdCLGNBQWNoQixLQUFRLEdBQUE7QUFDeEIsYUFBT3FDOztBQUlULFVBQU1zUSxnQkFBZ0IsS0FBS2xHLGVBQWUsS0FBSzlNLE1BQU0sS0FBSzRCO0FBQzFELFFBQUksS0FBS0UsUUFBUXlGLFNBQVM7QUFDeEIsY0FBUSxLQUFLdkgsTUFBTUssU0FBUzJTOztBQUU5QixZQUFRM1MsUUFBUSxLQUFLdUIsT0FBT29SO0VBQzlCO0VBRUFDLDhCQUE4QkMsVUFBVTtBQUN0QyxRQUFJN1IsY0FBYzZSLFFBQVcsR0FBQTtBQUMzQixhQUFPeFE7O0FBR1QsVUFBTXlRLGlCQUFpQkQsWUFBWSxLQUFLcEcsZUFBZSxLQUFLOU0sTUFBTSxLQUFLNEI7QUFDdkUsV0FBTyxLQUFLRSxRQUFReUYsVUFBVSxLQUFLdkgsTUFBTW1ULGlCQUFpQixLQUFLdlIsTUFBTXVSO0VBQ3ZFO0VBRUF4RyxxQkFBcUJ2TixPQUFPO0FBQzFCLFVBQU1pTixjQUFjLEtBQUtGLGdCQUFnQixDQUFBO0FBRXpDLFFBQUkvTSxTQUFTLEtBQUtBLFFBQVFpTixZQUFZOUwsUUFBUTtBQUM1QyxZQUFNNlMsYUFBYS9HLFlBQVlqTixLQUFNO0FBQ3JDLGFBQU91Uyx3QkFBd0IsS0FBSzBCLFdBQVUsR0FBSWpVLE9BQU9nVSxVQUFBQTs7RUFFN0Q7RUFFQXZHLGlCQUFpQnpOLE9BQU9rVSxvQkFBb0JoSCxrQkFBa0IsR0FBRztBQUMvRCxVQUFNckIsUUFBUSxLQUFLbUMsY0FBY2hPLEtBQUFBLElBQVMrTyxVQUFVN0I7QUFDcEQsV0FBTztNQUNMaUIsR0FBR3JOLEtBQUt5RixJQUFJc0YsS0FBQUEsSUFBU3FJLHFCQUFxQixLQUFLN0M7TUFDL0NoRCxHQUFHdk4sS0FBS3dGLElBQUl1RixLQUFBQSxJQUFTcUkscUJBQXFCLEtBQUs1QztNQUMvQ3pGO0lBQ0Y7RUFDRjtFQUVBc0kseUJBQXlCblUsT0FBT2lCLE9BQU87QUFDckMsV0FBTyxLQUFLd00saUJBQWlCek4sT0FBTyxLQUFLMlQsOEJBQThCMVMsS0FBQUEsQ0FBQUE7RUFDekU7RUFFQW1ULGdCQUFnQnBVLE9BQU87QUFDckIsV0FBTyxLQUFLbVUseUJBQXlCblUsU0FBUyxHQUFHLEtBQUtxVSxhQUFZLENBQUE7RUFDcEU7RUFFQUMsc0JBQXNCdFUsT0FBTztBQUMzQixVQUFNLEVBQUNtTSxNQUFNSyxLQUFLRixPQUFPekksT0FBTSxJQUFJLEtBQUsySyxpQkFBaUJ4TyxLQUFNO0FBQy9ELFdBQU87TUFDTG1NO01BQ0FLO01BQ0FGO01BQ0F6STtJQUNGO0VBQ0Y7RUFLQTBRLGlCQUFpQjtBQUNmLFVBQU0sRUFBQ0MsaUJBQWlCQyxNQUFNLEVBQUN0RCxTQUFBQSxFQUFTLElBQUksS0FBS3pPO0FBQ2pELFFBQUk4UixpQkFBaUI7QUFDbkIsWUFBTWxKLE1BQU0sS0FBS0E7QUFDakJBLFVBQUl3RyxLQUFJO0FBQ1J4RyxVQUFJaUYsVUFBUztBQUNiVyxxQkFBZSxNQUFNLEtBQUt5Qyw4QkFBOEIsS0FBS2hOLFNBQVMsR0FBR3dLLFVBQVUsS0FBS3BFLGFBQWE1TCxNQUFNO0FBQzNHbUssVUFBSThHLFVBQVM7QUFDYjlHLFVBQUkwRSxZQUFZd0U7QUFDaEJsSixVQUFJb0YsS0FBSTtBQUNScEYsVUFBSWdILFFBQU87O0VBRWY7RUFLQW9DLFdBQVc7QUFDVCxVQUFNcEosTUFBTSxLQUFLQTtBQUNqQixVQUFNeEQsT0FBTyxLQUFLcEY7QUFDbEIsVUFBTSxFQUFDaVMsWUFBWUYsTUFBTUcsT0FBQUEsSUFBVTlNO0FBQ25DLFVBQU0rSSxhQUFhLEtBQUs5RCxhQUFhNUw7QUFFckMsUUFBSWtNLElBQUd4SyxRQUFRZ1M7QUFFZixRQUFJL00sS0FBS21GLFlBQVlsQyxTQUFTO0FBQzVCNkYsc0JBQWdCLE1BQU1DLFVBQUFBOztBQUd4QixRQUFJNEQsS0FBSzFKLFNBQVM7QUFDaEIsV0FBS2pJLE1BQU1nUyxRQUFRLENBQUNDLE1BQU0vVSxVQUFVO0FBQ2xDLFlBQUlBLFVBQVUsS0FBTUEsVUFBVSxLQUFLLEtBQUt3QyxNQUFNLEdBQUk7QUFDaERLLG1CQUFTLEtBQUs4USw4QkFBOEJvQixLQUFLOVQsS0FBSztBQUN0RCxnQkFBTStULFVBQVUsS0FBS2YsV0FBV2pVLEtBQUFBO0FBQ2hDLGdCQUFNOFEsY0FBYzJELEtBQUtuSCxXQUFXMEgsT0FBQUE7QUFDcEMsZ0JBQU1DLG9CQUFvQkwsT0FBT3RILFdBQVcwSCxPQUFBQTtBQUU1Q3RELHlCQUFlLE1BQU1aLGFBQWFqTyxRQUFRZ08sWUFBWW9FLGlCQUFBQTs7TUFFMUQsQ0FBQTs7QUFHRixRQUFJTixXQUFXNUosU0FBUztBQUN0Qk8sVUFBSXdHLEtBQUk7QUFFUixXQUFLekUsS0FBSXdELGFBQWEsR0FBR3hELE1BQUssR0FBR0EsTUFBSztBQUNwQyxjQUFNeUQsY0FBYzZELFdBQVdySCxXQUFXLEtBQUtDLHFCQUFxQkYsRUFBQUEsQ0FBQUE7QUFDcEUsY0FBTSxFQUFDMkQsT0FBQUEsUUFBT2EsVUFBQUEsSUFBYWY7QUFFM0IsWUFBSSxDQUFDZSxhQUFhLENBQUNiLFFBQU87QUFDeEI7O0FBR0YxRixZQUFJdUcsWUFBWUE7QUFDaEJ2RyxZQUFJeUcsY0FBY2Y7QUFFbEIxRixZQUFJMEcsWUFBWWxCLFlBQVlvRSxVQUFVO0FBQ3RDNUosWUFBSTRHLGlCQUFpQnBCLFlBQVlxRTtBQUVqQ3RTLGlCQUFTLEtBQUs4USw4QkFBOEI3TCxLQUFLSyxVQUFVLEtBQUszRixNQUFNLEtBQUs1QixHQUFHO0FBQzlFaVUsbUJBQVcsS0FBS3BILGlCQUFpQkosSUFBR3hLLE1BQUFBO0FBQ3BDeUksWUFBSWlGLFVBQVM7QUFDYmpGLFlBQUlrRyxPQUFPLEtBQUtILFNBQVMsS0FBS0MsT0FBTztBQUNyQ2hHLFlBQUltRyxPQUFPb0QsU0FBUzFHLEdBQUcwRyxTQUFTeEcsQ0FBQztBQUNqQy9DLFlBQUkrRyxPQUFNO01BQ1o7QUFFQS9HLFVBQUlnSCxRQUFPOztFQUVmO0VBS0E4QyxhQUFhO0VBQUE7RUFLYkMsYUFBYTtBQUNYLFVBQU0vSixNQUFNLEtBQUtBO0FBQ2pCLFVBQU14RCxPQUFPLEtBQUtwRjtBQUNsQixVQUFNNkUsV0FBV08sS0FBS2hGO0FBRXRCLFFBQUksQ0FBQ3lFLFNBQVN3RCxTQUFTO0FBQ3JCOztBQUdGLFVBQU0ySSxhQUFhLEtBQUsxRixjQUFjLENBQUE7QUFDdEMsUUFBSW5MLFFBQVE0RjtBQUVaNkMsUUFBSXdHLEtBQUk7QUFDUnhHLFFBQUlnSyxVQUFVLEtBQUtqRSxTQUFTLEtBQUtDLE9BQU87QUFDeENoRyxRQUFJaUssT0FBTzdCLFVBQUFBO0FBQ1hwSSxRQUFJMkQsWUFBWTtBQUNoQjNELFFBQUkyRixlQUFlO0FBRW5CLFNBQUtuTyxNQUFNZ1MsUUFBUSxDQUFDQyxNQUFNL1UsVUFBVTtBQUNsQyxVQUFLQSxVQUFVLEtBQUssS0FBS3dDLE9BQU8sS0FBTSxDQUFDc0YsS0FBS0ssU0FBUztBQUNuRDs7QUFHRixZQUFNMkksY0FBY3ZKLFNBQVMrRixXQUFXLEtBQUsyRyxXQUFXalUsS0FBQUEsQ0FBQUE7QUFDeEQsWUFBTTJJLFdBQVdpRixPQUFPa0QsWUFBWTNGLElBQUk7QUFDeEN0SSxlQUFTLEtBQUs4USw4QkFBOEIsS0FBSzdRLE1BQU05QyxLQUFNLEVBQUNpQixLQUFLO0FBRW5FLFVBQUk2UCxZQUFZMEUsbUJBQW1CO0FBQ2pDbEssWUFBSUgsT0FBT3hDLFNBQVMrQztBQUNwQmpELGdCQUFRNkMsSUFBSW1LLFlBQVlWLEtBQUszVSxLQUFLLEVBQUVxSTtBQUNwQzZDLFlBQUkwRSxZQUFZYyxZQUFZakI7QUFFNUIsY0FBTTdFLFVBQVVDLFVBQVU2RixZQUFZNUYsZUFBZTtBQUNyREksWUFBSXFGLFNBQ0YsQ0FBQ2xJLFFBQVEsSUFBSXVDLFFBQVFtQixNQUNyQixDQUFDdEosU0FBUzhGLFNBQVN5QyxPQUFPLElBQUlKLFFBQVF3QixLQUN0Qy9ELFFBQVF1QyxRQUFRdkMsT0FDaEJFLFNBQVN5QyxPQUFPSixRQUFRdEMsTUFBTTs7QUFJbENxSSxpQkFBV3pGLEtBQUt5SixLQUFLM1UsT0FBTyxHQUFHLENBQUN5QyxRQUFROEYsVUFBVTtRQUNoRHFJLE9BQU9GLFlBQVlFO1FBQ25CMEUsYUFBYTVFLFlBQVk2RTtRQUN6QkMsYUFBYTlFLFlBQVkrRTtNQUMzQixDQUFBO0lBQ0YsQ0FBQTtBQUVBdkssUUFBSWdILFFBQU87RUFDYjtFQUtBd0QsWUFBWTtFQUFBO0FBQ2Q7QUF4VkUsY0FGbUJuRCxtQkFFWjdPLE1BQUs7QUFLWixjQVBtQjZPLG1CQU9aNU8sWUFBVztFQUNoQmdILFNBQVM7RUFHVGdMLFNBQVM7RUFDVGxCLFVBQVU7RUFFVkYsWUFBWTtJQUNWNUosU0FBUztJQUNUOEcsV0FBVztJQUNYcUQsWUFBWSxDQUFBO0lBQ1pDLGtCQUFrQjtFQUNwQjtFQUVBVixNQUFNO0lBQ0p0RCxVQUFVO0VBQ1o7RUFFQXVDLFlBQVk7RUFHWjVRLE9BQU87SUFFTDBTLG1CQUFtQjtJQUVuQnhSLFVBQVU4RSxNQUFNQyxXQUFXQztFQUM3QjtFQUVBaUUsYUFBYTtJQUNYNEMsZUFBZXBPO0lBR2Z5SixpQkFBaUI7SUFHakJILFNBQVM7SUFHVEksTUFBTTtNQUNKQyxNQUFNO0lBQ1I7SUFHQXBILFNBQVM1RCxPQUFPO0FBQ2QsYUFBT0E7SUFDVDtJQUdBNEssU0FBUztJQUdUbUMsbUJBQW1CO0VBQ3JCOztBQUdGLGNBOURtQndGLG1CQThEWnFELGlCQUFnQjtFQUNyQixvQkFBb0I7RUFDcEIscUJBQXFCO0VBQ3JCLGVBQWU7O0FBR2pCLGNBcEVtQnJELG1CQW9FWnNELGVBQWM7RUFDbkJ0QixZQUFZO0lBQ1Z1QixXQUFXO0VBQ2I7O0FDellKLElBQU1DLFlBQVk7RUFDaEJDLGFBQWE7SUFBQ0MsUUFBUTtJQUFNakwsTUFBTTtJQUFHNUIsT0FBTztFQUFJO0VBQ2hEOE0sUUFBUTtJQUFDRCxRQUFRO0lBQU1qTCxNQUFNO0lBQU01QixPQUFPO0VBQUU7RUFDNUMrTSxRQUFRO0lBQUNGLFFBQVE7SUFBTWpMLE1BQU07SUFBTzVCLE9BQU87RUFBRTtFQUM3Q2dOLE1BQU07SUFBQ0gsUUFBUTtJQUFNakwsTUFBTTtJQUFTNUIsT0FBTztFQUFFO0VBQzdDaU4sS0FBSztJQUFDSixRQUFRO0lBQU1qTCxNQUFNO0lBQVU1QixPQUFPO0VBQUU7RUFDN0NrTixNQUFNO0lBQUNMLFFBQVE7SUFBT2pMLE1BQU07SUFBVzVCLE9BQU87RUFBQztFQUMvQ21OLE9BQU87SUFBQ04sUUFBUTtJQUFNakwsTUFBTTtJQUFTNUIsT0FBTztFQUFFO0VBQzlDb04sU0FBUztJQUFDUCxRQUFRO0lBQU9qTCxNQUFNO0lBQVM1QixPQUFPO0VBQUM7RUFDaERxTixNQUFNO0lBQUNSLFFBQVE7SUFBTWpMLE1BQU07RUFBUTtBQUNyQztBQUtBLElBQU0wTCxRQUE2Q25LLHVCQUFPb0ssS0FBS1osU0FBQUE7QUFNL0QsU0FBU2EsT0FBT0MsSUFBR3hLLElBQUc7QUFDcEIsU0FBT3dLLEtBQUl4SztBQUNiO0FBT0EsU0FBU3pLLE9BQU1nSyxPQUFPa0wsT0FBTztBQUMzQixNQUFJalYsY0FBY2lWLEtBQVEsR0FBQTtBQUN4QixXQUFPOztBQUdULFFBQU1DLFVBQVVuTCxNQUFNb0w7QUFDdEIsUUFBTSxFQUFDQyxRQUFRdFcsT0FBQUEsUUFBT3VXLFdBQVUsSUFBSXRMLE1BQU11TDtBQUMxQyxNQUFJdFcsUUFBUWlXO0FBRVosTUFBSSxPQUFPRyxXQUFXLFlBQVk7QUFDaENwVyxZQUFRb1csT0FBT3BXLEtBQUFBOztBQUlqQixNQUFJLENBQUNpQixlQUFTakIsS0FBUSxHQUFBO0FBQ3BCQSxZQUFRLE9BQU9vVyxXQUFXLFdBQ3RCRixRQUFRblYsTUFBTWYsT0FBT29XLE1BQ3JCRixJQUFBQSxRQUFRblYsTUFBTWYsS0FBTTs7QUFHMUIsTUFBSUEsVUFBVSxNQUFNO0FBQ2xCLFdBQU87O0FBR1QsTUFBSUYsUUFBTztBQUNURSxZQUFRRixXQUFVLFdBQVd5VyxTQUFTRixVQUFlQSxLQUFBQSxlQUFlLFFBQ2hFSCxRQUFRTSxRQUFReFcsT0FBTyxXQUFXcVcsVUFBQUEsSUFDbENILFFBQVFNLFFBQVF4VyxPQUFPRixNQUFNOztBQUduQyxTQUFPLENBQUNFO0FBQ1Y7QUFVQSxTQUFTeVcsMEJBQTBCQyxTQUFTblYsS0FBSzVCLEtBQUtnWCxVQUFVO0FBQzlELFFBQU1DLE9BQU9mLE1BQU0zVjtBQUVuQixXQUFTa00sS0FBSXlKLE1BQU10VyxRQUFRbVgsT0FBQUEsR0FBVXRLLEtBQUl3SyxPQUFPLEdBQUcsRUFBRXhLLElBQUc7QUFDdEQsVUFBTXlLLFdBQVczQixVQUFVVyxNQUFNekosRUFBQUEsQ0FBRTtBQUNuQyxVQUFNbEksU0FBUzJTLFNBQVN0TyxRQUFRc08sU0FBU3RPLFFBQVE1QyxPQUFPbVI7QUFFeEQsUUFBSUQsU0FBU3pCLFVBQVV2VixLQUFLeUUsTUFBTTNFLE1BQU00QixRQUFRMkMsU0FBUzJTLFNBQVMxTSxLQUFHLEtBQU93TSxVQUFVO0FBQ3BGLGFBQU9kLE1BQU16SixFQUFFOztFQUVuQjtBQUVBLFNBQU95SixNQUFNZSxPQUFPLENBQUU7QUFDeEI7QUFXQSxTQUFTRywyQkFBMkJoTSxPQUFPaU0sVUFBVU4sU0FBU25WLEtBQUs1QixLQUFLO0FBQ3RFLFdBQVN5TSxLQUFJeUosTUFBTTNWLFNBQVMsR0FBR2tNLE1BQUt5SixNQUFNdFcsUUFBUW1YLE9BQUFBLEdBQVV0SyxNQUFLO0FBQy9ELFVBQU0xSSxPQUFPbVMsTUFBTXpKLEVBQUU7QUFDckIsUUFBSThJLFVBQVV4UixJQUFLLEVBQUMwUixVQUFVckssTUFBTW9MLFNBQVNjLEtBQUt0WCxLQUFLNEIsS0FBS21DLElBQUFBLEtBQVNzVCxXQUFXLEdBQUc7QUFDakYsYUFBT3RUOztFQUVYO0FBRUEsU0FBT21TLE1BQU1hLFVBQVViLE1BQU10VyxRQUFRbVgsT0FBQUEsSUFBVyxDQUFDO0FBQ25EO0FBTUEsU0FBU1EsbUJBQW1CeFQsTUFBTTtBQUNoQyxXQUFTMEksS0FBSXlKLE1BQU10VyxRQUFRbUUsSUFBUSxJQUFBLEdBQUdrVCxPQUFPZixNQUFNM1YsUUFBUWtNLEtBQUl3SyxNQUFNLEVBQUV4SyxJQUFHO0FBQ3hFLFFBQUk4SSxVQUFVVyxNQUFNekosRUFBQUEsQ0FBRSxFQUFFZ0osUUFBUTtBQUM5QixhQUFPUyxNQUFNekosRUFBRTs7RUFFbkI7QUFDRjtBQU9BLFNBQVMrSyxRQUFRdFYsT0FBT3VWLE1BQU1DLFlBQVk7QUFDeEMsTUFBSSxDQUFDQSxZQUFZO0FBQ2Z4VixVQUFNdVYsSUFBSyxJQUFHO2FBQ0xDLFdBQVduWCxRQUFRO0FBQzVCLFVBQU0sRUFBQ29YLElBQUlDLEdBQUFBLElBQU1DLFFBQVFILFlBQVlELElBQUFBO0FBQ3JDLFVBQU1LLFlBQVlKLFdBQVdDLEVBQUFBLEtBQU9GLE9BQU9DLFdBQVdDLEVBQUcsSUFBR0QsV0FBV0UsRUFBRztBQUMxRTFWLFVBQU00VixTQUFVLElBQUc7O0FBRXZCO0FBU0EsU0FBU0MsY0FBYzNNLE9BQU9sSixPQUFPa1EsTUFBSzRGLFdBQVc7QUFDbkQsUUFBTXpCLFVBQVVuTCxNQUFNb0w7QUFDdEIsUUFBTTdXLFFBQVEsQ0FBQzRXLFFBQVFNLFFBQVEzVSxNQUFNLENBQUEsRUFBRzdCLE9BQU8yWCxTQUFBQTtBQUMvQyxRQUFNblksT0FBT3FDLE1BQU1BLE1BQU0zQixTQUFTLENBQUEsRUFBR0Y7QUFDckMsTUFBSWlKLE9BQU9sSztBQUVYLE9BQUtrSyxRQUFRM0osT0FBTzJKLFNBQVN6SixNQUFNeUosUUFBUSxDQUFDaU4sUUFBUTBCLElBQUkzTyxPQUFPLEdBQUcwTyxTQUFZLEdBQUE7QUFDNUU1WSxZQUFRZ1QsS0FBSTlJLEtBQU07QUFDbEIsUUFBSWxLLFNBQVMsR0FBRztBQUNkOEMsWUFBTTlDLEtBQUFBLEVBQU9rSyxRQUFROztFQUV6QjtBQUNBLFNBQU9wSDtBQUNUO0FBUUEsU0FBU2dXLG9CQUFvQjlNLE9BQU9xRSxRQUFRdUksV0FBVztBQUNyRCxRQUFNOVYsUUFBUSxDQUFBO0FBRWQsUUFBTWtRLE9BQU0sQ0FBQTtBQUNaLFFBQU02RSxPQUFPeEgsT0FBT2xQO0FBQ3BCLE1BQUlrTSxJQUFHcE07QUFFUCxPQUFLb00sS0FBSSxHQUFHQSxLQUFJd0ssTUFBTSxFQUFFeEssSUFBRztBQUN6QnBNLFlBQVFvUCxPQUFPaEQsRUFBRTtBQUNqQjJGLElBQUFBLEtBQUkvUixLQUFBQSxJQUFTb007QUFFYnZLLFVBQU01QyxLQUFLO01BQ1RlO01BQ0FpSixPQUFPO0lBQ1QsQ0FBQTtFQUNGO0FBSUEsU0FBUTJOLFNBQVMsS0FBSyxDQUFDZSxZQUFhOVYsUUFBUTZWLGNBQWMzTSxPQUFPbEosT0FBT2tRLE1BQUs0RixTQUFVO0FBQ3pGO0FBRWUsSUFBTUcsWUFBTixjQUF3QjFYLE1BQUFBO0VBZ0RyQ0MsWUFBWTBYLE9BQU87QUFDakIsVUFBTUEsS0FBQUE7QUFHTixTQUFLQyxTQUFTO01BQ1pDLE1BQU0sQ0FBQTtNQUNOcFosUUFBUSxDQUFBO01BQ1JxWixLQUFLLENBQUE7SUFDUDtBQUdBLFNBQUtDLFFBQVE7QUFFYixTQUFLQyxhQUFhNVg7QUFDbEIsU0FBSzZYLFdBQVcsQ0FBQTtBQUNoQixTQUFLQyxjQUFjO0FBQ25CLFNBQUtoQyxhQUFhOVY7RUFDcEI7RUFFQUcsS0FBSzRYLFdBQVcxUixPQUFPLENBQUEsR0FBSTtBQUN6QixVQUFNdVEsT0FBT21CLFVBQVVuQixTQUFTbUIsVUFBVW5CLE9BQU8sQ0FBQTtBQUVqRCxVQUFNbEIsVUFBVSxLQUFLQyxXQUFXLElBQUlxQyxTQUFTQyxNQUFNRixVQUFVQyxTQUFTRSxJQUFJO0FBRTFFeEMsWUFBUXZWLEtBQUtrRyxJQUFBQTtBQU1iOFIsWUFBUXZCLEtBQUt3QixnQkFBZ0IxQyxRQUFRMkMsUUFBTyxDQUFBO0FBRTVDLFNBQUt2QyxhQUFhO01BQ2hCRixRQUFRZ0IsS0FBS2hCO01BQ2J0VyxPQUFPc1gsS0FBS3RYO01BQ1p1VyxZQUFZZSxLQUFLZjtJQUNuQjtBQUVBLFVBQU0xVixLQUFLNFgsU0FBQUE7QUFFWCxTQUFLRCxjQUFjelIsS0FBS2lTO0VBQzFCO0VBT0EvWCxNQUFNakMsS0FBS0MsT0FBTztBQUNoQixRQUFJRCxRQUFRMEIsUUFBVztBQUNyQixhQUFPOztBQUVULFdBQU9PLE9BQU0sTUFBTWpDLEdBQUFBO0VBQ3JCO0VBRUFpYSxlQUFlO0FBQ2IsVUFBTUEsYUFBWTtBQUNsQixTQUFLZixTQUFTO01BQ1pDLE1BQU0sQ0FBQTtNQUNOcFosUUFBUSxDQUFBO01BQ1JxWixLQUFLLENBQUE7SUFDUDtFQUNGO0VBRUEvVyxzQkFBc0I7QUFDcEIsVUFBTU0sVUFBVSxLQUFLQTtBQUNyQixVQUFNeVUsVUFBVSxLQUFLQztBQUNyQixVQUFNelMsT0FBT2pDLFFBQVEyVixLQUFLMVQsUUFBUTtBQUVsQyxRQUFJLEVBQUNuQyxLQUFLNUIsS0FBS3lCLFlBQVlDLFdBQUFBLElBQWMsS0FBS0MsY0FBYTtBQUszRCxhQUFTMFgsYUFBYXRYLFFBQVE7QUFDNUIsVUFBSSxDQUFDTixjQUFjLENBQUNoQyxNQUFNc0MsT0FBT0gsR0FBRyxHQUFHO0FBQ3JDQSxjQUFNMUIsS0FBSzBCLElBQUlBLEtBQUtHLE9BQU9ILEdBQUc7O0FBRWhDLFVBQUksQ0FBQ0YsY0FBYyxDQUFDakMsTUFBTXNDLE9BQU8vQixHQUFHLEdBQUc7QUFDckNBLGNBQU1FLEtBQUtGLElBQUlBLEtBQUsrQixPQUFPL0IsR0FBRzs7SUFFbEM7QUFHQSxRQUFJLENBQUN5QixjQUFjLENBQUNDLFlBQVk7QUFFOUIyWCxtQkFBYSxLQUFLQyxnQkFBZSxDQUFBO0FBSWpDLFVBQUl4WCxRQUFRQyxXQUFXLFdBQVdELFFBQVFJLE1BQU1xWCxXQUFXLFVBQVU7QUFDbkVGLHFCQUFhLEtBQUt4WCxVQUFVLEtBQUssQ0FBQTs7O0FBSXJDRCxVQUFNTixlQUFTTSxHQUFBQSxLQUFRLENBQUNuQyxNQUFNbUMsR0FBT0EsSUFBQUEsTUFBTSxDQUFDMlUsUUFBUU0sUUFBUTJDLEtBQUtDLElBQUcsR0FBSTFWLElBQUs7QUFDN0UvRCxVQUFNc0IsZUFBU3RCLEdBQUFBLEtBQVEsQ0FBQ1AsTUFBTU8sR0FBQUEsSUFBT0EsTUFBTSxDQUFDdVcsUUFBUW1ELE1BQU1GLEtBQUtDLElBQUcsR0FBSTFWLElBQUFBLElBQVE7QUFHOUUsU0FBS25DLE1BQU0xQixLQUFLMEIsSUFBSUEsS0FBSzVCLE1BQU0sQ0FBQTtBQUMvQixTQUFLQSxNQUFNRSxLQUFLRixJQUFJNEIsTUFBTSxHQUFHNUIsR0FBQUE7RUFDL0I7RUFLQXNaLGtCQUFrQjtBQUNoQixVQUFNSyxNQUFNLEtBQUtDLG1CQUFrQjtBQUNuQyxRQUFJaFksTUFBTW9FLE9BQU9pQjtBQUNqQixRQUFJakgsTUFBTWdHLE9BQU82VDtBQUVqQixRQUFJRixJQUFJcFosUUFBUTtBQUNkcUIsWUFBTStYLElBQUksQ0FBRTtBQUNaM1osWUFBTTJaLElBQUlBLElBQUlwWixTQUFTLENBQUU7O0FBRTNCLFdBQU87TUFBQ3FCO01BQUs1QjtJQUFHO0VBQ2xCO0VBS0FnQyxhQUFhO0FBQ1gsVUFBTUYsVUFBVSxLQUFLQTtBQUNyQixVQUFNZ1ksV0FBV2hZLFFBQVEyVjtBQUN6QixVQUFNOVEsV0FBVzdFLFFBQVFJO0FBQ3pCLFVBQU13VixhQUFhL1EsU0FBUzRTLFdBQVcsV0FBVyxLQUFLSyxtQkFBa0IsSUFBSyxLQUFLRyxVQUFTO0FBRTVGLFFBQUlqWSxRQUFRQyxXQUFXLFdBQVcyVixXQUFXblgsUUFBUTtBQUNuRCxXQUFLcUIsTUFBTSxLQUFLaUksWUFBWTZOLFdBQVcsQ0FBRTtBQUN6QyxXQUFLMVgsTUFBTSxLQUFLOEosWUFBWTROLFdBQVdBLFdBQVduWCxTQUFTLENBQUU7O0FBRy9ELFVBQU1xQixNQUFNLEtBQUtBO0FBQ2pCLFVBQU01QixNQUFNLEtBQUtBO0FBRWpCLFVBQU1rQyxRQUFROFgsZUFBZXRDLFlBQVk5VixLQUFLNUIsR0FBQUE7QUFLOUMsU0FBS3dZLFFBQVFzQixTQUFTL1YsU0FBUzRDLFNBQVNzVCxXQUNwQ25ELDBCQUEwQmdELFNBQVMvQyxTQUFTLEtBQUtuVixLQUFLLEtBQUs1QixLQUFLLEtBQUtrYSxrQkFBa0J0WSxHQUN2RndWLENBQUFBLElBQUFBLDJCQUEyQixNQUFNbFYsTUFBTTNCLFFBQVF1WixTQUFTL0MsU0FBUyxLQUFLblYsS0FBSyxLQUFLNUIsR0FBRztBQUN2RixTQUFLeVksYUFBYSxDQUFDOVIsU0FBUzJDLE1BQU1XLFdBQVcsS0FBS3VPLFVBQVUsU0FBUzNYLFNBQ2pFMFcsbUJBQW1CLEtBQUtpQixLQUFLO0FBQ2pDLFNBQUsyQixZQUFZekMsVUFBQUE7QUFFakIsUUFBSTVWLFFBQVF5RixTQUFTO0FBQ25CckYsWUFBTXFGLFFBQU87O0FBR2YsV0FBTzJRLG9CQUFvQixNQUFNaFcsT0FBTyxLQUFLdVcsVUFBVTtFQUN6RDtFQUVBMkIsZ0JBQWdCO0FBR2QsUUFBSSxLQUFLdFksUUFBUXVZLHFCQUFxQjtBQUNwQyxXQUFLRixZQUFZLEtBQUtqWSxNQUFNa1EsSUFBSStCLENBQUFBLFNBQVEsQ0FBQ0EsS0FBSzlULEtBQUssQ0FBQTs7RUFFdkQ7RUFVQThaLFlBQVl6QyxhQUFhLENBQUEsR0FBSTtBQUMzQixRQUFJN1IsUUFBUTtBQUNaLFFBQUlDLE1BQU07QUFDVixRQUFJbkcsT0FBT0U7QUFFWCxRQUFJLEtBQUtpQyxRQUFRRyxVQUFVeVYsV0FBV25YLFFBQVE7QUFDNUNaLGNBQVEsS0FBSzJhLG1CQUFtQjVDLFdBQVcsQ0FBRSxDQUFBO0FBQzdDLFVBQUlBLFdBQVduWCxXQUFXLEdBQUc7QUFDM0JzRixnQkFBUSxJQUFJbEc7YUFDUDtBQUNMa0csaUJBQVMsS0FBS3lVLG1CQUFtQjVDLFdBQVcsQ0FBQSxDQUFFLElBQUkvWCxTQUFTOztBQUU3REUsYUFBTyxLQUFLeWEsbUJBQW1CNUMsV0FBV0EsV0FBV25YLFNBQVMsQ0FBRSxDQUFBO0FBQ2hFLFVBQUltWCxXQUFXblgsV0FBVyxHQUFHO0FBQzNCdUYsY0FBTWpHO2FBQ0Q7QUFDTGlHLGVBQU9qRyxPQUFPLEtBQUt5YSxtQkFBbUI1QyxXQUFXQSxXQUFXblgsU0FBUyxDQUFBLENBQUUsS0FBSzs7O0FBR2hGLFVBQU1nYSxRQUFRN0MsV0FBV25YLFNBQVMsSUFBSSxNQUFNO0FBQzVDc0YsWUFBUTVGLFlBQVk0RixPQUFPLEdBQUcwVSxLQUFBQTtBQUM5QnpVLFVBQU03RixZQUFZNkYsS0FBSyxHQUFHeVUsS0FBQUE7QUFFMUIsU0FBSzdCLFdBQVc7TUFBQzdTO01BQU9DO01BQUt2QixRQUFRLEtBQUtzQixRQUFRLElBQUlDO0lBQUk7RUFDNUQ7RUFTQWlVLFlBQVk7QUFDVixVQUFNeEQsVUFBVSxLQUFLQztBQUNyQixVQUFNNVUsTUFBTSxLQUFLQTtBQUNqQixVQUFNNUIsTUFBTSxLQUFLQTtBQUNqQixVQUFNOEIsVUFBVSxLQUFLQTtBQUNyQixVQUFNZ1ksV0FBV2hZLFFBQVEyVjtBQUV6QixVQUFNK0MsUUFBUVYsU0FBUy9WLFFBQVErUywwQkFBMEJnRCxTQUFTL0MsU0FBU25WLEtBQUs1QixLQUFLLEtBQUtrYSxrQkFBa0J0WSxHQUFBQSxDQUFBQTtBQUM1RyxVQUFNaUYsV0FBV3RGLGVBQWVPLFFBQVFJLE1BQU0yRSxVQUFVLENBQUE7QUFDeEQsVUFBTTRULFVBQVVELFVBQVUsU0FBU1YsU0FBU3BELGFBQWE7QUFDekQsVUFBTWdFLGFBQWE5RCxTQUFTNkQsT0FBWUEsS0FBQUEsWUFBWTtBQUNwRCxVQUFNdlksUUFBUSxDQUFBO0FBQ2QsUUFBSXZDLFFBQVFpQztBQUNaLFFBQUk2VixNQUFNOVQ7QUFHVixRQUFJK1csWUFBWTtBQUNkL2EsY0FBUSxDQUFDNFcsUUFBUU0sUUFBUWxYLE9BQU8sV0FBVzhhLE9BQUFBOztBQUk3QzlhLFlBQVEsQ0FBQzRXLFFBQVFNLFFBQVFsWCxPQUFPK2EsYUFBYSxRQUFRRixLQUFLO0FBRzFELFFBQUlqRSxRQUFRZSxLQUFLdFgsS0FBSzRCLEtBQUs0WSxLQUFBQSxJQUFTLE1BQVMzVCxVQUFVO0FBQ3JELFlBQU0sSUFBSThULE1BQU0vWSxNQUFNLFVBQVU1QixNQUFNLHlDQUF5QzZHLFdBQVcsTUFBTTJULEtBQU87O0FBR3pHLFVBQU05QyxhQUFhNVYsUUFBUUksTUFBTXFYLFdBQVcsVUFBVSxLQUFLcUIsa0JBQWlCO0FBQzVFLFNBQUtuRCxPQUFPOVgsT0FBT2dFLFFBQVEsR0FBRzhULE9BQU96WCxLQUFLeVgsT0FBTyxDQUFDbEIsUUFBUTBCLElBQUlSLE1BQU01USxVQUFVMlQsS0FBQUEsR0FBUTdXLFNBQVM7QUFDN0Y2VCxjQUFRdFYsT0FBT3VWLE1BQU1DLFVBQUFBO0lBQ3ZCO0FBRUEsUUFBSUQsU0FBU3pYLE9BQU84QixRQUFRQyxXQUFXLFdBQVc0QixVQUFVLEdBQUc7QUFDN0Q2VCxjQUFRdFYsT0FBT3VWLE1BQU1DLFVBQUFBOztBQUl2QixXQUFPM0wsT0FBT29LLEtBQUtqVSxLQUFPMlksRUFBQUEsS0FBS3pFLE1BQUFBLEVBQVFoRSxJQUFJN0UsQ0FBQUEsT0FBSyxDQUFDQSxFQUFBQTtFQUNuRDtFQU1BbkwsaUJBQWlCL0IsT0FBTztBQUN0QixVQUFNa1csVUFBVSxLQUFLQztBQUNyQixVQUFNc0QsV0FBVyxLQUFLaFksUUFBUTJWO0FBRTlCLFFBQUlxQyxTQUFTZ0IsZUFBZTtBQUMxQixhQUFPdkUsUUFBUTVPLE9BQU90SCxPQUFPeVosU0FBU2dCLGFBQWE7O0FBRXJELFdBQU92RSxRQUFRNU8sT0FBT3RILE9BQU95WixTQUFTYixlQUFlOEIsUUFBUTtFQUMvRDtFQU9BcFQsT0FBT3RILE9BQU9zSCxRQUFRO0FBQ3BCLFVBQU03RixVQUFVLEtBQUtBO0FBQ3JCLFVBQU1vWCxVQUFVcFgsUUFBUTJWLEtBQUt3QjtBQUM3QixVQUFNbFYsT0FBTyxLQUFLeVU7QUFDbEIsVUFBTXdDLE1BQU1yVCxVQUFVdVIsUUFBUW5WLElBQUs7QUFDbkMsV0FBTyxLQUFLeVMsU0FBUzdPLE9BQU90SCxPQUFPMmEsR0FBQUE7RUFDckM7RUFXQUMsb0JBQW9CeEQsTUFBTXJZLE9BQU84QyxPQUFPeUYsUUFBUTtBQUM5QyxVQUFNN0YsVUFBVSxLQUFLQTtBQUNyQixVQUFNb1osWUFBWXBaLFFBQVFJLE1BQU1rQjtBQUVoQyxRQUFJOFgsV0FBVztBQUNiLGFBQU83WSxTQUFLNlksV0FBVztRQUFDekQ7UUFBTXJZO1FBQU84QztNQUFNLEdBQUUsSUFBSTs7QUFHbkQsVUFBTWdYLFVBQVVwWCxRQUFRMlYsS0FBS3dCO0FBQzdCLFVBQU1sVixPQUFPLEtBQUt5VTtBQUNsQixVQUFNUixZQUFZLEtBQUtTO0FBQ3ZCLFVBQU0wQyxjQUFjcFgsUUFBUW1WLFFBQVFuVixJQUFLO0FBQ3pDLFVBQU1xWCxjQUFjcEQsYUFBYWtCLFFBQVFsQixTQUFVO0FBQ25ELFVBQU03RCxPQUFPalMsTUFBTTlDLEtBQU07QUFDekIsVUFBTWtLLFFBQVEwTyxhQUFhb0QsZUFBZWpILFFBQVFBLEtBQUs3SztBQUV2RCxXQUFPLEtBQUtrTixTQUFTN08sT0FBTzhQLE1BQU05UCxXQUFXMkIsUUFBUThSLGNBQWNELFlBQVU7RUFDL0U7RUFLQWhKLG1CQUFtQmpRLE9BQU87QUFDeEIsUUFBSXVLLElBQUd3SyxNQUFNOUM7QUFFYixTQUFLMUgsS0FBSSxHQUFHd0ssT0FBTy9VLE1BQU0zQixRQUFRa00sS0FBSXdLLE1BQU0sRUFBRXhLLElBQUc7QUFDOUMwSCxhQUFPalMsTUFBTXVLLEVBQUU7QUFDZjBILFdBQUszVSxRQUFRLEtBQUt5YixvQkFBb0I5RyxLQUFLOVQsT0FBT29NLElBQUd2SyxLQUFBQTtJQUN2RDtFQUNGO0VBTUFvWSxtQkFBbUJqYSxPQUFPO0FBQ3hCLFdBQU9BLFVBQVUsT0FBT3FDLE9BQU9yQyxRQUFRLEtBQUt1QixRQUFRLEtBQUs1QixNQUFNLEtBQUs0QjtFQUN0RTtFQU1BYSxpQkFBaUJwQyxPQUFPO0FBQ3RCLFVBQU1nYixVQUFVLEtBQUszQztBQUNyQixVQUFNeE4sTUFBTSxLQUFLb1AsbUJBQW1CamEsS0FBQUE7QUFDcEMsV0FBTyxLQUFLc0Msb0JBQW9CMFksUUFBUXhWLFFBQVFxRixPQUFPbVEsUUFBUTlXLE1BQU07RUFDdkU7RUFNQTFCLGlCQUFpQkMsT0FBTztBQUN0QixVQUFNdVksVUFBVSxLQUFLM0M7QUFDckIsVUFBTXhOLE1BQU0sS0FBS25JLG1CQUFtQkQsS0FBQUEsSUFBU3VZLFFBQVE5VyxTQUFTOFcsUUFBUXZWO0FBQ3RFLFdBQU8sS0FBS2xFLE1BQU1zSixPQUFPLEtBQUtsTCxNQUFNLEtBQUs0QjtFQUMzQztFQU9BMFosY0FBYzliLE9BQU87QUFDbkIsVUFBTStiLFlBQVksS0FBS3paLFFBQVFJO0FBQy9CLFVBQU1zWixpQkFBaUIsS0FBSzlRLElBQUltSyxZQUFZclYsS0FBQUEsRUFBT3FJO0FBQ25ELFVBQU1vRCxRQUFRekYsVUFBVSxLQUFLakQsYUFBWSxJQUFLZ1osVUFBVUUsY0FBY0YsVUFBVWpXLFdBQVc7QUFDM0YsVUFBTW9XLGNBQWN4YixLQUFLeUYsSUFBSXNGLEtBQUFBO0FBQzdCLFVBQU0wUSxjQUFjemIsS0FBS3dGLElBQUl1RixLQUFBQTtBQUM3QixVQUFNMlEsZUFBZSxLQUFLNVQsd0JBQXdCLENBQUEsRUFBR3dDO0FBRXJELFdBQU87TUFDTEksR0FBSTRRLGlCQUFpQkUsY0FBZ0JFLGVBQWVEO01BQ3BENVEsR0FBSXlRLGlCQUFpQkcsY0FBZ0JDLGVBQWVGO0lBQ3REO0VBQ0Y7RUFPQXhCLGtCQUFrQjJCLGFBQWE7QUFDN0IsVUFBTS9CLFdBQVcsS0FBS2hZLFFBQVEyVjtBQUM5QixVQUFNd0IsaUJBQWlCYSxTQUFTYjtBQUdoQyxVQUFNdFIsU0FBU3NSLGVBQWVhLFNBQVMvVixJQUFJLEtBQUtrVixlQUFlekQ7QUFDL0QsVUFBTXNHLGVBQWUsS0FBS2Isb0JBQW9CWSxhQUFhLEdBQUczRCxvQkFBb0IsTUFBTTtNQUFDMkQ7T0FBYyxLQUFLcEQsVUFBVSxHQUFHOVEsTUFBQUE7QUFDekgsVUFBTTZDLE9BQU8sS0FBSzhRLGNBQWNRLFlBQUFBO0FBR2hDLFVBQU05RSxXQUFXOVcsS0FBSzBFLE1BQU0sS0FBS3JDLGFBQVksSUFBSyxLQUFLc0YsUUFBUTJDLEtBQUtJLElBQUksS0FBSzlDLFNBQVMwQyxLQUFLTyxDQUFDLElBQUk7QUFDaEcsV0FBT2lNLFdBQVcsSUFBSUEsV0FBVztFQUNuQztFQUtBNEQsb0JBQW9CO0FBQ2xCLFFBQUlsRCxhQUFhLEtBQUtXLE9BQU9DLFFBQVEsQ0FBQTtBQUNyQyxRQUFJN0wsSUFBR3dLO0FBRVAsUUFBSVMsV0FBV25YLFFBQVE7QUFDckIsYUFBT21YOztBQUdULFVBQU1xRSxRQUFRLEtBQUtDLHdCQUF1QjtBQUUxQyxRQUFJLEtBQUtyRCxlQUFlb0QsTUFBTXhiLFFBQVE7QUFDcEMsYUFBUSxLQUFLOFgsT0FBT0MsT0FBT3lELE1BQU0sQ0FBQSxFQUFHRSxXQUFXQyxtQkFBbUIsSUFBSTs7QUFHeEUsU0FBS3pQLEtBQUksR0FBR3dLLE9BQU84RSxNQUFNeGIsUUFBUWtNLEtBQUl3SyxNQUFNLEVBQUV4SyxJQUFHO0FBQzlDaUwsbUJBQWFBLFdBQVd5RSxPQUFPSixNQUFNdFAsRUFBRSxFQUFDd1AsV0FBV0MsbUJBQW1CLElBQUksQ0FBQTtJQUM1RTtBQUVBLFdBQVEsS0FBSzdELE9BQU9DLE9BQU8sS0FBSzhELFVBQVUxRSxVQUFBQTtFQUM1QztFQUtBa0MscUJBQXFCO0FBQ25CLFVBQU1sQyxhQUFhLEtBQUtXLE9BQU9uWixVQUFVLENBQUE7QUFDekMsUUFBSXVOLElBQUd3SztBQUVQLFFBQUlTLFdBQVduWCxRQUFRO0FBQ3JCLGFBQU9tWDs7QUFHVCxVQUFNeFksU0FBUyxLQUFLb0IsVUFBUztBQUM3QixTQUFLbU0sS0FBSSxHQUFHd0ssT0FBTy9YLE9BQU9xQixRQUFRa00sS0FBSXdLLE1BQU0sRUFBRXhLLElBQUc7QUFDL0NpTCxpQkFBV3BZLEtBQUs4QixPQUFNLE1BQU1sQyxPQUFPdU4sRUFBRSxDQUFBLENBQUE7SUFDdkM7QUFFQSxXQUFRLEtBQUs0TCxPQUFPblosU0FBUyxLQUFLeVosY0FBY2pCLGFBQWEsS0FBSzBFLFVBQVUxRSxVQUFXO0VBQ3pGO0VBTUEwRSxVQUFVM00sUUFBUTtBQUVoQixXQUFPNE0sYUFBYTVNLE9BQU9vTCxLQUFLekUsTUFBQUEsQ0FBQUE7RUFDbEM7QUFDRjtBQTFkRSxjQUZtQitCLFdBRVpqVixNQUFLO0FBS1osY0FQbUJpVixXQU9aaFYsWUFBVztFQVFoQnBCLFFBQVE7RUFFUjhXLFVBQVUsQ0FBQTtFQUNWcEIsTUFBTTtJQUNKaEIsUUFBUTtJQUNSMVMsTUFBTTtJQUNONUQsT0FBTztJQUNQdVcsWUFBWTtJQUNaSyxTQUFTO0lBQ1RrQyxnQkFBZ0IsQ0FBQTtFQUNsQjtFQUNBL1csT0FBTztJQVNMcVgsUUFBUTtJQUVSblcsVUFBVTtJQUVWa0csT0FBTztNQUNMVyxTQUFTO0lBQ1g7RUFDRjs7QUNyT0osU0FBU3FTLGFBQVlDLE9BQU9DLEtBQUtqVixTQUFTO0FBQ3hDLE1BQUlvUSxLQUFLO0FBQ1QsTUFBSUMsS0FBSzJFLE1BQU1oYyxTQUFTO0FBQ3hCLE1BQUlrYyxZQUFZQyxZQUFZQyxZQUFZQztBQUN4QyxNQUFJclYsU0FBUztBQUNYLFFBQUlpVixPQUFPRCxNQUFNNUUsRUFBQUEsRUFBSXpNLE9BQU9zUixPQUFPRCxNQUFNM0UsRUFBRyxFQUFDMU0sS0FBSztBQUMvQyxPQUFBLEVBQUN5TSxJQUFJQyxHQUFBQSxJQUFNaUYsYUFBYU4sT0FBTyxPQUFPQyxHQUFHOztBQUUzQyxLQUFBLEVBQUN0UixLQUFLdVIsWUFBWWhGLE1BQU1rRixXQUFVLElBQUlKLE1BQU01RSxFQUFBQTtBQUM1QyxLQUFBLEVBQUN6TSxLQUFLd1IsWUFBWWpGLE1BQU1tRixXQUFVLElBQUlMLE1BQU0zRSxFQUFBQTtTQUN4QztBQUNMLFFBQUk0RSxPQUFPRCxNQUFNNUUsRUFBQUEsRUFBSUYsUUFBUStFLE9BQU9ELE1BQU0zRSxFQUFHLEVBQUNILE1BQU07QUFDakQsT0FBQSxFQUFDRSxJQUFJQyxHQUFBQSxJQUFNaUYsYUFBYU4sT0FBTyxRQUFRQyxHQUFHOztBQUU1QyxLQUFBLEVBQUMvRSxNQUFNZ0YsWUFBWXZSLEtBQUt5UixXQUFVLElBQUlKLE1BQU01RSxFQUFBQTtBQUM1QyxLQUFBLEVBQUNGLE1BQU1pRixZQUFZeFIsS0FBSzBSLFdBQVUsSUFBSUwsTUFBTTNFLEVBQUFBOztBQUcvQyxRQUFNa0YsT0FBT0osYUFBYUQ7QUFDMUIsU0FBT0ssT0FBT0gsY0FBY0MsYUFBYUQsZUFBZUgsTUFBTUMsY0FBY0ssT0FBT0g7QUFDckY7QUFFQSxJQUFNSSxrQkFBTixjQUE4QjVFLFVBQUFBO0VBWTVCelgsWUFBWTBYLE9BQU87QUFDakIsVUFBTUEsS0FBQUE7QUFHTixTQUFLNEUsU0FBUyxDQUFBO0FBRWQsU0FBS0MsVUFBVXBjO0FBRWYsU0FBS3FjLGNBQWNyYztFQUNyQjtFQUtBc1osY0FBYztBQUNaLFVBQU16QyxhQUFhLEtBQUt5Rix1QkFBc0I7QUFDOUMsVUFBTVosUUFBUSxLQUFLUyxTQUFTLEtBQUtJLGlCQUFpQjFGLFVBQUFBO0FBQ2xELFNBQUt1RixVQUFVWCxhQUFZQyxPQUFPLEtBQUszYSxHQUFHO0FBQzFDLFNBQUtzYixjQUFjWixhQUFZQyxPQUFPLEtBQUt2YyxHQUFHLElBQUksS0FBS2lkO0FBQ3ZELFVBQU05QyxZQUFZekMsVUFBQUE7RUFDcEI7RUFhQTBGLGlCQUFpQjFGLFlBQVk7QUFDM0IsVUFBTSxFQUFDOVYsS0FBSzVCLElBQUcsSUFBSTtBQUNuQixVQUFNOE8sUUFBUSxDQUFBO0FBQ2QsVUFBTXlOLFFBQVEsQ0FBQTtBQUNkLFFBQUk5UCxJQUFHd0ssTUFBTW9HLE1BQU1DLE1BQU1DO0FBRXpCLFNBQUs5USxLQUFJLEdBQUd3SyxPQUFPUyxXQUFXblgsUUFBUWtNLEtBQUl3SyxNQUFNLEVBQUV4SyxJQUFHO0FBQ25ENlEsYUFBTzVGLFdBQVdqTCxFQUFFO0FBQ3BCLFVBQUk2USxRQUFRMWIsT0FBTzBiLFFBQVF0ZCxLQUFLO0FBQzlCOE8sY0FBTXhQLEtBQUtnZSxJQUFBQTs7SUFFZjtBQUVBLFFBQUl4TyxNQUFNdk8sU0FBUyxHQUFHO0FBRXBCLGFBQU87UUFDTDtVQUFDa1gsTUFBTTdWO1VBQUtzSixLQUFLO1FBQUM7UUFDbEI7VUFBQ3VNLE1BQU16WDtVQUFLa0wsS0FBSztRQUFDO01BQ25COztBQUdILFNBQUt1QixLQUFJLEdBQUd3SyxPQUFPbkksTUFBTXZPLFFBQVFrTSxLQUFJd0ssTUFBTSxFQUFFeEssSUFBRztBQUM5QzhRLGFBQU96TyxNQUFNckMsS0FBSSxDQUFFO0FBQ25CNFEsYUFBT3ZPLE1BQU1yQyxLQUFJLENBQUU7QUFDbkI2USxhQUFPeE8sTUFBTXJDLEVBQUU7QUFHZixVQUFJdk0sS0FBS0MsT0FBT29kLE9BQU9GLFFBQVEsQ0FBQSxNQUFPQyxNQUFNO0FBQzFDZixjQUFNamQsS0FBSztVQUFDbVksTUFBTTZGO1VBQU1wUyxLQUFLdUIsTUFBS3dLLE9BQU87UUFBRSxDQUFBOztJQUUvQztBQUNBLFdBQU9zRjtFQUNUO0VBUUF4QyxZQUFZO0FBQ1YsVUFBTW5ZLE1BQU0sS0FBS0E7QUFDakIsVUFBTTVCLE1BQU0sS0FBS0E7QUFDakIsUUFBSTBYLGFBQWEsTUFBTWtELGtCQUFpQjtBQUN4QyxRQUFJLENBQUNsRCxXQUFXOEYsU0FBUzViLEdBQUFBLEtBQVEsQ0FBQzhWLFdBQVduWCxRQUFRO0FBQ25EbVgsaUJBQVd2VyxPQUFPLEdBQUcsR0FBR1MsR0FBQUE7O0FBRTFCLFFBQUksQ0FBQzhWLFdBQVc4RixTQUFTeGQsR0FBQUEsS0FBUTBYLFdBQVduWCxXQUFXLEdBQUc7QUFDeERtWCxpQkFBV3BZLEtBQUtVLEdBQUFBOztBQUVsQixXQUFPMFgsV0FBV21ELEtBQUssQ0FBQ3hFLElBQUd4SyxPQUFNd0ssS0FBSXhLLEVBQUFBO0VBQ3ZDO0VBT0FzUix5QkFBeUI7QUFDdkIsUUFBSXpGLGFBQWEsS0FBS1csT0FBT0UsT0FBTyxDQUFBO0FBRXBDLFFBQUliLFdBQVduWCxRQUFRO0FBQ3JCLGFBQU9tWDs7QUFHVCxVQUFNWSxPQUFPLEtBQUtzQyxrQkFBaUI7QUFDbkMsVUFBTXBiLFFBQVEsS0FBS29hLG1CQUFrQjtBQUNyQyxRQUFJdEIsS0FBSy9YLFVBQVVmLE1BQU1lLFFBQVE7QUFHL0JtWCxtQkFBYSxLQUFLMEUsVUFBVTlELEtBQUs2RCxPQUFPM2MsS0FBQUEsQ0FBQUE7V0FDbkM7QUFDTGtZLG1CQUFhWSxLQUFLL1gsU0FBUytYLE9BQU85WTs7QUFFcENrWSxpQkFBYSxLQUFLVyxPQUFPRSxNQUFNYjtBQUUvQixXQUFPQTtFQUNUO0VBTUE0QyxtQkFBbUJqYSxPQUFPO0FBQ3hCLFlBQVFpYyxhQUFZLEtBQUtVLFFBQVEzYyxLQUFTLElBQUEsS0FBSzRjLFdBQVcsS0FBS0M7RUFDakU7RUFNQXJhLGlCQUFpQkMsT0FBTztBQUN0QixVQUFNdVksVUFBVSxLQUFLM0M7QUFDckIsVUFBTTNPLFVBQVUsS0FBS2hILG1CQUFtQkQsS0FBQUEsSUFBU3VZLFFBQVE5VyxTQUFTOFcsUUFBUXZWO0FBQzFFLFdBQU93VyxhQUFZLEtBQUtVLFFBQVFqVCxVQUFVLEtBQUttVCxjQUFjLEtBQUtELFNBQVMsSUFBSTtFQUNqRjtBQUNGO0FBM0lFLGNBRklGLGlCQUVHN1osTUFBSztBQUtaLGNBUEk2WixpQkFPRzVaLFlBQVdnVixVQUFVaFY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJRXlCN0JzYTtBQUFBQSxFQU5ELFNBQVlBLElBQUFBO0FBQ1ZBLEVBQUFBLEdBQUFBLEdBQUEsT0FBQSxDQUFBLElBQUEsUUFDQUEsR0FBQUEsR0FBQSxVQUFBLENBQUEsSUFBQSxXQUNBQSxHQUFBQSxHQUFBLFNBQUEsQ0FBQSxJQUFBLFVBQ0FBLEdBQUFBLEdBQUEsV0FBQSxDQUFBLElBQUEsWUFDQUEsR0FBQUEsR0FBQSxRQUFBLENBQUEsSUFBQTtBQUNELEdBTldBLE1BQUFBLElBTVgsQ0FBQSxFQUFBO0FDakVELElBQUlDO0FBQUosSUFBTUM7QUFBTixJQUFRQztBQUFSLElBQVVDO0FBQVYsSUFBWUM7QUFBWixJQUFjQztBQUFkLElBQWdCQztBQUFoQixJQUFrQkMsSUFBRSxDQUFFO0FBQXRCLElBQXVCQyxJQUFFLENBQUE7QUFBekIsSUFBNEJDLElBQUU7QUFBb0UsU0FBU0MsRUFBRVYsSUFBRUMsSUFBQUE7QUFBRyxXQUFRQyxNQUFLRCxHQUFFRCxDQUFBQSxHQUFFRSxFQUFBQSxJQUFHRCxHQUFFQyxFQUFBQTtBQUFHLFNBQU9GO0FBQUM7QUFBQyxTQUFTVyxFQUFFWCxJQUFBQTtBQUFHLE1BQUlDLEtBQUVELEdBQUVZO0FBQVdYLEVBQUFBLE1BQUdBLEdBQUVZLFlBQVliLEVBQUFBO0FBQUU7QUFBQyxTQUFTYyxFQUFFYixJQUFFQyxJQUFFQyxJQUFBQTtBQUFHLE1BQUlDLElBQUVDLElBQUVDLElBQUVDLEtBQUUsQ0FBRTtBQUFDLE9BQUlELE1BQUtKLEdBQUUsVUFBT0ksS0FBRUYsS0FBRUYsR0FBRUksRUFBQUEsSUFBRyxTQUFPQSxLQUFFRCxLQUFFSCxHQUFFSSxFQUFBQSxJQUFHQyxHQUFFRCxFQUFBQSxJQUFHSixHQUFFSSxFQUFBQTtBQUFHLE1BQUdTLFVBQVVDLFNBQU8sTUFBSVQsR0FBRVUsV0FBU0YsVUFBVUMsU0FBTyxJQUFFaEIsRUFBRWtCLEtBQUtILFdBQVUsQ0FBQSxJQUFHWixLQUFHLGNBQUEsT0FBbUJGLE1BQUcsUUFBTUEsR0FBRWtCLGFBQWEsTUFBSWIsTUFBS0wsR0FBRWtCLGFBQUFBLFlBQXNCWixHQUFFRCxFQUFBQSxNQUFLQyxHQUFFRCxFQUFBQSxJQUFHTCxHQUFFa0IsYUFBYWIsRUFBQUE7QUFBSSxTQUFPYyxFQUFFbkIsSUFBRU0sSUFBRUgsSUFBRUMsSUFBRSxJQUFBO0FBQUs7QUFBQyxTQUFTZSxFQUFFcEIsSUFBRUcsSUFBRUMsSUFBRUMsSUFBRUMsSUFBQUE7QUFBRyxNQUFJQyxLQUFFLEVBQUNjLE1BQUtyQixJQUFFc0IsT0FBTW5CLElBQUVvQixLQUFJbkIsSUFBRW9CLEtBQUluQixJQUFFb0IsS0FBSSxNQUFLQyxJQUFHLE1BQUtDLEtBQUksR0FBRUMsS0FBSSxNQUFLQyxLQUFBQSxRQUFXQyxLQUFJLE1BQUtDLEtBQUksTUFBS0MsYUFBQUEsUUFBbUJDLEtBQUksUUFBTTNCLEtBQUFBLEVBQUlKLElBQUVJLEdBQUFBO0FBQUcsU0FBTyxRQUFNQSxNQUFHLFFBQU1MLEVBQUVpQyxTQUFPakMsRUFBRWlDLE1BQU0zQixFQUFBQSxHQUFHQTtBQUFDO0FBQW1DLFNBQVM0QixFQUFFQyxJQUFBQTtBQUFHLFNBQU9BLEdBQUVDO0FBQVE7QUFBQyxTQUFTQyxFQUFFRixJQUFFRyxJQUFBQTtBQUFHQyxPQUFLQyxRQUFNTCxJQUFFSSxLQUFLRSxVQUFRSDtBQUFDO0FBQUMsU0FBU0ksRUFBRVAsSUFBRUcsSUFBQUE7QUFBRyxNQUFHLFFBQU1BLEdBQUUsUUFBT0gsR0FBRVEsS0FBR0QsRUFBRVAsR0FBRVEsSUFBR1IsR0FBRVEsR0FBR0MsSUFBSUMsUUFBUVYsRUFBQUEsSUFBRyxDQUFBLElBQUc7QUFBSyxXQUFRVyxJQUFFUixLQUFFSCxHQUFFUyxJQUFJRyxRQUFPVCxLQUFJLEtBQUcsU0FBT1EsS0FBRVgsR0FBRVMsSUFBSU4sRUFBQUEsTUFBSyxRQUFNUSxHQUFFRSxJQUFJLFFBQU9GLEdBQUVFO0FBQUksU0FBTSxjQUFBLE9BQW1CYixHQUFFYyxPQUFLUCxFQUFFUCxFQUFBQSxJQUFHO0FBQUk7QUFBQyxTQUFTZSxFQUFFZixJQUFBQTtBQUFHLE1BQUlHLElBQUVRO0FBQUUsTUFBRyxTQUFPWCxLQUFFQSxHQUFFUSxPQUFLLFFBQU1SLEdBQUVnQixLQUFJO0FBQUMsU0FBSWhCLEdBQUVhLE1BQUliLEdBQUVnQixJQUFJQyxPQUFLLE1BQUtkLEtBQUUsR0FBRUEsS0FBRUgsR0FBRVMsSUFBSUcsUUFBT1QsS0FBSSxLQUFHLFNBQU9RLEtBQUVYLEdBQUVTLElBQUlOLEVBQUFBLE1BQUssUUFBTVEsR0FBRUUsS0FBSTtBQUFDYixNQUFBQSxHQUFFYSxNQUFJYixHQUFFZ0IsSUFBSUMsT0FBS04sR0FBRUU7QUFBSTtJQUFLO0FBQUMsV0FBT0UsRUFBRWYsRUFBQUE7RUFBRTtBQUFDO0FBQUMsU0FBU2tCLEVBQUVsQixJQUFBQTtBQUFBQSxHQUFBQSxDQUFLQSxHQUFFbUIsUUFBTW5CLEdBQUVtQixNQUFBQSxTQUFTQyxFQUFFQyxLQUFLckIsRUFBQUEsS0FBQUEsQ0FBS3NCLEVBQUVDLFNBQU9DLE1BQUlyQixFQUFFc0Isd0JBQXNCRCxJQUFFckIsRUFBRXNCLHNCQUFvQkMsWUFBWUosQ0FBQUE7QUFBRTtBQUFDLFNBQVNBLElBQUFBO0FBQUksV0FBUXRCLElBQUVzQixFQUFFQyxNQUFJSCxFQUFFUixTQUFRWixDQUFBQSxLQUFFb0IsRUFBRU8sS0FBSyxTQUFTM0IsSUFBRUcsSUFBQUE7QUFBRyxXQUFPSCxHQUFFNEIsSUFBSUMsTUFBSTFCLEdBQUV5QixJQUFJQztFQUFHLENBQUEsR0FBR1QsSUFBRSxDQUFBLEdBQUdwQixHQUFFOEIsS0FBSyxTQUFTOUIsSUFBQUE7QUFBRyxRQUFJRyxJQUFFUSxJQUFFb0IsSUFBRVgsSUFBRUksSUFBRVE7QUFBRWhDLElBQUFBLEdBQUVtQixRQUFNSyxNQUFHSixNQUFHakIsS0FBRUgsSUFBRzRCLEtBQUtmLE1BQUttQixLQUFFN0IsR0FBRThCLFNBQU90QixLQUFFLENBQUEsSUFBSW9CLEtBQUVHLEVBQUUsQ0FBQSxHQUFHZCxFQUFBQSxHQUFJUSxNQUFJUixHQUFFUSxNQUFJLEdBQUVPLEVBQUVILElBQUVaLElBQUVXLElBQUU1QixHQUFFaUMsS0FBQUEsV0FBYUosR0FBRUssaUJBQWdCLFFBQU1qQixHQUFFa0IsTUFBSSxDQUFDZCxFQUFBQSxJQUFHLE1BQUtiLElBQUUsUUFBTWEsS0FBRWpCLEVBQUVhLEVBQUFBLElBQUdJLElBQUVKLEdBQUVrQixHQUFBQSxHQUFLQyxFQUFFNUIsSUFBRVMsRUFBQUEsR0FBR0EsR0FBRVAsT0FBS1csTUFBR1QsRUFBRUssRUFBQUE7RUFBSSxDQUFBO0FBQUU7QUFBQyxTQUFTb0IsRUFBRXhDLElBQUVHLElBQUVRLElBQUVvQixJQUFFWCxJQUFFSSxJQUFFUSxJQUFFUyxJQUFFUCxJQUFFUSxJQUFBQTtBQUFHLE1BQUlDLElBQUVDLElBQUUxQyxJQUFFYSxJQUFFRyxJQUFFSSxJQUFFa0IsSUFBRUssS0FBRWQsTUFBR0EsR0FBRXRCLE9BQUtxQyxHQUFFQyxLQUFFRixHQUFFakM7QUFBTyxPQUFJRCxHQUFFRixNQUFJLENBQUEsR0FBR2tDLEtBQUUsR0FBRUEsS0FBRXhDLEdBQUVTLFFBQU8rQixLQUFJLEtBQUcsU0FBTzVCLEtBQUVKLEdBQUVGLElBQUlrQyxFQUFBQSxJQUFHLFNBQU81QixLQUFFWixHQUFFd0MsRUFBQUEsTUFBSyxhQUFBLE9BQWtCNUIsS0FBRSxPQUFLLFlBQUEsT0FBaUJBLE1BQUcsWUFBQSxPQUFpQkEsTUFBRyxZQUFBLE9BQWlCQSxLQUFFaUMsRUFBRSxNQUFLakMsSUFBRSxNQUFLLE1BQUtBLEVBQUFBLElBQUdrQyxNQUFNQyxRQUFRbkMsRUFBQUEsSUFBR2lDLEVBQUVqRCxHQUFFLEVBQUNFLFVBQVNjLEdBQUFBLEdBQUcsTUFBSyxNQUFLLElBQUEsSUFBTUEsR0FBRWMsTUFBSSxJQUFFbUIsRUFBRWpDLEdBQUVELE1BQUtDLEdBQUVWLE9BQU1VLEdBQUVvQyxLQUFJcEMsR0FBRXFDLE1BQUlyQyxHQUFFcUMsTUFBSSxNQUFLckMsR0FBRWEsR0FBQUEsSUFBS2IsS0FBRztBQUFDLFFBQUdBLEdBQUVQLEtBQUdHLElBQUVJLEdBQUVjLE1BQUlsQixHQUFFa0IsTUFBSSxHQUFFLFVBQVEzQixLQUFFMkMsR0FBRUYsRUFBQUEsTUFBS3pDLE1BQUdhLEdBQUVvQyxPQUFLakQsR0FBRWlELE9BQUtwQyxHQUFFRCxTQUFPWixHQUFFWSxLQUFLK0IsQ0FBQUEsR0FBRUYsRUFBQUEsSUFBQUE7UUFBZSxNQUFJQyxLQUFFLEdBQUVBLEtBQUVHLElBQUVILE1BQUk7QUFBQyxXQUFJMUMsS0FBRTJDLEdBQUVELEVBQUFBLE1BQUs3QixHQUFFb0MsT0FBS2pELEdBQUVpRCxPQUFLcEMsR0FBRUQsU0FBT1osR0FBRVksTUFBSztBQUFDK0IsUUFBQUEsR0FBRUQsRUFBQUEsSUFBQUE7QUFBVTtNQUFLO0FBQUMxQyxNQUFBQSxLQUFFO0lBQUk7QUFBQ2lDLE1BQUVuQyxJQUFFZSxJQUFFYixLQUFFQSxNQUFHbUQsR0FBRWpDLElBQUVJLElBQUVRLElBQUVTLElBQUVQLElBQUVRLEVBQUFBLEdBQUd4QixLQUFFSCxHQUFFRixNQUFLK0IsS0FBRTdCLEdBQUVxQyxRQUFNbEQsR0FBRWtELE9BQUtSLE9BQUlKLE9BQUlBLEtBQUUsQ0FBQSxJQUFJdEMsR0FBRWtELE9BQUtaLEdBQUVuQixLQUFLbkIsR0FBRWtELEtBQUksTUFBS3JDLEVBQUFBLEdBQUd5QixHQUFFbkIsS0FBS3VCLElBQUU3QixHQUFFQyxPQUFLRSxJQUFFSCxFQUFBQSxJQUFJLFFBQU1HLE1BQUcsUUFBTUksT0FBSUEsS0FBRUosS0FBRyxjQUFBLE9BQW1CSCxHQUFFRCxRQUFNQyxHQUFFTixRQUFNUCxHQUFFTyxNQUFJTSxHQUFFSSxNQUFJZSxLQUFFb0IsRUFBRXZDLElBQUVtQixJQUFFbEMsRUFBQUEsSUFBR2tDLEtBQUVxQixFQUFFdkQsSUFBRWUsSUFBRWIsSUFBRTJDLElBQUUzQixJQUFFZ0IsRUFBQUEsR0FBRyxjQUFBLE9BQW1CdkIsR0FBRUcsU0FBT0gsR0FBRVEsTUFBSWUsT0FBSUEsTUFBR2hDLEdBQUVXLE9BQUtxQixNQUFHQSxHQUFFc0IsY0FBWXhELE9BQUlrQyxLQUFFM0IsRUFBRUwsRUFBQUE7RUFBRztBQUFDLE9BQUlTLEdBQUVFLE1BQUlTLElBQUVxQixLQUFFSSxJQUFFSixPQUFLLFNBQU1FLEdBQUVGLEVBQUFBLEtBQUljLEVBQUVaLEdBQUVGLEVBQUFBLEdBQUdFLEdBQUVGLEVBQUFBLENBQUFBO0FBQUksTUFBR0gsR0FBRSxNQUFJRyxLQUFFLEdBQUVBLEtBQUVILEdBQUU1QixRQUFPK0IsS0FBSWUsR0FBRWxCLEdBQUVHLEVBQUFBLEdBQUdILEdBQUFBLEVBQUlHLEVBQUFBLEdBQUdILEdBQUFBLEVBQUlHLEVBQUFBLENBQUFBO0FBQUc7QUFBQyxTQUFTVyxFQUFFdEQsSUFBRUcsSUFBRVEsSUFBQUE7QUFBRyxXQUFRb0IsSUFBRVgsS0FBRXBCLEdBQUVTLEtBQUllLEtBQUUsR0FBRUosTUFBR0ksS0FBRUosR0FBRVIsUUFBT1ksS0FBQUEsRUFBS08sS0FBRVgsR0FBRUksRUFBQUEsT0FBTU8sR0FBRXZCLEtBQUdSLElBQUVHLEtBQUUsY0FBQSxPQUFtQjRCLEdBQUVqQixPQUFLd0MsRUFBRXZCLElBQUU1QixJQUFFUSxFQUFBQSxJQUFHNEMsRUFBRTVDLElBQUVvQixJQUFFQSxJQUFFWCxJQUFFVyxHQUFFbEIsS0FBSVYsRUFBQUE7QUFBSSxTQUFPQTtBQUFDO0FBQXlILFNBQVNvRCxFQUFFdkQsSUFBRUcsSUFBRVEsSUFBRW9CLElBQUVYLElBQUVJLElBQUFBO0FBQUcsTUFBSVEsSUFBRXFCLElBQUVQO0FBQUUsTUFBQSxXQUFZM0MsR0FBRWdCLElBQUlhLENBQUFBLEtBQUU3QixHQUFFZ0IsS0FBSWhCLEdBQUVnQixNQUFBQTtXQUFtQixRQUFNUixNQUFHUyxNQUFHSSxNQUFHLFFBQU1KLEdBQUVvQyxXQUFXeEQsR0FBRSxLQUFHLFFBQU13QixNQUFHQSxHQUFFZ0MsZUFBYXhELEdBQUVBLENBQUFBLEdBQUUyRCxZQUFZdkMsRUFBQUEsR0FBR1ksS0FBRTtPQUFTO0FBQUMsU0FBSXFCLEtBQUU3QixJQUFFc0IsS0FBRSxJQUFHTyxLQUFFQSxHQUFFTyxnQkFBY2QsS0FBRWYsR0FBRW5CLFFBQU9rQyxNQUFHLEVBQUUsS0FBR08sTUFBR2pDLEdBQUUsT0FBTXBCO0FBQUVBLElBQUFBLEdBQUU2RCxhQUFhekMsSUFBRUksRUFBQUEsR0FBR1EsS0FBRVI7RUFBQztBQUFDLFNBQUEsV0FBZ0JRLEtBQUVBLEtBQUVaLEdBQUV3QztBQUFXO0FBQTROLFNBQVNFLEVBQUU5RCxJQUFFRyxJQUFFUSxJQUFBQTtBQUFHLFVBQU1SLEdBQUUsQ0FBQSxJQUFHSCxHQUFFK0QsWUFBWTVELElBQUVRLEVBQUFBLElBQUdYLEdBQUVHLEVBQUFBLElBQUcsUUFBTVEsS0FBRSxLQUFHLFlBQUEsT0FBaUJBLE1BQUc4QixFQUFFdUIsS0FBSzdELEVBQUFBLElBQUdRLEtBQUVBLEtBQUU7QUFBSTtBQUFDLFNBQVNzRCxFQUFFakUsSUFBRUcsSUFBRVEsSUFBRW9CLElBQUVYLElBQUFBO0FBQUcsTUFBSUk7QUFBRXhCLElBQUUsS0FBRyxZQUFVRyxHQUFFLEtBQUcsWUFBQSxPQUFpQlEsR0FBRVgsQ0FBQUEsR0FBRWtFLE1BQU1DLFVBQVF4RDtPQUFNO0FBQUMsUUFBRyxZQUFBLE9BQWlCb0IsT0FBSS9CLEdBQUVrRSxNQUFNQyxVQUFRcEMsS0FBRSxLQUFJQSxHQUFFLE1BQUk1QixNQUFLNEIsR0FBRXBCLENBQUFBLE1BQUdSLE1BQUtRLE1BQUdtRCxFQUFFOUQsR0FBRWtFLE9BQU0vRCxJQUFFLEVBQUE7QUFBSSxRQUFHUSxHQUFFLE1BQUlSLE1BQUtRLEdBQUVvQixDQUFBQSxNQUFHcEIsR0FBRVIsRUFBQUEsTUFBSzRCLEdBQUU1QixFQUFBQSxLQUFJMkQsRUFBRTlELEdBQUVrRSxPQUFNL0QsSUFBRVEsR0FBRVIsRUFBQUEsQ0FBQUE7RUFBRztXQUFTLFFBQU1BLEdBQUUsQ0FBQSxLQUFJLFFBQU1BLEdBQUUsQ0FBQSxFQUFHcUIsQ0FBQUEsS0FBRXJCLFFBQUtBLEtBQUVBLEdBQUVpRSxRQUFRLFlBQVcsRUFBQSxJQUFLakUsS0FBRUEsR0FBRWtFLFlBQUFBLEtBQWdCckUsS0FBRUcsR0FBRWtFLFlBQUFBLEVBQWNDLE1BQU0sQ0FBQSxJQUFHbkUsR0FBRW1FLE1BQU0sQ0FBQSxHQUFHdEUsR0FBRUcsTUFBSUgsR0FBRUcsSUFBRSxDQUFFLElBQUVILEdBQUVHLEVBQUVBLEtBQUVxQixFQUFBQSxJQUFHYixJQUFFQSxLQUFFb0IsTUFBRy9CLEdBQUV1RSxpQkFBaUJwRSxJQUFFcUIsS0FBRWdELElBQUVDLEdBQUVqRCxFQUFBQSxJQUFHeEIsR0FBRTBFLG9CQUFvQnZFLElBQUVxQixLQUFFZ0QsSUFBRUMsR0FBRWpELEVBQUFBO1dBQVcsOEJBQTRCckIsSUFBRTtBQUFDLFFBQUdpQixHQUFFakIsQ0FBQUEsS0FBRUEsR0FBRWlFLFFBQVEsZUFBYyxHQUFBLEVBQUtBLFFBQVEsVUFBUyxHQUFBO2FBQWEsV0FBU2pFLE1BQUcsV0FBU0EsTUFBRyxXQUFTQSxNQUFHLGVBQWFBLE1BQUcsZUFBYUEsTUFBR0EsTUFBS0gsR0FBRSxLQUFBO0FBQUlBLE1BQUFBLEdBQUVHLEVBQUFBLElBQUcsUUFBTVEsS0FBRSxLQUFHQTtBQUFFLFlBQU1YO0lBQUFBLFNBQVFBLElBQUFBO0lBQUFBO0FBQUksa0JBQUEsT0FBbUJXLE9BQUksUUFBTUEsTUFBQUEsVUFBUUEsTUFBQUEsTUFBT1IsR0FBRU8sUUFBUSxHQUFBLElBQUtWLEdBQUUyRSxnQkFBZ0J4RSxFQUFBQSxJQUFHSCxHQUFFNEUsYUFBYXpFLElBQUVRLEVBQUFBO0VBQUc7QUFBQztBQUFDLFNBQVM4RCxFQUFFekUsSUFBQUE7QUFBR0ksT0FBS0QsRUFBRUgsR0FBRWMsT0FBQUEsS0FBSyxFQUFJWCxFQUFFMEUsUUFBTTFFLEVBQUUwRSxNQUFNN0UsRUFBQUEsSUFBR0EsRUFBQUE7QUFBRTtBQUFDLFNBQVN3RSxFQUFFeEUsSUFBQUE7QUFBR0ksT0FBS0QsRUFBRUgsR0FBRWMsT0FBQUEsSUFBSyxFQUFJWCxFQUFFMEUsUUFBTTFFLEVBQUUwRSxNQUFNN0UsRUFBQUEsSUFBR0EsRUFBQUE7QUFBRTtBQUFDLFNBQVNtQyxFQUFFbkMsSUFBRVcsSUFBRW9CLElBQUVYLElBQUVJLElBQUVRLElBQUVxQixJQUFFUCxJQUFFTCxJQUFBQTtBQUFHLE1BQUlDLElBQUVDLElBQUVLLElBQUVKLElBQUVyQyxJQUFFUSxJQUFFRyxJQUFFSSxJQUFFZ0MsSUFBRVQsSUFBRVUsSUFBRVIsSUFBRWUsR0FBRUcsSUFBRVEsSUFBRUQsS0FBRTdELEdBQUVHO0FBQUssTUFBQSxXQUFZSCxHQUFFbUUsWUFBWSxRQUFPO0FBQUssVUFBTS9DLEdBQUVPLFFBQU1HLEtBQUVWLEdBQUVPLEtBQUlRLEtBQUVuQyxHQUFFRSxNQUFJa0IsR0FBRWxCLEtBQUlGLEdBQUUyQixNQUFJLE1BQUtOLEtBQUUsQ0FBQ2MsRUFBQUEsS0FBS0osS0FBRXZDLEVBQUUwQixRQUFNYSxHQUFFL0IsRUFBQUE7QUFBRyxNQUFBO0FBQUlYLE1BQUUsS0FBRyxjQUFBLE9BQW1Cd0UsSUFBRTtBQUFDLFVBQUdsRCxLQUFFWCxHQUFFTixPQUFNaUQsTUFBR1osS0FBRThCLEdBQUVPLGdCQUFjM0QsR0FBRXNCLEdBQUUxQixHQUFBQSxHQUFLNkIsS0FBRUgsS0FBRVksS0FBRUEsR0FBRWpELE1BQU0yRSxRQUFNdEMsR0FBRWxDLEtBQUdZLElBQUVXLEdBQUVmLE1BQUlFLE1BQUd5QixLQUFFaEMsR0FBRUssTUFBSWUsR0FBRWYsS0FBS1IsS0FBR21DLEdBQUVzQyxPQUFLLGVBQWNULE1BQUdBLEdBQUVVLFVBQVVDLFNBQU94RSxHQUFFSyxNQUFJMkIsS0FBRSxJQUFJNkIsR0FBRWxELElBQUV1QixFQUFBQSxLQUFJbEMsR0FBRUssTUFBSTJCLEtBQUUsSUFBSXpDLEVBQUVvQixJQUFFdUIsRUFBQUEsR0FBR0YsR0FBRW1DLGNBQVlOLElBQUU3QixHQUFFd0MsU0FBT0MsSUFBRzlCLE1BQUdBLEdBQUUrQixJQUFJMUMsRUFBQUEsR0FBR0EsR0FBRXRDLFFBQU1pQixJQUFFcUIsR0FBRTJDLFVBQVEzQyxHQUFFMkMsUUFBTSxDQUFBLElBQUkzQyxHQUFFckMsVUFBUXVDLElBQUVGLEdBQUVQLE1BQUloQixJQUFFNEIsS0FBRUwsR0FBRXhCLE1BQUFBLE1BQU93QixHQUFFTCxNQUFJLENBQUEsR0FBR0ssR0FBRTRDLE1BQUksQ0FBQSxJQUFJLFFBQU01QyxHQUFFNkMsUUFBTTdDLEdBQUU2QyxNQUFJN0MsR0FBRTJDLFFBQU8sUUFBTWQsR0FBRWlCLDZCQUEyQjlDLEdBQUU2QyxPQUFLN0MsR0FBRTJDLFVBQVEzQyxHQUFFNkMsTUFBSXRELEVBQUUsQ0FBRSxHQUFDUyxHQUFFNkMsR0FBQUEsSUFBTXRELEVBQUVTLEdBQUU2QyxLQUFJaEIsR0FBRWlCLHlCQUF5Qm5FLElBQUVxQixHQUFFNkMsR0FBQUEsQ0FBQUEsSUFBTzVDLEtBQUVELEdBQUV0QyxPQUFNRSxLQUFFb0MsR0FBRTJDLE9BQU10QyxHQUFFLFNBQU13QixHQUFFaUIsNEJBQTBCLFFBQU05QyxHQUFFK0Msc0JBQW9CL0MsR0FBRStDLG1CQUFBQSxHQUFxQixRQUFNL0MsR0FBRWdELHFCQUFtQmhELEdBQUVMLElBQUlqQixLQUFLc0IsR0FBRWdELGlCQUFBQTtXQUF1QjtBQUFDLFlBQUcsUUFBTW5CLEdBQUVpQiw0QkFBMEJuRSxPQUFJc0IsTUFBRyxRQUFNRCxHQUFFaUQsNkJBQTJCakQsR0FBRWlELDBCQUEwQnRFLElBQUV1QixFQUFBQSxHQUFBQSxDQUFJRixHQUFFOUIsT0FBSyxRQUFNOEIsR0FBRWtELHlCQUFBQSxVQUE0QmxELEdBQUVrRCxzQkFBc0J2RSxJQUFFcUIsR0FBRTZDLEtBQUkzQyxFQUFBQSxLQUFJbEMsR0FBRWlCLFFBQU1HLEdBQUVILEtBQUk7QUFBQyxlQUFJZSxHQUFFdEMsUUFBTWlCLElBQUVxQixHQUFFMkMsUUFBTTNDLEdBQUU2QyxLQUFJN0UsR0FBRWlCLFFBQU1HLEdBQUVILFFBQU1lLEdBQUV4QixNQUFBQSxRQUFRd0IsR0FBRWYsTUFBSWpCLElBQUVBLEdBQUVFLE1BQUlrQixHQUFFbEIsS0FBSUYsR0FBRUYsTUFBSXNCLEdBQUV0QixLQUFJRSxHQUFFRixJQUFJcUYsUUFBUSxTQUFTOUYsSUFBQUE7QUFBR0EsWUFBQUEsT0FBSUEsR0FBRVEsS0FBR0c7VUFBRSxDQUFBLEdBQUc0QyxLQUFFLEdBQUVBLEtBQUVaLEdBQUU0QyxJQUFJM0UsUUFBTzJDLEtBQUlaLENBQUFBLEdBQUVMLElBQUlqQixLQUFLc0IsR0FBRTRDLElBQUloQyxFQUFBQSxDQUFBQTtBQUFJWixVQUFBQSxHQUFFNEMsTUFBSSxDQUFBLEdBQUc1QyxHQUFFTCxJQUFJMUIsVUFBUXlDLEdBQUVoQyxLQUFLc0IsRUFBQUE7QUFBRyxnQkFBTTNDO1FBQUM7QUFBQyxnQkFBTTJDLEdBQUVvRCx1QkFBcUJwRCxHQUFFb0Qsb0JBQW9CekUsSUFBRXFCLEdBQUU2QyxLQUFJM0MsRUFBQUEsR0FBRyxRQUFNRixHQUFFcUQsc0JBQW9CckQsR0FBRUwsSUFBSWpCLEtBQUssV0FBQTtBQUFXc0IsVUFBQUEsR0FBRXFELG1CQUFtQnBELElBQUVyQyxJQUFFUSxFQUFBQTtRQUFFLENBQUE7TUFBRTtBQUFDLFVBQUc0QixHQUFFckMsVUFBUXVDLElBQUVGLEdBQUV0QyxRQUFNaUIsSUFBRXFCLEdBQUVmLE1BQUlqQixJQUFFZ0MsR0FBRVYsTUFBSWpDLElBQUUrQyxLQUFFNUMsRUFBRW9CLEtBQUl1QyxJQUFFLEdBQUUsZUFBY1UsTUFBR0EsR0FBRVUsVUFBVUMsUUFBTztBQUFDLGFBQUl4QyxHQUFFMkMsUUFBTTNDLEdBQUU2QyxLQUFJN0MsR0FBRXhCLE1BQUFBLE9BQU80QixNQUFHQSxHQUFFcEMsRUFBQUEsR0FBRytCLEtBQUVDLEdBQUV3QyxPQUFPeEMsR0FBRXRDLE9BQU1zQyxHQUFFMkMsT0FBTTNDLEdBQUVyQyxPQUFBQSxHQUFTMkQsS0FBRSxHQUFFQSxLQUFFdEIsR0FBRTRDLElBQUkzRSxRQUFPcUQsS0FBSXRCLENBQUFBLEdBQUVMLElBQUlqQixLQUFLc0IsR0FBRTRDLElBQUl0QixFQUFBQSxDQUFBQTtBQUFJdEIsUUFBQUEsR0FBRTRDLE1BQUksQ0FBQTtNQUFFLE1BQU0sSUFBQTtBQUFHNUMsUUFBQUEsR0FBRXhCLE1BQUFBLE9BQU80QixNQUFHQSxHQUFFcEMsRUFBQUEsR0FBRytCLEtBQUVDLEdBQUV3QyxPQUFPeEMsR0FBRXRDLE9BQU1zQyxHQUFFMkMsT0FBTTNDLEdBQUVyQyxPQUFBQSxHQUFTcUMsR0FBRTJDLFFBQU0zQyxHQUFFNkM7TUFBQUEsU0FBVTdDLEdBQUV4QixPQUFBQSxFQUFPMkMsSUFBRTtBQUFJbkIsTUFBQUEsR0FBRTJDLFFBQU0zQyxHQUFFNkMsS0FBSSxRQUFNN0MsR0FBRXNELG9CQUFrQjdFLEtBQUVjLEVBQUVBLEVBQUUsQ0FBQSxHQUFHZCxFQUFBQSxHQUFHdUIsR0FBRXNELGdCQUFBQSxDQUFBQSxJQUFvQmpELE1BQUcsUUFBTUwsR0FBRXVELDRCQUEwQm5GLEtBQUU0QixHQUFFdUQsd0JBQXdCdEQsSUFBRXJDLEVBQUFBLElBQUlrRSxLQUFFLFFBQU0vQixNQUFHQSxHQUFFNUIsU0FBT2YsS0FBRyxRQUFNMkMsR0FBRVMsTUFBSVQsR0FBRXJDLE1BQU1KLFdBQVN5QyxJQUFFRixFQUFFeEMsSUFBRWlELE1BQU1DLFFBQVF1QixFQUFBQSxJQUFHQSxLQUFFLENBQUNBLEVBQUFBLEdBQUc5RCxJQUFFb0IsSUFBRVgsSUFBRUksSUFBRVEsSUFBRXFCLElBQUVQLElBQUVMLEVBQUFBLEdBQUdFLEdBQUUxQixPQUFLTixHQUFFRSxLQUFJRixHQUFFMkIsTUFBSSxNQUFLSyxHQUFFTCxJQUFJMUIsVUFBUXlDLEdBQUVoQyxLQUFLc0IsRUFBQUEsR0FBR3pCLE9BQUl5QixHQUFFc0MsTUFBSXRDLEdBQUVuQyxLQUFHLE9BQU1tQyxHQUFFOUIsTUFBQUE7SUFBTSxNQUFNLFNBQU1tQixNQUFHckIsR0FBRWlCLFFBQU1HLEdBQUVILE9BQUtqQixHQUFFRixNQUFJc0IsR0FBRXRCLEtBQUlFLEdBQUVFLE1BQUlrQixHQUFFbEIsT0FBS0YsR0FBRUUsTUFBSXNGLEVBQUVwRSxHQUFFbEIsS0FBSUYsSUFBRW9CLElBQUVYLElBQUVJLElBQUVRLElBQUVxQixJQUFFWixFQUFBQTtBQUFBQSxLQUFJQyxLQUFFdkMsRUFBRWlHLFdBQVMxRCxHQUFFL0IsRUFBQUE7RUFBMEYsU0FBakZYLElBQUFBO0FBQUdXLElBQUFBLEdBQUVpQixNQUFJLE9BQU1hLE1BQUcsUUFBTVQsUUFBS3JCLEdBQUVFLE1BQUlpQyxJQUFFbkMsR0FBRTJCLE1BQUFBLENBQUFBLENBQU1HLElBQUVULEdBQUVBLEdBQUV0QixRQUFRb0MsRUFBQUEsQ0FBQUEsSUFBSSxPQUFNM0MsRUFBRVUsSUFBSWIsSUFBRVcsSUFBRW9CLEVBQUFBO0VBQUU7QUFBQztBQUFDLFNBQVNRLEVBQUV2QyxJQUFFVyxJQUFBQTtBQUFHUixJQUFFYSxPQUFLYixFQUFFYSxJQUFJTCxJQUFFWCxFQUFBQSxHQUFHQSxHQUFFOEIsS0FBSyxTQUFTbkIsSUFBQUE7QUFBRyxRQUFBO0FBQUlYLE1BQUFBLEtBQUVXLEdBQUUyQixLQUFJM0IsR0FBRTJCLE1BQUksQ0FBQSxHQUFHdEMsR0FBRThCLEtBQUssU0FBUzlCLElBQUFBO0FBQUdBLFFBQUFBLEdBQUVxRyxLQUFLMUYsRUFBQUE7TUFBRSxDQUFBO0lBQTBCLFNBQWpCWCxJQUFBQTtBQUFHRyxRQUFFVSxJQUFJYixJQUFFVyxHQUFFaUIsR0FBQUE7SUFBSTtFQUFDLENBQUE7QUFBRTtBQUFDLFNBQVN1RSxFQUFFaEcsSUFBRVEsSUFBRW9CLElBQUVYLElBQUVJLElBQUVRLElBQUVjLElBQUVMLElBQUFBO0FBQUcsTUFBSVAsSUFBRVMsSUFBRUssSUFBRUosS0FBRWIsR0FBRTFCLE9BQU1OLEtBQUVZLEdBQUVOLE9BQU1ILEtBQUVTLEdBQUVHLE1BQUtDLEtBQUU7QUFBRSxNQUFHLFVBQVFiLE9BQUlzQixLQUFBQSxPQUFNLFFBQU1RO0FBQUUsV0FBS2pCLEtBQUVpQixHQUFFcEIsUUFBT0csS0FBSSxNQUFJbUIsS0FBRUYsR0FBRWpCLEVBQUFBLE1BQUssa0JBQWlCbUIsTUFBQUEsQ0FBQUEsQ0FBS2hDLE9BQUlBLEtBQUVnQyxHQUFFb0UsY0FBWXBHLEtBQUUsTUFBSWdDLEdBQUVxRSxXQUFVO0FBQUNwRyxNQUFBQSxLQUFFK0IsSUFBRUYsR0FBRWpCLEVBQUFBLElBQUc7QUFBSztJQUFLOztBQUFDLE1BQUcsUUFBTVosSUFBRTtBQUFDLFFBQUcsU0FBT0QsR0FBRSxRQUFPc0csU0FBU0MsZUFBZTFHLEVBQUFBO0FBQUdJLElBQUFBLEtBQUVxQixLQUFFZ0YsU0FBU0UsZ0JBQWdCLDhCQUE2QnhHLEVBQUFBLElBQUdzRyxTQUFTRyxjQUFjekcsSUFBRUgsR0FBRTZHLE1BQUk3RyxFQUFBQSxHQUFHaUMsS0FBRSxNQUFLUyxLQUFBQTtFQUFJO0FBQUMsTUFBRyxTQUFPdkMsR0FBRTBDLENBQUFBLE9BQUk3QyxNQUFHMEMsTUFBR3RDLEdBQUUwRyxTQUFPOUcsT0FBSUksR0FBRTBHLE9BQUs5RztPQUFPO0FBQUMsUUFBR2lDLEtBQUVBLE1BQUdoQyxFQUFFcUcsS0FBS2xHLEdBQUUyRyxVQUFBQSxHQUFZbkUsTUFBR0MsS0FBRWIsR0FBRTFCLFNBQU9nRCxHQUFHMEQseUJBQXdCL0QsS0FBRWpELEdBQUVnSCx5QkFBQUEsQ0FBeUJ0RSxJQUFFO0FBQUMsVUFBRyxRQUFNVCxHQUFFLE1BQUlZLEtBQUUsQ0FBQSxHQUFHN0IsS0FBRSxHQUFFQSxLQUFFWixHQUFFNkcsV0FBV3BHLFFBQU9HLEtBQUk2QixDQUFBQSxHQUFFekMsR0FBRTZHLFdBQVdqRyxFQUFBQSxFQUFHa0csSUFBQUEsSUFBTTlHLEdBQUU2RyxXQUFXakcsRUFBQUEsRUFBR2lFO0FBQUFBLE9BQU9oQyxNQUFHTCxRQUFLSyxPQUFJTCxNQUFHSyxHQUFFa0UsVUFBUXZFLEdBQUV1RSxVQUFRbEUsR0FBRWtFLFdBQVMvRyxHQUFFZ0gsZUFBYWhILEdBQUVnSCxZQUFVbkUsTUFBR0EsR0FBRWtFLFVBQVE7SUFBSTtBQUFDLFNBQXRxSSxTQUFXbEgsSUFBRUcsSUFBRVEsSUFBRW9CLElBQUVYLElBQUFBO0FBQUcsVUFBSUk7QUFBRSxXQUFJQSxNQUFLYixHQUFFLGdCQUFhYSxNQUFHLFVBQVFBLE1BQUdBLE1BQUtyQixNQUFHOEQsRUFBRWpFLElBQUV3QixJQUFFLE1BQUtiLEdBQUVhLEVBQUFBLEdBQUdPLEVBQUFBO0FBQUcsV0FBSVAsTUFBS3JCLEdBQUVpQixDQUFBQSxNQUFHLGNBQUEsT0FBbUJqQixHQUFFcUIsRUFBQUEsS0FBSSxlQUFhQSxNQUFHLFVBQVFBLE1BQUcsWUFBVUEsTUFBRyxjQUFZQSxNQUFHYixHQUFFYSxFQUFBQSxNQUFLckIsR0FBRXFCLEVBQUFBLEtBQUl5QyxFQUFFakUsSUFBRXdCLElBQUVyQixHQUFFcUIsRUFBQUEsR0FBR2IsR0FBRWEsRUFBQUEsR0FBR08sRUFBQUE7SUFBRSxHQUFpOUg1QixJQUFFSixJQUFFNkMsSUFBRXBCLElBQUVpQixFQUFBQSxHQUFHTyxHQUFFckMsQ0FBQUEsR0FBRUYsTUFBSSxDQUFBO2FBQVdNLEtBQUVKLEdBQUVOLE1BQU1KLFVBQVN1QyxFQUFFckMsSUFBRThDLE1BQU1DLFFBQVFuQyxFQUFBQSxJQUFHQSxLQUFFLENBQUNBLEVBQUFBLEdBQUdKLElBQUVvQixJQUFFWCxJQUFFSSxNQUFHLG9CQUFrQnRCLElBQUU4QixJQUFFYyxJQUFFZCxLQUFFQSxHQUFFLENBQUEsSUFBR0QsR0FBRXRCLE9BQUtGLEVBQUV3QixJQUFFLENBQUEsR0FBR1UsRUFBQUEsR0FBRyxRQUFNVCxHQUFFLE1BQUlqQixLQUFFaUIsR0FBRXBCLFFBQU9HLE9BQUssU0FBTWlCLEdBQUVqQixFQUFBQSxLQUFJMkIsRUFBRVYsR0FBRWpCLEVBQUFBLENBQUFBO0FBQUkwQixJQUFBQSxPQUFJLFdBQVUxQyxNQUFBQSxZQUFhZ0IsS0FBRWhCLEdBQUVpRixXQUFTakUsT0FBSVosR0FBRTZFLFNBQU8sZUFBYTlFLE1BQUFBLENBQUlhLE1BQUcsYUFBV2IsTUFBR2EsT0FBSTZCLEdBQUVvQyxVQUFRZixFQUFFOUQsSUFBRSxTQUFRWSxJQUFFNkIsR0FBRW9DLE9BQUFBLEtBQU0sR0FBSSxhQUFZakYsTUFBQUEsWUFBYWdCLEtBQUVoQixHQUFFcUgsWUFBVXJHLE9BQUlaLEdBQUVpSCxXQUFTbkQsRUFBRTlELElBQUUsV0FBVVksSUFBRTZCLEdBQUV3RSxTQUFBQSxLQUFRO0VBQUk7QUFBQyxTQUFPakg7QUFBQztBQUFDLFNBQVN1RCxFQUFFMUQsSUFBRVcsSUFBRW9CLElBQUFBO0FBQUcsTUFBQTtBQUFJLGtCQUFBLE9BQW1CL0IsS0FBRUEsR0FBRVcsRUFBQUEsSUFBR1gsR0FBRXFILFVBQVExRztFQUFxQixTQUFiWCxJQUFBQTtBQUFHRyxNQUFFVSxJQUFJYixJQUFFK0IsRUFBQUE7RUFBRTtBQUFDO0FBQUMsU0FBUzBCLEVBQUV6RCxJQUFFVyxJQUFFb0IsSUFBQUE7QUFBRyxNQUFJWCxJQUFFSTtBQUFFLE1BQUdyQixFQUFFbUgsV0FBU25ILEVBQUVtSCxRQUFRdEgsRUFBQUEsSUFBSW9CLEtBQUVwQixHQUFFb0QsU0FBT2hDLEdBQUVpRyxXQUFTakcsR0FBRWlHLFlBQVVySCxHQUFFYSxPQUFLNkMsRUFBRXRDLElBQUUsTUFBS1QsRUFBQUEsSUFBSSxTQUFPUyxLQUFFcEIsR0FBRWdCLE1BQUs7QUFBQyxRQUFHSSxHQUFFbUcscUJBQXFCLEtBQUE7QUFBSW5HLE1BQUFBLEdBQUVtRyxxQkFBQUE7SUFBMEMsU0FBYnZILElBQUFBO0FBQUdHLFFBQUVVLElBQUliLElBQUVXLEVBQUFBO0lBQUU7QUFBQ1MsSUFBQUEsR0FBRUgsT0FBS0csR0FBRWEsTUFBSSxNQUFLakMsR0FBRWdCLE1BQUFBO0VBQVU7QUFBQyxNQUFHSSxLQUFFcEIsR0FBRVMsSUFBSSxNQUFJZSxLQUFFLEdBQUVBLEtBQUVKLEdBQUVSLFFBQU9ZLEtBQUlKLENBQUFBLEdBQUVJLEVBQUFBLEtBQUlpQyxFQUFFckMsR0FBRUksRUFBQUEsR0FBR2IsSUFBRW9CLE1BQUcsY0FBQSxPQUFtQi9CLEdBQUVjLElBQUFBO0FBQU1pQixFQUFBQSxNQUFHLFFBQU0vQixHQUFFYSxPQUFLNkIsRUFBRTFDLEdBQUVhLEdBQUFBLEdBQUtiLEdBQUVRLEtBQUdSLEdBQUVhLE1BQUliLEdBQUVtQixNQUFBQTtBQUFVO0FBQUMsU0FBU2lFLEVBQUVwRixJQUFFRyxJQUFFUSxJQUFBQTtBQUFHLFNBQU9QLEtBQUswRSxZQUFZOUUsSUFBRVcsRUFBQUE7QUFBRTtBQUFDLFNBQVM2RyxFQUFFN0csSUFBRW9CLElBQUVYLElBQUFBO0FBQUcsTUFBSUksSUFBRVEsSUFBRWM7QUFBRTNDLElBQUVLLE1BQUlMLEVBQUVLLEdBQUdHLElBQUVvQixFQUFBQSxHQUFHQyxNQUFHUixLQUFFLGNBQUEsT0FBbUJKLE1BQUcsT0FBS0EsTUFBR0EsR0FBRVgsT0FBS3NCLEdBQUV0QixLQUFJcUMsS0FBRSxDQUFBLEdBQUdYLEVBQUVKLElBQUVwQixNQUFBQSxDQUFJYSxNQUFHSixNQUFHVyxJQUFHdEIsTUFBSWtDLEVBQUU1QyxHQUFFLE1BQUssQ0FBQ1ksRUFBQUEsQ0FBQUEsR0FBSXFCLE1BQUdxQixHQUFFQSxHQUFBQSxXQUFXdEIsR0FBRU0saUJBQUFBLENBQWlCYixNQUFHSixLQUFFLENBQUNBLEVBQUFBLElBQUdZLEtBQUUsT0FBS0QsR0FBRTBGLGFBQVd6SCxFQUFFcUcsS0FBS3RFLEdBQUUrRSxVQUFBQSxJQUFZLE1BQUtoRSxJQUFBQSxDQUFHdEIsTUFBR0osS0FBRUEsS0FBRVksS0FBRUEsR0FBRW5CLE1BQUlrQixHQUFFMEYsWUFBV2pHLEVBQUFBLEdBQUdlLEVBQUVPLElBQUVuQyxFQUFBQTtBQUFFO0FBQUEsU0FBQSxJQUFBO0FDRzl6USxTQUFPLHVDQUF1Q3lELFFBQVEsU0FBUyxTQUFVM0IsSUFBQUE7QUFDdkUsUUFBTVQsS0FBcUIsS0FBaEIwRixLQUFLQyxPQUFBQSxJQUFpQjtBQUVqQyxZQURXLE9BQUxsRixLQUFXVCxLQUFTLElBQUpBLEtBQVcsR0FDeEI0RixTQUFTLEVBQUE7RUFDcEIsQ0FBQTtBQUNGO0FEUmtoUzVILElBQUU4QyxFQUFFd0IsT0FBTW5FLElBQUUsRUFBQ1UsS0FBSSxTQUFTYixJQUFFRyxJQUFFUSxJQUFFb0IsSUFBQUE7QUFBRyxXQUFRWCxJQUFFSSxJQUFFUSxJQUFFN0IsS0FBRUEsR0FBRUssS0FBSSxNQUFJWSxLQUFFakIsR0FBRWEsUUFBQUEsQ0FBT0ksR0FBRVosR0FBRyxLQUFBO0FBQUksU0FBSWdCLEtBQUVKLEdBQUUwRCxnQkFBYyxRQUFNdEQsR0FBRXFHLDZCQUEyQnpHLEdBQUUwRyxTQUFTdEcsR0FBRXFHLHlCQUF5QjdILEVBQUFBLENBQUFBLEdBQUlnQyxLQUFFWixHQUFFRCxNQUFLLFFBQU1DLEdBQUUyRyxzQkFBb0IzRyxHQUFFMkcsa0JBQWtCL0gsSUFBRStCLE1BQUcsQ0FBRSxDQUFBLEdBQUVDLEtBQUVaLEdBQUVELE1BQUthLEdBQUUsUUFBT1osR0FBRTZELE1BQUk3RDtFQUFjLFNBQU5qQixJQUFBQTtBQUFHSCxJQUFBQSxLQUFFRztFQUFDO0FBQUMsUUFBTUg7QUFBQyxFQUFBLEdBQUdXLElBQUUsR0FBRW9CLElBQUUsU0FBUy9CLElBQUFBO0FBQUcsU0FBTyxRQUFNQSxNQUFBQSxXQUFZQSxHQUFFOEU7QUFBVyxHQUFFNUUsRUFBRWdGLFVBQVU0QyxXQUFTLFNBQVM5SCxJQUFFRyxJQUFBQTtBQUFHLE1BQUlRO0FBQUVBLEVBQUFBLEtBQUUsUUFBTVAsS0FBS29GLE9BQUtwRixLQUFLb0YsUUFBTXBGLEtBQUtrRixRQUFNbEYsS0FBS29GLE1BQUlwRixLQUFLb0YsTUFBSXRELEVBQUUsQ0FBRSxHQUFDOUIsS0FBS2tGLEtBQUFBLEdBQU8sY0FBQSxPQUFtQnRGLE9BQUlBLEtBQUVBLEdBQUVrQyxFQUFFLENBQUEsR0FBR3ZCLEVBQUFBLEdBQUdQLEtBQUtDLEtBQUFBLElBQVFMLE1BQUdrQyxFQUFFdkIsSUFBRVgsRUFBQUEsR0FBRyxRQUFNQSxNQUFHSSxLQUFLd0IsUUFBTXpCLE1BQUdDLEtBQUttRixJQUFJbEUsS0FBS2xCLEVBQUFBLEdBQUdlLEVBQUVkLElBQUFBO0FBQU0sR0FBRUYsRUFBRWdGLFVBQVU4QyxjQUFZLFNBQVNoSSxJQUFBQTtBQUFHSSxPQUFLd0IsUUFBTXhCLEtBQUtTLE1BQUFBLE1BQU9iLE1BQUdJLEtBQUtrQyxJQUFJakIsS0FBS3JCLEVBQUFBLEdBQUdrQixFQUFFZCxJQUFBQTtBQUFNLEdBQUVGLEVBQUVnRixVQUFVQyxTQUFPcEYsR0FBRXFCLElBQUUsQ0FBQSxHQUFHRSxFQUFFQyxNQUFJLEdBQUVTLElBQUU7QUVBbnFULElBRW5DaUcsSUFBQSw0QkFBQTtBQUdSLFdBQVlDLEdBQUFBLElBQUFBO0FBQU85SCxTQUZGK0gsTUFBQUEsUUFHZi9ILEtBQUsrSCxNQUFNRCxNQUFNRSxFQUFBQTtFQUNuQjtBQUlDLFNBSkFDLEVBQUFBLElBQUFBLENBQUFBLEVBQUFBLEtBQUFBLE1BQUFBLEtBRUQsV0FBQTtBQUNFLFdBQU9qSSxLQUFLK0g7RUFDZCxFQUFBLENBQUEsQ0FBQSxHQUFDRjtBQUFBLEdBVE87QUNLSixTQUFxQkssRUFBQ2pJLElBQUFBO0FBQzFCLFNBQUEsRUFBU0EsR0FBTWtJLGlCQUFpQixRQUFRLEVBQ3RDeEIseUJBQXlCLEVBQUVHLFFBQVE3RyxHQUFNbUksUUFBQUEsRUFBQUEsQ0FBQUE7QUFFN0M7QUNIZ0JDLFNBQUFBLEVBQUtELElBQWlCRCxJQUFBQTtBQUNwQyxTQUFPNUYsRUFBRTJGLEdBQWEsRUFBRUUsU0FBU0EsSUFBU0QsZUFBZUEsR0FBQUEsQ0FBQUE7QUFDM0Q7QUNMTUcsSUNXTEM7QURYS0QsSUNXTEMsSURQQywwQkFBQUMsSUFBQUE7QUFBQSxXQUFBRixHQUFZN0IsSUFBQUE7QUFBQUEsUUFBQUE7QUFHUSxZQUZsQmdDLEtBQU9ELEdBQUF2QyxLQUFBakcsSUFBQUEsS0FBQUEsTUFIRnlHLE9BQUFBLFFBS0xnQyxHQUFLQyxPQUFPakMsRUFBQUEsR0FBTWdDO0VBQ3BCO0FBSkFFLElBQUFMLElBQUFFLEVBQUFBO0FBSUMsTUFBQUksS0FBQU4sR0FBQXhEO0FBQUFBLFNBQUE4RCxHQUVPQyxPQUFBLFNBQUtwQyxJQUFBQTtBQUNYLFdBQUlBLGNBQTJCeUIsY0FDdEJHLEVBQUs1QixHQUFLcUMsU0FBQUEsSUFBQUE7RUFJckIsR0FBQ0YsR0FPTUYsU0FBQSxTQUFPakMsSUFBQUE7QUFFWixXQURBekcsS0FBS3lHLE9BQU96RyxLQUFLNkksS0FBS3BDLEVBQUFBLEdBRXhCekc7RUFBQSxHQUFBSjtBQUFBLEdBMUJpQmlJLENBQUFBO0FBQWJTLElFRElTLElBQUEsMEJBQUFQLElBQUFBO0FBR1IsV0FBWVEsR0FBQUEsSUFBQUE7QUFBYyxRQUFBUDtBQUdDLFlBRnpCQSxLQUFPRCxHQUFBdkMsS0FBQWpHLElBQUFBLEtBQUFBLE1BSERpSixTQUFBQSxRQUtOUixHQUFLTyxRQUFRQSxNQUFTLENBQUEsR0FDeEJQO0VBQUE7QUFQUUUsSUFBQUksSUFBQVAsRUFBQUE7QUFPUCxNQUVNVSxLQUFBQSxHQUFBQTtBQTZCTixTQTdCTUEsR0FBQUEsT0FBQSxTQUFLQyxJQUFBQTtBQUNWLFdBQVduSixLQUFDaUosT0FBT0UsRUFBQUE7RUFDckIsR0FBQ1AsR0FVTVEsVUFBQSxXQUFBO0FBQ0wsV0FBT3BKLEtBQUtnSixNQUFNSyxJQUFJLFNBQUNILElBQUFBO0FBQUksYUFBQWxJLEdBQVV5RjtJQUFJLENBQUE7RUFDM0MsR0FTTzZDLEdBQUFBLFlBQVAsU0FBaUJOLElBQUFBO0FBQ2YsV0FBV0QsSUFBQUEsR0FBSUMsR0FBTUssSUFBSSxTQUFDSCxJQUFBQTtBQUFJLGFBQVNaLElBQUFBLEVBQUtZLEdBQUt6QyxJQUFBQTtJQUFLLENBQUEsQ0FBQTtFQUN4RCxHQXJCQXdCLEVBQUFjLElBQUEsQ0FBQSxFQUFBaEcsS0FBQSxTQUFBd0csS0FBQSxXQUFBO0FBQ0UsV0FBV3ZKLEtBQUNpSjtFQUNkLEdBRUFPLEtBQUEsU0FBaUJSLElBQUFBO0FBQ2ZoSixTQUFLaUosU0FBU0Q7RUFDaEIsRUFBQSxHQUFDLEVBQUFqRyxLQUFBLFVBQUF3RyxLQWlCRCxXQUFBO0FBQ0UsV0FBT3ZKLEtBQUtnSixNQUFNeEk7RUFDcEIsRUFBQSxDQUFBLENBQUEsR0FBQ3VJO0FBQUEsR0F0Q2VsQixDQUFBQTtBRkNaUyxJR0NRbUIsSUFBQSwwQkFBQWpCLElBQUFBO0FBSVosV0FBWWtCLEdBQUFBLElBQUFBO0FBQ1YsUUFBQWpCO0FBUUMsWUFSREEsS0FBQUQsR0FBQXZDLEtBQUFqRyxJQUFBQSxLQUFBQSxNQUpNMkosUUFBQUEsUUFBQUEsR0FDQUMsVUFBQUEsUUFNSm5CLEdBQUtpQixPQURIQSxjQUFnQjdHLFFBQ042RyxLQUNIQSxjQUFnQlgsSUFDYixDQUFDVyxFQUFBQSxJQUVELENBQUEsR0FFaEJqQjtFQUFBO0FBZG9CWixTQUFSYyxFQUFBYyxJQUFBakIsRUFBQUEsR0FpQ0xZLEdBQUFBLFVBQUFBLFVBQUEsV0FBQTtBQUNMLFdBQU9wSixLQUFLMEosS0FBS0wsSUFBSSxTQUFDUSxJQUFBQTtBQUFBQSxhQUFXQSxHQUFDVCxRQUFBQTtJQUFTLENBQUE7RUFDN0MsR0FBQ0ssR0FTTUssV0FBUCxTQUFnQkosSUFBQUE7QUFDZCxXQUFXRCxJQUFBQSxHQUFRQyxHQUFLTCxJQUFJLFNBQUNRLElBQUFBO0FBQUFBLGFBQVdkLEVBQUNPLFVBQVVPLEdBQUliLEtBQUFBO0lBQU0sQ0FBQSxDQUFBO0VBQy9ELEdBQUNTLEdBU01NLFlBQVAsU0FDRXRELElBQUFBO0FBSUEsV0FBV2dELElBQUFBLElBRlhoRCxNQzlERSxTQUF3QkEsSUFBQUE7QUFDNUIsYUFBQSxDQUFJQSxHQUFLLENBQUEsS0FBUUEsR0FBSyxDQUFBLGFBQWM1RCxRQUt0QzRELEtBSlcsQ0FBQ0EsRUFBQUE7SUFJWixHRHdEc0JBLEVBQUFBLEdBR1g0QyxJQUFJLFNBQUNRLElBQUFBO0FBQUcsYUFBU2QsSUFBQUEsRUFBSWMsR0FBSVIsSUFBSSxTQUFDSCxJQUFBQTtBQUFBQSxlQUFhWixJQUFBQSxFQUFLWSxFQUFBQTtNQUFLLENBQUEsQ0FBQTtJQUFFLENBQUEsQ0FBQTtFQUVoRSxHQS9DQWpCLEVBQUF3QixJQUFBLENBQUEsRUFBQTFHLEtBQUEsUUFBQXdHLEtBQUEsV0FBQTtBQUNFLFdBQU92SixLQUFLMko7RUFDZCxHQUFDSCxLQUVELFNBQVNFLElBQUFBO0FBQ1AxSixTQUFLMkosUUFBUUQ7RUFDZixFQUFBLEdBRUEsRUFBQTNHLEtBQUEsVUFBQXdHLEtBQUEsV0FBQTtBQUNFLFdBQUEsS0FBWUssV0FBVzVKLEtBQUswSixLQUFLbEo7RUFDbkMsR0FBQ2dKLEtBR0QsU0FBV1EsSUFBQUE7QUFDVGhLLFNBQUs0SixVQUFVSTtFQUNqQixFQUFBLENBQUEsQ0FBQSxHQS9Cb0JuQztBQUFBQSxHQUFBQSxDQUFBQTtBSERoQlMsSUsrQk8yQixJQUFBQSw0QkFBQUE7QUFBQUEsV0FBQUEsS0FBQUE7QUFBQUEsU0FDSEMsWUFBQUE7RUFBUztBQUFBLE1BQUF0QixLQUFBcUIsR0FBQW5GO0FBOERoQixTQTlEZ0I4RCxHQUtUdUIsT0FBQSxTQUFLMUYsSUFBQUE7QUFDTnpFLFNBQUtrSyxjQUNSbEssS0FBS2tLLFlBQVksQ0FDbEIsSUFFR3pGLE1BQUFBLENBQVV6RSxLQUFLa0ssVUFBVXpGLEVBQUFBLE1BQzNCekUsS0FBS2tLLFVBQVV6RixFQUFBQSxJQUFTLENBQUE7RUFFNUIsR0FBQ21FLEdBRUR3QixZQUFBLFdBQUE7QUFDRSxXQUFXcEssS0FBQ2tLO0VBQ2QsR0FBQ3RCLEdBRUR5QixLQUFBLFNBQ0U1RixJQUNBNkYsSUFBQUE7QUFJQSxXQUZBdEssS0FBS21LLEtBQUsxRixFQUFBQSxHQUNWekUsS0FBS2tLLFVBQVV6RixFQUFBQSxFQUFpQnhELEtBQUtxSixFQUFBQSxHQUV2Q3RLO0VBQUEsR0FFQXVLLEdBQUFBLE1BQUEsU0FDRTlGLElBQ0E2RixJQUFBQTtBQUVBLFFBQU1FLEtBQVkvRjtBQUlsQixXQUZBekUsS0FBS21LLEtBQUFBLEdBRUFuSyxLQUFLa0ssVUFBVU0sRUFBQUEsS0FBbUQsTUFBckN4SyxLQUFLa0ssVUFBVU0sRUFBQUEsRUFBV2hLLFVBSzVEUixLQUFLa0ssVUFBVU0sRUFBQUEsSUFBYXhLLEtBQUtrSyxVQUFVTSxFQUFBQSxFQUFXQyxPQUNwRCxTQUFDN0YsSUFBQUE7QUFBSyxhQUFVQSxNQUFJMEY7SUFBUSxDQUFBLEdBR3ZCdEssUUFQRUE7RUFRWCxHQUFDNEksR0FFRDhCLE9BQUEsU0FDRWpHLElBQUFBO0FBQ3lDLFFBQUFrRyxLQUFBQyxXQUUxQkosS0FBRy9GO0FBSWxCLFdBRkF6RSxLQUFLbUssS0FBS0ssRUFBQUEsR0FFTnhLLEtBQUtrSyxVQUFVTSxFQUFBQSxFQUFXaEssU0FBUyxNQUNyQ1IsS0FBS2tLLFVBQVVNLEVBQUFBLEVBQVc5RSxRQUFRLFNBQUNkLElBQUFBO0FBQUssYUFBVUEsR0FBQWlHLE1BQUFBLFFBQUEsQ0FBQSxFQUFBM0csTUFBQStCLEtBQUEwRSxJQUFBLENBQUEsQ0FBQTtJQUFTLENBQUEsR0FBQTtFQUsvRCxHQUFDVjtBQUFBLEdBQUE7QUM3RmFhLFNBQUFBLEVBQWdCQyxJQUFTQyxJQUFBQTtBQUV2QyxNQUFBLE9BQWVELE1BQUFBLE9BQVlDLEdBQ3pCLFFBQUE7QUFHRixNQUFhLFNBQVRELE1BQTBCLFNBQVRDLEdBQ25CLFFBQUE7QUFHRixNQUFvQixZQUFBLE9BQVRELEdBR1QsUUFBT0EsT0FBU0M7QUFHbEIsTUFBSW5JLE1BQU1DLFFBQVFpSSxFQUFBQSxLQUFTbEksTUFBTUMsUUFBUWtJLEVBQUFBLEdBQU87QUFDOUMsUUFBSUQsR0FBS3ZLLFdBQVd3SyxHQUFLeEssT0FDdkIsUUFBQTtBQUVGLGFBQVVtQixLQUFHLEdBQUdBLEtBQUlvSixHQUFLdkssUUFBUW1CLEtBQy9CLEtBQUEsQ0FBS21KLEVBQVVDLEdBQUtwSixFQUFBQSxHQUFJcUosR0FBS3JKLEVBQUFBLENBQUFBLEVBQzNCLFFBQUE7QUFHSixXQUFBO0VBQ0Q7QUFFRCxNQUVFb0osR0FBS0UsZUFBZSxhQUFBLEtBRXBCRCxHQUFLQyxlQUFlLGFBQUEsS0FFcEJGLEdBQUtFLGVBQWUsT0FBQSxLQUVwQkQsR0FBS0MsZUFBZSxPQUFBLEtBRXBCRixHQUFLRSxlQUFlLEtBQUEsS0FFcEJELEdBQUtDLGVBQWUsS0FBQSxLQUVwQkYsR0FBS0UsZUFBZSxLQUFBLEtBRXBCRCxHQUFLQyxlQUFlLEtBQUEsS0FFcEJGLEdBQUtFLGVBQWUsTUFBQSxLQUVwQkQsR0FBS0MsZUFBZSxNQUFBLEVBRXBCLFFBQU9ILEVBQVVDLEdBQVksT0FBR0MsR0FBWSxLQUFBO0FBRzlDLE1BQVdFLEtBQUdDLE9BQU9DLEtBQUtMLEVBQUFBLEdBQ2ZNLEtBQUdGLE9BQU9DLEtBQUtKLEVBQUFBO0FBQzFCLE1BQUlFLEdBQU0xSyxXQUFXNkssR0FBTTdLLE9BQ3pCLFFBQUE7QUFFRixXQUFBOEssS0FBQSxHQUFBQyxLQUFrQkwsSUFBT0ksS0FBQUMsR0FBQS9LLFFBQUE4SyxNQUFBO0FBQXBCLFFBQU12SSxLQUVUd0ksR0FBQUQsRUFBQUE7QUFBQSxRQUFBLENBQUtOLEdBQUtDLGVBQWVsSSxFQUFBQSxLQUFBQSxDQUFTK0gsRUFBVUMsR0FBS2hJLEVBQUFBLEdBQU1pSSxHQUFLakksRUFBQUEsQ0FBQUEsRUFDMUQsUUFBQTtFQUVIO0FBQ0QsU0FBQTtBQUNGO0FBQUEsRUxqRUEsU0FBWXdGLElBQUFBO0FBQ1ZBLEVBQUFBLEdBQUFBLEdBQUEsWUFBQSxDQUFBLElBQUEsYUFDQUEsR0FBQUEsR0FBQSxlQUFBLENBQUEsSUFBQSxnQkFDQUEsR0FBQUEsR0FBQSxhQUFBLENBQUEsSUFBQSxjQUNBQSxHQUFBQSxHQUFBLGNBQUEsQ0FBQSxJQUFBLGVBQ0FBLEdBQUFBLEdBQUEsWUFBQSxDQUFBLElBQUEsYUFDQUEsR0FBQUEsR0FBQSxjQUFBLENBQUEsSUFBQSxlQUNBQSxHQUFBQSxHQUFBLFNBQUEsQ0FBQSxJQUFBLFVBQ0FBLEdBQUFBLEdBQUEsT0FBQSxDQUFBLElBQUEsUUFDQUEsR0FBQUEsR0FBQSxRQUFBLENBQUEsSUFBQTtBQUNELEdBVldBLE1BQUFBLElBVVgsQ0FBQSxFQUFBO0FBV0QsSUFHRWlELEtBQUEsMEJBQUFDLElBQUFBO0FBUUEsV0FBQXJLLEdBQVluQixJQUFBQTtBQUNWLFFBQUF3STtBQUtnQyxZQUxoQ0EsS0FBQWdELEdBQUF4RixLQUFBakcsSUFBQUEsS0FBUUEsTUFSTThILEtBQUFBLFFBQUVXLEdBQ1ZpRCxTQUFBQSxRQVNOakQsR0FBS2lELFNBQVMsQ0FBTyxHQUNyQmpELEdBQUtYLEtBQUtFLEVBQUFBLEdBRU4vSCxNQUFPd0ksR0FBS2tELFNBQVMxTCxFQUFBQSxHQUFBQTtFQUMzQjtBQWZBMEksSUFBQTZDLElBQUFDLEVBQUFBO0FBZUMsTUFBQTdDLEtBQUE0QyxHQUFBMUc7QUFBQUEsU0FBQThELEdBUURnRCxVQUFBLFdBQUE7QUFBV0MsUUFBQUEsS0FDVCxDQUFBLEVBQUEzSCxNQUFBK0IsS0FBQTJFLFNBQUFBO0FBQUk1SyxTQUFLOEwseUJBQUFBLFlBQ1A5TCxLQUFLOEwsY0FBTGpCLE1BQUE3SyxNQUFzQjZMLEVBQUFBLEdBR3hCN0wsS0FBSzBLLEtBQUxHLE1BQUE3SyxNQUFVLENBQUEsZUFBQSxFQUFBLE9BQW9CNkwsRUFBQUEsQ0FBQUE7QUFDOUIsUUFBQWpNLEtBQWVJLEtBQUsrTCxTQUFBQSxNQUFML0wsTUFBaUI2TCxFQUFBQTtBQUVoQyxXQURBN0wsS0FBSzBLLEtBQUFBLE1BQUwxSyxNQUFJLENBQU0sY0FBQSxFQUFjZ00sT0FBS0gsRUFBQUEsQ0FBQUEsR0FBQUE7RUFFL0IsR0FBQ2pELEdBRUQrQyxXQUFBLFNBQVMxTCxJQUFBQTtBQUNQLFFBQWtCZ00sS0FBQUMsRUFBQSxDQUFBLEdBQ2JsTSxLQUFLMEwsUUFDTHpMLEVBQUFBO0FBUUwsV0FMSzZLLEVBQVVtQixJQUFjak0sS0FBSzBMLE1BQUFBLE1BQ2hDMUwsS0FBSzBMLFNBQVNPLElBQ2RqTSxLQUFLMEssS0FBSyxnQkFBZ0IxSyxJQUFBQSxJQUFBQTtFQUk5QixHQUFDaUksRUFBQXVELElBQUEsQ0FBQSxFQUFBekksS0FBQSxTQUFBd0csS0FFRCxXQUFBO0FBQ0UsV0FBV3ZKLEtBQUMwTDtFQUNkLEVBQUEsQ0FBQSxDQUFBLEdBQUF0SztBQUFBLEdBbERRNkksQ0FBQUE7QUFIVixJTVhNa0MsS0FRSkosMEJBQUFBLElBQUFBO0FBQUFBLFdBQUFBLEtBQUFBO0FBQUFBLFdBQUFBLEdBQUFBLE1BQUFBLE1BQUFBLFNBQUFBLEtBQUFBO0VBQUFBO0FBQUFBLFNBQUFBLEVBQUFBLElBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLFVBQUFBLFdBQUEsU0FBU3RGLElBQUFBO0FBQ1AsV0FBSXpHLEtBQUtDLE1BQU1tTSxXQ25CakJBLEtEcUJNQyxPQUFPck0sS0FBS0MsTUFBTW1NLE9BQUFBLEVBQVNFLEtBQUFBLEdDcEJqQ0MsS0RxQk12TSxLQUFLQyxNQUFNc00sU0NwQmpCQyxLRHFCTXhNLEtBQUtDLE1BQU11TSxxQkNwQmpCQyxLRHFCTWhHLElDcEJOaUcsS0RxQk0xTSxLQUFLQyxNQUFNeU0sVUNsQmpCTixLQUFVQSxHQUFRcEksUUFBUSw0QkFBNEIsTUFBQSxHQUUzQ3lGLElBQUFBLEVBQ1RnRCxHQUFRL0MsS0FBS2UsT0FBTyxTQUFDWixJQUFLOEMsSUFBQUE7QUFBUSxhQUM3QjlDLEdBQUNiLE1BQU10SCxLQUFLLFNBQUN3SCxJQUFNMEQsSUFBQUE7QUFDcEIsWUFBQSxDQUFLMUQsR0FDSCxRQUFBO0FBR0YsWUFBSXNELE1BRUFELE1BQ0FBLEdBQVFLLEVBQUFBLEtBQ3NCLFlBQUEsT0FBaEJMLEdBQUNLLEVBQUFBLEtBRUtMLEdBQVFLLEVBQUFBLEVBQ1pDLE9BQ2QsUUFBQTtBQUtOLFlBQVFwRyxLQUFHO0FBRVgsWUFBd0IsY0FBQSxPQUFMaUcsR0FDakJqRyxDQUFBQSxLQUFPaUcsR0FBU3hELEdBQUt6QyxNQUFNa0csSUFBVUMsRUFBQUE7aUJBQ1AsWUFBQSxPQUFBNUwsR0FBVHlGLE1BQW1CO0FBRXhDLGNBQU1xRyxLQUFVNUQsR0FBS3pDO0FBQ2pCcUcsVUFBQUEsTUFBV0EsR0FBUTdNLFNBQVM2TSxHQUFRN00sTUFBTW1JLFlBRTVDM0IsS0FBT3FHLEdBQVE3TSxNQUFNbUk7UUFFeEIsTUFFQzNCLENBQUFBLEtBQU80RixPQUFPbkQsR0FBS3pDLElBQUFBO0FBR3JCLGVBQU8sSUFBQSxPQUFXMkYsSUFBUyxJQUFBLEVBQU14SSxLQUFLNkMsRUFBQUE7TUFDeEMsQ0FBQTtJQUFFLENBQUEsQ0FBQSxLRGhCTkE7QUM5QkEyRixRQUFBQSxJQUNBRyxJQUNBQyxJQUNBQyxJQUNBQztFRDBCQSxHQUFBLEVBQUFoSyxJQUFBLENBQUEsRUFBQSxLQUFBLFFBQUEsS0FoQkEsV0FBQTtBQUNFLFdBQU82RixFQUFjd0U7RUFDdkIsRUFBQSxDQUFBLENBQUEsR0FBQXJLO0FBQUEsR0FOK0I4SSxFQUFBQTtBQUFBQSxTRWRSd0IsS0FBQUE7QUFDdkIsTUFBQWhNLEtBQWU7QUFFZixTQUFBLEtBQVVpTSxLQUFTLENBQUEsRUFBQS9JLE1BQUErQixLQUFBMkUsU0FBQUEsRUFBS3NDLE9BQ3RCLFNBQUNDLElBQWNDLElBQUFBO0FBQVcsV0FBQXBNLEtBQWdCb00sTUFBQUE7RUFBRyxHQUM3QyxFQUFBO0FBRUo7QUFFZ0IsU0FBQSxLQUFBO0FBR2QsU0FBTyxDQUFBLEVBQUFsSixNQUFBK0IsS0FBQTJFLFNBQUFBLEVBQ0p2QixJQUFJLFNBQUM1RyxJQUFBQTtBQUFDLFdBQUF6QixLQUFVeUIsR0FBRStFLFNBQUFBLElBQWE7RUFBRSxDQUFBLEVBQ2pDaUQsT0FBTyxTQUFDaEksSUFBQUE7QUFBQUEsV0FBT0E7RUFBQSxDQUFBLEVBQ2Z5SyxPQUFPLFNBQUNGLElBQVdHLElBQUFBO0FBQUFBLFlBQVlILE1BQWEsTUFBRSxNQUFJRztFQUFJLEdBQUksRUFBQSxFQUMxRGIsS0FBQUE7QUFDTDtBQ2ZzQixJQ0pldEw7QURJZixJQ0ppQlk7QURJakIsSUNKbUJyQjtBREluQixJQ0pxQm9CO0FESXJCLElBU2hCMEwsS0FRSnRCLDBCQUFBQSxJQUFBQTtBQUFBQSxXQUFBQSxLQUFBQTtBQUFBQSxXQUFBQSxHQUFBQSxNQUFBQSxNQUFBQSxTQUFBQSxLQUFBQTtFQUFBQTtBQVJxQ1AsU0FRckNPLEVBQUFBLElBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLFVBQUFBLFdBQUEsU0FBU3VCLElBQUFBO0FBQ1AsUUFBQSxDQUFLdE4sS0FBS0MsTUFBTW1NLFFBQVMsUUFBY2tCO0FBRXZDLFFBQWFDLEtBQUcsQ0FBRTtBQVVsQixXQVJJdk4sS0FBS0MsTUFBTXVOLFFBQ2JELEdBQWEsTUFBSXZOLEtBQUtDLE1BQU11TixJQUFJRixHQUFRRSxLQUFLeE4sS0FBS0MsTUFBTW1NLE9BQUFBLElBR3REcE0sS0FBS0MsTUFBTXdOLFNBQ2JGLEdBQWMsT0FBSXZOLEtBQUtDLE1BQU13TixLQUFLSCxHQUFRRyxNQUFNek4sS0FBS0MsTUFBTW1NLE9BQUFBLElBRzdERixFQUFBLENBQUEsR0FDS29CLElBQ0FDLEVBQUFBO0VBRVAsR0FyQkF0RixFQUFBb0YsSUFBQSxDQUFBLEVBQUF0SyxLQUFBLFFBQUF3RyxLQUFBLFdBQUE7QUFDRSxXQUFvQmhCLEVBQUNtRjtFQUN2QixFQUFBLENBQUEsQ0FBQSxHQU5xQ2xDO0FBQUFBLEdBQUFBLEVBQUFBO0FBVGpCLElDSnVCcEssS0FBRTtBREl6QixJQ0oyQjZCLEtBQUUsQ0FBQTtBREk3QixJQ0pnQ1osS0FBRSxDQUFBO0FESWxDLElDSnFDSyxLQUFFOUMsRUFBRTZCO0FESXpDLElDSjZDYSxLQUFFMUMsRUFBRXVCO0FESWpELElDSnFEeUIsS0FBRWhELEVBQUVvRztBREl6RCxJQ0pnRWpHLEtBQUVILEVBQUVnQjtBRElwRSxJQ0p3RXNDLEtBQUV0RCxFQUFFc0g7QUFBUSxTQUFTcEgsR0FBRWtCLElBQUVULElBQUFBO0FBQUdYLElBQUVzQyxPQUFLdEMsRUFBRXNDLElBQUlOLElBQUVaLElBQUVJLE1BQUdiLEVBQUFBLEdBQUdhLEtBQUU7QUFBRSxNQUFJTyxLQUFFQyxHQUFFK0wsUUFBTS9MLEdBQUUrTCxNQUFJLEVBQUN2TixJQUFHLENBQUEsR0FBRzhCLEtBQUksQ0FBQSxFQUFBO0FBQUssU0FBT2xCLE1BQUdXLEdBQUV2QixHQUFHSSxVQUFRbUIsR0FBRXZCLEdBQUdhLEtBQUssRUFBQzJNLEtBQUl2TCxHQUFBQSxDQUFBQSxHQUFJVixHQUFFdkIsR0FBR1ksRUFBQUE7QUFBRTtBQUFDLFNBQVNyQixHQUFFQyxJQUFBQTtBQUFHLFNBQU93QixLQUFFLElBQVMsU0FBV3hCLElBQUVXLElBQUVvQixJQUFBQTtBQUFHLFFBQUlQLEtBQUV0QixHQUFFa0IsTUFBSSxDQUFBO0FBQUcsUUFBR0ksR0FBRUosSUFBRXBCLElBQUFBLENBQUd3QixHQUFFUixRQUFNUSxHQUFFaEIsS0FBRyxDQUFReU4sR0FBQUEsUUFBU3ROLEVBQUFBLEdBQUcsU0FBU1gsSUFBQUE7QUFBRyxVQUFJb0IsS0FBRUksR0FBRTBNLE1BQUkxTSxHQUFFME0sSUFBSSxDQUFBLElBQUcxTSxHQUFFaEIsR0FBRyxDQUFBLEdBQUd3QixLQUFFUixHQUFFSixFQUFFQSxJQUFFcEIsRUFBQUE7QUFBR29CLE1BQUFBLE9BQUlZLE9BQUlSLEdBQUUwTSxNQUFJLENBQUNsTSxJQUFFUixHQUFFaEIsR0FBRyxDQUFBLENBQUEsR0FBSWdCLEdBQUVSLElBQUk4RyxTQUFTLENBQUEsQ0FBQTtJQUFJLENBQUEsR0FBR3RHLEdBQUVSLE1BQUlnQixJQUFBQSxDQUFHQSxHQUFFckIsSUFBRztBQUFDcUIsU0FBRXJCLElBQUFBO0FBQUssVUFBSTBDLEtBQUVyQixHQUFFNkQ7QUFBc0I3RCxTQUFFNkQsd0JBQXNCLFNBQVM3RixJQUFFb0IsSUFBRVksSUFBQUE7QUFBRyxZQUFBLENBQUlSLEdBQUVSLElBQUkrTSxJQUFJLFFBQUE7QUFBUyxZQUFJcE4sS0FBRWEsR0FBRVIsSUFBSStNLElBQUl2TixHQUFHcUssT0FBTyxTQUFTN0ssSUFBQUE7QUFBRyxpQkFBT0EsR0FBRWdCO1FBQUcsQ0FBQTtBQUFHLFlBQUdMLEdBQUV3TixNQUFNLFNBQVNuTyxJQUFBQTtBQUFHLGlCQUFBLENBQU9BLEdBQUVrTztRQUFHLENBQUEsRUFBRyxRQUFBLENBQU83SyxNQUFHQSxHQUFFZ0QsS0FBS2pHLE1BQUtKLElBQUVvQixJQUFFWSxFQUFBQTtBQUFHLFlBQUlELEtBQUFBO0FBQUssZUFBT3BCLEdBQUVtRixRQUFRLFNBQVM5RixJQUFBQTtBQUFHLGNBQUdBLEdBQUVrTyxLQUFJO0FBQUMsZ0JBQUk5TSxLQUFFcEIsR0FBRVEsR0FBRyxDQUFBO0FBQUdSLFlBQUFBLEdBQUVRLEtBQUdSLEdBQUVrTyxLQUFJbE8sR0FBRWtPLE1BQUFBLFFBQVc5TSxPQUFJcEIsR0FBRVEsR0FBRyxDQUFBLE1BQUt1QixLQUFBQTtVQUFLO1FBQUMsQ0FBQSxHQUFBLEVBQUEsQ0FBTUEsTUFBR1AsR0FBRVIsSUFBSVgsVUFBUUwsUUFBQUEsQ0FBTXFELE1BQUdBLEdBQUVnRCxLQUFLakcsTUFBS0osSUFBRW9CLElBQUVZLEVBQUFBO01BQUc7SUFBQztBQUFDLFdBQU9SLEdBQUUwTSxPQUFLMU0sR0FBRWhCO0VBQUUsR0FBamxCeU4sSUFBRWpPLEVBQUFBO0FBQUU7QUFBOGtCLFNBQVMyQyxHQUFFaEMsSUFBRW9CLElBQUFBO0FBQUcsTUFBSVAsS0FBRXRCLEdBQUVrQixNQUFJLENBQUE7QUFBQSxHQUFJcEIsRUFBRXdGLE9BQUtqRCxHQUFFZixHQUFFdU0sS0FBSWhNLEVBQUFBLE1BQUtQLEdBQUVoQixLQUFHRyxJQUFFYSxHQUFFTyxJQUFFQSxJQUFFQyxHQUFFK0wsSUFBSXpMLElBQUlqQixLQUFLRyxFQUFBQTtBQUFHO0FBQWlGLFNBQVNqQixHQUFFUCxJQUFBQTtBQUFHLFNBQU93QixLQUFFLEdBQUU0TSxHQUFFLFdBQUE7QUFBVyxXQUFNLEVBQUMvRyxTQUFRckgsR0FBQUE7RUFBRSxHQUFFLENBQUEsQ0FBQTtBQUFHO0FBQXNMLFNBQVNvTyxHQUFFcE8sSUFBRWdDLElBQUFBO0FBQUcsTUFBSXJCLEtBQUVULEdBQUVrQixNQUFJLENBQUE7QUFBRyxTQUFPbUIsR0FBRTVCLEdBQUVvTixLQUFJL0wsRUFBQUEsS0FBSXJCLEdBQUVxTixNQUFJaE8sR0FBQUEsR0FBSVcsR0FBRW9CLElBQUVDLElBQUVyQixHQUFFMkIsTUFBSXRDLElBQUVXLEdBQUVxTixPQUFLck4sR0FBRUg7QUFBRTtBQUFxaUIsU0FBU1UsS0FBQUE7QUFBSSxXQUFRRSxJQUFFQSxLQUFFaUMsR0FBRWdMLE1BQUFBLElBQVMsS0FBR2pOLEdBQUVhLE9BQUtiLEdBQUUyTSxJQUFJLEtBQUE7QUFBSTNNLElBQUFBLEdBQUUyTSxJQUFJekwsSUFBSXdELFFBQVEvRSxFQUFBQSxHQUFHSyxHQUFFMk0sSUFBSXpMLElBQUl3RCxRQUFRdEQsRUFBQUEsR0FBR3BCLEdBQUUyTSxJQUFJekwsTUFBSSxDQUFBO0VBQXVDLFNBQTlCTixJQUFBQTtBQUFHWixJQUFBQSxHQUFFMk0sSUFBSXpMLE1BQUksQ0FBQSxHQUFHdEMsRUFBRWEsSUFBSW1CLElBQUVaLEdBQUVRLEdBQUFBO0VBQUk7QUFBQztBQUFDNUIsRUFBRTZCLE1BQUksU0FBUzdCLElBQUFBO0FBQUdnQyxPQUFFLE1BQUtjLE1BQUdBLEdBQUU5QyxFQUFBQTtBQUFFLEdBQUVBLEVBQUV1QixNQUFJLFNBQVN2QixJQUFBQTtBQUFHMEMsUUFBR0EsR0FBRTFDLEVBQUFBLEdBQUdvQixLQUFFO0FBQUUsTUFBSVcsTUFBR0MsS0FBRWhDLEdBQUVnQixLQUFLK007QUFBSWhNLEVBQUFBLE9BQUlwQixPQUFJcUIsTUFBR0QsR0FBRU8sTUFBSSxDQUFBLEdBQUdOLEdBQUVNLE1BQUksQ0FBQSxHQUFHUCxHQUFFdkIsR0FBR3NGLFFBQVEsU0FBUzlGLElBQUFBO0FBQUdBLElBQUFBLEdBQUVrTyxRQUFNbE8sR0FBRVEsS0FBR1IsR0FBRWtPLE1BQUtsTyxHQUFFZ08sTUFBSXZMLElBQUV6QyxHQUFFa08sTUFBSWxPLEdBQUUrQixJQUFBQTtFQUFRLENBQUEsTUFBS0EsR0FBRU8sSUFBSXdELFFBQVEvRSxFQUFBQSxHQUFHZ0IsR0FBRU8sSUFBSXdELFFBQVF0RCxFQUFBQSxHQUFHVCxHQUFFTyxNQUFJLENBQUEsS0FBSzNCLEtBQUVxQjtBQUFDLEdBQUVoQyxFQUFFb0csU0FBTyxTQUFTaEYsSUFBQUE7QUFBRzRCLFFBQUdBLEdBQUU1QixFQUFBQTtBQUFHLE1BQUlJLEtBQUVKLEdBQUVKO0FBQUlRLEVBQUFBLE1BQUdBLEdBQUV1TSxRQUFNdk0sR0FBRXVNLElBQUl6TCxJQUFJMUIsV0FBUyxNQUFJeUMsR0FBRWhDLEtBQUtHLEVBQUFBLEtBQUlPLE9BQUkvQixFQUFFc08sMkJBQXlCdk0sS0FBRS9CLEVBQUVzTywwQkFBd0JuTSxJQUFHakIsRUFBQUEsSUFBSU0sR0FBRXVNLElBQUl2TixHQUFHc0YsUUFBUSxTQUFTOUYsSUFBQUE7QUFBR0EsSUFBQUEsR0FBRStCLE1BQUkvQixHQUFFK04sTUFBSS9OLEdBQUUrQixJQUFHL0IsR0FBRWdPLFFBQU12TCxPQUFJekMsR0FBRVEsS0FBR1IsR0FBRWdPLE1BQUtoTyxHQUFFK0IsSUFBQUEsUUFBUy9CLEdBQUVnTyxNQUFJdkw7RUFBQyxDQUFBLElBQUk5QixLQUFFcUIsS0FBRTtBQUFJLEdBQUVoQyxFQUFFZ0IsTUFBSSxTQUFTSSxJQUFFWSxJQUFBQTtBQUFHQSxFQUFBQSxHQUFFRixLQUFLLFNBQVNWLElBQUFBO0FBQUcsUUFBQTtBQUFJQSxNQUFBQSxHQUFFa0IsSUFBSXdELFFBQVEvRSxFQUFBQSxHQUFHSyxHQUFFa0IsTUFBSWxCLEdBQUVrQixJQUFJdUksT0FBTyxTQUFTN0ssSUFBQUE7QUFBRyxlQUFBLENBQU9BLEdBQUVRLE1BQUlnQyxHQUFFeEMsRUFBQUE7TUFBRSxDQUFBO0lBQXNFLFNBQTdEVyxJQUFBQTtBQUFHcUIsTUFBQUEsR0FBRUYsS0FBSyxTQUFTOUIsSUFBQUE7QUFBR0EsUUFBQUEsR0FBRXNDLFFBQU10QyxHQUFFc0MsTUFBSSxDQUFBO01BQUcsQ0FBQSxHQUFHTixLQUFFLENBQUEsR0FBR2hDLEVBQUVhLElBQUlGLElBQUVTLEdBQUVRLEdBQUFBO0lBQUk7RUFBQyxDQUFBLEdBQUd6QixNQUFHQSxHQUFFaUIsSUFBRVksRUFBQUE7QUFBRSxHQUFFaEMsRUFBRXNILFVBQVEsU0FBU2xHLElBQUFBO0FBQUdrQyxRQUFHQSxHQUFFbEMsRUFBQUE7QUFBRyxNQUFJWSxJQUFFckIsS0FBRVMsR0FBRUo7QUFBSUwsRUFBQUEsTUFBR0EsR0FBRW9OLFFBQU1wTixHQUFFb04sSUFBSXZOLEdBQUdzRixRQUFRLFNBQVM5RixJQUFBQTtBQUFHLFFBQUE7QUFBSWUsU0FBRWYsRUFBQUE7SUFBZSxTQUFOQSxJQUFBQTtBQUFHZ0MsTUFBQUEsS0FBRWhDO0lBQUM7RUFBQyxDQUFBLEdBQUdXLEdBQUVvTixNQUFBQSxRQUFXL0wsTUFBR2hDLEVBQUVhLElBQUltQixJQUFFckIsR0FBRWlCLEdBQUFBO0FBQUs7QUFBRSxJQUFJTixLQUFFLGNBQUEsT0FBbUJnTjtBQUFzQixTQUFTbk0sR0FBRW5DLElBQUFBO0FBQUcsTUFBSW9CLElBQUVZLEtBQUUsV0FBQTtBQUFXdU0saUJBQWE1TixFQUFBQSxHQUFHVyxNQUFHa04scUJBQXFCcE4sRUFBQUEsR0FBR00sV0FBVzFCLEVBQUFBO0VBQUUsR0FBRVcsS0FBRWUsV0FBV00sSUFBRSxHQUFBO0FBQUtWLFNBQUlGLEtBQUVrTixzQkFBc0J0TSxFQUFBQTtBQUFHO0FBQUMsU0FBU2pCLEdBQUVmLElBQUFBO0FBQUcsTUFBSW9CLEtBQUVZLElBQUVyQixLQUFFWCxHQUFFZ0I7QUFBSSxnQkFBQSxPQUFtQkwsT0FBSVgsR0FBRWdCLE1BQUFBLFFBQVdMLEdBQUFBLElBQUtxQixLQUFFWjtBQUFDO0FBQUMsU0FBU29CLEdBQUV4QyxJQUFBQTtBQUFHLE1BQUlvQixLQUFFWTtBQUFFaEMsRUFBQUEsR0FBRWdCLE1BQUloQixHQUFFUSxHQUFBQSxHQUFLd0IsS0FBRVo7QUFBQztBQUFDLFNBQVNtQixHQUFFdkMsSUFBRW9CLElBQUFBO0FBQUcsU0FBQSxDQUFPcEIsTUFBR0EsR0FBRVksV0FBU1EsR0FBRVIsVUFBUVEsR0FBRVUsS0FBSyxTQUFTVixJQUFFWSxJQUFBQTtBQUFHLFdBQU9aLE9BQUlwQixHQUFFZ0MsRUFBQUE7RUFBRSxDQUFBO0FBQUU7QUFBQyxTQUFTaU0sR0FBRWpPLElBQUVvQixJQUFBQTtBQUFHLFNBQU0sY0FBQSxPQUFtQkEsS0FBRUEsR0FBRXBCLEVBQUFBLElBQUdvQjtBQUFDO0FBQUEsU0FBQSxLQUFBO0FDSTV1RyxVREp1M0MsU0FBV3BCLElBQUFBO0FBQUcsUUFBSVcsS0FBRXFCLEdBQUUxQixRQUFRTixHQUFFZ0IsR0FBQUEsR0FBS2UsS0FBRTdCLEdBQUVrQixNQUFJLENBQUE7QUFBRyxXQUFPVyxHQUFFVSxJQUFFekMsSUFBRVcsTUFBRyxRQUFNb0IsR0FBRXZCLE9BQUt1QixHQUFFdkIsS0FBQUEsTUFBTUcsR0FBRTBFLElBQUlyRCxFQUFBQSxJQUFJckIsR0FBRU4sTUFBTTJFLFNBQU9oRixHQUFFUTtFQUFFLEdDSXY5Q2lPLEVBQUFBO0FBQ3BCO0FDTEEsSUFBZUMsS0FBQSxFQUNiQyxRQUFRLEVBQ05DLGFBQWEsb0JBQUEsR0FFZmpOLE1BQU0sRUFDSmtOLFNBQVMseUJBQ1RDLFVBQVUseUJBQUEsR0FFWkMsWUFBWSxFQUNWQyxVQUFVLFlBQ1ZDLE1BQU0sUUFDTkMsVUFBVSxTQUFDQyxJQUFNQyxJQUFBQTtBQUFrQkQsU0FBQUEsVUFBQUEsS0FBV0MsU0FBQUE7QUFBSyxHQUNuREQsTUFBTSxTQUFDQSxJQUFBQTtBQUFpQkEsU0FBQUEsVUFBQUE7QUFBSSxHQUM1QkUsU0FBUyxXQUNUQyxJQUFJLE1BQ0pDLElBQUksTUFDSkMsU0FBUyxVQUFBLEdBRVhDLFNBQVMsY0FDVEMsZ0JBQWdCLDZCQUNoQkMsT0FBTyw0Q0FBQTtBQXBCVCxJQ01hQyxLQUFBQSw0QkFBQUE7QUFJWCxXQUFZQyxHQUFBQSxJQUFBQTtBQUFtQnpQLFNBSGQwUCxZQUFBQSxRQUFTMVAsS0FDVDJQLG1CQUFBQSxRQUdmM1AsS0FBSzBQLFlBQVlELElBQ2pCelAsS0FBSzJQLG1CQUFtQnJCO0VBQzFCO0FBQUMsTUFBQTFPLEtBQUFvQixHQUFBO0FBNkNBLFNBQUFwQixHQXBDRGdRLFlBQUEsU0FBVUMsSUFBaUJDLElBQUFBO0FBQ3pCLFFBQUEsQ0FBS0EsTUFBQUEsQ0FBU0QsR0FBUyxRQUFXO0FBRWxDLFFBQU1FLEtBQVdGLEdBQVFHLE1BQU0sR0FBQSxHQUN6QmpOLEtBQU1nTixHQUFTLENBQUE7QUFFckIsUUFBSUQsR0FBSy9NLEVBQUFBLEdBQU07QUFDYixVQUFTa04sS0FBR0gsR0FBSy9NLEVBQUFBO0FBRWpCLGFBQW1CLFlBQUEsT0FBTGtOLEtBQ0wsV0FBQTtBQUFBLGVBQWlCQTtNQUFBLElBQ0EsY0FBQSxPQUFSQSxLQUVqQkEsS0FDWWpRLEtBQUM0UCxVQUFVRyxHQUFTN0wsTUFBTSxDQUFBLEVBQUdnTSxLQUFLLEdBQUEsR0FBTUQsRUFBQUE7SUFFdEQ7QUFFRCxXQUFPO0VBQ1QsR0FBQ3JILEdBRUR1SCxZQUFBLFNBQVVOLElBQUFBO0FBQ1IsUUFDaUJPLElBRERDLEtBQUdyUSxLQUFLNFAsVUFBVUMsSUFBUzdQLEtBQUswUCxTQUFBQTtBQVNoRCxZQUxFVSxLQURFQyxNQUdjclEsS0FBSzRQLFVBQVVDLElBQVM3UCxLQUFLMlAsZ0JBQUFBLEtBQUFBLEdBSzlDOUUsTUFBQUEsUUFBQSxDQUFBLEVBQUEzRyxNQUFBK0IsS0FBQTJFLFdBQUEsQ0FBQSxDQUFBLElBRU1pRjtFQUNULEdBQUNMO0FBQUEsR0FBQTtBQUdhYyxTQUFBQSxLQUFBQTtBQUNkLE1BQU1DLEtBQVNDLEdBQUFBO0FBRWYsU0FBaUJYLFNBQUFBLElBQUFBO0FBQ2YsUUFBQVk7QUFBQSxZQUFPRixLQUFBQSxHQUFPRyxZQUFXUCxVQUFTdEYsTUFBQTRGLElBQUEsQ0FBQ1osRUFBQUEsRUFBTzdELE9BQUEsQ0FBQSxFQUFBOUgsTUFBQStCLEtBQUEyRSxXQUFBLENBQUEsQ0FBQSxDQUFBO0VBQzVDO0FBQ0Y7QUNuRU8sSUFBQSxLQUFzQixTQUFDK0YsSUFBQUE7QUFBWSxTQUFBLFNBQUN6TCxJQUFBQTtBQUN6QyxXQUNLQSxFQUFBQSxDQUFBQSxHQUFBQSxJQUNIcUosRUFBQUEsUUFBUSxFQUNObkMsU0FBU3VFLEdBQUFBLEVBQUFBLENBQUFBO0VBR2Y7QUFBQztBQUFBLFNBQUEsS0FBQTtBQ0hDLFNBRGVILEdBQUFBLEVBQ0RJO0FBQ2hCO0FDRndCQyxTQUFBQSxHQUFlbkUsSUFBQUE7QUFDckMsTUFBTWtFLEtBQVFFLEdBQUFBLEdBQ2RDLEtBQThCQyxHQUFTdEUsR0FBU2tFLEdBQU1LLFNBQUFBLENBQUFBLENBQUFBLEdBQS9DaEssS0FBQUEsR0FBQUEsQ0FBQUEsR0FBU2lLLEtBQVVILEdBQUEsQ0FBQTtBQWMxQixTQVpBSSxHQUFVLFdBQUE7QUFTUixXQVJvQlAsR0FBTVEsVUFBVSxXQUFBO0FBQ2xDLFVBQWFDLEtBQUczRSxHQUFTa0UsR0FBTUssU0FBQUEsQ0FBQUE7QUFFM0JoSyxNQUFBQSxPQUFZb0ssTUFDZEgsR0FBV0csRUFBQUE7SUFFZixDQUFBO0VBR0YsR0FBRyxDQUFBLENBQUEsR0FHTHBLO0FBQUE7QUNJZ0JxSyxTQUFBQSxLQUFBQTtBQUNkLE1BQUFDLElBQUFSLEtBQWtDQyxHQUFBQSxNQUVoQ1EsR0FGS0MsS0FBV0MsR0FBQUEsQ0FBQUEsR0FBQUEsS0FHbEJYLEdBQUEsQ0FBQSxHQUFBM1AsS0FBZW9QLEdBQUFBLEdBQUFBLEtBQ0RELEdBQU9oQyxRQUFBQSxLQUNYK0IsR0FBQUEsR0FDRnFCLEtBQWFiLEdBQUFBLEVBQWJhLFVBQUFBLEtBQ01kLEdBQVksU0FBQzNMLElBQUFBO0FBQUFBLFdBQWVBLEdBQUNxSjtFQUFNLENBQUE7QUFFakQ0QyxLQUFVLFdBQUE7QUFDSE0sSUFBQUEsTUFFTEEsR0FBVTlGLFNBQVMsRUFDakJTLFNBQUFBLFFBQVNsSCxLQUFBQSxTQUFBQSxHQUFPa0gsUUFBQUEsQ0FBQUE7RUFFcEIsR0FBRyxDQUFDbEgsSUFBT3VNLEVBQUFBLENBQUFBLEdBRVhOLEdBQVUsV0FBQTtBQUVOTyxJQUFBQSxHQURFelIsR0FBTTJSLFNBRU4sSUFBNEJ2RSxHQUFDLEVBQzNCakIsU0FBU25NLEdBQU1tTSxTQUNmb0IsS0FBS3ZOLEdBQU0yUixPQUFPcEUsS0FDbEJDLE1BQU14TixHQUFNMlIsT0FBT25FLEtBQUFBLENBQUFBLElBS3JCLElBQUl0QixHQUFtQixFQUNyQkMsU0FBU25NLEdBQU1tTSxTQUNmRyxTQUFTZ0UsR0FBT3NCLFVBQVV0QixHQUFPc0IsT0FBT3RGLFNBQ3hDQyxxQkFDRXZNLEdBQU11TSx1QkFBQUEsV0FDTnZNLEdBQU11TSxxQkFDUkUsVUFBVXpNLEdBQU15TSxTQUFBQSxDQUFBQSxDQUFBQSxHQU1sQnpNLEdBQU1tTSxXQUFTdUYsR0FBU0csR0FBc0I3UixHQUFNbU0sT0FBQUEsQ0FBQUE7RUFDMUQsR0FBRyxDQUFDbk0sRUFBQUEsQ0FBQUEsR0FFSmtSLEdBQVUsV0FBQTtBQUNSLFFBQUtNLEdBSUwsUUFGQWxCLEdBQU93QixTQUFTQyxTQUF5QlAsRUFBQUEsR0FFNUJsQixXQUFBQTtBQUFBQSxhQUFBQSxHQUFPd0IsU0FBU0UsV0FBMkJSLEVBQUFBO0lBQVU7RUFDcEUsR0FBRyxDQUFDbEIsSUFBUWtCLEVBQUFBLENBQUFBO0FBRVosTUMzRUFTLElBQ0FDLElBRVdDLElEd0VXQyxNUDVFNHlDLFNBQVd6UyxJQUFFb0IsSUFBQUE7QUFBRyxXQUFPSSxLQUFFLEdBQUU0TSxHQUFFLFdBQUE7QUFBVyxhQUFPcE87SUFBQyxHQUFFb0IsRUFBQUE7RUFBRSxJUUN0M0NrUixLRDZFSSxTQUFDek4sSUFBQUE7QUFDS0EsSUFBQUEsR0FBTTZOLGtCQUFrQkMsb0JBQzFCWixHQUFTRyxHQUFzQnJOLEdBQU02TixPQUFPMU4sS0FBQUEsQ0FBQUE7RUFFaEQsR0NoRkp1TixLRGlGSVYsY0FBcUJwRSxLQUNqQnBOLEdBQU11UyxtQkFBbUIsTUFDekIsR0M5RU4sV0FBQTtBQUFBLFFBQUE3SCxLQUFBQztBQUFBLFdBQUEsSUFBQSxRQUFZLFNBQUM2SCxJQUFBQTtBQUNQTCxNQUFBQSxNQUNGakUsYUFBYWlFLEVBQUFBLEdBR2ZBLEtBQVU5USxXQUFXLFdBQUE7QUFBQSxlQUFBMUIsR0FBY3NTLEdBQUFBLE1BQUFBLFFBQUFBLENBQUFBLEVBQUFBLE1BQUFBLEtBQUFBLEVBQUFBLENBQUFBLENBQUFBO01BQWMsR0FBRUMsRUFBQUE7SUFDckQsQ0FBQTtFQUFFLElEMEVGLENBQUNsUyxJQUFPd1IsRUFBQUEsQ0FBQUE7QUFHVixTQUNPbFAsRUFBQSxPQUFBLEVBQUF5SyxXQUFXQSxHQUFVMEYsR0FBVSxVQUFVLFNBQUZuQixLQUFFaEIsR0FBT3ZELGFBQUFBLFNBQVB1RSxHQUFrQmhELE1BQUFBLENBQUFBLEVBQUFBLEdBQzlEaE0sRUFBQSxTQUFBLEVBQ0U3QixNQUFLLFVBQ0w4TixhQUFhck8sR0FBRSxvQkFBQSxHQUNmLGNBQVlBLEdBQUUsb0JBQUEsR0FDZHdTLFNBQVNOLElBQ1RyRixXQUFXMEYsR0FBVTFGLEdBQVUsT0FBQSxHQUFVQSxHQUFVLFVBQVUsT0FBQSxDQUFBLEdBQzdENEYsZUFBYzFOLFFBQUFBLEtBQUFBLFNBQUFBLEdBQU9rSCxZQUFXLEdBQUEsQ0FBQSxDQUFBO0FBSXhDO0FFakdzQixJQU9oQnlHLEtBQ00vRywwQkFBQUEsSUFBQUE7QUFBQUEsV0FBQUEsS0FBQUE7QUFBQUEsV0FBQUEsR0FBQUEsTUFBQUEsTUFBQUEsU0FBQUEsS0FBQUE7RUFBQUE7QUFBQUEsSUFBQUEsSUFBQUEsRUFBQUE7QUFBQUEsTUFBQUEsS0FBQUEsR0FBQUE7QUFEa0JOLFNBQ2xCTSxHQUFBQSxnQkFBQSxXQUFBO0FBQ1IsUUFBSWdILE1BQU1DLE9BQU8vUyxLQUFLQyxNQUFNK1MsS0FBQUEsQ0FBQUEsS0FBV0YsTUFBTUMsT0FBTy9TLEtBQUtDLE1BQU04TyxJQUFBQSxDQUFBQSxFQUM3RCxPQUFNa0UsTUFBTSwyQkFBQTtFQUVoQixHQUFDckssR0FNU21ELFdBQUEsU0FBU3RGLElBQUFBO0FBQ2pCLFFBQU1zSSxLQUFPL08sS0FBS0MsTUFBTThPO0FBSXhCLFdBQU8sSUFBV3RGLEVBQUNoRCxHQUFLaUQsS0FBS3hGLE1BSGY2SyxLQUFPL08sS0FBS0MsTUFBTStTLFFBQ25CakUsS0FBTyxLQUFLL08sS0FBS0MsTUFBTStTLEtBQUFBLENBQUFBO0VBR3RDLEdBVkEvSyxFQUFBNEssSUFBQSxDQUFBLEVBQUE5UCxLQUFBLFFBQUF3RyxLQUFBLFdBQUE7QUFDRSxXQUFvQmhCLEVBQUMySztFQUN2QixFQUFBLENBQUEsQ0FBQSxHQVQ0QjFIO0FBQUFBLEdBQUFBLEVBQUFBO0FBUFIsSUNTaEIySCxLQVFKcEgsMEJBQUFBLElBQUFBO0FBQUFBLFdBQUFBLEtBQUFBO0FBQUFBLFdBQUFBLEdBQUFBLE1BQUFBLE1BQUFBLFNBQUFBLEtBQUFBO0VBQUFBO0FBUmtDUCxTQVFsQ08sRUFBQUEsSUFBQUEsRUFBQUEsR0FBQUEsR0FBQUEsVUFBQUEsV0FBQSxTQUFTdUIsSUFBQUE7QUFDUCxRQUFNQyxLQUFVLENBQUE7QUFrQmhCLFdBaEJJdk4sS0FBS0MsTUFBTXVOLFFBQ2JELEdBQWEsTUFBSXZOLEtBQUtDLE1BQU11TixJQUMxQkYsR0FBUUUsS0FDUnhOLEtBQUtDLE1BQU04TyxNQUNYL08sS0FBS0MsTUFBTStTLEtBQUFBLElBSVhoVCxLQUFLQyxNQUFNd04sU0FDYkYsR0FBYyxPQUFJdk4sS0FBS0MsTUFBTXdOLEtBQzNCSCxHQUFRRyxNQUNSek4sS0FBS0MsTUFBTThPLE1BQ1gvTyxLQUFLQyxNQUFNK1MsS0FBQUEsSUFJZjlHLEVBQUEsQ0FBQSxHQUNLb0IsSUFDQUMsRUFBQUE7RUFFUCxHQTNCQXRGLEVBQUFrTCxJQUFBLENBQUEsRUFBQXBRLEtBQUEsUUFBQXdHLEtBQUEsV0FBQTtBQUNFLFdBQW9CaEIsRUFBQzZLO0VBQ3ZCLEVBQUEsQ0FBQSxDQUFBLEdBTmtDNUg7QUFBQUEsR0FBQUEsRUFBQUE7QUNRcEI2SCxTQUFBQSxLQUFBQTtBQUNkLE1BQVk5QyxLQUFHQyxHQUFBQSxHQUNmOEMsS0FTSS9DLEdBQU81QixZQVJUaUQsS0FBQUEsR0FBQUEsUUFDQTJCLEtBQUFBLEdBQUFBLFNBQUFBLEtBQUFBLFdBQUFBLE1BQWNDLElBQUFDLEtBQUFILEdBQ2RJLFlBQUFBLEtBQUFBLFdBQVVELE1BQU9BLElBQUFFLEtBQUFMLEdBQ2pCTSxZQUFBQSxLQUFBQSxXQUFVRCxNQUFPQSxJQUFBRSxLQUFBUCxHQUNqQlEsY0FBQUEsS0FBQUEsV0FBZUQsS0FBQSxJQUNmYixJQUFBQSxLQUFBQSxHQUFBQSxPQUFBQSxLQUFBQSxXQUFRZSxLQUFBLEtBQUE5USxJQUFBbkQsS0FBQUYsR0FDUm1QLE1BQUFBLEtBQUFBLFdBQUlpRixLQUFHLElBQUNBLElBQUFDLEtBQUFYLEdBQ1JZLG1CQUFBQSxLQUFBQSxXQUFvQkQsTUFHdEJBLElBQWV4QyxLQUFHMEMsR0FBZ0QsSUFBQSxHQUNsRXBELEtBQXNDQyxHQUFTakMsRUFBQUEsR0FBeENxRixLQUFXckQsR0FBQSxDQUFBLEdBQUVzRCxLQUFjdEQsR0FBQSxDQUFBLEdBQ1JDLEtBQUFBLEdBQVMsQ0FBQSxHQUE1QnNELElBQU9DLEdBQUFBLENBQUFBLEdBQUFBLEtBQ2RDLEdBQUEsQ0FBQSxHQUFPclUsS0FBR21RLEdBQUFBO0FBRVZhLEtBQVUsV0FBQTtBQXVDUixXQXRDSVMsTUFDRkgsR0FBVXhLLFVBQVUsSUFBSWtNLEdBQXNCLEVBQzVDSCxPQUFPQSxJQUNQakUsTUFBTXFGLElBQ041RyxLQUFLb0UsR0FBT3BFLEtBQ1pDLE1BQU1tRSxHQUFPbkUsS0FBQUEsQ0FBQUEsR0FHZjhDLEdBQU93QixTQUFTQyxTQUFTUCxHQUFVeEssT0FBQUEsTUFFbkN3SyxHQUFVeEssVUFBVSxJQUFtQjRMLEdBQUMsRUFDdENHLE9BQU9BLElBQ1BqRSxNQUFNcUYsR0FBQUEsQ0FBQUEsR0FHUjdELEdBQU93QixTQUFTQyxTQUFTUCxHQUFVeEssT0FBQUEsSUFHakN3SyxHQUFVeEssbUJBQXdDa00sS0FDcEQ1QyxHQUFPd0IsU0FBUzFILEdBQUcsZ0JBQWdCLFNBQUNvQyxJQUFBQTtBQUFZOEgsYUFBQUEsR0FBUzlILEdBQVFqTSxNQUFBQTtJQUFPLENBQUEsSUFDL0RpUixHQUFVeEssbUJBQWtDNEwsTUFJckRwQixHQUFVeEssUUFBUW9ELEdBQUcsaUJBQWlCLFNBQUNvQyxJQUFBQTtBQUNyQzhILGFBQUFBLEdBQVM5SCxHQUFRak0sTUFBQUE7SUFBTyxDQUFBLEdBSTVCK1AsR0FBT3dCLFNBQVMxSCxHQUFHLFdBQVdvSyxFQUFBQSxHQUk5QmxFLEdBQU93QixTQUFTMUgsR0FBRyxTQUFTLFdBQUE7QUFDMUJrSyxNQUFBQSxHQUFTLENBQUEsR0FDVEYsR0FBZSxDQUFBO0lBQ2pCLENBQUEsR0FFTyxXQUFBO0FBQ0w5RCxNQUFBQSxHQUFPd0IsU0FBU0UsV0FBMkJSLEdBQVV4SyxPQUFBQSxHQUNyRHNKLEdBQU93QixTQUFTeEgsSUFBSSxXQUFXa0ssRUFBQUE7SUFDakM7RUFDRixHQUFHLENBQUEsQ0FBQTtBQUVILE1BQWNBLEtBQUcsU0FBQ0MsSUFBQUE7QUFHWlIsSUFBQUEsTUFBcUJRLE9BQXFCakQsR0FBVXhLLFlBQ3REb04sR0FBZSxDQUFBLEdBRXNCLE1BQWpDNUMsR0FBVXhLLFFBQVFoSCxNQUFNOE8sUUFDMUIwQyxHQUFVeEssUUFBUTBFLFNBQVMsRUFDekJvRCxNQUFNLEVBQUEsQ0FBQTtFQUlkLEdBRVdDLEtBQUcsV0FBQTtBQUFNMUgsV0FBQUEsS0FBS3FOLEtBQUtMLElBQVF0QixFQUFBQTtFQUFNLEdBRS9CNEIsS0FBRyxTQUFDN0YsSUFBQUE7QUFDZixRQUFJQSxNQUFRQyxHQUFBQSxLQUFXRCxLQUFPLEtBQUtBLE9BQVNxRixHQUMxQyxRQUNEO0FBRURDLElBQUFBLEdBQWV0RixFQUFBQSxHQUVmMEMsR0FBVXhLLFFBQVEwRSxTQUFTLEVBQ3pCb0QsTUFBTUEsR0FBQUEsQ0FBQUE7RUFFVjtBQW1IQSxTQUVJeE0sRUFBQSxPQUFBLEVBQUF5SyxXQUFXMEYsR0FDVDFGLEdBQVUsWUFBQSxHQUNWdUQsR0FBT3ZELFVBQVUyQixVQUFBQSxFQUFBQSxHQTFCbEJwTSxFQUFBc1MsR0FDRXRCLE1BQUFBLE1BQVdlLElBQVEsS0FDbEIvUixFQUNFLE9BQUEsRUFBQXVTLE1BQUssVUFDTCxhQUFVLFVBQ1Y5SCxXQUFXMEYsR0FDVDFGLEdBQVUsU0FBQSxHQUNWdUQsR0FBT3ZELFVBQVUrSCxpQkFBQUEsR0FFbkJDLE9BQU83VSxHQUFFLHVCQUF1QmlVLEtBQWMsR0FBR3BGLEdBQUFBLENBQUFBLEVBQUFBLEdBRWhEN08sR0FBRSxvQkFBQSxHQUF1QixLQUFBb0MsRUFBQSxLQUFBLE1BQUlwQyxHQUFDLE1BQUlpVSxLQUFjcEIsS0FBUSxFQUFBLENBQUEsR0FBVSxLQUNsRTdTLEdBQUUsZUFBQSxHQUFrQixLQUNyQm9DLEVBQUEsS0FBQSxNQUFJcEMsR0FBS21ILEtBQUFBLEtBQUsyTixLQUFLYixLQUFjLEtBQUtwQixJQUFPc0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBZSxLQUMzRG5VLEdBQUUsZUFBQSxHQUFrQixLQUFBLEVBQUEsS0FBQSxNQUFJQSxHQUFDLEtBQUltVSxDQUFBQSxDQUFBQSxHQUFjLEtBQzNDblUsR0FBRSxvQkFBQSxDQUFBLENBQUEsR0FnQlRvQyxFQUFLLE9BQUEsRUFBQXlLLFdBQVdBLEdBQVUsT0FBQSxFQUFBLEdBQ3ZCNEcsTUFDQ3JSLEVBQUEsVUFBQSxFQUNFMlMsVUFBVSxHQUNWSixNQUFLLFVBQ0xLLFVBQTBCLE1BQWhCZixJQUNWZ0IsU0FBUyxXQUFBO0FBQUEsV0FBYVIsR0FBQ1IsS0FBYyxDQUFBO0VBQUUsR0FDdkNZLE9BQU83VSxHQUFFLHFCQUFBLEdBQ1QsY0FBWUEsR0FBRSxxQkFBQSxHQUNkNk0sV0FBVzBGLEdBQ1RuQyxHQUFPdkQsVUFBVXFJLGtCQUNqQjlFLEdBQU92RCxVQUFVc0ksb0JBQUFBLEVBQUFBLEdBR2xCblYsR0FBRSxxQkFBQSxDQUFBLElBeElPLFdBQUE7QUFDbEIsUUFBSTJULE1BQWdCLEVBQ2xCLFFBQ0Q7QUFHRCxRQUFNeUIsS0FBbUJqTyxLQUFLMk4sSUFBSWpHLEdBQUFBLEdBQVM4RSxFQUFBQSxHQUU5QjBCLEtBQUdsTyxLQUFLMk4sSUFBSWIsSUFBYTlNLEtBQUttTyxNQUFNRixLQUFXLENBQUEsQ0FBQTtBQUs1RCxXQUpJbkIsS0FBYzlNLEtBQUttTyxNQUFNRixLQUFXLENBQUEsS0FBTXZHLEdBQUFBLE1BQzVDd0csS0FBWUQsTUFBWXZHLEdBQUFBLElBQVVvRixNQUlsQzdSLEVBQUNzUyxHQUFRLE1BQ043RixHQUFBQSxJQUFVdUcsTUFBWW5CLEtBQWNvQixLQUFZLEtBQy9DalQsRUFBQ3NTLEdBQ0MsTUFBQXRTLEVBQUEsVUFBQSxFQUNFMlMsVUFBVSxHQUNWSixNQUFLLFVBQ0xNLFNBQVMsV0FBQTtBQUFBLGFBQWFSLEdBQUMsQ0FBQTtJQUFFLEdBQ3pCSSxPQUFPN1UsR0FBRSxzQkFBQSxHQUNULGNBQVlBLEdBQUUsc0JBQUEsR0FDZDZNLFdBQVd1RCxHQUFPdkQsVUFBVXFJLGlCQUFBQSxHQUUzQmxWLEdBQUUsR0FBQSxDQUFBLEdBRUxvQyxFQUNFLFVBQUEsRUFBQTJTLFVBQUFBLElBQ0FsSSxXQUFXMEYsR0FDVDFGLEdBQVUsUUFBQSxHQUNWdUQsR0FBT3ZELFVBQVVxSSxnQkFBQUEsRUFBQUEsR0FHbkIsS0FBQSxDQUFBLEdBS0x4UyxNQUFNNlMsS0FBSzdTLE1BQU0wUyxFQUFBQSxFQUFVbkssS0FBQUEsQ0FBQUEsRUFDekIvQixJQUFJLFNBQUMxSCxJQUFBQTtBQUFDLGFBQWdCeVMsTUFBSXpTLEtBQUk2VDtJQUFVLENBQUEsRUFDeENuTSxJQUFJLFNBQUMxSCxJQUFBQTtBQUFBQSxhQUVGWSxFQUFBLFVBQUEsRUFBQTJTLFVBQVUsR0FDVkosTUFBSyxVQUNMTSxTQUFTLFdBQUE7QUFBTVIsZUFBQUEsR0FBUWpULEVBQUFBO01BQUUsR0FDekJxTCxXQUFXMEYsR0FDVDBCLE9BQWdCelMsS0FDWitRLEdBQ0UxRixHQUFVLGFBQUEsR0FDVnVELEdBQU92RCxVQUFVMkksdUJBQUFBLElBRW5CLE1BQ0pwRixHQUFPdkQsVUFBVXFJLGdCQUFBQSxHQUVuQkwsT0FBTzdVLEdBQUUsbUJBQW1Cd0IsS0FBSSxDQUFBLEdBQ2hDLGNBQVl4QixHQUFFLG1CQUFtQndCLEtBQUksQ0FBQSxFQUFBLEdBRXBDeEIsR0FBQyxNQUFJd0IsS0FBSSxFQUFBLENBQUE7SUFDSCxDQUFBLEdBR1pxTixHQUFBQSxJQUFVdUcsTUFBWXZHLEdBQUFBLElBQVVvRixLQUFjb0IsS0FBWSxLQUN6RGpULEVBQUNzUyxHQUNDLE1BQUF0UyxFQUFBLFVBQUEsRUFDRTJTLFVBQUFBLElBQ0FsSSxXQUFXMEYsR0FDVDFGLEdBQVUsUUFBQSxHQUNWdUQsR0FBT3ZELFVBQVVxSSxnQkFBQUEsRUFBQUEsR0FHbkIsS0FBQSxHQUVGOVMsRUFBQUEsVUFBQUEsRUFDRTJTLFVBQVUsR0FDVkosTUFBSyxVQUNMTSxTQUFTLFdBQUE7QUFBTVIsYUFBQUEsR0FBUTVGLEdBQUFBLElBQVUsQ0FBQTtJQUFFLEdBQ25DZ0csT0FBTzdVLEdBQUUsbUJBQW1CNk8sR0FBQUEsQ0FBQUEsR0FDNUIsY0FBWTdPLEdBQUUsbUJBQW1CNk8sR0FBQUEsQ0FBQUEsR0FDakNoQyxXQUFXdUQsR0FBT3ZELFVBQVVxSSxpQkFBQUEsR0FFM0JsVixHQUFDLEtBQUk2TyxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQTtFQU1sQixHQXFETzRHLEdBRUFsQyxNQUNDblIsRUFDRSxVQUFBLEVBQUEyUyxVQUFVLEdBQ1ZKLE1BQUssVUFDTEssVUFBVW5HLEdBQUFBLE1BQVlvRixLQUFjLEtBQWlCLE1BQVpwRixHQUFBQSxHQUN6Q29HLFNBQVMsV0FBQTtBQUFBLFdBQWFSLEdBQUNSLEtBQWMsQ0FBQTtFQUFFLEdBQ3ZDWSxPQUFPN1UsR0FBRSxpQkFBQSxHQUNULGNBQVlBLEdBQUUsaUJBQUEsR0FDZDZNLFdBQVcwRixHQUNUbkMsR0FBT3ZELFVBQVVxSSxrQkFDakI5RSxHQUFPdkQsVUFBVTZJLG9CQUFBQSxFQUFBQSxHQUdsQjFWLEdBQUUsaUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFNZjtBQ2xSZ0IyVixTQUFBQSxHQUFNQSxJQUF3QkMsSUFBQUE7QUFDNUMsU0FBb0IsWUFBQSxPQUFKRCxLQUNWQSxHQUFNeFYsUUFBUSxHQUFBLElBQUEsS0FDUnlWLEtBQWlCLE1BQU9DLFNBQVNGLElBQU8sRUFBQSxJQUV6Q0UsU0FBU0YsSUFBTyxFQUFBLElBSzdCQTtBQUFBO0FBRWdCRyxTQUFBQSxHQUFHSCxJQUFBQTtBQUNqQixTQUFLQSxLQUFBQSxLQUNVTCxNQUFNSyxFQUFBQSxJQUN2QixPQUZxQjtBQUVyQjtBQ1JnQkksU0FBQUEsR0FBWWpXLElBQUFBO0FBQzFCLE1BQWlCa1csS0FBR2xXLEdBQU1tVyxTQUFTQyxVQUFBQSxJQUFVO0FBTzdDLFNBTEFGLEdBQVlyUyxNQUFNd1MsV0FBVyxZQUM3QkgsR0FBWXJTLE1BQU1nUyxRQUFRLFFBQzFCSyxHQUFZclMsTUFBTXlTLFNBQVMsZUFDM0JKLEdBQVlyUyxNQUFNMFMsYUFBYSxVQUkzQmpVLEVBQUEsT0FBQSxFQUFBUyxLQUFLLFNBQUN5VCxJQUFBQTtBQUNKQSxJQUFBQSxNQUFlQSxHQUFZbFQsWUFBWTRTLEVBQUFBO0VBQ3pDLEVBQUEsQ0FBQTtBQUdOO0FBQUEsU0N0QnlCTyxHQUFDQyxJQUFBQTtBQUN4QixNQUFBLENBQUtBLEdBQUssUUFBTztBQUVqQixNQUFNQyxLQUFRRCxHQUFJM0csTUFBTSxHQUFBO0FBR3hCLFNBQXFCLE1BQWpCNEcsR0FBTXBXLFVBQWdCLGlCQUFpQm9ELEtBQUsrUyxFQUFBQSxJQUFBQSxLQUFBQSxHQUs3Q3ROLElBQUksU0FBVXdOLElBQU0xTixJQUFBQTtBQUVuQixXQUFhLEtBQVRBLEtBQUFBLEdBQ1VsRixZQUFBQSxJQUFBQSxHQUlGNlMsT0FBTyxDQUFBLEVBQUdDLFlBQUFBLElBQWdCRixHQUFLM1MsTUFBTSxDQUFBLEVBQUdELFlBQUFBO0VBQ3RELENBQUEsRUFDQ2lNLEtBQUssRUFBQTtBQUNWO0FBQUEsSUNqQlk4RztBRGlCWixJRVFBQyxLQUFlLEtBeEJILDRCQUFBO0FBQUEsV0FBQUMsS0FBQUE7RUFBQTtBQUFBLE1BQUF0TyxLQUFBc08sR0FBQXBTO0FBcUJULFNBckJTOEQsR0FDRnVPLFNBQUEsU0FBT3RILElBQWlCblAsSUFBQUE7QUFDOUIsV0FBQSxnQkFBcUJBLEdBQUtxVyxZQUFBQSxJQUFhLFFBQU1sSDtFQUMvQyxHQUVBTixHQUFBQSxRQUFBLFNBQU1NLElBQWlCdUgsSUFBQUE7QUFBQUEsZUFBQUEsT0FBQUEsS0FBQUE7QUFDckIsUUFBQTFVLEtBQVkxQyxLQUFLbVgsT0FBT3RILElBQVMsT0FBQTtBQUVqQyxRQUFJdUgsR0FDRixPQUFNbkUsTUFBTW9FLEVBQUFBO0FBRVpDLFlBQVEvSCxNQUFNOEgsRUFBQUE7RUFFbEIsR0FFQUUsR0FBQUEsT0FBQSxTQUFLMUgsSUFBQUE7QUFDSHlILFlBQVFDLEtBQUt2WCxLQUFLbVgsT0FBT3RILElBQVMsTUFBQSxDQUFBO0VBQ3BDLEdBRUEySCxHQUFBQSxPQUFBLFNBQUszSCxJQUFBQTtBQUNIeUgsWUFBUUUsS0FBS3hYLEtBQUttWCxPQUFPdEgsSUFBUyxNQUFBLENBQUE7RUFDcEMsR0FBQ3FIO0FBQUEsR0FyQlM7QUFBQSxFRERaLFNBQVlGLElBQUFBO0FBQ1ZBLEVBQUFBLEdBQUFBLEdBQUEsU0FBQSxDQUFBLElBQUEsVUFDQUEsR0FBQUEsR0FBQSxTQUFBLENBQUEsSUFBQSxVQUNBQSxHQUFBQSxHQUFBLE9BQUEsQ0FBQSxJQUFBO0FBQ0QsR0FKV0EsT0FBQUEsS0FJWCxDQUFBLEVBQUE7QUFTRCxJQUEwQlMsS0FBQSw0QkFBQTtBQUd4QixXQUFBelcsS0FBQTtBQUZpQjBXLFNBQUFBLFVBQUFBLFFBR2YxWCxLQUFLMFgsVUFBVSxDQUFBO0VBQ2pCO0FBQUMsTUFBQTlPLEtBQUE2TyxHQUFBM1M7QUFBQUEsU0FBQThELEdBRURXLE1BQUEsU0FBaUN6QixJQUFBQTtBQUMvQixXQUFPOUgsS0FBSzBYLFFBQVFDLEtBQUssU0FBQ2hZLElBQUFBO0FBQUFBLGFBQU9BLEdBQUNtSSxPQUFPQTtJQUFFLENBQUE7RUFDN0MsR0FBQ2MsR0FFRGdQLE1BQUEsU0FBc0NDLElBQUFBO0FBQ3BDLFdBQUtBLEdBQU8vUCxLQUtSOUgsS0FBS3VKLElBQUlzTyxHQUFPL1AsRUFBQUEsS0FDbEJtUCxHQUFJMUgsTUFBSywwQkFBeUJzSSxHQUFPL1AsRUFBQUEsR0FDbEM5SCxTQUdUQSxLQUFLMFgsUUFBUXpXLEtBQUs0VyxFQUFBQSxHQUVwQjdYLFNBWElpWCxHQUFJMUgsTUFBTSwyQkFBQSxHQUNIdlA7RUFVWCxHQUFBSixHQUVBa1ksU0FBQSxTQUFPaFEsSUFBQUE7QUFDTCxRQUFZK1AsS0FBRzdYLEtBQUt1SixJQUFJekIsRUFBQUE7QUFNeEIsV0FKSStQLE1BQ0Y3WCxLQUFLMFgsUUFBUUssT0FBTy9YLEtBQUswWCxRQUFRcFgsUUFBUXVYLEVBQUFBLEdBQVMsQ0FBQSxHQUl0RDdYO0VBQUEsR0FBQUosR0FFQW9ZLE9BQUEsU0FBa0MxQixJQUFBQTtBQUNoQyxRQUFJb0I7QUFRSixXQUxFQSxLQURjLFFBQVpwQixNQUFnQzlFLFFBQVo4RSxLQUNadFcsS0FBSzBYLFFBQVFqTixPQUFPLFNBQUM5SyxJQUFBQTtBQUFNQSxhQUFBQSxHQUFFMlcsYUFBYUE7SUFBUSxDQUFBLElBRWxEdFcsS0FBSzBYLFNBR1ZBLEdBQVFuVyxLQUFLLFNBQUNlLElBQUd4QixJQUFBQTtBQUFPd0IsYUFBQUEsR0FBRTJWLFNBQVNuWCxHQUFFbVgsUUFBUTNWLEdBQUUyVixRQUFRblgsR0FBRW1YLFFBQVE7SUFBQyxDQUFBO0VBQzNFLEdBQUFqWDtBQUFBLEdBOUN3QjtBQWlEcEIsU0FBd0JrWCxHQUFDalksSUFBQUE7QUFBQUEsTUFBQUEsS0FBQUEsTUFPdkJzUSxLQUFTQyxHQUFBQTtBQUVmLE1BQUl2USxHQUFNa1ksVUFBVTtBQUVsQixRQUFZTixLQUFHdEgsR0FBT3NILE9BQU90TyxJQUFJdEosR0FBTWtZLFFBQUFBO0FBRXZDLFdBQUtOLEtBRUV0VixFQUNMc1MsR0FDQSxDQUFBLEdBQ0F0UyxFQUFFc1YsR0FBT08sV0FDUFAsRUFBQUEsRUFBQUEsUUFBUUEsR0FBQUEsR0FDTDVYLEdBQU1BLEtBQUFBLENBQUFBLENBQUFBLElBUFc7RUFVekI7QUFBTSxTQUFBLFdBQUlBLEdBQU1xVyxXQUVQL1QsRUFDTnNTLEdBQ0EsQ0FBRSxHQUNGdEUsR0FBT3NILE9BQU9HLEtBQUsvWCxHQUFNcVcsUUFBQUEsRUFBVWpOLElBQUksU0FBQzFKLElBQUFBO0FBQ3RDLFdBQUEsRUFBU0EsR0FBRXlZLFdBQVNsTSxFQUFBLEVBQUkyTCxRQUFRbFksR0FBQUEsR0FBTThJLEdBQUt4SSxNQUFNQSxLQUFBQSxDQUFBQTtFQUNuRCxDQUFBLENBQUEsSUFLTjtBQUFBO0FFNUZ5RCxJQUduRG9ZLEtBQUFBLDBCQUFBQSxJQUFBQTtBQUdKLFdBQUFBLEtBQUFBO0FBQUEsUUFBQTVQO0FBR3FCLFlBRm5CQSxLQUFPRCxHQUFBdkMsS0FBQWpHLElBQUFBLEtBQUFBLE1BSERzWSxXQUFBQSxRQUtON1AsR0FBSzZQLFdBQVcsQ0FBQSxHQUFHN1A7RUFDckI7QUFBQSxJQUFBckgsSUFBQUosRUFBQTtBQUFDLE1BQUE0SCxLQUFBeVAsR0FBQXZUO0FBWUEsU0FaQThELEdBc0JEMlAsY0FBQSxTQUNFaEksSUFDQTZGLElBQ0FvQyxJQUFBQTtBQUVBLFFBQUE3VyxLQUEyQjRPLEdBQU9rSSxXQUNuQkMsS0FBR25JLEdBQU9tSTtBQUV6QixRQUFBLENBQUtELEdBR0gsUUFDRHpZO0FBR0QsUUFBTStWLEtBQWlCMEMsR0FBVUUsYUFFN0JDLEtBQVMsQ0FBQTtBQUVUeEMsSUFBQUEsR0FBU25QLFdBQVd5UixPQU10QjNULEVBQ0V4QyxFQUFFMlQsSUFBYSxFQUNiRSxVQUFVQSxHQUFTblAsUUFBQUEsQ0FBQUEsR0FFckJ1UixHQUFRdlIsT0FBQUEsR0FHVjJSLE1KakRVQyxTQUFxQkwsSUFBQUE7QUFHbkMsVUFBQTVZLEtBQXVDNFksR0FBUU0sY0FDN0MsT0FBQTtBQUdGLFVBQUEsQ0FBS0MsR0FDSCxRQUFPLENBQ1I7QUFFRCxVQUFNQyxLQUFpQkQsR0FBYS9MLFdBQ3BCaU0sS0FBR0YsR0FBYWpWLE1BQU1DO0FBQ3RDZ1YsTUFBQUEsR0FBYS9MLFlBQWVnTSxLQUFjLE1BQUloTSxHQUFVLGFBQUEsR0FFeEQrTCxHQUFhalYsTUFBTW9WLGNBQWMsUUFDakNILEdBQWFqVixNQUFNZ1MsUUFBUSxRQUMzQmlELEdBQWFqVixNQUFNcVYsVUFBVSxLQUM3QkosR0FBYWpWLE1BQU1zVixTQUFTLEtBQzVCTCxHQUFhalYsTUFBTXVWLFNBQVMsUUFDNUJOLEdBQWFqVixNQUFNd1YsVUFBVTtBQUU3QixVQUFBM1gsS0FBVWtCLE1BQU02UyxLQUNkcUQsR0FBYTNWLFdBQVdtVyxpQkFBOEIsVUFBQSxDQUFBLEVBQ3REck0sT0FBTyxTQUFDQyxJQUFNbEcsSUFBQUE7QUFDZEEsWUFBQUE7QUFFQSxlQUZBQSxHQUFRbkQsTUFBTWdTLFFBQVc3TyxHQUFRMFIsY0FBZSxNQUFBLElBQUEvVyxLQUFBLENBQUEsR0FHN0NxRixHQUFRdVMsYUFBYSxnQkFBQSxDQUFBLElBQW9CLEVBQ3hDQyxVQUFVeFMsR0FBUTBSLFlBQUFBLEdBQUFBLEtBRWpCeEwsRUFBQUE7TUFFUCxHQUFHLENBQUEsQ0FBQTtBQWNILGFBWkE0TCxHQUFhL0wsWUFBWWdNLElBQ3pCRCxHQUFhalYsTUFBTUMsVUFBVWtWLElBQzdCRixHQUFhalYsTUFBTW9WLGNBQWMsUUFFM0JyVyxNQUFNNlMsS0FDVnFELEdBQWEzVixXQUFXbVcsaUJBQThCLFVBQUEsQ0FBQSxFQUN0RHJNLE9BQU8sU0FBQ0MsSUFBTWxHLElBQUFBO0FBR2QsZUFGQWtHLEdBQUtsRyxHQUFRdVMsYUFBYSxnQkFBQSxDQUFBLEVBQTBCLFFBQUl2UyxHQUFRMFIsYUFFekR4TDtNQUNULEdBQUd1TSxFQUFBQTtJQUdMLEdJQ29DbEIsR0FBUXZSLE9BQUFBO0FBR3hDLGFBQWdFMFMsSUFBaEVDLEtBQUFDLEVBQTZCeEIsR0FBT3lCLGNBQWM5WixLQUFLdU0sT0FBQUEsRXhCakUzQ1csT0FBTyxTQUFDQyxJQUFNMUssSUFBQUE7QUFBQyxhQUFTMEssR0FBQ25CLE9BQU92SixFQUFBQTtJQUFFLEdBQUUsQ0FBQSxDQUFBLENBQUEsR0FBQSxFd0JpRWdCa1gsS0FBQUMsR0FBQUEsR0FBQUcsUUFBRTtBQUF2REMsVUFBQUEsS0FFVEwsR0FBQS9VO0FBQUlvVixNQUFBQSxHQUFPek4sV0FBV3lOLEdBQU96TixRQUFRL0wsU0FBUyxNQUFBLENBSXpDd1osR0FBT2xFLFNBQVM0QyxLQUlmc0IsR0FBT2xTLE1BQUFBLE9BRVRrUyxHQUFPbEUsUUFBUUcsR0FBRzJDLEdBQU9vQixHQUFPbFMsRUFBQUEsRUFBVyxLQUFBLEdBQzNDa1MsR0FBT1AsV0FBV3hELEdBQUcyQyxHQUFPb0IsR0FBT2xTLEVBQUFBLEVBQWMsUUFBQSxLQUtuRGtTLEdBQU9sRSxRQUFRRyxHQUFHSCxHQUFNa0UsR0FBT2xFLE9BQU9DLEVBQUFBLENBQUFBO0lBRXpDO0FBT0QsV0FMSUssR0FBU25QLFdBQVd5UixNQUV0QjNULEVBQU8sTUFBTXlULEdBQVF2UixPQUFBQSxHQUl6QmpIO0VBQUEsR0FFUWlhLEdBQUFBLFVBQUEsU0FDTkMsSUFDQTNOLElBQUFBO0FBSUEsYUFGQTNLLElBRXFCdVksS0FBQUEsRUFGUjVOLE1BQVd2TSxLQUFLdU0sV0FBVyxDQUFBLENBQUEsR0FBQSxFQUFBM0ssS0FBQVIsR0FBQSxHQUFBLFFBRWI7QUFBaEI0WSxVQUFBQSxLQUVUSSxHQUFBeFY7QUFBSW9WLE1BQUFBLEdBQU96TixXQUFXeU4sR0FBT3pOLFFBQVEvTCxTQUFTLElBQzVDd1osR0FBT3pZLE9BQUFBLFNBQU9pUSxXQUNMd0ksR0FBT3pZLFFBQXNCMlksS0FDdENGLEdBQU96WSxPQUFPLENBQUEsSUFDSnlZLEdBQU96WSxPQUdlLFlBQUEsT0FBVnlZLEdBQUN6WSxTQUN2QnlZLEdBQU96WSxPQUFJMkssRUFBQSxDQUFBLEdBQ044TixHQUFPelksSUFBQUEsS0FIWnlZLEdBQU96WSxPQUFBQSxRQU9MeVksR0FBT3pOLFdBQ1R2TSxLQUFLaWEsUUFBUUMsSUFBWUYsR0FBT3pOLE9BQUFBO0lBRW5DO0VBQ0gsR0FBQzNELEdBRU95UixlQUFBLFNBQWFDLElBQW9CL04sSUFBQUE7QUFHdkMsYUFBeUJnTyxJQUF6QkMsS0FBQVgsRUFGYXROLE1BQVd2TSxLQUFLdU0sV0FBVyxDQUFBLENBQUEsR0FBQSxFQUVmZ08sS0FBQUMsR0FBQUEsR0FBQVQsUUFBRTtBQUFBLFVBQVZDLEtBQUFPLEdBQUEzVjtBQUFBQSxpQkFDWG9WLEdBQU9NLGNBQ1ROLEdBQU9NLFlBQVlBLEtBR2pCTixHQUFPek4sV0FDVHZNLEtBQUtxYSxhQUFhQyxJQUFXTixHQUFPek4sT0FBQUE7SUFFdkM7RUFDSCxHQUFBNUssR0FFUThZLFFBQUEsU0FBTWxPLElBQUFBO0FBR1osYUFBeUJtTyxJQUFBQSxLQUFBQSxFQUZabk8sTUFBV3ZNLEtBQUt1TSxXQUFXLENBQUEsQ0FBQSxHQUFBLEVBRWZtTyxLQUFBQyxHQUFBQSxHQUFBWixRQUFFO0FBQWhCQyxVQUFBQSxLQUNUVSxHQUFBOVY7QUFBS29WLE1BQUFBLEdBQU9sUyxNQUE2QixZQUFBLE9BQWhCa1MsR0FBT25ULFNBRTlCbVQsR0FBT2xTLEtBQUs0TyxHQUFVc0QsR0FBT25ULElBQUFBLElBRzFCbVQsR0FBT2xTLE1BQ1Y4UyxHQUFPckwsTUFHUixrR0FBQSxHQUdHeUssR0FBT3pOLFdBQ1R2TSxLQUFLeWEsTUFBTVQsR0FBT3pOLE9BQUFBO0lBRXJCO0VBQ0gsR0FBQzNELEdBRU9pUyxrQkFBQSxTQUNOQyxJQUNBdk8sSUFBQUE7QUFHQSxhQUE0QndPLElBQTVCQyxLQUFBbkIsRUFBcUJ0TixFQUFBQSxHQUFBQSxFQUFPd08sS0FBQUMsR0FBQUEsR0FBQWpCLFFBQUU7QUFBQSxVQUFiQyxLQUFBZSxHQUFBblc7QUFBQUEsaUJBQ1hvVixHQUFPbkMsVUFDVGlELEdBQWNsRCxJQUNaOVAsRUFBQUEsRUFBQUEsSUFBSWtTLEdBQU9sUyxHQUFBQSxHQUNSa1MsR0FBT25DLFFBQU0sRUFDaEJ2QixVQUFVVSxHQUFlMU8sS0FBQUEsQ0FBQUEsQ0FBQUE7SUFHOUI7RUFDSCxHQUFDK1AsR0FFTTRDLGNBQVAsU0FDRTFPLElBQUFBO0FBSUEsYUFBOEIyTyxJQUZsQnJKLEtBQUcsSUFBSXdHLE1BRUU5TCxLQUFBQSxFQUFBQSxFQUFBQSxHQUFBQSxFQUFTMk8sS0FBQUMsR0FBQUEsR0FBQXBCLFFBQUE7QUFBQSxVQUFiQyxLQUFBa0IsR0FBQXRXO0FBQ2YsVUFBc0IsWUFBQSxPQUFBakQsTUFBWXlaLEVBQWVwQixFQUFBQSxFQUMvQ25JLENBQUFBLEdBQU90RixRQUFRdEwsS0FBSyxFQUNsQjRGLE1BQU1tVCxHQUFBQSxDQUFBQTtlQUVtQixZQUFBLE9BQVhBLElBQXFCO0FBQ3JDLFlBQWlCcUIsS0FBR3JCO0FBRWhCcUIsUUFBQUEsR0FBWTlPLFlBQ2Q4TyxHQUFZOU8sVUFBVThMLEdBQU80QyxZQUFZSSxHQUFZOU8sT0FBQUEsRUFBU0EsVUFLOUIsWUFBQSxPQUFaOE8sR0FBQ3hELFVBQUFBLFdBQ2pCd0QsR0FBWTVVLFNBQ2Q0VSxHQUFZNVUsT0FBTyxPQUt2Qm9MLEdBQU90RixRQUFRdEwsS0FBSytZLEVBQUFBO01BQ3JCO0lBQ0Y7QUFFRCxXQUFPbkk7RUFDVCxHQUFDd0csR0FFTWlELG1CQUFQLFNBQXdCL0ssSUFBQUE7QUFDdEIsUUFBWXNCLEtBQUcsSUFBSXdHO0FBbUJuQixXQWhCSTlILEdBQU9tRixPQUNUN0QsR0FBT3RGLFVBQVU4TCxHQUFPa0QsY0FBY2hMLEdBQU9tRixJQUFBQSxFQUFNbkosVUFDMUNnRSxHQUFPaEUsVUFDaEJzRixHQUFPdEYsVUFBVThMLEdBQU80QyxZQUFZMUssR0FBT2hFLE9BQUFBLEVBQVNBLFVBQUFBLENBRXBEZ0UsR0FBTzlKLFFBQ21CLFlBQUEsT0FBbkI4SixHQUFPOUosS0FBSyxDQUFBLEtBQ2pCOEosR0FBTzlKLEtBQUssQ0FBQSxhQUFtQjVELFVBSWpDZ1AsR0FBT3RGLFVBQVVwQixPQUFPQyxLQUFLbUYsR0FBTzlKLEtBQUssQ0FBQSxDQUFBLEVBQUk0QyxJQUFJLFNBQUN4QyxJQUFBQTtBQUNoRCxhQUFPLEVBQUVBLE1BQU1BLEdBQUFBO0lBQ2pCLENBQUEsSUFHRWdMLEdBQU90RixRQUFRL0wsVUFDakJxUixHQUFPNEksTUFBQUEsR0FDUDVJLEdBQU9vSSxRQUFRMUosR0FBT2hQLElBQUFBLEdBQ3RCc1EsR0FBT3dJLGFBQWE5SixHQUFPK0osU0FBQUEsR0FDM0J6SSxHQUFPZ0osZ0JBQWdCdEssR0FBT3NILFFBQVFoRyxHQUFPdEYsT0FBQUEsR0FDdENzRixNQUlYO0VBQUEsR0FFTzBKLEdBQUFBLGdCQUFQLFNBQXFCek8sSUFBQUE7QUFLbkIsYUFBMkIwTyxJQUpyQjNKLEtBQVMsSUFBQXpRLE1BSWZxYSxLQUFBNUIsRUFIYy9NLEdBQVFnTSxjQUFjLE9BQUEsRUFDbEJTLGlCQUFpQixJQUFBLENBQUEsR0FBQSxFQUVSaUMsS0FBQUMsR0FBQUEsR0FBQTFCLFFBQUU7QUFBbEIyQixVQUFBQSxLQUFBQSxHQUFBQTtBQUNUN0osTUFBQUEsR0FBT3RGLFFBQVF0TCxLQUFLLEVBQ2xCNEYsTUFBTTZVLEdBQUczVSxXQUNUK08sT0FBTzRGLEdBQUc1RixNQUFBQSxDQUFBQTtJQUViO0FBRUQsV0FDRmpFO0VBQUEsR0FxQk9pSSxHQUFBQSxnQkFBUCxTQUFxQnZOLElBQUFBO0FBQ25CLFFBQUlvUCxLQUE2QixDQUFBLEdBQzNCeEIsS0FBTzVOLE1BQVcsQ0FBQSxHQUFBM0ssS0FDVixDQUFBO0FBRWQsUUFBSXVZLE1BQVFBLEdBQUszWixRQUFRO0FBQ3ZCbWIsTUFBQUEsR0FBTzFhLEtBQUtrWixFQUFBQTtBQUVaLGVBQXdCeUIsSUFBTnpCLEtBQUFBLEVBQUFBLEVBQUFBLEdBQUFBLEVBQU15QixLQUFBQyxHQUFBQSxHQUFBOUIsUUFBQTtBQUFBLFlBQVYrQixLQUFBRixHQUFBaFg7QUFDUmtYLFFBQUFBLEdBQUl2UCxXQUFXdVAsR0FBSXZQLFFBQVEvTCxXQUM3QnViLEtBQVVBLEdBQVEvUCxPQUFPOFAsR0FBSXZQLE9BQUFBO01BRWhDO0FBRUd3UCxNQUFBQSxHQUFRdmIsV0FDVm1iLEtBQVNBLEdBQU8zUCxPQUFPaE0sS0FBSzhaLGNBQWNpQyxFQUFBQSxDQUFBQTtJQUU3QztBQUVELFdBQU9KO0VBQ1QsR0FPT0ssR0FBQUEsY0FBUCxTQUFtQnpQLElBQUFBO0FBQ2pCLFFBQUEzTSxLQUFpQyxDQUFBLEdBQ3ZCdWEsS0FBRzVOLE1BQVcsQ0FBQTtBQUV4QixRQUFJNE4sTUFBUUEsR0FBSzNaLE9BQ2YsVUFBd0J5YixJQUFOOUIsS0FBQUEsRUFBQUEsRUFBQUEsR0FBQUEsRUFBTThCLEtBQUFDLEdBQUFBLEdBQUFuQyxRQUFBO0FBQUEsVUFBVitCLEtBQUFHLEdBQUFyWDtBQUNQa1gsTUFBQUEsR0FBSXZQLFdBQWtDLE1BQXZCdVAsR0FBSXZQLFFBQVEvTCxVQUM5Qm1iLEdBQU8xYSxLQUFLNmEsRUFBQUEsR0FHVkEsR0FBSXZQLFlBQ05vUCxLQUFTQSxHQUFPM1AsT0FBT2hNLEtBQUtnYyxZQUFZRixHQUFJdlAsT0FBQUEsQ0FBQUE7SUFFL0M7QUFHSCxXQUFBM007RUFDRixHQUFDeVksR0FNTThELGVBQVAsU0FBb0JuQyxJQUFBQTtBQUNsQixXQUFXaGEsS0FBQzhaLGNBQWMsQ0FBQ0UsRUFBQUEsQ0FBQUEsRUFBU3haLFNBQVM7RUFDL0MsR0ExVEF5SCxFQUFBb1EsSUFBQSxDQUFBLEVBQUF0VixLQUFBLFdBQUF3RyxLQUFBLFdBQUE7QUFDRSxXQUFBLEtBQVkrTztFQUNkLEdBQUM5TyxLQUVELFNBQVkrQyxJQUFBQTtBQUNWdk0sU0FBS3NZLFdBQVcvTDtFQUNsQixFQUFBLEdBQUMsRUFBQXhKLEtBQUEsa0JBQUF3RyxLQUVELFdBQUE7QUFDRSxXQUFXdkosS0FBQ3NZLFNBQVM3TixPQUFPLFNBQUNwSSxJQUFBQTtBQUFBQSxhQUFBQSxDQUFPQSxHQUFFd0s7SUFBTSxDQUFBO0VBQzlDLEVBQUEsQ0FBQSxDQUFBLEdBQUN3TDtBQUFBLEdBbkJrQnhRLENBQUFBO0FBSG9DLElDSm5DdVUsS0FBQSxXQUFBO0FBQUE7QURJbUMsSUVObkRDLEtBQUFBLDBCQUFBQSxJQUFBQTtBQUdKLFdBQVk1VixHQUFBQSxJQUFBQTtBQUNWLFFBQUFnQztBQUNlLFlBRGZBLEtBQUE2VCxHQUFBclcsS0FBQWpHLElBQUFBLEtBQUFBLE1BSE15RyxPQUFBQSxRQUlOZ0MsR0FBS2UsSUFBSS9DLEVBQUFBLEdBQ1hnQztFQUFBO0FBQUEsSUFBQTdJLElBQUFvQixFQUFBO0FBQUMsTUFBQTBCLEtBQUE5QyxHQUFBO0FBQUEsU0FBQThDLEdBRVk2RyxNQUFHLFdBQUE7QUFBQSxRQUFBO0FBQ1MsYUFBQWdULFFBQUE5SixRQUFKelMsS0FBS3lHLEtBQUFBLENBQUFBLEVBQUFBLEtBQUFBLFNBQWxCQSxJQUFBQTtBQUVOLGVBQU8sRUFDTEEsTUFBTUEsSUFDTjZOLE9BQU83TixHQUFLakcsT0FBQUE7TUFDWixDQUFBO0lBQ0gsU0FBQWtDLElBQUFBO0FBQUEsYUFBQTZaLFFBQUFDLE9BQUE5WixFQUFBQTtJQUFBO0VBQUEsR0FBQWtHLEdBRU1ZLE1BQUEsU0FBSS9DLElBQUFBO0FBT1QsV0FOSUEsY0FBQUEsUUFDRnpHLEtBQUt5RyxPQUFPLFdBQUE7QUFBYUEsYUFBQUE7SUFBSSxJQUNwQkEsY0FBQUEsYUFDVHpHLEtBQUt5RyxPQUFPQSxLQUloQnpHO0VBQUEsR0FBQUo7QUFBQSxHQXpCMEJ3YyxFQUFBQTtBRk02QixJR1VyQ0ssS0FBQSwwQkFBQUgsSUFBQUE7QUFHbEIsV0FBQTFjLEdBQVkwTixJQUFBQTtBQUFBQSxRQUFBQTtBQUVhLFlBRHZCN0UsS0FBTzZULEdBQUFyVyxLQUFBakcsSUFBQUEsS0FBQUEsTUFIUXNOLFVBQUFBLFFBSWY3RSxHQUFLNkUsVUFBVUEsSUFBUTdFO0VBQ3pCO0FBTmtCRSxJQUFBOFQsSUFBQUgsRUFBQUE7QUFNakIsTUFFT0ksS0FBQUEsR0FBQUE7QUFBQUEsU0FBQUEsR0FBQUEsVUFBQSxTQUFRQyxJQUFBQTtBQUNkLFdBQW1DLGNBQUEsT0FBcEIzYyxLQUFDc04sUUFBUXNQLFNBQ2Y1YyxLQUFLc04sUUFBUXNQLE9BQU9ELEVBQUFBLElBR3pCQSxHQUFTRSxLQUFBQSxHQUNLQyxLQUFBQSxLQUVoQjdGLEdBQUkxSCxNQUN1Qm9OLDJCQUFBQSxHQUFTSSxTQUFNLFFBQU1KLEdBQVNLLFlBQUFBLElBQ3ZELEdBRUs7RUFFWCxHQUFDcFUsR0FFTVcsTUFBQSxTQUFJK0QsSUFBQUE7QUFHVCxRQUFVMlAsS0FBQS9RLEVBQUEsQ0FBQSxHQUNMbE0sS0FBS3NOLFNBQ0xBLEVBQUFBO0FBT0wsV0FBeUIsY0FBQSxPQUFBMU4sR0FBVDZHLE9BQ1B3VyxHQUFLeFcsS0FBS3dXLEVBQUFBLElBR1BDLE1BQUNELEdBQUt6UCxLQUFLeVAsRUFBQUEsRUFDcEJFLEtBQUtuZCxLQUFLMGMsUUFBUVUsS0FBS3BkLElBQUFBLENBQUFBLEVBQ3ZCbWQsS0FBSyxTQUFDRSxJQUFBQTtBQUNMLGFBQU8sRUFDTDVXLE1BQU13VyxHQUFLRSxLQUFLRSxFQUFBQSxHQUNoQi9JLE9BQTZCLGNBQUEsT0FBQTFVLEdBQVYwVSxRQUF1QjJJLEdBQUszSSxNQUFNK0ksRUFBQUEsSUFBQUEsT0FBTzdMO0lBRWhFLENBQUE7RUFDSixHQUFBNVI7QUFBQSxHQWhEMEJ3YyxFQUFBQTtBSFY2QixJSUZ2Q2tCLEtBQUEsNEJBQUE7QUFBQSxXQUFBQSxLQUFBQTtFQUFBO0FBaUVsQixTQWpFa0JBLEdBTUZoQyxtQkFBUCxTQUF3Qi9LLElBQUFBO0FBQzdCLFFBQVdnTixLQUFHO0FBb0JkLFdBbEJJaE4sR0FBTzlKLFNBQ1Q4VyxLQUFVLElBQWlCbEIsR0FBQzlMLEdBQU85SixJQUFBQSxJQUdqQzhKLEdBQU9tRixTQUNUNkgsS0FBVSxJQUFJbEIsR0FBY3JjLEtBQUt3ZCxvQkFBb0JqTixHQUFPbUYsSUFBQUEsQ0FBQUEsR0FFNURuRixHQUFPbUYsS0FBSzVSLE1BQU0yWixVQUFVLFNBRzFCbE4sR0FBT3FCLFdBQ1QyTCxLQUFVLElBQWlCZCxHQUFDbE0sR0FBT3FCLE1BQUFBLElBR2hDMkwsTUFDSHRHLEdBQUkxSCxNQUFNLHdDQUFBLElBQXdDLEdBRzdDZ087RUFDVCxHQUFDRCxHQVNNRSxzQkFBUCxTQUEyQjFRLElBQUFBO0FBS3pCLGFBQStCNk0sSWpDOUNadlIsSWlDMENWc1YsS0FBRyxDQUFBLEdBSVo5RCxLQUFBQyxFQUhjL00sR0FBUWdNLGNBQWMsT0FBQSxFQUNqQlMsaUJBQWlCLElBQUEsQ0FBQSxHQUFBLEVBRUxJLEtBQUFDLEdBQUFBLEdBQUFHLFFBQUE7QUFJN0IsZUFBMEJLLElBRlh1RCxLQUFHLENBQUEsR0FFQzNVLEtBQUFBLEVBSlAyUSxHQUFBL1UsTUFDcUIyVSxpQkFBaUIsSUFBQSxDQUFBLEdBQUEsRUFHeEJhLEtBQUF3RCxHQUFBQSxHQUFBN0QsUUFBQTtBQUFBLFlBQVg3USxLQUFBa1IsR0FBQXhWO0FBR2dCLGNBQTNCc0UsR0FBS3hDLFdBQVdsRyxVQUNoQjBJLEdBQUt4QyxXQUFXLENBQUEsRUFBR1AsYUFBYTBYLEtBQUtDLFlBRXJDSCxHQUFVMWMsTWpDeERHbUgsS2lDd0RTYyxHQUFLbkMsV2pDdkRyQixJQUFhZ1gsWUFBR0MsZ0JBQWdCNVYsSUFBUyxXQUFBLEVBQzFDNlYsZ0JBQWdCQyxZQUFBQSxJaUN3RHJCUCxHQUFVMWMsS0FBS29ILEVBQUthLEdBQUtuQyxTQUFBQSxDQUFBQTtNQUU1QjtBQUVEMlcsTUFBQUEsR0FBSXpjLEtBQUswYyxFQUFBQTtJQUNWO0FBRUQsV0FDRkQ7RUFBQSxHQUdGSjtBQUFBLEdBakVrQjtBSkV1QyxJSUZ2QyxLQUFBLGVBQUEsT0FBQSxTQUFBLE9BQUEsYUFBQSxPQUFBLFdBQUEsT0FBQSxpQkFBQSxLQUFBO0FDMkdmLFNBQUEsR0FBQWEsSUFBQWpaLElBQUFOLElBQUFBO0FBT0QsTUFBQSxDQUFBdVosR0FBQXJjLEdBQVU7QUFDUixRQUFBOEMsY0FBQUEsSUFBYztBQUFBLFVBQUEsQ0FBQWxDLEdBQVNaLEVBV3RCLFFBQUEsTUFEQzhDLEdBQUF4RCxJQUFBZ2QsR0FBVWhCLEtBQUFBLE1BQVdlLElBQUFqWixFQUFBQTtBQVRmLFVBQVJBLE9BQUFBLEtBQTZETixHQUFBOUMsSUFJN0Q4QyxLQUFJQSxHQUFRaEM7SUFBQUE7QUFtQlosUUFBQWdDLE1BQVlBLEdBQUF1WSxLQUFBQSxRQUFBQSxLQUFBQSxHQUVSQSxLQUFBQSxHQUFXQyxLQUFBLE1BQUFlLElBQUFqWixFQUFBQSxHQUFBa1osR0FBQWhCLEtBQUEsTUFBQWUsSUFBQSxDQUFBLENBQUE7QUFBQSxJQUFBbmQsR0FBQSxJQUFBcEIsSUFJZHVlLEdBQUF2YixJQUFBZ0M7QUFFRCxRQUFBaEQsS0FBQVosR0FBaUJJO0FBQ2ZpZCxJQUFBQSxNQUNEQSxHQUFBRixFQUFBQTtFQUNDO0FBRUU7QUFBQSxJQTdKUUcsS0FBYyw0QkFBQTtBQUM5QixXQUFBdGQsS0FBQTtFQUFTO0FBMEdKLFNBdkVDc2QsR0FBQXhaLFVBQUFBLE9BQW1ELFNBQUF5WixJQUFBQyxJQUFBQTtBQUV0QyxRQUFBN0MsS0FHVCxJQUE0RDJDLE1BRTlCcFosS0FBSWxGLEtBQXNCOEI7QUFBQUEsUUFJL0JvRCxJQUFBO0FBRWpDLFVBQUF1WixLQUF5RCxJQUFBdlosS0FBQXFaLEtBQUFDO0FBQ3ZELFVBQUFDLElBQVE7QUFFUixZQUFBO0FBQ0VMLGFBQUF6QyxJQUFNLEdBQUE4QyxHQUFlemUsS0FBRzRDLENBQUFBLENBQUFBO1FBTzVCLFNBTkdGLElBQUFBO0FBQ0YwYixhQUFBekMsSUFBQSxHQUFBalosRUFBQUE7UUFLRDtBQUNFLGVBQ0FpWjtNQUFBO0FBQ0YsYUFRQTNiO0lBQUFBO0FBQUFBLFdBS0lBLEtBQUFvQixJQUFBLFNBQVdxSCxJQUFBQTtBQUNaLFVBQUE7QUFFRCxZQUFBckgsS0FBYXFILEdBQUs3RjtBQUNWLFlBQU42RixHQUFBM0csSUFDRHNjLEdBQUF6QyxJQUFBLEdBQUE0QyxLQUFBQSxHQUFBM1osRUFBQUEsSUFBQUEsRUFBQUEsSUFFRzRaLEtBQUFBLEdBQ0k3QyxJQUFBLEdBQU02QyxHQUFnQjVaLEVBQUFBLENBQUFBLElBSTlCd1osR0FBQXpDLElBQWEsR0FBQS9XLEVBQUFBO01BQUFBLFNBR1RsQyxJQUFBQTtBQUVKMGIsV0FBQXpDLElBQUFBLEdBQUFBLEVBQUFBO01BQUFBO0lBUUYsR0FJTUE7RUFBQUEsR0FBQUE7QUFFRixHQTNHd0I7QUE4SmpCLFNBQUErQyxHQUFBQyxJQUFBQTtBQUVMLFNBQUFBLGNBQUFBLE1BQXdDLElBQWxCQSxHQUFRN2M7QUFBQUE7QUFBQUEsSUFBQUEsS0EvR3BDLDBCQUFBMkosSUFBQUE7QUFBQSxXQUFBbVQsR0FBWUMsSUFBQUE7QUFBNkMsUUFBQXBXO0FBS3RELFlBSkRBLEtBQUFBLEdBQUFBLEtBQUFBLElBQUFBLEtBQVF6SSxNQVpPOGUsU0FHYixvQkFBQSxPQUVJQyxHQUFBQSxRQUE4QixvQkFBMEJDLE9BQUF2VyxHQUl4RHdXLDRCQUFBQSxJQUtGSixNQUNGQSxHQUFNblosUUFBUSxTQUFDd1osSUFBQUE7QUFBSSxhQUFBeGMsR0FBVXNQLFNBQVNrTixFQUFBQTtJQUFLLENBQUEsR0FDNUN6VztFQUNIO0FBTkFFLElBQUFpVyxJQUFBblQsRUFBQUE7QUFNQyxNQUFBN0MsS0FBQWdXLEdBQUE5WjtBQWlJQSxTQWpJQThELEdBS0R1VyxhQUFBLFdBQUE7QUFDRW5mLFNBQUsrZSxRQUFRLG9CQUF5QkMsT0FDdENoZixLQUFLaWYsNEJBQUFBO0VBQ1AsR0FBQ3JXLEdBUURvSixXQUFBLFNBQ0VQLElBQ0EyTixJQUFBQTtBQUVBLFFBQUEsV0FGQUEsT0FBQUEsS0FBbUIsT0FBQSxDQUVkM04sR0FDSCxPQUFBLE1BQVksMEJBQUE7QUFHZCxRQUF1QixTQUFuQkEsR0FBVS9RLEtBQ1osT0FBV3VTLE1BQUMsK0JBQUE7QUFHZCxRQUFJalQsS0FBS3FmLHVCQUF1QjVOLEdBQVUzSixFQUFBQSxJQUFBQSxHQUN4QyxPQUFXbUwsTUFBQSxrQkFBaUJ4QixHQUFVM0osS0FDdkMscUJBQUE7QUFRRCxXQUxBMkosR0FBVXBILEdBQUcsZ0JBQWdCckssS0FBS3NmLHNCQUFzQmxDLEtBQUtwZCxJQUFBQSxDQUFBQSxHQUU3REEsS0FBS3VmLHVCQUF1QjlOLElBQVcyTixFQUFBQSxHQUN2Q3BmLEtBQUt3ZixnQkFBZ0IvTixFQUFBQSxHQUVkQTtFQUNULEdBQUM3SSxHQU9ENlcsY0FBQSxTQUNFaE8sSUFDQTJOLElBQUFBO0FBQUFBLGVBQUFBLE9BQUFBLEtBQW1CO0FBRW5CLFFBQUE7QUFDRSxhQUFXcGYsS0FBQ2dTLFNBQVNQLElBQVcyTixFQUFBQTtJQUFBQSxTQUN6QmpmLElBQUFBO0lBQUFBO0VBS1gsR0FBQ3lJLEdBT0RxSixhQUFBLFNBQWlCUixJQUFBQTtBQUNmLFFBQUtBLE1BQUFBLE9BQ0R6UixLQUFLcWYsdUJBQXVCNU4sR0FBVTNKLEVBQUFBLEdBQTFDO0FBRUEsVUFBTTRYLEtBQVcxZixLQUFLOGUsT0FBT3ZWLElBQUlrSSxHQUFVL1EsSUFBQUE7QUFFdkNnZixNQUFBQSxNQUFZQSxHQUFTbGYsV0FDdkJSLEtBQUs4ZSxPQUFPdFYsSUFDVmlJLEdBQVUvUSxNQUNWZ2YsR0FBU2pWLE9BQU8sU0FBQ2tWLElBQUFBO0FBQUksZUFBU0EsTUFBSWxPO01BQVMsQ0FBQSxDQUFBLEdBRTdDelIsS0FBSzBLLEtBQUssV0FBVytHLEVBQUFBO0lBUHZCO0VBU0YsR0FBQzdJLEdBUU8yVyx5QkFBQSxTQUNOOU4sSUFDQTJOLElBQUFBO0FBRUEsUUFBWU0sS0FBRzFmLEtBQUs4ZSxPQUFPdlYsSUFBSWtJLEdBQVUvUSxJQUFBQTtBQUV6QyxRQUFBLENBQUtnZixJQUFVO0FBQ2IsVUFBTUUsS0FBYSxDQUFBO0FBQ25CNWYsV0FBSzhlLE9BQU90VixJQUFJaUksR0FBVS9RLE1BQU1rZixFQUFBQSxHQUNoQ0YsS0FBV0U7SUFDWjtBQUVELFFBQWlCLFNBQWJSLE1BQXFCQSxLQUFXLEVBQ2xDTSxDQUFBQSxHQUFTemUsS0FBS3dRLEVBQUFBO2FBRVRpTyxHQUFTTixFQUFBQSxHQUdQO0FBRUwsVUFBQWhlLEtBQWNzZSxHQUFTeGIsTUFBTSxHQUFHa2IsS0FBVyxDQUFBLEdBQy9CUyxLQUFHSCxHQUFTeGIsTUFBTWtiLEtBQVcsQ0FBQTtBQUV6Q3BmLFdBQUs4ZSxPQUFPdFYsSUFBSWlJLEdBQVUvUSxNQUFNb2YsR0FBTTlULE9BQU95RixFQUFBQSxFQUFXekYsT0FBTzZULEVBQUFBLENBQUFBO0lBQ2hFLE1BUENILENBQUFBLEdBQVNOLEVBQUFBLElBQVkzTjtFQVMzQixHQUFDN0ksR0EwQkRtWCxpQkFBQSxTQUFlcmYsSUFBQUE7QUFDYixXQUFXVixLQUFDNmUsTUFBTXBVLE9BQU8sU0FBQ21CLElBQUFBO0FBQU8sYUFBQWhNLEdBQWFjLFNBQVNBO0lBQUksQ0FBQTtFQUM3RCxHQUtRc2YsR0FBQUEsMEJBQUEsV0FBQTtBQUNOLFdBQUEsT0FBYzVVLEtBQUs3QyxDQUFBQSxFQUNoQmtDLE9BQU8sU0FBQzFILElBQUFBO0FBQVEsYUFBQSxDQUFDK1AsTUFBTUMsT0FBT2hRLEVBQUFBLENBQUFBO0lBQUssQ0FBQSxFQUNuQ3NHLElBQUksU0FBQ3RHLElBQUFBO0FBQUFBLGFBQWNnUSxPQUFDaFEsRUFBQUE7SUFBSSxDQUFBO0VBQzdCLEdBUU02SSxHQUFBQSxVQUFRbkYsU0FBQUEsSUFBQUE7QUFBUSxRQUFBO0FBQUEsVUFBQXdaLEtBQUEsU0FBQUMsSUFBQUE7QUFxQ3BCLGVBTEFDLEdBQUtsQiw0QkFBNEJKLEdBQU1yZSxRQUd2QzJmLEdBQUt6VixLQUFLLGdCQUFnQnlDLEVBQUFBLEdBQUFBO01BRWQsR0FwQ3NCZ1QsS0FBQW5nQixNQUE1QmlmLEtBQTRCa0IsR0FBS2xCLDJCQUM1QkosS0FBR3NCLEdBQUt0QixPQUVYMVIsS0FBRzFHLElBQUsyWixNQUFBQSxTQUFBQSxJQUFBQSxJQUFBQTtBQUFBQSxZQUFBQTtBQUFBQSxjQUFBQSxNQUFBQSxTQUFBQSxJQUFBQSxJQUFBQSxJQUFBQTtBQUFBQSxnQkFBQUEsY0FBQUEsT0FBQUEsR0FBQUEsRUFBQUEsR0FBQUE7QUFBQUEsa0JBQUFBLElBQUFBLElBQUFBLElBQUFBLEtBQUFBLEdBQUFBLEVBQUFBLEVBQUFBO0FBQUFBLG1CQUFBQSxTQUFBQSxHQUFBQSxJQUFBQTtBQUFBQSxvQkFBQUE7QUFBQUEseUJBQUFBLEVBQUFBLEtBQUFBLEdBQUFBLEtBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEtBQUFBLEdBQUFBLEdBQUFBLEtBQUFBLE1BQUFBLEdBQUFBLE1BQUFBO0FBQUFBLHdCQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxFQUFBQSxRQUFBQSxLQUFBQSxHQUFBQSxLQUFBQSxJQUFBQSxPQUFBQSxLQUFBQSxHQUFBQSxLQUFBQSxNQUFBQSxLQUFBQSxJQUFBQSxNQUFBQSxDQUFBQSxFQUFBQTtBQUFBQSxvQkFBQUEsS0FBQUEsR0FBQUE7a0JBQUFBO0FBQUFBLGtCQUFBQSxLQUFBQSxHQUFBQSxJQUFBQSxHQUFBQSxFQUFBQSxJQUFBQSxLQUFBQTtnQkFBQUEsU0FBQUEsSUFBQUE7QUFBQUEscUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE9BQUFBLEdBQUFBLEVBQUFBO2dCQUFBQTtjQUFBQSxHQUFBQSxHQUFBQSxHQUFBQSxRQUFBQTtBQUFBQSxvQkFBQUEsS0FBQUEsU0FBQUEsSUFBQUE7QUFBQUEsc0JBQUFBO0FBQUFBLG9CQUFBQSxHQUFBQSxRQUFBQSxHQUFBQSxPQUFBQTtrQkFBQUEsU0FBQUEsSUFBQUE7a0JBQUFBO0FBQUFBLHlCQUFBQTtnQkFBQUE7QUFBQUEsb0JBQUFBLE1BQUFBLEdBQUFBLEtBQUFBLFFBQUFBLEdBQUFBLEtBQUFBLElBQUFBLFNBQUFBLElBQUFBO0FBQUFBLHdCQUFBQSxHQUFBQSxFQUFBQTtnQkFBQUEsQ0FBQUE7QUFBQUEsZ0JBQUFBLEdBQUFBO2NBQUFBO0FBQUFBLHFCQUFBQTtZQUFBQTtBQUFBQSxnQkFBQUEsRUFBQUEsWUFBQUEsSUFBQUEsT0FBQUEsSUFBQUEsVUFBQUEsd0JBQUFBO0FBQUFBLHFCQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxLQUFBQSxHQUFBQSxLQUFBQSxHQUFBQSxRQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxLQUFBQSxHQUFBQSxFQUFBQSxDQUFBQTtBQUFBQSxvQkFrQ2pCLFNBQUFDLElBQUE1UyxJQUFBNlMsSUFBQUE7QUFPTyxrQkFBQW5DLElBQUEzQixJQUFBQSxLQUFBQTtBQUFBLHNCQUNOLFNBQUE5WixHQUFBbkMsSUFBQTtBQUFBLG9CQUFBO0FBUU0seUJBQUEsRUFBQW9CLEtBQUEwZSxHQUFBN2YsU0FLTixNQUFBRCxLQUZNa04sR0FBQTlMLEVBQUFBLE1BRTRCZ2EsR0FBQXdCLE1BQUE7QUFDaEMsd0JBQUEsQ0FBQXVCLEdBQUsvQyxFQUFBQSxFQUtQLFFBQUEsS0FETUEsR0FBQXdCLEtBQUFvRCxJQUFzQi9ELE9BQVNBLEtBQUE0QixHQUFBaEIsS0FBQSxNQUFBZSxLQUFBLElBQUFHLE1BQUEsQ0FBQSxFQUFBO0FBSHBDM0Msb0JBQUFBLEtBQUFBLEdBQUEvWTtrQkFNRDtBQUdNdWIsa0JBQUFBLEtBQ05DLEdBQUlELElBQUMsR0FBQXhDLEVBQUFBLElBRUx3QyxLQUFBeEM7Z0JBQUFBLFNBRUhqWixJQUFBQTtBQUVEMGIscUJBQUFELE9BQUFBLEtBQXdCLElBQUEsT0FBQSxHQUFBemIsRUFBQUE7Z0JBQUFBO2NBQUFBLEdBQUFBLEdBQUFBO1lBQUFBLEdBQUFBLElBQUFBLFNBQUFBLElBQUFBO0FBQUFBLHFCQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxDQUFBQTtZQUFBQSxDQUFBQTtVQUFBQSxHQXRFTW1jLElBQUssU0FBbEJwTixJQUFBQTtBQUNULGdCQUFvQitPLEtBQUdMLEdBQUtkLHVCQUF1QjVOLEdBQVUzSixFQUFBQSxHQUV6RDBZLE1BQUFBLFdBQUFBO0FBQUFBLGtCQUFBQSxNQUFrQnZCLEdBQXlCLFFBQUExQyxRQUFBOUosUUFLL0JoQixHQUFVN0YsUUFBUXVCLEVBQUFBLENBQUFBLEVBQUtnUSxLQUFBLFNBQUFzRCxJQUFBQTtBQUNyQ04sZ0JBQUFBLEdBQUtwQixNQUFNdlYsSUFBSWlJLEdBQVUzSixJQUR6QnFGLEtBQTJDc1QsRUFBQUE7Y0FDUixDQUFBO0FBR25DdFQsY0FBQUEsS0FBT2dULEdBQUtwQixNQUFNeFYsSUFBSWtJLEdBQVUzSixFQUFBQTtZQUFBQSxHQVQ5QjBZO0FBQUFBLGdCQUFBQSxNQUFBQSxHQUFBQSxLQUFBQSxRQUFBQSxHQUFBQSxLQUFBQSxXQUFBQTtZQUFBQSxDQUFBQTtVQVdMLENBQUE7UUFBQSxTQUFBeGYsSUFBQTtBQUFBLGlCQUFBcEIsR0FBQW9CLEVBQUE7UUFBQTtBQUFBLGVBQUFULE1BQUFBLEdBQUEsT0FBQUEsR0FBQSxLQUFBLFFBQUFYLEVBQUEsSUFBQVc7TUFBQSxHQWpCYSxHQWtCUG1DLFNBQUFBLElBQUFBO0FBTVAsY0FMQXVVLEdBQUkxSCxNQUFNN00sRUFBQUEsR0FFVnlkLEdBQUt6VixLQUFLLFNBQVN5QyxFQUFBQSxHQUlwQnpLO01BQUEsQ0FBQTtBQUFBLGFBQUEsUUFBQSxRQUFBbkMsTUFBQUEsR0FBQSxPQUFBQSxHQUFBLEtBQUFYLEVBQUEsSUFBQUEsR0FBQSxDQUFBO0lBU0YsU0FBQThDLElBQUFBO0FBQUEsYUFBQTZaLFFBQUFDLE9BQUE5WixFQUFBQTtJQUFBO0VBQUEsR0FBQWtHLEdBT095Vyx5QkFBQSxTQUF1QnFCLElBQUFBO0FBQzdCLFdBQUEsS0FBWTdCLE1BQU04QixVQUFVLFNBQUNoaEIsSUFBQUE7QUFBQyxhQUFBQyxHQUFPa0ksTUFBTTRZO0lBQVcsQ0FBQTtFQUN4RCxHQU9RRSxHQUFBQSx3QkFBQSxTQUNOblAsSUFBQUE7QUFFQSxRQUFNK08sS0FBaUJ4Z0IsS0FBS3FmLHVCQUF1QjVOLEdBQVUzSixFQUFBQTtBQUV6RDlILFNBQUtpZiw0QkFBNEJ1QixPQUNuQ3hnQixLQUFLaWYsNEJBQTRCdUI7RUFFckMsR0FBQzVYLEdBRU8wVyx3QkFBQSxTQUFzQjdOLElBQUFBO0FBQzVCelIsU0FBSzRnQixzQkFBc0JuUCxFQUFBQSxHQUMzQnpSLEtBQUswSyxLQUFLLGNBQUEsR0FDVjFLLEtBQUswSyxLQUFLLFdBQVcrRyxFQUFBQTtFQUN2QixHQUFBclEsR0FFUW9lLGtCQUFBLFNBQWdCL04sSUFBQUE7QUFDdEJ6UixTQUFLNGdCLHNCQUFzQm5QLEVBQUFBLEdBQzNCelIsS0FBSzBLLEtBQUssZUFBQSxHQUNWMUssS0FBSzBLLEtBQUssV0FBVytHLEVBQUFBO0VBQ3ZCLEdBbEhBeEosRUFBQTJXLElBQUEsQ0FBQSxFQUFBN2IsS0FBQSxTQUFBd0csS0FBQSxXQUFBO0FBR0UsYUFBaURvUSxJQUY3Q2tGLEtBQStDLENBQUEsR0FBQW5jLEtBQUEsRUFFaEMxQyxLQUFLZ2dCLHdCQUFBQSxDQUFBQSxHQUFBQSxFQUF5QnJHLEtBQUFDLEdBQUFBLEdBQUFHLFFBQUU7QUFBeENyWixVQUFBQSxLQUNRVixLQUFLOGUsT0FBT3ZWLElBQTdCb1EsR0FBQS9VLEtBQUFBO0FBRUk4YSxNQUFBQSxNQUFZQSxHQUFTbGYsV0FDdkJxZSxLQUFRQSxHQUFNN1MsT0FBTzBULEVBQUFBO0lBRXhCO0FBR0QsV0FBWWIsR0FBQ3BVLE9BQU8sU0FBQzNJLElBQUFBO0FBQU1BLGFBQUFBO0lBQUMsQ0FBQTtFQUM5QixFQUFBLENBQUEsQ0FBQSxHQUFDOGM7QUFBQSxHQXBKdUIzVSxDQUFBQTtBQTRIWW5JLElDdkpoQytlLEtBUUU5VSwwQkFBQUEsSUFBQUE7QUFBQUEsV0FBQUEsS0FBQUE7QUFBQUEsV0FBQUEsR0FBQUEsTUFBQUEsTUFBQUEsU0FBQUEsS0FBQUE7RUFBQUE7QUFBQUEsU0FBQUEsRUFBQUEsSUFBQUEsRUFBQUEsR0FBQUEsR0FBQUEsVUFBQUEsV0FBQUEsU0FBU2tSLElBQUFBO0FBQVMsUUFBQTtBQUNMLGFBQUFWLFFBQUE5SixRQUFKelMsS0FBS0MsTUFBTXNkLFFBQVFoVSxJQUFJMFQsRUFBQUEsQ0FBQUE7SUFBQUEsU0FDckNqYyxJQUFBO0FBQUEsYUFBQSxRQUFBLE9BQUFBLEVBQUE7SUFBQTtFQUFBLEdBQUEsRUFBQTBCLElBQUEsQ0FBQSxFQUFBLEtBQUEsUUFBQSxLQU5ELFdBQUE7QUFDRSxXQUFPNkYsRUFBY3VZO0VBQ3ZCLEVBQUEsQ0FBQSxDQUFBLEdBQUFwZTtBQUFBLEdBTjZCOEksRUFBQUE7QUR1Sk8xSixJQ3ZKUDBKLEtDQzdCTywwQkFBQUEsSUFBQUE7QUFBQUEsV0FBQUEsS0FBQUE7QUFBQUEsV0FBQUEsR0FBQUEsTUFBQUEsTUFBQUEsU0FBQUEsS0FBQUE7RUFBQUE7QUFSc0NQLFNBUXRDTyxFQUFBQSxJQUFBQSxFQUFBQSxHQUFBQSxHQUFBQSxVQUFBQSxXQUFBLFNBQVNnVixJQUFBQTtBQUNQLFFBQWF0VSxLQUFHaEQsRUFBUU0sVUFBVWdYLEdBQWN0YSxJQUFBQTtBQUtoRCxXQUZBZ0csR0FBUWpNLFNBQVN1Z0IsR0FBY3pNLE9BRXhCN0g7RUFDVCxHQVhBeEUsRUFBQStZLElBQUEsQ0FBQSxFQUFBamUsS0FBQSxRQUFBd0csS0FBQSxXQUFBO0FBQ0UsV0FBb0JoQixFQUFDMFk7RUFDdkIsRUFBQSxDQUFBLENBQUEsR0FOc0N6VjtBQUFBQSxHQUFBQSxFQUFBQTtBRjhKRjFKLElHdkpoQm9mLEtBQUEsMEJBQUFDLElBQUFBO0FBQUEsV0FBQUQsS0FBQUE7QUFBQSxXQUFBQyxHQUFBdFcsTUFBQTdLLE1BQUE0SyxTQUFBQSxLQUFBNUs7RUFBQTtBQU1uQixTQU5tQjJJLEVBQUF1WSxJQUFBQyxFQUFBQSxHQUFBRCxHQUFBcGMsVUFRcEJpSCxXQUFBLFdBQUE7QUFDRSxXQUFhWixPQUFDaVcsUUFBUXBoQixLQUFLQyxNQUFNb2hCLG9CQUFBQSxFQUM5QjVXLE9BQU8sU0FBQXpKLElBQUE7QUFBUSxhQUFxQixjQUFBLE9BQXJCc2dCLEdBQUEsQ0FBQTtJQUErQixDQUFBLEVBQzlDcFUsT0FDQyxTQUFDcVUsSUFBTTVnQixJQUFBQTtBQUFBQSxVQUFBQTtBQUFnQjRnQixhQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxNQUFNNWdCLEtBQUFBLENBQUFBLEdBQW5CaUMsR0FBQUEsQ0FBQUEsQ0FBQUEsSUFBYTJlLEdBQUFBLENBQUFBLEdBQVdDLEdBQUFBO0lBQUEsR0FDbEMsQ0FBRSxDQUFBO0VBRVIsR0FBQ3ZaLEVBQUFpWixJQUFBLENBQUEsRUFBQW5lLEtBQUEsUUFBQXdHLEtBWEQsV0FBQTtBQUNFLFdBQW9CaEIsRUFBQ2taO0VBQ3ZCLEVBQUEsQ0FBQSxDQUFBLEdBQUNQO0FBQUEsR0FOMkIxVixFQUFBQTtBSHVKUTFKLElJOUlFNGYsS0FBQSwwQkFBQVAsSUFBQUE7QUFBQSxXQUFBTyxLQUFBQTtBQUFBLFdBQUFQLEdBQUF0VyxNQUFBN0ssTUFBQTRLLFNBQUFBLEtBQUE1SztFQUFBO0FBQUEySSxJQUFBK1ksSUFBQVAsRUFBQUE7QUFBQSxNQUFBdlksS0FBQThZLEdBQUE1YztBQU1yQyxTQU5xQzhELEdBUTlCK1ksV0FBQSxTQUFTbGIsSUFBQUE7QUFDZixRQUFBLENBQUtBLE1BQUFBLENBQVNBLEdBQUtqRyxPQUNqQixRQUFPLENBQUE7QUFHVCxRQUFBLENBQUtSLEtBQUtDLE1BQU00UixVQUFBQSxDQUFXN1IsS0FBS0MsTUFBTTRSLE9BQU90RixRQUMzQyxRQUNEOUY7QUFFRCxRQUFNOEYsS0FBVThMLEdBQU8yRCxZQUFZaGMsS0FBS0MsTUFBTTRSLE9BQU90RixPQUFBQTtBQUdyRCxXQUFJOUYsR0FBSyxDQUFBLGFBQW1CNUQsUUFBQUEsR0FDRXdHLElBQUksU0FBQ1EsSUFBQUE7QUFDL0IsVUFBSStYLEtBQU07QUFFVixhQUFBaGlCLEdBQWV5SixJQUFJLFNBQUMyUSxJQUFRclksSUFBQUE7QUFFMUIsZUFBQSxXQUFJcVksR0FBT3ZULFFBQ1RtYixNQUUyQixjQUFBLE9BQWhCNUgsR0FBT3ZULE9BQ1R1VCxHQUFPdlQsS0FBS29ELEVBQUFBLElBRU5tUSxHQUFDdlQsUUFJWG9ELEdBQUlsSSxLQUFJaWdCLEVBQUFBO01BQ2pCLENBQUE7SUFDRixDQUFBLElBSXFCLFlBQUEsT0FBUm5iLEdBQUMsQ0FBQSxLQUFxQkEsR0FBSyxDQUFBLGFBQWM1RCxRQW9CakQsQ0FBQSxJQW5CRzRELEdBQXFCNEMsSUFBSSxTQUFDUSxJQUFBQTtBQUNoQzBDLGFBQUFBLEdBQVFsRCxJQUFJLFNBQUMyUSxJQUFRclksSUFBQUE7QUFDbkIsZUFBQSxXQUFJcVksR0FBT3ZULE9BQ2tCLGNBQUEsT0FBQTdHLEdBQVQ2RyxPQUNUdVQsR0FBT3ZULEtBQUtvRCxFQUFBQSxJQUVabVEsR0FBT3ZULE9BRVB1VCxHQUFPbFMsS0FDTitCLEdBQUNtUSxHQUFPbFMsRUFBQUEsS0FFbEI4UyxHQUFPckwsTUFBZ0U1Tiw0REFBQUEsS0FDUSw4RkFBQSxHQUVoRjtNQUNILENBQUE7SUFBRSxDQUFBO0VBS1IsR0FBQVAsR0FFQTJLLFdBQUEsU0FBUzhWLElBQUFBO0FBQ1AsV0FBTyxFQUNMcGIsTUFBTXpHLEtBQUsyaEIsU0FBU0UsR0FBZ0JwYixJQUFBQSxHQUNwQzZOLE9BQU91TixHQUFnQnZOLE1BQUFBO0VBRTNCLEdBQUNyTSxFQUFBeVosSUFBQSxDQUFBLEVBQUEzZSxLQUFBLFFBQUF3RyxLQWxFRCxXQUFBO0FBQ0UsV0FBb0JoQixFQUFDMFk7RUFDdkIsRUFBQSxDQUFBLENBQUEsR0FBQ1M7QUFBQSxHQU42Q2xXLEVBQUFBO0FKOElWMUosSUt6SmhDZ2dCLEtBQ0d4Ryw0QkFBQUE7QUFBQUEsV0FBQUEsS0FBQUE7RUFBQUE7QUFxQlQsU0FyQlNBLEdBQUFBLG1CQUFQLFNBQXdCL0ssSUFBQUE7QUFDdEIsUUFBY3dCLEtBQUcsSUFBSTZNO0FBZ0JyQixXQWRJck8sR0FBT2dOLG1CQUFtQmQsTUFDNUIxSyxHQUFTQyxTQUNQLElBQUlrUCxHQUFnQixFQUNsQkcsc0JBQXNCOVEsR0FBT3FCLE9BQUFBLENBQUFBLENBQUFBLEdBS25DRyxHQUFTQyxTQUFTLElBQW9CNk8sR0FBQyxFQUFFdEQsU0FBU2hOLEdBQU9nTixRQUFBQSxDQUFBQSxDQUFBQSxHQUN6RHhMLEdBQVNDLFNBQ1AsSUFBcUMwUCxHQUFDLEVBQUU3UCxRQUFRdEIsR0FBT3NCLE9BQUFBLENBQUFBLENBQUFBLEdBRXpERSxHQUFTQyxTQUFTLElBQStCZ1AsSUFBQUEsR0FHbkRqUDtFQUFBLEdBR0YrUDtBQUFBLEdBckJTeEc7QUx3SjZCeFosSUt4SjdCd1osS0NMUCxTQUFZeUcsSUFBQUE7QUFBZSxNQUFBdFosS0FBQXpJO0FBQUFBLE9BSm5Ca0YsUUFBQUEsUUFDQWtGLEtBQUFBLFlBQWlELENBQUEsR0FBQSxLQUNqRDRYLGdCQUFBQSxPQU1SL1EsS0FBQUEsV0FBVyxXQUFBO0FBQU0sV0FBQXhJLEdBQUt2RDtFQUFLLEdBQUEsS0FDM0IrYyxlQUFlLFdBQUE7QUFBQSxXQUFVeFosR0FBQzJCO0VBQVMsR0FFbkN1SCxLQUFBQSxXQUFXLFNBQUN1USxJQUFBQTtBQUNWLFFBQXVCLGNBQUEsT0FBWkEsR0FDVCxPQUFNLElBQUEsTUFBVSwyQkFBQTtBQUNsQixRQUFJelosR0FBS3VaLGNBQ1AsT0FBQSxJQUFlL08sTUFBQyxtQ0FBQTtBQUVsQnhLLElBQUFBLEdBQUt1WixnQkFBQUE7QUFFTCxRQUFNRyxLQUFZMVosR0FBS3ZEO0FBQ3ZCLFFBQUE7QUFDRXVELE1BQUFBLEdBQUt2RCxRQUFRZ2QsR0FBUXpaLEdBQUt2RCxLQUFBQTtJQUczQixVQUZBO0FBQ0N1RCxNQUFBQSxHQUFLdVosZ0JBQUFBO0lBQ047QUFFRCxhQUFxQ3JJLElBQUFBLEtBQUFBLEVBQWRsUixHQUFLMkIsU0FBQUEsR0FBQUEsRUFBU3VQLEtBQUFDLEdBQUFBLEdBQUFHLE9BQUFBLEVBQ25DelAsR0FEaUJxUCxHQUFBL1UsT0FDUjZELEdBQUt2RCxPQUFPaWQsRUFBQUE7QUFHdkIsV0FBTzFaLEdBQUt2RDtFQUNkLEdBQUEsS0FFQWtNLFlBQVksU0FBQzlHLElBQUFBO0FBQ1gsUUFBd0IsY0FBQSxPQUFBdEosR0FDdEIsT0FBTSxJQUFTaVMsTUFBQyw0QkFBQTtBQUdsQixXQURBeEssR0FBSzJCLFlBQUFBLENBQUFBLEVBQUFBLE9BQWdCM0IsR0FBSzJCLFdBQVMsQ0FBRUUsRUFBQUEsQ0FBQUEsR0FFbEMsV0FBQTtBQUFBLGFBQUE3QixHQUFLMkIsWUFBWTNCLEdBQUsyQixVQUFVSyxPQUFPLFNBQUMyWCxJQUFBQTtBQUFBQSxlQUFXQSxPQUFLOVg7TUFBUSxDQUFBO0lBQUM7RUFDdEUsR0FuQ0V0SyxLQUFLa0YsUUFBUTZjO0FBQ2Y7QU4ySm9DamdCLElPL0ladU0sTTdDbkJxaFIsU0FBV3pPLElBQUVHLElBQUFBO0FBQUcsTUFBSVEsS0FBRSxFQUFDSyxLQUFJYixLQUFFLFNBQU82QixLQUFJeEIsSTZDbUI1aVIsTTdDbkJpalJpaUIsVUFBUyxTQUFTemlCLElBQUVHLElBQUFBO0FBQUcsV0FBT0gsR0FBRUMsU0FBU0UsRUFBQUE7RUFBRSxHQUFFdWlCLFVBQVMsU0FBUzFpQixJQUFBQTtBQUFHLFFBQUlXLElBQUVvQjtBQUFFLFdBQU8zQixLQUFLNkYsb0JBQWtCdEYsS0FBRSxDQUFBLElBQUlvQixLQUFFLENBQUEsR0FBSTVCLEVBQUFBLElBQUdDLE1BQUtBLEtBQUs2RixrQkFBZ0IsV0FBQTtBQUFXLGFBQU9sRTtJQUFDLEdBQUUzQixLQUFLeUYsd0JBQXNCLFNBQVM3RixJQUFBQTtBQUFHSSxXQUFLQyxNQUFNMkUsVUFBUWhGLEdBQUVnRixTQUFPckUsR0FBRW1CLEtBQUtaLENBQUFBO0lBQUUsR0FBRWQsS0FBS2lGLE1BQUksU0FBU3JGLElBQUFBO0FBQUdXLE1BQUFBLEdBQUVVLEtBQUtyQixFQUFBQTtBQUFHLFVBQUlHLEtBQUVILEdBQUV1SDtBQUFxQnZILE1BQUFBLEdBQUV1SCx1QkFBcUIsV0FBQTtBQUFXNUcsUUFBQUEsR0FBRXdYLE9BQU94WCxHQUFFRCxRQUFRVixFQUFBQSxHQUFHLENBQUEsR0FBR0csTUFBR0EsR0FBRWtHLEtBQUtyRyxFQUFBQTtNQUFFO0lBQUMsSUFBR0EsR0FBRUM7RUFBUSxFQUFBO0FBQUcsU0FBT1UsR0FBRStoQixTQUFTbGlCLEtBQUdHLEdBQUU4aEIsU0FBUzFkLGNBQVlwRTtBQUFDLEc2Q21CcC9SZ2lCO0FQK0lTemdCLElPL0lUeWdCLEtBd0UzQiw0QkFBQTtBQUFBLFdBQUFDLEtBQUFBO0FBQ0VyWCxXQUFPc1gsT0FBT3ppQixNQUFNd2lCLEdBQU9FLGNBQUFBLENBQUFBO0VBQzdCO0FBQUMsTUFBQTlpQixLQUFBb0IsR0FBQTtBQXVHQSxTQUFBcEIsR0FqR0Q2aUIsU0FBQSxTQUFPRSxJQUFBQTtBQUNMLFdBQU94WCxPQUFPc1gsT0FBT3ppQixNQUFNMmlCLEVBQUFBO0VBQzdCLEdBT0FqYSxHQUFBQSxTQUFBLFNBQU9pYSxJQUFBQTtBQUNMLFdBQUtBLE1BRUwzaUIsS0FBS3lpQixPQUNIRCxHQUFPSSxrQkFDRjFXLEVBQUEsQ0FBQSxHQUFBbE0sTUFDQTJpQixFQUFBQSxDQUFBQSxDQUFBQSxHQUlBM2lCLFFBVHdCQTtFQVVqQyxHQUVPMGlCLEdBQUFBLGdCQUFQLFdBQUE7QUFDRSxXQUFPLEVBQ0w5UixPQUFPLElBQUlpUyxHQUFNLEVBQ2Y5RixRQUFRK0YsRUFBT0MsTUFDZmxSLFFBQUFBLFFBQ0FwTCxNQUFNLEtBQUEsQ0FBQSxHQUVSb1IsUUFBUSxJQUFJSixNQUNackIsVTdDaklrc0IsRUFBQ25QLFNBQVEsS0FBQSxHNkNrSTNzQjZPLE9BQU8sUUFDUGtOLFFBQVEsUUFDUkMsc0JBQXNCLEtBQ3RCdkssV0FBQUEsTUFDQTVVLE9BQU8sQ0FBQSxHQUNQa0osV0FBVyxDQUFBLEVBQUE7RUFFZixHQUFDd1YsR0FFTUksb0JBQVAsU0FBeUJELElBQUFBO0FBQ3ZCLFFBQUFqZ0IsS0FBZSxJQUFBMUIsS0FBYXloQixPQUFPRSxFQUFBQTtBQXVEbkMsV0FwRGtDLGFBQUEsT0FBVkEsR0FBQ3BoQixRQUFzQm9oQixHQUFjcGhCLFFBQzNEZ1AsR0FBT2tTLE9BQU8sRUFDWmxoQixNQUFNLEVBQ0oyaEIsYUFBQUEsS0FBYSxFQUFBLENBQUEsR0FNbkIzUyxHQUFPa1MsT0FBTyxFQUNaNVEsUUFBUXdHLEdBQU9pRCxpQkFBaUIvSyxFQUFBQSxFQUFBQSxDQUFBQSxHQUdsQ0EsR0FBT2tTLE9BQU8sRUFDWmxGLFNBQVNELEdBQWFoQyxpQkFBaUIvSyxFQUFBQSxFQUFBQSxDQUFBQSxHQUd6Q0EsR0FBT2tTLE9BQU8sRUFDWjFRLFVBQVUrUCxHQUFjeEcsaUJBQWlCL0ssRUFBQUEsRUFBQUEsQ0FBQUEsR0FJM0NBLEdBQU9rUyxPQUFPLEVBQ1ovUixZQUFZLElBQWNsQixHQUFDZSxHQUFPZCxRQUFBQSxFQUFBQSxDQUFBQSxHQUlwQ2MsR0FBT3NILFNBQVMsSUFBQSxNQUVadEgsR0FBT2hDLFVBRVRnQyxHQUFPc0gsT0FBT0QsSUFBSSxFQUNoQjlQLElBQUksVUFDSndPLFVBQVVVLEdBQWVxQixRQUN6QkQsV0FBVzlHLEdBQUFBLENBQUFBLEdBSVhmLEdBQU81QixjQUVUNEIsR0FBT3NILE9BQU9ELElBQUksRUFDaEI5UCxJQUFJLGNBQ0p3TyxVQUFVVSxHQUFlbU0sUUFDekIvSyxXQUFXL0UsR0FBQUEsQ0FBQUEsR0FLWDlDLEdBQU9tSCxXQUNUbkgsR0FBT21ILFFBQVFoUyxRQUFRLFNBQUMvRixJQUFBQTtBQUFNNFEsYUFBQUEsR0FBT3NILE9BQU9ELElBQUlqWSxFQUFBQTtJQUFFLENBQUEsR0FHN0M0UTtFQUNULEdBQUNpUztBQUFBLEdBekdEO0FBQUEsU0NqRmdCWSxHQUNoQm5qQixJQUFBQTtBQVFBLE1Bc0NFK1osSUF0Q0l6SixLQUFTQyxHQUFBQTtBQWlEZixTQUVJak8sRUFBQSxNQUFBMkosRUFBQSxFQUFBNEksTUFBTTdVLEdBQU02VSxNQUNadU8sU0FBU3BqQixHQUFNb2pCLFNBQ2Ysa0JBQWdCcGpCLEdBQU0rWixVQUFVL1osR0FBTStaLE9BQU9sUyxJQUM3Q2tGLFdBQVcwRixHQUNUMUYsR0FBVSxJQUFBLEdBQ1YvTSxHQUFNK00sV0FDTnVELEdBQU92RCxVQUFVc1csRUFBQUEsR0FFbkJ4ZixPQUFBQSxFQUFBQSxDQUFBQSxHQUNLN0QsR0FBTTZELE9BQ055TSxHQUFPek0sTUFBTXdmLEVBQUFBLEdBRWxCbE8sU0F4Q2dCLFNBQ2xCMVMsSUFBQUE7QUFFSXpDLElBQUFBLEdBQU1zakIsZUFFVmhULEdBQU9pVCxhQUFhOVksS0FDbEIsYUFDQWhJLElBQ0F6QyxHQUFNaUosTUFDTmpKLEdBQU0rWixRQUNOL1osR0FBTTRKLEdBQUFBO0VBRVYsRUFBQSxJQUdFbVEsS0EwQjBCL1osR0FBTStaLFVBdEJDLGNBQUEsT0FBdEJBLEdBQU9wVCxhQUNUb1QsR0FBT3BULFdBQVczRyxHQUFNaUosS0FBS3pDLE1BQU14RyxHQUFNNEosS0FBSzVKLEdBQU0rWixNQUFBQSxJQUFBQSxHQUU3Q3BULGFBTEksQ0FBQSxDQUFBLEdBckNoQjNHLEdBQU0rWixVQUE0QyxjQUFBLE9BQXRCL1osR0FBQytaLE9BQU95SixZQUMvQnhqQixHQUFNK1osT0FBT3lKLFVBQVV4akIsR0FBTWlKLEtBQUt6QyxNQUFNeEcsR0FBTTRKLEtBQUs1SixHQUFNK1osTUFBQUEsSUFHOUQvWixHQUFNK1osVUFBVS9aLEdBQU0rWixPQUFPbkMsU0FFN0J0VixFQUFDMlYsSUFBYyxFQUNiQyxVQUFVbFksR0FBTStaLE9BQU9sUyxJQUN2QjdILE9BQU8sRUFDTCtaLFFBQVEvWixHQUFNK1osUUFDZDlRLE1BQU1qSixHQUFNaUosTUFDWlcsS0FBSzVKLEdBQU00SixJQUFBQSxFQUFBQSxDQUFBQSxJQU1aNUosR0FBTWlKLEtBQUt6QyxJQUFBQTtBQWlEdEI7QUM3RWdCaWQsU0FBQUEsR0FBR3pqQixJQUFBQTtBQUtqQixNQUFZc1EsS0FBR0MsR0FBQUEsR0FDVHFCLEtBQVNoQixHQUFZLFNBQUMzTCxJQUFBQTtBQUFLLFdBQVVBLEdBQUMyTTtFQUFNLENBQUE7QUFtQ2xELFNBRUl0UCxFQUFBLE1BQUEsRUFBQXlLLFdBQVcwRixHQUFVMUYsR0FBVSxJQUFBLEdBQU91RCxHQUFPdkQsVUFBVTJXLEVBQUFBLEdBQ3ZEdk8sU0F4QmdCLFNBQ2xCMVMsSUFBQUE7QUFFSXpDLElBQUFBLEdBQU0yakIsY0FDVnJULEdBQU9pVCxhQUFhOVksS0FBSyxZQUFZaEksSUFBR3pDLEdBQU00SixHQUFBQTtFQUNoRCxFQUFBLEdBR001SixHQUFNSixXQUNJSSxHQUFDSixXQUdISSxHQUFDNEosSUFBSWIsTUFBTUssSUFBSSxTQUFDSCxJQUFZdkgsSUFBQUE7QUFDdEMsUUFBWXFZLE1BekJFLFNBQUNwTixJQUFBQTtBQUNqQixVQUFJaUYsSUFBUTtBQUNWLFlBQVVzSSxLQUFHOUIsR0FBTzJELFlBQVluSyxHQUFPdEYsT0FBQUE7QUFFdkMsWUFBSTROLEdBQ0YsUUFBT0EsR0FBS3ZOLEVBQUFBO01BRWY7QUFFRCxhQUNGO0lBQUEsR0FlNkJqTCxFQUFBQTtBQUV6QixXQUFJcVksTUFBVUEsR0FBT25OLFNBQW1CLE9BRWpDdEssRUFBQzZnQixJQUFHLEVBQUFyZ0IsS0FBS21HLEdBQUtwQixJQUFJb0IsTUFBTUEsSUFBTVcsS0FBSzVKLEdBQU00SixLQUFLbVEsUUFBUUEsR0FBQUEsQ0FBQUE7RUFDL0QsQ0FBQSxDQUFBO0FBV0o7QUN0RGdCNkosU0FBQUEsR0FBVzVqQixJQUFBQTtBQUt6QixTQUNFc0MsRUFBQ21oQixJQUFHLEVBQUFFLFlBQUFBLEtBQVksR0FDZHJoQixFQUFDNmdCLElBQUUsRUFDRHRPLE1BQUssU0FDTHVPLFNBQVNwakIsR0FBTW9qQixTQUNmRSxhQUFBQSxNQUNBcmEsTUFBTSxJQUFBLEVBQVNqSixHQUFNNFAsT0FBQUEsR0FDckI3QyxXQUFXMEYsR0FDVDFGLEdBQVUsU0FBQSxHQUNWL00sR0FBTStNLFlBQVkvTSxHQUFNK00sWUFBWSxJQUFBLEVBQUEsQ0FBQSxDQUFBO0FBSzlDO0FDZmdCOFcsU0FBQUEsS0FBQUE7QUFDZCxNQUFZdlQsS0FBR0MsR0FBQUEsR0FDVC9KLEtBQU9vSyxHQUFZLFNBQUMzTCxJQUFBQTtBQUFLLFdBQUFsRSxHQUFXeUY7RUFBSSxDQUFBLEdBQ2xDc1csS0FBR2xNLEdBQVksU0FBQzNMLElBQUFBO0FBQUssV0FBVUEsR0FBQzZYO0VBQU0sQ0FBQSxHQUFBbmIsS0FDbkNpUCxHQUFZLFNBQUMzTCxJQUFBQTtBQUFLLFdBQVVBLEdBQUMyTTtFQUFNLENBQUEsR0FDNUMxUixLQUFJbVEsR0FBQUEsR0FFUXlULEtBQUcsV0FBQTtBQUNuQixXQUFJbFMsS0FDS0EsR0FBT21TLGVBQWV4akIsU0FBQUE7RUFHakM7QUFFQSxTQUNFK0IsRUFBQSxTQUFBLEVBQU95SyxXQUFXMEYsR0FBVTFGLEdBQVUsT0FBQSxHQUFVdUQsR0FBT3ZELFVBQVVpWCxLQUFBQSxFQUFBQSxHQUM5RHhkLE1BQ0NBLEdBQUtpRCxLQUFLTCxJQUFJLFNBQUNRLElBQUFBO0FBQ2IsV0FBUXRILEVBQUFtaEIsSUFBRyxFQUFBM2dCLEtBQUs4RyxHQUFJL0IsSUFBSStCLEtBQUtBLEdBQUFBLENBQUFBO0VBQy9CLENBQUEsR0FFRGtULE9BQVcrRixFQUFPb0IsWUFBQUEsQ0FBYXpkLE1BQXdCLE1BQWhCQSxHQUFLakcsV0FDM0MrQixFQUFDc2hCLElBQVUsRUFDVGhVLFNBQVMxUCxHQUFFLFNBQUEsR0FDWGtqQixTQUFTVSxHQUFBQSxHQUNUL1csV0FBVzBGLEdBQVUxRixHQUFVLFNBQUEsR0FBWXVELEdBQU92RCxVQUFVcUMsT0FBQUEsRUFBQUEsQ0FBQUEsR0FJL0QwTixPQUFXK0YsRUFBT3FCLFlBQVkxZCxNQUF3QixNQUFoQkEsR0FBS2pHLFVBQzFDK0IsRUFBQ3NoQixJQUNDLEVBQUFoVSxTQUFTMVAsR0FBRSxnQkFBQSxHQUNYa2pCLFNBQVNVLEdBQUFBLEdBQ1QvVyxXQUFXMEYsR0FDVDFGLEdBQVUsVUFBQSxHQUNWdUQsR0FBT3ZELFVBQVVvWCxRQUFBQSxFQUFBQSxDQUFBQSxHQUt0QnJILE9BQVcrRixFQUFPN1AsU0FDakIxUSxFQUFDc2hCLElBQ0MsRUFBQWhVLFNBQVMxUCxHQUFFLE9BQUEsR0FDWGtqQixTQUFTVSxHQUFBQSxHQUNUL1csV0FBVzBGLEdBQVUxRixHQUFVLE9BQUEsR0FBVXVELEdBQU92RCxVQUFVdUMsS0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUE7QUFLcEU7QUNuRGlDLElBV2hCOFUsS0FBQSwwQkFBQWxELElBQUFBO0FBQUEsV0FBQWtELEtBQUFBO0FBQUEsV0FBQWxELEdBQUF0VyxNQUFBN0ssTUFBQTRLLFNBQUFBLEtBQUE1SztFQUFBO0FBQUEySSxJQUFBMGIsSUFBQWxELEVBQUFBO0FBQUEsTUFBQXZZLEtBQUF5YixHQUFBdmY7QUFlZCxTQWZjOEQsR0FDTGtELGdCQUFBLFdBQUE7QUFDUixhQUF3QjlLLElBQUE0WSxLQUFBQyxFQUFBN1osS0FBS0MsTUFBTXNNLE9BQUFBLEdBQUFBLEVBQUFBLEtBQUFBLEdBQUFBLEdBQUFBLFFBQVM7QUFBakMrWCxVQUFBQSxLQUNUM0ssR0FBQS9VO0FBQUFBLGlCQUFJMGYsR0FBVUMsY0FDWkQsR0FBVUMsWUFBWSxJQUdJLE1BQXhCRCxHQUFVQyxhQUFBQSxPQUFtQkQsR0FBVUMsYUFDekN0TixHQUFJMUgsTUFBZ0MrVSw0QkFBQUEsR0FBVUMsU0FBQUE7SUFFakQ7RUFDSCxHQU1RQyxHQUFBQSxVQUFBLFNBQVFDLElBQWNDLElBQUFBO0FBQzVCLFdBQUlELEtBQVFDLEtBQ0gsSUFDRUQsS0FBUUMsS0FBQUEsS0FJWjtFQUNULEdBQUM5YixHQUVPK2IsaUJBQUEsU0FBZXJpQixJQUFReEIsSUFBQUE7QUFHN0IsYUFGQTRCLElBQUlraUIsS0FBTSxHQUVXaEgsS0FBQS9ELEVBQUE3WixLQUFLQyxNQUFNc00sT0FBQUEsR0FBQUEsRUFBQUEsS0FBQUEsR0FBQUEsR0FBQUEsUUFBUztBQUE5QnlOLFVBQUFBLEtBQ1RJLEdBQUF4VjtBQUFBLFVBQVksTUFBUmdnQixHQVVGO0FBVEEsVUFBTUgsS0FBUW5pQixHQUFFMEcsTUFBTWdSLEdBQU83USxLQUFBQSxFQUFPMUMsTUFDOUJpZSxLQUFRNWpCLEdBQUVrSSxNQUFNZ1IsR0FBTzdRLEtBQUFBLEVBQU8xQztBQUdsQ21lLE1BQUFBLE1BRDRCLGNBQUEsT0FBbkI1SyxHQUFPd0ssVUFDVHhLLEdBQU93SyxRQUFRQyxJQUFPQyxFQUFBQSxJQUFTMUssR0FBT3VLLFlBRXRDdmtCLEtBQUt3a0IsUUFBUUMsSUFBT0MsRUFBQUEsSUFBUzFLLEdBQU91SztJQUtoRDtBQUVELFdBQU9LO0VBQ1QsR0FBQ2hjLEdBRVNtRCxXQUFBLFNBQVN0RixJQUFBQTtBQUNqQixRQUFnQm9lLEtBQUEsQ0FBQSxFQUFBN1ksT0FBT3ZGLEdBQUtpRCxJQUFBQTtBQUM1Qm1iLElBQUFBLEdBQVd0akIsS0FBS3ZCLEtBQUsya0IsZUFBZXZILEtBQUtwZCxJQUFBQSxDQUFBQTtBQUV6QyxRQUFZOGtCLEtBQUcsSUFBSXJiLEVBQVFvYixFQUFBQTtBQUszQixXQUZBQyxHQUFPdGtCLFNBQVNpRyxHQUFLakcsUUFHdkJza0I7RUFBQSxHQTdDQTdjLEVBQUFvYyxJQUFBLENBQUEsRUFBQXRoQixLQUFBLFFBQUF3RyxLQUFBLFdBQUE7QUFDRSxXQUFPaEIsRUFBY3djO0VBQ3ZCLEVBQUEsQ0FBQSxDQUFBLEdBQUNWO0FBQUEsR0Fmc0I3WSxFQUFBQTtBQVhRLElBV1JBLEtDaEJ2QixTQUNFckMsSUFDQW9iLElBQ0FTLElBQ0FSLElBQUFBO0FBQUFBLFNBRUR0ZixTQUFBQSxJQUFBQTtBQUNDLFFBQUErZixJQUFBQSxLQUFBQSxTQUFjQSxLQUFBL2YsR0FBTTNELFNBQU4wakIsR0FBWTFZLFVBQ3RCckgsR0FBTTNELEtBQUtnTCxRQUFRbEQsSUFBSSxTQUFDNUcsSUFBQUE7QUFDdEIsYUFBWUEsRUFBQUEsQ0FBQUEsR0FBQUEsRUFBQUE7SUFDZCxDQUFBLElBQ0EsQ0FBQSxHQUFBSCxLQUNVaUssR0FBUS9MLFFBQ1Z3WixLQUFHek4sR0FBUW9MLEtBQUssU0FBQ2xWLElBQUFBO0FBQUFBLGFBQU9BLEdBQUMwRyxVQUFVQTtJQUFLLENBQUEsR0FBQTlHLEtBQUEsT0FJaEQ2aUIsS0FBQUEsT0FDTXBOLEtBQUFBLE9BQ05wUCxLQUFBQTtBQThDSixRQUFBLFdBbkRlc1IsS0F3QlJnTCxLQUFBQSxPQVlDaEwsR0FBT3VLLFlBR1R6TSxLQUFBQSxPQUVBcFAsS0FBQUEsT0FmWSxNQUFWeWMsS0FDRnpjLEtBQUFBLE9BQ1N5YyxLQUFRLE1BR2pCRCxLQUFBQSxNQUNBdE4sS0FBQUEsUUF2QlUsTUFBVnVOLEtBRUZ2TixLQUFBQSxPQUNTdU4sS0FBUSxLQUFBLENBQU1ILE1BR3ZCcE4sS0FBQUEsTUFDQXNOLEtBQUFBLFFBQ1NDLEtBQVEsS0FBS0gsT0FHdEJwTixLQUFBQSxPQTBCQXNOLE9BRUYzWSxLQUFVLENBQUEsSUFHUnFMLEdBQ0ZyTCxDQUFBQSxHQUFRdEwsS0FBSyxFQUNYa0ksT0FBT0EsSUFDUG9iLFdBQVdBLElBQ1hDLFNBQVNBLEdBQUFBLENBQUFBO2FBRUY5YixJQUFRO0FBQ2pCLFVBQU1TLEtBQVFvRCxHQUFRak0sUUFBUTBaLEVBQUFBO0FBQzlCek4sTUFBQUEsR0FBUXBELEVBQUFBLEVBQU9vYixZQUFZQTtJQUM1QixXQUFVek0sSUFBUTtBQUNqQixVQUFXc04sS0FBRzdZLEdBQVFqTSxRQUFRMFosRUFBQUE7QUFDOUJ6TixNQUFBQSxHQUFRd0wsT0FBTzVPLElBQU8sQ0FBQTtJQUN2QjtBQUVELFdBQUEsRUFBQSxDQUFBLEdBQ0tqRSxJQUFLLEVBQ1IzRCxNQUFNLEVBQ0pnTCxTQUFTQSxHQUFBQSxFQUFBQSxDQUFBQTtFQUdmO0FBQUM7QURoRjhCLElDa0ZwQjhZLEtBQ1gsU0FBQ2xjLElBQWU2YixJQUFnQlIsSUFBQUE7QUFBQUEsU0FBaUN0ZixTQUFBQSxJQUFBQTtBQUMvRCxRQUNNOFUsTUFEVTlVLEdBQU0zRCxPQUFXMkQsQ0FBQUEsRUFBQUEsT0FBQUEsR0FBTTNELEtBQUtnTCxPQUFBQSxJQUFXLENBQUEsR0FDaENvTCxLQUFLLFNBQUNsVixJQUFBQTtBQUFNQSxhQUFBQSxHQUFFMEcsVUFBVUE7SUFBSyxDQUFBO0FBRXBELFdBT0ErQyxFQUFBLENBQUEsR0FDS2hILElBUkE4VSxLQVNBc0wsR0FDRG5jLElBQ3FCLE1BQXJCNlEsR0FBT3VLLFlBQUFBLEtBQXVCLEdBQzlCUyxJQUNBUixFQUFBQSxFQUNBdGYsRUFBQUEsSUFYR29nQixHQUFXbmMsSUFBTyxHQUFHNmIsSUFBT1IsRUFBQUEsRUFBU3RmLEVBQUFBLENBQUFBO0VBYTlDO0FBQUM7QUR2RzhCLElDdUc5QixLQ3pGRDZHLDBCQUFBQSxJQUFBQTtBQUFBQSxXQUFBQSxLQUFBQTtBQUFBQSxXQUFBQSxHQUFBQSxNQUFBQSxNQUFBQSxTQUFBQSxLQUFBQTtFQUFBQTtBQVJ1QlAsU0FRdkJPLEVBQUFBLElBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLFVBQUFBLFdBQUEsU0FBU3VCLElBQUFBO0FBQ1AsUUFBQTFOLEtBQWdCLENBQUU7QUFVbEIsV0FSSUksS0FBS0MsTUFBTXVOLFFBQ2JELEdBQWEsTUFBSXZOLEtBQUtDLE1BQU11TixJQUFJRixHQUFRRSxLQUFLeE4sS0FBS0MsTUFBTXNNLE9BQUFBLElBR3REdk0sS0FBS0MsTUFBTXdOLFNBQ2JGLEdBQWMsT0FBSXZOLEtBQUtDLE1BQU13TixLQUFLSCxHQUFRRyxNQUFNek4sS0FBS0MsTUFBTXNNLE9BQUFBLElBQUFBLEVBQUFBLENBQUFBLEdBSXhEZSxJQUNBQyxFQUFBQTtFQUVQLEdBQUN0RixFQUFBc2QsSUFBQSxDQUFBLEVBQUF4aUIsS0FBQSxRQUFBd0csS0FuQkQsV0FBQTtBQUNFLFdBQUEsRUFBcUJnYztFQUN2QixFQUFBLENBQUEsQ0FBQSxHQU51Qi9aO0FBQUFBLEdBQUFBLEVBQUFBO0FDcUJUdVosU0FBQUEsR0FDZDlrQixJQUFBQTtBQUtBLE1BQVlzUSxLQUFHQyxHQUFBQSxHQUNQbUIsS0FBYWIsR0FBQUEsRUFBYmEsVUFDRnhSLEtBQUltUSxHQUFBQSxHQUN3QlUsS0FBQUEsR0FBUyxDQUFBLEdBQXBDdVQsS0FBU3hULEdBQUEsQ0FBQSxHQUFFeVUsS0FBWXpVLEdBQUEsQ0FBQSxHQUNkbUosS0FBRzNKLEdBQU9oUCxNQUNwQjJELEtBQVEyTCxHQUFZLFNBQUMzTCxJQUFBQTtBQUFLLFdBQVVBLEdBQUMzRDtFQUFJLENBQUEsR0FDekNra0IsS0FDMEIsWUFBQSxRQUFiLFFBQVZ2TCxLQUFBQSxTQUFBQSxHQUFZdEksVUFDZnJKLEVBQWNnZCxhQUNkaGQsRUFBY3djLE1BRUVXLEtBQUcsV0FBQTtBQUN2QixRQUFNQyxLQUFhcFYsR0FBT3dCLFNBQVNnTyxlQUFlMEYsRUFBQUE7QUFDbEQsUUFBSUUsR0FBV25sQixPQUNiLFFBQU9tbEIsR0FBVyxDQUFBO0VBR3RCO0FBcUZBLFNBN0RBeFUsR0FBVSxXQUFBO0FBQ1IsUUFBZU0sS0FUZWlVLEdBQUFBLE1BYjFCRCxPQUFrQmxkLEVBQWNnZCxhQUN2QkEsSUFBQUEsR0FDVGhaLEVBQUFBLEVBQUFBLFNBQVNySCxLQUFRQSxHQUFNcUgsVUFBVSxDQUFBLEVBQUEsR0FDOUIyTixHQUFXdEksTUFBQUEsQ0FBQUEsSUFJUHlTLElBQUFBLEdBQVcsRUFDcEI5WCxTQUFTckgsS0FBUUEsR0FBTXFILFVBQVUsQ0FBQSxFQUFBLENBQUE7QUFpQm5DLFdBRkFnRSxHQUFPd0IsU0FBUzBOLFlBQVloTyxFQUFBQSxHQUVmbEIsV0FBQUE7QUFBQUEsYUFBQUEsR0FBT3dCLFNBQVNFLFdBQVdSLEVBQUFBO0lBQVU7RUFDcEQsR0FBRyxDQUFDbEIsRUFBQUEsQ0FBQUEsR0FLSlksR0FBVSxXQUFBO0FBQ1IsUUFBS2pNLElBQUw7QUFFQSxVQUFBdEYsSUFBTWdtQixLQUFnQjFnQixHQUFNcUgsUUFBUW9MLEtBQUssU0FBQ2xWLElBQUFBO0FBQU1BLGVBQUFBLEdBQUUwRyxVQUFVbEosR0FBTWtKO01BQUssQ0FBQTtBQUVsRXljLE1BQUFBLE1BS2UsTUFBZHJCLE9BQ0ZxQixHQUFjckIsWUFBMkIsU0FBbEJzQixLQUFHNWxCLEdBQU1za0IsYUFBU3NCLEtBQUksSUFFL0NMLEdBQWFJLEdBQWNyQixTQUFBQSxLQVAzQmlCLEdBQWEsQ0FBQTtJQUxIO0VBY2QsR0FBRyxDQUFDdGdCLEVBQUFBLENBQUFBLEdBRUppTSxHQUFVLFdBQUE7QUFDUixRQUFlTSxLQUFHaVUsR0FBQUE7QUFFYmpVLElBQUFBLE1BQ0F2TSxNQUVMdU0sR0FBVTlGLFNBQVMsRUFDakJZLFNBQVNySCxHQUFNcUgsUUFBQUEsQ0FBQUE7RUFFbkIsR0FBRyxDQUFDckgsRUFBQUEsQ0FBQUEsR0E0QkEzQyxFQUFBLFVBQUEsRUFBQTJTLFVBQUFBLElBQ0EsY0FBWS9VLEdBQUFBLGVBQTRCLE1BQWRva0IsS0FBa0IsU0FBUyxNQUFBLEdBQ3JEdlAsT0FBTzdVLEdBQWNva0IsZUFBYyxNQUFkQSxLQUFrQixTQUFTLE1BQUEsR0FDaER2WCxXQUFXMEYsR0FDVDFGLEdBQVUsTUFBQSxHQUNWQSxHQUFVLFFBbEJTLDBCQUFDdVgsSUFBQUE7QUFDeEIsV0FBa0IsTUFBZEEsS0FDSyxRQUFBLE9BQ0VBLEtBQ0YsU0FHRjtFQUNULEdBVXlDQSxFQUFBQSxDQUFBQSxHQUNuQ2hVLEdBQU92RCxVQUFVekwsSUFBQUEsR0FFbkI2VCxTQWxDb0IsU0FBQzFTLElBQUFBO0FBQ3ZCQSxJQUFBQSxHQUFFb2pCLGVBQUFBLEdBQ0ZwakIsR0FBRXFqQixnQkFBQUEsR0FFRnBVLEdBQ0VHLEdBQ0U3UixHQUFNa0osT0FBQUEsU0FDTnpHLEdBQUVzakIsWUFBcUI5TCxHQUFXZ0osYUFDbENqakIsR0FBTXVrQixPQUFBQSxDQUFBQTtFQUdaLEVBQUEsQ0FBQTtBQTBCRjtBQ3ZKTyxJQUFjeUIsS0FBRyxTQUFDQyxJQUF1QkMsSUFBQUE7QUFDOUMsTUFBSUM7QUFBQUEsYUFEMENELE9BQUFBLEtBQU87QUFFckQsTUFBSUUsS0FBV0MsS0FBS0MsSUFBQUEsR0FFUEMsS0FBRyxXQUFBO0FBQ2RILElBQUFBLEtBQVdDLEtBQUtDLElBQUFBLEdBQ2hCTCxHQUNGcmIsTUFBQUEsUUFBQSxDQUFBLEVBQUEzRyxNQUFBK0IsS0FBQTJFLFNBQUFBLENBQUFBO0VBQUE7QUFFQSxTQUFtQixXQUFBO0FBQUEsUUFBSmlCLEtBQUEsQ0FBQSxFQUFBM0gsTUFBQStCLEtBQUEyRSxTQUFBQSxHQUNQNmIsS0FBY0gsS0FBS0MsSUFBQUEsR0FDWkcsS0FBR0QsS0FBY0o7QUFFMUJLLElBQUFBLE1BQVdQLEtBRWJLLEdBQU8zYixNQUFBQSxRQUFJZ0IsRUFBQUEsS0FHUHVhLE1BQ0ZqWSxhQUFhaVksRUFBQUEsR0FHZkEsS0FBWTlrQixXQUFXLFdBQUE7QUFDckJrbEIsTUFBQUEsR0FBVzNhLE1BQUFBLFFBQUFBLEVBQUFBLEdBQ1h1YSxLQUFZO0lBQ2QsR0FBR0QsS0FBT08sRUFBQUE7RUFFZDtBQUNGO0FDN0JnQkMsU0FBQUEsR0FBTzFtQixJQUFBQTtBQUlyQixNQUFBTCxJQUVjZ25CLEtBQUcsU0FBQ2xrQixJQUFBQTtBQUNoQixXQUFJQSxjQUFhbWtCLGFBQ0p2ZixLQUFDbU8sTUFBTS9TLEdBQUVva0IsS0FBQUEsSUFBQUEsS0FFUnJSLE1BQU0vUyxHQUFFcWtCLGVBQWUsQ0FBQSxFQUFHRCxLQUFBQTtFQUUxQyxHQUVNRSxLQUFRLFNBQUN0a0IsSUFBQUE7QUFDYkEsSUFBQUEsR0FBRXFqQixnQkFBQUE7QUFFRixRQUVpQmtCLEtBQUdqUixTQUZGL1YsR0FBTWluQixNQUFNamdCLFFBRVNuRCxNQUFNZ1MsT0FBTyxFQUFBLElBQU04USxHQUFTbGtCLEVBQUFBO0FBRW5FeWtCLElBQUFBLEtBQVNsQixHQUFTLFNBQUN2akIsSUFBQUE7QUFBQUEsYUFBVTBrQixHQUFDMWtCLElBQUd1a0IsRUFBQUE7SUFBWSxHQUFFLEVBQUEsR0FFL0M3Z0IsU0FBU2pDLGlCQUFpQixXQUFXa2pCLEVBQUFBLEdBQ3JDamhCLFNBQVNqQyxpQkFBaUIsWUFBWWtqQixFQUFBQSxHQUN0Q2poQixTQUFTakMsaUJBQWlCLGFBQWFnakIsRUFBQUEsR0FDdkMvZ0IsU0FBU2pDLGlCQUFpQixhQUFhZ2pCLEVBQUFBO0VBQ3pDLEdBQUEvbEIsS0FFYSxTQUFDc0IsSUFBNEJ1a0IsSUFBQUE7QUFDeEN2a0IsSUFBQUEsR0FBRXFqQixnQkFBQUE7QUFFRixRQUFldUIsS0FBR3JuQixHQUFNaW5CLE1BQU1qZ0I7QUFFMUJnZ0IsSUFBQUEsS0FBY0wsR0FBU2xrQixFQUFBQSxLQUFNc1QsU0FBU3NSLEdBQVV4akIsTUFBTTJWLFVBQVUsRUFBQSxNQUNsRTZOLEdBQVV4akIsTUFBTWdTLFFBQVdtUixLQUFjTCxHQUFTbGtCLEVBQUFBLElBQ25EO0VBQ0gsR0FFUzJrQixLQUFHLFNBQU5BLEdBQU8za0IsSUFBQUE7QUFDWEEsSUFBQUEsR0FBRXFqQixnQkFBQUEsR0FFRjNmLFNBQVM5QixvQkFBb0IsV0FBVytpQixFQUFBQSxHQUN4Q2poQixTQUFTOUIsb0JBQW9CLGFBQWE2aUIsRUFBQUEsR0FDMUMvZ0IsU0FBUzlCLG9CQUFvQixhQUFhNmlCLEVBQUFBLEdBQzFDL2dCLFNBQVM5QixvQkFBb0IsWUFBWStpQixFQUFBQTtFQUMzQztBQUVBLFNBQ0U5a0IsRUFBQSxPQUFBLEVBQ0V5SyxXQUFXMEYsR0FBVTFGLEdBQVUsSUFBQSxHQUFPQSxHQUFVLFdBQUEsQ0FBQSxHQUNoRHVhLGFBQWFQLElBQ2JRLGNBQWNSLElBQ2Q1UixTQUFTLFNBQUMxUyxJQUFBQTtBQUFBQSxXQUFPQSxHQUFDcWpCLGdCQUFBQTtFQUFpQixFQUFBLENBQUE7QUFHekM7QUNqRE0sU0FBWTBCLEdBQ2hCeG5CLElBQUFBO0FBTUEsTUFBTXNRLEtBQVNDLEdBQUFBLEdBQ1QwVyxLQUFRL1MsR0FBTyxJQUFBLEdBQ3JCcEQsS0FBMEJDLEdBQVMsQ0FBRSxDQUFBLEdBQTlCbE4sS0FBTzRqQixHQUFBQSxDQUFBQSxHQUFBQSxLQUNkM1csR0FBQSxDQUFBLEdBQVFZLEtBQWFiLEdBQUFBLEVBQWJhO0FBRVJSLEtBQVUsV0FBQTtBQUVSLFFBQUlaLEdBQU9vWCxlQUFlVCxHQUFNamdCLFNBQVM7QUFDdkMsVUFBTTJnQixLQUFZVixHQUFNamdCLFFBQVEyZ0I7QUFFUCxrQkFBQSxPQUFMQSxNQUNsQkYsR0FBUyxFQUNQRyxLQUFLRCxHQUFBQSxDQUFBQTtJQUdWO0VBQ0gsR0FBRyxDQUFDVixFQUFBQSxDQUFBQTtBQUVKLE1BaURRbE4sSUFqRFE4TixLQUFHLFdBQUE7QUFBZTduQixXQUFxQnVSLFFBQXJCdlIsR0FBTStaLE9BQU96WTtFQUFpQixHQUFBYyxLQUVoRCxTQUNkSyxJQUFBQTtBQUlBQSxJQUFBQSxHQUFFcWpCLGdCQUFBQSxHQUVFK0IsR0FBQUEsS0FHRm5XLEdBQ0VvVyxHQUNFOW5CLEdBQU1rSixPQUFBQSxTQUNOekcsR0FBRXNqQixZQUxhelYsR0FBT2hQLEtBS1kyaEIsYUFDbENqakIsR0FBTStaLE9BQU96WSxLQUFLaWpCLE9BQUFBLENBQUFBO0VBSTFCO0FBd0NBLFNBQ0VqaUIsRUFBQSxNQUFBMkosRUFBQSxFQUNFbEosS0FBS2trQixJQUNMLGtCQUFnQmpuQixHQUFNK1osVUFBVS9aLEdBQU0rWixPQUFPbFMsSUFDN0NrRixXQUFXMEYsR0FDVDFGLEdBQVUsSUFBQSxHQUNWOGEsR0FBQUEsSUFBZTlhLEdBQVUsTUFBTSxNQUFBLElBQVUsTUFDekN1RCxHQUFPb1gsY0FBYzNhLEdBQVUsTUFBTSxPQUFBLElBQVcsTUFDaER1RCxHQUFPdkQsVUFBVTBPLEVBQUFBLEdBRW5CdEcsU0FBU0EsSUFDVHRSLE9BQ0t5TSxFQUFBQSxDQUFBQSxHQUFBQSxHQUFPek0sTUFBTTRYLElBQ2IsRUFDRGpDLFVBQVV4WixHQUFNK1osT0FBT1AsVUFDdkIzRCxPQUFPN1YsR0FBTStaLE9BQU9sRSxNQUFBQSxHQUVuQmhTLElBQ0E3RCxHQUFNNkQsS0FBQUEsR0FFWGtrQixXQTFEWSxTQUFDdGxCLElBQUFBO0FBRVhvbEIsSUFBQUEsR0FBQUEsS0FBNEIsT0FBWnBsQixHQUFFdWxCLFNBQ3BCN1MsR0FBUTFTLEVBQUFBO0VBRVosR0FzREl3bEIsU0FBU2pvQixHQUFNaW9CLFVBQVUsSUFBSWpvQixHQUFNaW9CLFVBQUFBLFFBQ25DN0UsU0FBU3BqQixHQUFNb2pCLFVBQVUsSUFBSXBqQixHQUFNb2pCLFVBQUFBLE9BQVU3UixJQWpDekN3SSxLQUFTL1osR0FBTStaLFVBSVksY0FBQSxPQUFBMVgsR0FBZnNFLGFBQ1RvVCxHQUFPcFQsV0FBVyxNQUFNLE1BQU0zRyxHQUFNK1osTUFBQUEsSUFFcENBLEdBQU9wVCxhQUxJLENBQUEsR0FpQ2JraEIsR0FBQUEsSUFBZSxFQUFFNVMsVUFBVSxFQUFBLElBQU0sQ0FBQSxDQUFBLEdBRXRDM1MsRUFBSyxPQUFBLEVBQUF5SyxXQUFXQSxHQUFVLE1BQU0sU0FBQSxFQUFBLEdBQUEsV0F4RDlCL00sR0FBTStaLE9BQU9uVCxPQUNINUcsR0FBQytaLE9BQU9uVCxPQUFBQSxXQUdsQjVHLEdBQU0rWixPQUFPbkMsU0FFYnRWLEVBQUMyVixJQUFjLEVBQ2JDLFVBQVVsWSxHQUFNK1osT0FBT25DLE9BQU8vUCxJQUM5QjdILE9BQU8sRUFDTCtaLFFBQVEvWixHQUFNK1osT0FBQUEsRUFBQUEsQ0FBQUEsSUFBQUEsSUFBQUEsR0FnRG5COE4sR0FBQUEsS0FBZ0J2bEIsRUFBQ3dpQixJQUFJN1ksRUFBQSxFQUFDL0MsT0FBT2xKLEdBQU1rSixNQUFBQSxHQUFXbEosR0FBTStaLE9BQU96WSxJQUFBQSxDQUFBQSxHQXRGN0J0QixHQUFNK1osT0FBT00sYUF3RjFDcmEsR0FBTWtKLFFBQVFvSCxHQUFPc0IsT0FBT21TLGVBQWV4akIsU0FBUyxLQUNsRCtCLEVBQUNva0IsSUFBTSxFQUFDM00sUUFBUS9aLEdBQU0rWixRQUFRa04sT0FBT0EsR0FBQUEsQ0FBQUEsQ0FBQUE7QUFJL0M7QUFBQSxTQ3pIcUJpQixLQUFBQTtBQUNuQixNQThDWXplLElBOUNBNkcsS0FBR0MsR0FBQUEsR0FDSHFCLEtBQUdoQixHQUFZLFNBQUMzTCxJQUFBQTtBQUFVQSxXQUFBQSxHQUFNMk07RUFBTSxDQUFBO0FBa0RsRCxTQUFJQSxLQUdFdFAsRUFBQSxTQUFBLEVBQUFRLEtBQUs4TyxHQUFPL0osSUFDWmtGLFdBQVcwRixHQUFVMUYsR0FBVSxPQUFBLEdBQVV1RCxHQUFPdkQsVUFBVW9iLEtBQUFBLEVBQUFBLElBVHBEMWUsS0FBRzJPLEdBQU95QixjQUFjakksR0FBT3RGLE9BQUFBLEdBRTdCbEQsSUFBSSxTQUFDUSxJQUFLOEMsSUFBQUE7QUFBYTBiLFlBdkJuQixTQUFDeGUsSUFBZ0I4QyxJQUFrQjJiLElBQUFBO0FBRW5ELFVBQWlCdE0sS0FBRzNELEdBQU8yRCxZQUFZbkssR0FBT3RGLE9BQUFBO0FBRTlDLGFBQ0doSyxFQUFBbWhCLElBQ0U3WixNQUFBQSxHQUFJUixJQUFJLFNBQUN5UyxJQUFBQTtBQUNSLGVBQUlBLEdBQUlqUCxTQUFtQixRQTdCZCxTQUNuQm1OLElBQ0FyTixJQUNBNGIsSUFDQUQsSUFBQUE7QUFFQSxjQUE2QkUsTUNqQmpCQSxTQUNkeE8sSUFDQXJOLElBQ0EyYixJQUFBQTtBQUVBLGdCQUFNRyxLQUFRcFEsR0FBTzhELGFBQWFuQyxFQUFBQSxHQUNmME8sS0FBR0osS0FBWTNiO0FBSWxDLG1CQUFPLEVBQ0x1YixTQUpjNWdCLEtBQUttTyxNQUFNaVQsS0FBZ0JELEtBQVFBLEtBQVFDLEVBQUFBLEdBS3pEckYsU0FKZXJKLEdBQU96TixXQUFXeU4sR0FBT3pOLFFBQVEvTCxVQUFXLEVBQUE7VUFNL0QsR0RJTXdaLElBQ0FyTixJQUNBMmIsRUFBQUE7QUFHRixpQkFDRy9sQixFQUFBa2xCLElBQ0MsRUFBQXpOLFFBQVFBLElBQ1I3USxPQUFPb2YsSUFDUGxGLFNBVmFBLEdBQUFBLFNBV2I2RSxTQVhXUyxHQUFQVCxRQUFBQSxDQUFBQTtRQWNWLEdBWVVwTSxJQUNBblAsSUFDQXFQLEdBQVkxYixRQUFRd2IsRUFBQUEsR0FDcEJ3TSxFQUFBQTtNQUVKLENBQUEsQ0FBQTtJQUdOLEdBSytDemUsSUFBSzhDLElBQVVqRCxHQUFLbEosTUFBQUE7RUFBTyxDQUFBLENBQUEsSUFlNUU7QUFBQTtBQUFBLElFbENzQm9vQixLQUFHLFNBQUMvVyxJQUFBQTtBQUFjLFNBQUEsU0FBTTNNLElBQUFBO0FBQzVDLFdBQUFnSCxFQUFBLENBQUEsR0FDS2hILElBQ0gyTSxFQUFBQSxRQUFRQSxHQUFBQSxDQUFBQTtFQUVaO0FBQUM7QUFBQSxTQ3BDb0JnWCxLQUFBQTtBQUNuQixNQUFBN25CLEtBQWV3UCxHQUFBQSxHQUNUNEYsS0FBV2pDLEdBQU8sSUFBQSxHQUNoQnhDLEtBQWFiLEdBQUFBLEVBQWJhO0FBTVIsU0FKQVIsR0FBVSxXQUFBO0FBQ0ppRixJQUFBQSxNQUFVekUsR0RnQ1MsMEJBQUN5RSxJQUFBQTtBQUFBQSxhQUFjbFIsU0FBQUEsSUFBQUE7QUFDeEMsZUFBQSxFQUFBLENBQUEsR0FDS0EsSUFBSyxFQUNSa1IsVUFBVUEsR0FBQUEsQ0FBQUE7TUFFZDtJQUFDLEdDckM4Q0EsRUFBQUEsQ0FBQUE7RUFDN0MsR0FBRyxDQUFDQSxFQUFBQSxDQUFBQSxHQUdGN1QsRUFBQSxTQUFBLEVBQ0VTLEtBQUtvVCxJQUNMdEIsTUFBSyxRQUNMOUgsV0FBVzBGLEdBQVUxRixHQUFVLE9BQUEsR0FBVXVELEdBQU92RCxVQUFVOGIsS0FBQUEsR0FDMURobEIsT0FBS29JLEVBQUEsQ0FBQSxHQUNBcUUsR0FBT3pNLE1BQU1nbEIsT0FDYixFQUNEOUYsUUFBUXpTLEdBQU95UyxPQUFBQSxDQUFBQSxFQUFBQSxHQUluQnpnQixFQUFDNGxCLElBQ0QsSUFBQSxHQUFBNWxCLEVBQUN1aEIsSUFBQUEsSUFBQUEsQ0FBQUE7QUFHUDtBQzVCZ0JpRixTQUFBQSxLQUFBQTtBQUNkLE1BQWdDL1gsS0FBQUEsR0FBQUEsSUFBUyxHQUFsQ2dZLEtBQVFqWSxHQUFBLENBQUEsR0FBRWtZLEtBQVdsWSxHQUFBLENBQUEsR0FDYm1ZLEtBQUcvVSxHQUFPLElBQUEsR0FBQXhTLEtBQ1Y2TyxHQUFBQTtBQVFmLFNBTkFXLEdBQVUsV0FBQTtBQUNrQyxVQUF0QytYLEdBQVVqaUIsUUFBUXBILFNBQVNXLFVBQzdCeW9CLEdBQUFBLEtBQVk7RUFFaEIsR0FBRyxDQUFDQyxFQUFBQSxDQUFBQSxHQUVBRixLQUdFem1CLEVBQUEsT0FBQSxFQUFBUyxLQUFLa21CLElBQ0xsYyxXQUFXMEYsR0FBVTFGLEdBQVUsTUFBQSxHQUFTdUQsR0FBT3ZELFVBQVU2RSxNQUFBQSxHQUN6RC9OLE9BQUtvSSxFQUFBLENBQUEsR0FBT3FFLEdBQU96TSxNQUFNK04sTUFBQUEsRUFBQUEsR0FFekJ0UCxFQUFDMlYsSUFBQUEsRUFBZTVCLFVBQVVVLEdBQWVxQixPQUFBQSxDQUFBQSxDQUFBQSxJQU1qRDtBQUFBO0FDeEJnQjhRLFNBQUFBLEtBQUFBO0FBQ2QsTUFBTUMsS0FBWWpWLEdBQU8sSUFBQSxHQUNPbkQsS0FBQUEsR0FBQUEsSUFBUyxHQUFsQ2dZLEtBQVVDLEdBQUFBLENBQUFBLEdBQUFBLEtBQ2pCbFksR0FBQSxDQUFBLEdBQUFwUCxLQUFlNk8sR0FBQUE7QUFRZixTQU5BVyxHQUFVLFdBQUE7QUFDa0MsVUFBdENpWSxHQUFVbmlCLFFBQVFwSCxTQUFTVyxVQUM3QnlvQixHQUFBQSxLQUFZO0VBRWhCLEdBQUcsQ0FBQ0csRUFBQUEsQ0FBQUEsR0FFQUosS0FHRXptQixFQUFBLE9BQUEsRUFBQVMsS0FBS29tQixJQUNMcGMsV0FBVzBGLEdBQVUxRixHQUFVLFFBQUEsR0FBV3VELEdBQU92RCxVQUFVcWMsTUFBQUEsR0FDM0R2bEIsT0FBS29JLEVBQUEsQ0FBQSxHQUFPcUUsR0FBT3pNLE1BQU11bEIsTUFBQUEsRUFBQUEsR0FFekI5bUIsRUFBQzJWLElBQUFBLEVBQWU1QixVQUFVVSxHQUFlbU0sT0FBQUEsQ0FBQUEsQ0FBQUEsSUFNakQ7QUFBQTtBQ2hCZ0JtRyxTQUFBQSxLQUFBQTtBQUNkLE1BQVkvWSxLQUFHQyxHQUFBQSxHQUNQbUIsS0FBYWIsR0FBQUEsRUFBYmEsVUFDRm9MLEtBQVNsTSxHQUFZLFNBQUMzTCxJQUFBQTtBQUFLLFdBQVVBLEdBQUM2WDtFQUFNLENBQUEsR0FBQTNiLEtBQ3JDeVAsR0FBWSxTQUFDM0wsSUFBQUE7QUFBSyxXQUFVQSxHQUFDdUI7RUFBSSxDQUFBLEdBQ2hDMlAsS0FBR3ZGLEdBQVksU0FBQzNMLElBQUFBO0FBQUssV0FBVUEsR0FBQ2tSO0VBQVEsQ0FBQSxHQUN6Q29DLEsvRHBCeXJCLEVBQUN2UixTQUFRLEtBQUEsRytEc0J6c0JzaUIsS0FBa0J0RCxHQUFvQixXQUFBO0FBQUEsUUFBQTtBQUMxQ3RVLE1BQUFBLEdKUmdDLFNBQUN6TSxJQUFBQTtBQUNuQyxlQUNLQSxFQUFBQSxDQUFBQSxHQUFBQSxJQUFBQSxFQUNINlgsUUFBUStGLEVBQU9vQixRQUFBQSxDQUFBQTtNQUVuQixDQUFBO0FJR3VDLFVBQUF0aUIsTUFBQSxTQUFBQSxJQUFBUixJQUFBO0FBQUEsWUFBQTtBQUFBLGNBQUFPLEtBR2Q0TyxRQUFBQSxRQUFBQSxHQUFPd0IsU0FBU25HLFFBQUFBLENBQUFBLEVBQVN1UixLQUFBLFNBQXRDMVcsSUFBQUE7QUFDTmtMLFlBQUFBLEdKTGlCLDBCQUFDbEwsSUFBQUE7QUFBa0IscUJBQUEsU0FBQ3ZCLElBQUFBO0FBQ3pDLHVCQUFLdUIsS0FFTHlGLEVBQUEsQ0FBQSxHQUNLaEgsSUFBSyxFQUNSdUIsTUFBTUEsSUFDTnNXLFFBQVErRixFQUFPMEcsT0FBQUEsQ0FBQUEsSUFBQUE7Y0FFbkI7WUFBQyxHSUg4Qi9pQixFQUFBQSxDQUFBQSxHQUd6Qm5GLFdBQVcsV0FBQTtBQUNUcVEsY0FBQUEsR0ozQmtDek0sU0FBQUEsSUFBQUE7QUFDeEMsdUJBQUlBLEdBQU02WCxXQUFXK0YsRUFBTzBHLFNBQzFCdGQsRUFBQSxDQUFBLEdBQ0toSCxJQUNINlgsRUFBQUEsUUFBUStGLEVBQU9xQixTQUFBQSxDQUFBQSxJQUlaamY7Y0FDVCxDQUFBO1lJbUJNLEdBQUcsQ0FBQTtVQUFHLENBQUE7UUFBQSxTQUFBbEUsSUFBQTtBQUFBLGlCQUFBSSxHQUFBSixFQUFBO1FBQUE7QUFBQSxlQUFBVyxNQUFBQSxHQUFBLE9BQUFBLEdBQUEsS0FBQSxRQUFBUCxFQUFBLElBQUFPO01BQUEsR0FBQSxHQUNQLFNBQVFlLElBQUFBO0FBQ1B1VSxXQUFJMUgsTUFBTTdNLEVBQUFBLEdBQ1ZpUCxHSkgrQnpNLFNBQUFBLElBQUFBO0FBQ25DLGlCQUFBZ0gsRUFBQSxDQUFBLEdBQ0toSCxJQUFLLEVBQ1J1QixNQUFNLE1BQ05zVyxRQUFRK0YsRUFBTzdQLE1BQUFBLENBQUFBO1FBRW5CLENBQUE7TUlGSyxDQUFBO0FBQUEsYUFBQXNKLFFBQUE5SixRQUFBZ1gsTUFBQUEsR0FBQXRNLE9BQUFzTSxHQUFBdE0sS0FBQSxXQUFBO01BQUEsQ0FBQSxJQUFBLE1BQUE7SUFDRixTQUFBemEsSUFBQUE7QUFBQSxhQUFBNlosUUFBQUMsT0FBQTlaLEVBQUFBO0lBQUE7RUFBQSxHQUFFNk4sR0FBTzBTLG9CQUFBQTtBQXdCVixTQXRCQTlSLEdBQVUsV0FBQTtBQVNSLFdBTEFRLEdBQVNHLEdBQWtCdkIsR0FBT3NCLE1BQUFBLENBQUFBLEdBRWxDMFgsR0FBQUEsR0FDQWhaLEdBQU93QixTQUFTMUgsR0FBRyxXQUFXa2YsRUFBQUEsR0FFdkIsV0FBQTtBQUFBLGFBQVloWixHQUFDd0IsU0FBU3hILElBQUksV0FBV2dmLEVBQUFBO0lBQWdCO0VBQzlELEdBQUcsQ0FBQSxDQUFBLEdBRUhwWSxHQUFVLFdBQUE7QUFDSlosSUFBQUEsR0FBT3NCLFVBQVVrTCxPQUFXK0YsRUFBTzBHLFVBQVUvaUIsUUFBQUEsTUFBQUEsR0FBTWpHLFVBR3JEbVIsR0FDRUcsR0FBa0J2QixHQUFPc0IsT0FBTzBHLFlBQVloSSxJQUFRNkYsSUFBVW9DLEVBQUFBLENBQUFBLENBQUFBO0VBR3BFLEdBQUcsQ0FBQy9SLElBQU04SixJQUFRaUksRUFBQUEsQ0FBQUEsR0FJZGpXLEVBQUEsT0FBQSxFQUFBdVMsTUFBSyxpQkFDTDlILFdBQVcwRixHQUNULFVBQ0ExRixHQUFVLFdBQUEsR0FDVitQLE9BQVcrRixFQUFPb0IsVUFBVWxYLEdBQVUsU0FBQSxJQUFhLE1BQ25EdUQsR0FBT3ZELFVBQVV5TCxTQUFBQSxHQUVuQjNVLE9BQUtvSSxFQUFBLENBQUEsR0FDQXFFLEdBQU96TSxNQUFNMlUsV0FDYixFQUNEM0MsT0FBT3ZGLEdBQU91RixNQUFBQSxDQUFBQSxFQUFBQSxHQUlqQmlILE9BQVcrRixFQUFPb0IsV0FDakIzaEIsRUFBQSxPQUFBLEVBQUt5SyxXQUFXQSxHQUFVLGFBQUEsRUFBQSxDQUFBLEdBRzVCekssRUFBQ3dtQixJQUVELElBQUEsR0FBQXhtQixFQUFBQSxPQUFBQSxFQUFLeUssV0FBV0EsR0FBVSxTQUFBLEdBQVlsSixPQUFPLEVBQUVrZixRQUFRelMsR0FBT3lTLE9BQUFBLEVBQUFBLEdBQzVEemdCLEVBQUNzbUIsSUFDSCxJQUFBLENBQUEsR0FFQXRtQixFQUFDNG1CLElBQWUsSUFBQSxHQUVoQjVtQixFQUFBLE9BQUEsRUFBS1MsS0FBS3dWLElBQVMxUSxJQUFHLGVBQWNrRixXQUFXQSxHQUFVLE1BQUEsRUFBQSxDQUFBLENBQUE7QUFHL0Q7QUNuRk0wYyxJQUFLQSxLQUFBLDBCQUFBamUsSUFBQUE7QUFJVCxXQUFZOEUsR0FBQUEsSUFBQUE7QUFBd0IsUUFBQTlIO0FBS0QsWUFKakNBLEtBQU9nRCxHQUFBeEYsS0FBQWpHLElBQUFBLEtBQUFBLE1BSkZ1USxTQUFBQSxRQUNBc0gsR0FBQUEsU0FBQUEsUUFJTHBQLEdBQUs4SCxTQUFTLElBQVVpUyxLQUNyQkMsT0FBTyxFQUFFa0gsVUFBUUMsRUFBQW5oQixFQUFBQSxHQUFRK2EsY0FBa0JvRyxFQUFBbmhCLEVBQUFBLEVBQUFBLENBQUFBLEVBQzNDQyxPQUFPNkgsRUFBQUEsR0FDVjlILEdBQUtvUCxTQUFTcFAsR0FBSzhILE9BQU9zSCxRQUM1QnBQO0VBQUE7QUFWU0UsSUFBQStnQixJQUFBamUsRUFBQUE7QUFVUixNQUFBL0ksS0FBQTlDLEdBQUE7QUFtRUEsU0FBQThDLEdBakVNbW5CLGVBQUEsU0FBYXRaLElBQUFBO0FBRWxCLFdBREF2USxLQUFLdVEsT0FBTzdILE9BQU82SCxFQUFBQSxHQUFBQTtFQUVyQixHQUFDM0gsR0FFRHJDLGdCQUFBLFdBQUE7QUFDRSxXQUFPaEUsRUFBRThMLEdBQWNpVSxVQUFVLEVBQy9CMWQsT0FBTzVFLEtBQUt1USxRQUNaMVEsVUFBVTBDLEVBQUUrbUIsSUFBVyxDQUFBLENBQUEsRUFBQSxDQUFBO0VBRTNCLEdBUUFRLEdBQUFBLGNBQUEsV0FBQTtBQWFFLFdBWks5cEIsS0FBS3VRLFVBQVd2USxLQUFLdVEsT0FBT2tJLGFBQy9CeEIsR0FBSTFILE1BQ0Ysd0VBQUEsSUFDQSxHQUlKdlAsS0FBSytwQixRQUFBQSxHQUdMaGxCLEVBQU8vRSxLQUFLdUcsY0FBQUEsR0FBaUJ2RyxLQUFLdVEsT0FBT2tJLFNBQUFBLEdBRWxDelk7RUFDVCxHQUFDNEksR0FLRG1oQixVQUFBLFdBQUE7QUFDRS9wQixTQUFLdVEsT0FBT3dCLFNBQVNvTixXQUFBQSxHQUVyQnBhLEVBQU8sTUFBTS9FLEtBQUt1USxPQUFPa0ksU0FBQUE7RUFDM0IsR0FBQzdQLEdBUUQ3RCxTQUFBLFNBQU8wVCxJQUFBQTtBQUtMLFdBSktBLE1BQ0h4QixHQUFJMUgsTUFBTSxvQ0FBQSxJQUFvQyxHQUc1Q2tKLEdBQVUvUixXQUFXbEcsU0FBUyxLQUNoQ3lXLEdBQUkxSCxNQUFLLDJCQUNrQmtKLEtBQVMseUVBQUEsR0FHckN6WSxTQUVEQSxLQUFLdVEsT0FBT2tJLFlBQVlBLElBQ3hCMVQsRUFBTy9FLEtBQUt1RyxjQUFBQSxHQUFpQmtTLEVBQUFBLEdBRXRCelk7RUFDVCxHQUFDMHBCO0FBQUEsR0E3RWdCemYsQ0FBQUE7OztBQ01uQixrQkFBaUI7QUFFakIsbUJBQWM7QUFVZCxNQUFNO0FBQUEsRUFDRjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKO0FBRU8sSUFBTSxpQkFBTixNQUFxQjtBQUFBLEVBVXhCLFlBQVksYUFBMEIsU0FBa0I7QUFDcEQsU0FBSyxjQUFjO0FBQ25CLFNBQUssVUFBVTtBQUFBLEVBQ25CO0FBQUEsRUFFQSxTQUFlO0FBQ1gsU0FBSyxZQUFZLE1BQU0sWUFBWTtBQUVuQyxTQUFLLFlBQVksYUFDYixpQ0FBQStmLFNBQUMsWUFBTyxJQUFHLHFCQUNQLGlDQUFBQSxTQUFDLFlBQU8sT0FBTSxTQUFRLFVBQVEsUUFDekIsRUFBRSxPQUFPLENBQ2QsR0FDQSxpQ0FBQUEsU0FBQyxZQUFPLE9BQU0sYUFBVyxFQUFFLFNBQVMsQ0FBRSxHQUN0QyxpQ0FBQUEsU0FBQyxZQUFPLE9BQU0sVUFBUSxFQUFFLE1BQU0sQ0FBRSxHQUNoQyxpQ0FBQUEsU0FBQyxZQUFPLE9BQU0sY0FBWSxFQUFFLFVBQVUsQ0FBRSxDQUM1QztBQUlKLFVBQU0sWUFBbUIsS0FBSyxRQUFRO0FBQ3RDLFFBQUksT0FBZSxVQUFVLFlBQVksWUFBWTtBQUNyRCxhQUFTLFlBQVksR0FBRyxhQUFhLE1BQU0sYUFBYTtBQUNwRCxnQkFBVSxZQUFZLG9CQUFvQixTQUFTO0FBQUEsSUFDdkQ7QUFFQSxVQUFNLHlCQUFpRCxFQUFFLEdBQUcsRUFBRTtBQUM5RCxlQUFXLENBQUMsV0FBVyxRQUFRLEtBQUssc0JBQXNCLFVBQVUsWUFBWSxJQUFJLEdBQUc7QUFDbkYsVUFBSSxhQUFhLEdBQUc7QUFDaEIsK0JBQXVCLENBQUMsS0FBSztBQUFBLE1BQ2pDLE9BQU87QUFDSCwrQkFBdUIsU0FBUyxJQUFJO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBRUEsVUFBTSxpQkFBeUIsVUFBVSxhQUFhLFVBQVU7QUFDaEUsV0FBTyxLQUFLLElBQUksTUFBTSxDQUFDO0FBRXZCLFNBQUssWUFBWSxhQUNiLGlDQUFBQSxTQUFDLGFBQ0csaUNBQUFBLFNBQUMsWUFBTyxJQUFHLGlCQUFnQixHQUMzQixpQ0FBQUEsU0FBQyxVQUFLLElBQUcsd0JBQXVCLEdBQ2hDLGlDQUFBQSxTQUFDLFVBQUcsR0FDSixpQ0FBQUEsU0FBQyxVQUFHLEdBQ0osaUNBQUFBLFNBQUMsWUFBTyxJQUFHLGtCQUFpQixHQUM1QixpQ0FBQUEsU0FBQyxVQUFLLElBQUcseUJBQXdCLEdBQ2pDLGlDQUFBQSxTQUFDLFVBQUcsR0FDSixpQ0FBQUEsU0FBQyxVQUFHLEdBQ0osaUNBQUFBLFNBQUMsWUFBTyxJQUFHLGNBQWEsR0FDeEIsaUNBQUFBLFNBQUMsVUFBSyxJQUFHLHFCQUFvQixHQUM3QixpQ0FBQUEsU0FBQyxVQUFHLEdBQ0osaUNBQUFBLFNBQUMsVUFBRyxHQUNKLGlDQUFBQSxTQUFDLFlBQU8sSUFBRyxrQkFBaUIsR0FDNUIsaUNBQUFBLFNBQUMsVUFBRyxHQUNKLGlDQUFBQSxTQUFDLFVBQUssSUFBRyx5QkFBd0IsR0FDakMsaUNBQUFBLFNBQUMsVUFBRyxHQUNKLGlDQUFBQSxTQUFDLFVBQUcsR0FDSixpQ0FBQUEsU0FBQyxZQUFHLE9BQUssR0FDVCxpQ0FBQUEsU0FBQyxTQUFJLElBQUcsYUFBWSxDQUN4QjtBQUdKLFNBQUssZ0JBQWdCO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQSxFQUFFLFVBQVU7QUFBQSxNQUNaLEVBQUUsZUFBZTtBQUFBLE1BQ2pCLE9BQU8sS0FBSyxzQkFBc0I7QUFBQSxNQUNsQyxPQUFPLE9BQU8sc0JBQXNCO0FBQUEsTUFDcEMsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGlCQUFpQixNQUFNLFFBQVEsQ0FBQyxFQUFFLENBQUM7QUFBQSxNQUNoRSxFQUFFLFdBQVc7QUFBQSxNQUNiLEVBQUUsTUFBTTtBQUFBLE1BQ1IsRUFBRSxpQkFBaUI7QUFBQSxJQUN2QjtBQUVBLFdBQU8sVUFBVSxVQUFVLFlBQVk7QUFDdkMsYUFBUyxXQUFXLEdBQUcsWUFBWSxNQUFNLFlBQVk7QUFDakQsZ0JBQVUsVUFBVSxvQkFBb0IsUUFBUTtBQUFBLElBQ3BEO0FBR0EsVUFBTSxrQkFBMEI7QUFBQSxNQUN4QixLQUFLO0FBQUEsUUFDQSxVQUFVLFVBQVUsNkJBQTZCLElBQUksaUJBQWtCO0FBQUEsTUFDNUUsSUFBSSxNQUFNO0FBQUEsTUFDVjtBQUFBLElBQ0osR0FDQSxrQkFBMEIsYUFBYSxVQUFVLFVBQVUsWUFBWSxHQUFHLEtBQUs7QUFFbkYsU0FBSyxpQkFBaUI7QUFBQSxNQUNsQjtBQUFBLE1BQ0E7QUFBQSxNQUNBLEVBQUUsV0FBVztBQUFBLE1BQ2IsRUFBRSxnQkFBZ0I7QUFBQSxNQUNsQixPQUFPLEtBQUssVUFBVSxVQUFVLElBQUk7QUFBQSxNQUNwQyxPQUFPLE9BQU8sVUFBVSxVQUFVLElBQUk7QUFBQSxNQUN0QyxFQUFFLHFCQUFxQixFQUFFLEtBQUssaUJBQWlCLFNBQVMsZ0JBQWdCLENBQUM7QUFBQSxNQUN6RSxFQUFFLE9BQU87QUFBQSxNQUNULEVBQUUsTUFBTTtBQUFBLE1BQ1IsRUFBRSxpQkFBaUI7QUFBQSxJQUN2QjtBQUdBLFVBQU0sUUFBa0Isb0JBQW9CLFVBQVUsTUFBTSxJQUFJO0FBQ2hFLGFBQVMsT0FBTyxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsUUFBUSxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsUUFBUTtBQUNwRSxnQkFBVSxNQUFNLG9CQUFvQixJQUFJO0FBQUEsSUFDNUM7QUFDQSxVQUFNLGNBQ0YsS0FBSyxNQUFNLFVBQVUsTUFBTSw2QkFBNkIsSUFBSSxjQUFjLEtBQUs7QUFFbkYsU0FBSyxhQUFhO0FBQUEsTUFDZDtBQUFBLE1BQ0E7QUFBQSxNQUNBLEVBQUUsT0FBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE9BQU8sS0FBSyxVQUFVLE1BQU0sSUFBSTtBQUFBLE1BQ2hDLE9BQU8sT0FBTyxVQUFVLE1BQU0sSUFBSTtBQUFBLE1BQ2xDLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxZQUFZLENBQUM7QUFBQSxNQUMzQyxFQUFFLE9BQU87QUFBQSxNQUNULEVBQUUsT0FBTztBQUFBLE1BQ1QsRUFBRSxpQkFBaUI7QUFBQSxJQUN2QjtBQUdBLFVBQU0sa0JBQTBCLEtBQUssUUFBUSxtQkFBbUI7QUFBQTtBQUFBLE1BRTVEO0FBQUEsSUFDSjtBQUNBLFNBQUssaUJBQWlCO0FBQUEsTUFDbEI7QUFBQSxNQUNBO0FBQUEsTUFDQSxFQUFFLFlBQVk7QUFBQSxNQUNkLEVBQUUsaUJBQWlCO0FBQUEsTUFDbkI7QUFBQSxRQUNJLEdBQUcsRUFBRSxlQUFlLENBQUMsTUFBTSxLQUFLLE1BQU8sVUFBVSxXQUFXLGtCQUFtQixHQUFHLENBQUM7QUFBQSxRQUNuRixHQUFHLEVBQUUsaUJBQWlCLENBQUMsTUFBTSxLQUFLO0FBQUEsVUFDN0IsVUFBVSxhQUFhLGtCQUFtQjtBQUFBLFFBQy9DLENBQUM7QUFBQSxRQUNELEdBQUcsRUFBRSxrQkFBa0IsQ0FBQyxNQUFNLEtBQUs7QUFBQSxVQUM5QixVQUFVLGNBQWMsa0JBQW1CO0FBQUEsUUFDaEQsQ0FBQztBQUFBLE1BQ0w7QUFBQSxNQUNBLENBQUMsVUFBVSxVQUFVLFVBQVUsWUFBWSxVQUFVLFdBQVc7QUFBQSxNQUNoRSxFQUFFLHNCQUFzQixFQUFFLGdCQUFnQixDQUFDO0FBQUEsSUFDL0M7QUFFQSxVQUFNLFlBQVk7QUFBQSxNQUNkLGFBQWEsWUFBWSxFQUFFLFVBQVUsRUFBRTtBQUFBLE1BQ3ZDLENBQUMsS0FBYSxVQUFvQztBQUFBLFFBQzlDLFlBQUFDLFFBQUssTUFBTSxHQUFHLEVBQUU7QUFBQSxRQUNoQixLQUFLLE1BQU0sS0FBSztBQUFBLE1BQ3BCO0FBQUEsSUFDSjtBQUVBLFNBQUssZ0JBQWdCLElBQUksR0FBSztBQUFBLE1BQzFCLFNBQVM7QUFBQSxRQUNMO0FBQUEsVUFDSSxNQUFNLEVBQUUsTUFBTTtBQUFBLFFBQ2xCO0FBQUEsUUFDQTtBQUFBLFVBQ0ksTUFBTSxFQUFFLE1BQU07QUFBQSxVQUNkLE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUFBLE1BQ0EsUUFBUTtBQUFBLE1BQ1IsV0FBVztBQUFBLE1BQ1gsTUFBTSxPQUFPLFFBQVEsU0FBUyxFQUFFLEtBQUssQ0FBQ0MsSUFBR0MsT0FBTUEsR0FBRSxDQUFDLElBQUlELEdBQUUsQ0FBQyxDQUFDO0FBQUEsTUFDMUQsWUFBWTtBQUFBLFFBQ1IsT0FBTztBQUFBLFFBQ1AsU0FBUztBQUFBLE1BQ2I7QUFBQSxNQUNBLFVBQVU7QUFBQSxRQUNOLFFBQVE7QUFBQSxVQUNKLGFBQWEsRUFBRSxRQUFRO0FBQUEsUUFDM0I7QUFBQSxRQUNBLFlBQVk7QUFBQSxVQUNSLFVBQVUsRUFBRSxVQUFVO0FBQUEsVUFDdEIsTUFBTSxFQUFFLE1BQU07QUFBQSxRQUNsQjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFDRCxTQUFLLGNBQWMsT0FBTyxTQUFTLGVBQWUsV0FBVyxDQUFDO0FBQUEsRUFDbEU7QUFBQSxFQUVBLFVBQWdCO0FBQ1osU0FBSyxjQUFjLFFBQVE7QUFDM0IsU0FBSyxlQUFlLFFBQVE7QUFDNUIsU0FBSyxXQUFXLFFBQVE7QUFDeEIsU0FBSyxlQUFlLFFBQVE7QUFDNUIsU0FBSyxjQUFjLFFBQVE7QUFBQSxFQUMvQjtBQUNKO0FBRUEsU0FBUyxpQkFDTCxNQUNBLFVBQ0EsT0FDQSxVQUNBLFFBQ0EsTUFDQSxTQUNBLGNBQWMsSUFDZCxhQUFhLElBQ2IsYUFBYSxJQUNSO0FBQ0wsUUFBTSxRQUFRLGlCQUFpQixTQUFTLElBQUk7QUFDNUMsUUFBTSxZQUFZLE1BQU0saUJBQWlCLGVBQWU7QUFFeEQsTUFBSSxTQUFTLENBQUMsR0FDVixrQkFBa0IsQ0FBQyxTQUFTO0FBQ2hDLE1BQUksU0FBUyxPQUFPO0FBQ2hCLGFBQVM7QUFBQSxNQUNMLEdBQUc7QUFBQSxRQUNDLE9BQU87QUFBQSxVQUNILFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUFBLE1BQ0EsR0FBRztBQUFBLFFBQ0MsT0FBTztBQUFBLFVBQ0gsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFFBQ1g7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQ0osT0FBTztBQUNILHNCQUFrQixDQUFDLFdBQVcsV0FBVyxPQUFPO0FBQUEsRUFDcEQ7QUFFQSxRQUFNLGVBQWUsYUFBYSxtQkFBbUIsYUFBYTtBQUVsRSxRQUFNLGFBQWEsSUFBSSxNQUFNLFNBQVMsZUFBZSxRQUFRLEdBQXdCO0FBQUEsSUFDakY7QUFBQSxJQUNBLE1BQU07QUFBQSxNQUNGLFFBQVEsZUFBZSxPQUFPLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFBQSxNQUM3QyxVQUFVO0FBQUEsUUFDTjtBQUFBLFVBQ0ksT0FBTztBQUFBLFVBQ1A7QUFBQSxVQUNBLE1BQU0sZUFBZSxLQUFLLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFBQSxRQUM3QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsSUFDQSxTQUFTO0FBQUEsTUFDTDtBQUFBLE1BQ0EsU0FBUztBQUFBLFFBQ0wsT0FBTztBQUFBLFVBQ0gsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFlBQ0YsTUFBTTtBQUFBLFVBQ1Y7QUFBQSxVQUNBLE9BQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxVQUFVO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsWUFDRixNQUFNO0FBQUEsWUFDTixPQUFPO0FBQUEsVUFDWDtBQUFBLFVBQ0EsT0FBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLFFBQVE7QUFBQSxVQUNKLFNBQVM7QUFBQSxRQUNiO0FBQUEsTUFDSjtBQUFBLE1BQ0EsYUFBYTtBQUFBLElBQ2pCO0FBQUEsRUFDSixDQUFDO0FBRUQsTUFBSSxjQUFjO0FBQ2QsVUFBTSxnQkFBZ0IsU0FBUyxlQUFlLGlCQUFpQjtBQUMvRCxrQkFBYyxpQkFBaUIsU0FBUyxNQUFNO0FBQzFDLFVBQUksZ0JBQWdCO0FBQ3BCLFlBQU0sY0FBYyxjQUFjO0FBQ2xDLFVBQUksZ0JBQWdCLFNBQVM7QUFDekIseUJBQWlCLE9BQU8sTUFBTSxHQUFHLEVBQUU7QUFDbkMsdUJBQWUsS0FBSyxNQUFNLEdBQUcsRUFBRTtBQUFBLE1BQ25DLFdBQVcsZ0JBQWdCLFdBQVc7QUFDbEMseUJBQWlCLE9BQU8sTUFBTSxHQUFHLEVBQUU7QUFDbkMsdUJBQWUsS0FBSyxNQUFNLEdBQUcsRUFBRTtBQUFBLE1BQ25DLFdBQVcsZ0JBQWdCLFFBQVE7QUFDL0IseUJBQWlCLE9BQU8sTUFBTSxHQUFHLEdBQUc7QUFDcEMsdUJBQWUsS0FBSyxNQUFNLEdBQUcsR0FBRztBQUFBLE1BQ3BDLE9BQU87QUFDSCx5QkFBaUI7QUFDakIsdUJBQWU7QUFBQSxNQUNuQjtBQUVBLGlCQUFXLEtBQUssU0FBUztBQUN6QixpQkFBVyxLQUFLLFNBQVMsQ0FBQyxJQUFJO0FBQUEsUUFDMUIsT0FBTztBQUFBLFFBQ1A7QUFBQSxRQUNBLE1BQU07QUFBQSxNQUNWO0FBQ0EsaUJBQVcsT0FBTztBQUFBLElBQ3RCLENBQUM7QUFBQSxFQUNMO0FBRUEsV0FBUyxlQUFlLEdBQUcsUUFBUSxTQUFTLEVBQUUsWUFBWTtBQUUxRCxTQUFPO0FBQ1g7OztBQ2xWQSxJQUFBRSxtQkFBd0I7QUFFeEIsSUFBQUMsZ0JBQWM7QUFrQ1AsU0FBUyxXQUNaLGtCQUNBLE1BQ0EsZUFDWTtBQUNaLFFBQU0sWUFBWSxpQkFBaUIsU0FBUyxPQUFPO0FBQUEsSUFDL0MsTUFBTSxFQUFFLE9BQU8sZ0JBQWdCO0FBQUEsRUFDbkMsQ0FBQztBQUNELFFBQU0sdUJBQTZDLENBQUM7QUFDcEQsUUFBTSxhQUF5QixDQUFDO0FBQ2hDLFFBQU0sZUFBNkI7QUFBQSxJQUMvQixRQUFRO0FBQUE7QUFBQTtBQUFBLElBR1IsYUFBYSxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7QUFBQSxJQUNoQyxTQUFTO0FBQUEsSUFDVCxtQkFBbUI7QUFBQSxJQUNuQiwwQkFBMEIsQ0FBQztBQUFBLEVBQy9CO0FBQ0EsTUFBSTtBQUNKLGFBQVcsU0FBUyxNQUFNO0FBQ3RCLFVBQU0sTUFBTSxLQUFLLEtBQUs7QUFHdEIsVUFBTSxTQUFTLFVBQVUsU0FBUyxVQUFVO0FBQUEsTUFDeEMsTUFBTTtBQUFBLFFBQ0YsT0FBTztBQUFBLFFBQ1AsYUFBYSxZQUFZO0FBQUEsTUFDN0I7QUFBQSxJQUNKLENBQUM7QUFDRCxXQUFPLFVBQVUsU0FBVSxPQUFtQjtBQXBGdEQ7QUF1RlksWUFBTSxZQUFZO0FBR2xCLFVBQUksV0FBVztBQUNmLFVBQUksWUFBWTtBQUNoQixZQUFNQyxhQUFZLFVBQVU7QUFDNUIsVUFBSSxTQUFTQSxZQUFXO0FBQ3BCLGNBQU0sSUFBSSxNQUFNLDhEQUE4RDtBQUFBLE1BQ2xGO0FBQ0EsWUFBTUMsb0JBQW1CRCxXQUFVO0FBQ25DLFVBQUksU0FBU0MsbUJBQWtCO0FBQzNCLGNBQU0sSUFBSTtBQUFBLFVBQ047QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUlBLFlBQU0sY0FBY0Esa0JBQWlCLFFBQVEsb0JBQW9CO0FBQ2pFLFlBQU0sc0JBQXNCQSxrQkFBaUIsU0FBUyxzQkFBc0I7QUFDNUUsaUJBQVcsU0FBUyxhQUFhO0FBQzdCLGNBQU1DLGNBQWEsWUFBWSxLQUFLO0FBSXBDLFlBQUksQ0FBQyxxQkFBcUI7QUFFdEIsVUFBQUEsWUFBVyxTQUFTLGVBQWU7QUFDbkMsY0FBSUEsWUFBVyxlQUFlLFdBQVc7QUFDckMsd0JBQVlBLFlBQVc7QUFBQSxVQUMzQjtBQUNBLGNBQUlBLFlBQVcsY0FBYyxVQUFVO0FBQ25DLHVCQUFXQSxZQUFXO0FBQUEsVUFDMUI7QUFBQSxRQUNKO0FBR0EsUUFBQUEsWUFBVyxZQUFZLGVBQWU7QUFBQSxNQUMxQztBQUtBLFlBQU0scUJBQXFCRixXQUFVLFFBQVEsdUJBQXVCO0FBQ3BFLGlCQUFXLFNBQVMsb0JBQW9CO0FBQ3BDLGNBQU1HLGFBQVksbUJBQW1CLEtBQUs7QUFDMUMsUUFBQUEsV0FBVSxZQUFZLGVBQWU7QUFBQSxNQUN6QztBQUdBLGdCQUFVLFNBQVMsZUFBZTtBQUNsQyxZQUFNLHVCQUNGLFVBQVUsV0FBVyxhQUFhLGFBQWE7QUFDbkQsVUFBSSxTQUFTLHNCQUFzQjtBQUMvQixjQUFNLElBQUksTUFBTSx1REFBdUQ7QUFBQSxNQUMzRTtBQUNBLFlBQU1DLGlCQUFnQixxQkFBcUI7QUFDM0MsWUFBTSxhQUFpQyxTQUFTLGVBQWVBLGNBQWE7QUFDNUUsVUFBSSxTQUFTLFlBQVk7QUFDckIsY0FBTSxJQUFJO0FBQUEsVUFDTixvREFBb0RBLGlCQUFnQjtBQUFBLFFBQ3hFO0FBQUEsTUFDSjtBQUNBLGlCQUFXLFNBQVMsZUFBZTtBQUluQyxtQkFBYSxjQUFjQSxlQUFjLFFBQVEsWUFBWSxFQUFFO0FBSS9ELHVCQUFXLEtBQUssa0NBQWtDLE1BQWxELG1CQUFxRDtBQUlyRCxVQUFJLENBQUMscUJBQXFCO0FBQ3RCLG1CQUFXLE1BQU0sUUFBUSxXQUFXO0FBQ3BDLG1CQUFXLE1BQU0sU0FBUyxZQUFZO0FBQUEsTUFDMUM7QUFHQSxZQUFNLGVBQWU7QUFBQSxJQUN6QjtBQUNBLFFBQUksSUFBSSxLQUFNLCtCQUFRLFFBQVEsSUFBSSxJQUFJO0FBRXRDLFdBQU8sbUJBQW1CLGFBQWEsa0NBQUFDLFNBQUMsVUFBSyxPQUFNLHdCQUFzQixJQUFJLEtBQU0sQ0FBTztBQUMxRixlQUFXLEtBQUssSUFBSTtBQUdwQix5QkFBcUIsS0FBSyxJQUFJLGlCQUFpQixTQUFTLE9BQU87QUFBQSxNQUMzRCxNQUFNLEVBQUUsT0FBTyxrQkFBa0IsSUFBSSxZQUFZLE1BQU07QUFBQSxJQUMzRCxDQUFDO0FBR0QsaUJBQWEseUJBQXlCLEtBQUssSUFBSSxJQUFJO0FBQUEsTUFDL0MscUJBQXFCLEtBQUs7QUFBQSxJQUM5QjtBQUdBLFFBQUksV0FBYyxhQUFhO0FBQzNCLG9CQUFjO0FBQUEsSUFDbEI7QUFBQSxFQUNKO0FBR0EsYUFBVyxhQUFhLEVBQUUsTUFBTTtBQUdoQyxTQUFPO0FBQ1g7OztBL0kxTEEsSUFBSSxxQkFBcUI7QUFDekIsU0FBUyxvQkFBb0JDLFdBQTRCO0FBQ3JELGVBQWEsa0JBQWtCO0FBQy9CLHVCQUFxQixPQUFPLFdBQVdBLFdBQVUsR0FBRztBQUN4RDtBQUVPLElBQU0sZUFBTixjQUEyQixrQ0FBaUI7QUFBQSxFQUsvQyxZQUFZLEtBQVUsUUFBa0I7QUFDcEMsVUFBTSxLQUFLLE1BQU07QUFta0NyQixTQUFRLGVBR0o7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLE1BQ2hCLFNBQVM7QUFBQSxJQUNiO0FBeGtDSSxTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsVUFBZ0I7QUFDWixVQUFNLEVBQUUsWUFBWSxJQUFJO0FBRXhCLGdCQUFZLE1BQU07QUFFbEIsVUFBTSxTQUFTLFlBQVksU0FBUyxNQUFNO0FBQUEsTUFDdEMsTUFBTSxHQUFHLEVBQUUsaUJBQWlCLENBQUM7QUFBQSxJQUNqQyxDQUFDO0FBQ0QsV0FBTyxTQUFTLGFBQWE7QUFFN0IsU0FBSyxlQUFlO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsUUFDSSxtQkFBbUI7QUFBQSxVQUNmLE9BQU8sRUFBRSxZQUFZO0FBQUEsVUFDckIsTUFBTTtBQUFBLFVBQ04sa0JBQWtCLENBQUMscUJBQ2YsS0FBSyxjQUFjLGdCQUFnQjtBQUFBLFFBQzNDO0FBQUEsUUFDQSxjQUFjO0FBQUEsVUFDVixPQUFPLEVBQUUsT0FBTztBQUFBLFVBQ2hCLE1BQU07QUFBQSxVQUNOLGtCQUFrQixDQUFDLHFCQUNmLEtBQUssU0FBUyxnQkFBZ0I7QUFBQSxRQUN0QztBQUFBLFFBQ0Esa0JBQWtCO0FBQUEsVUFDZCxPQUFPLEVBQUUsWUFBWTtBQUFBLFVBQ3JCLE1BQU07QUFBQSxVQUNOLGtCQUFrQixDQUFDLHFCQUNmLEtBQUssY0FBYyxnQkFBZ0I7QUFBQSxRQUMzQztBQUFBLFFBQ0EsdUJBQXVCO0FBQUEsVUFDbkIsT0FBTyxFQUFFLElBQUk7QUFBQSxVQUNiLE1BQU07QUFBQSxVQUNOLGtCQUFrQixDQUFDLHFCQUNmLEtBQUssaUJBQWlCLGdCQUFnQjtBQUFBLFFBQzlDO0FBQUEsUUFDQSxtQkFBbUI7QUFBQSxVQUNmLE9BQU8sRUFBRSxhQUFhO0FBQUEsVUFDdEIsTUFBTTtBQUFBLFVBQ04sa0JBQWtCLE9BQU8scUJBQWlEO0FBQ3RFLGdCQUFJLEtBQUssT0FBTyxXQUFXLGFBQWEsTUFBTTtBQUMxQyxvQkFBTSxLQUFLLE9BQU8sS0FBSztBQUFBLFlBQzNCO0FBRUEsaUJBQUssYUFBYSxJQUFJO0FBQUEsY0FDbEI7QUFBQSxjQUNBLEtBQUssT0FBTztBQUFBLFlBQ2hCO0FBQ0EsaUJBQUssV0FBVyxPQUFPO0FBQUEsVUFDM0I7QUFBQSxRQUNKO0FBQUEsUUFDQSxhQUFhO0FBQUEsVUFDVCxPQUFPLEVBQUUsTUFBTTtBQUFBLFVBQ2YsTUFBTTtBQUFBLFVBQ04sa0JBQWtCLENBQUMscUJBQ2YsS0FBSyxRQUFRLGdCQUFnQjtBQUFBLFFBQ3JDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsS0FBSyxhQUFhO0FBQUEsSUFDdEI7QUFLQSxTQUFLLGFBQWEseUJBQXlCLEtBQUssYUFBYSxXQUFXLEVBQUUsS0FBSyxNQUFNO0FBQ2pGLFdBQUsscUJBQXFCLFdBQVc7QUFBQSxJQUN6QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUEsT0FBYTtBQUNULFNBQUssV0FBVyxRQUFRO0FBQ3hCLFNBQUssWUFBWSxNQUFNO0FBQUEsRUFDM0I7QUFBQSxFQUVBLE1BQWMsY0FBYyxhQUF5QztBQUNqRSxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQztBQUM1RCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLEVBQzNCLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVksQ0FBQyxTQUNWLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGNBQWMsS0FBSyxHQUFHLENBQUMsRUFDMUQsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsTUFBTSxNQUFNLEtBQUs7QUFDM0QsZ0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUNyQyxDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsMEJBQTBCLENBQUMsRUFDckMsUUFBUSxFQUFFLCtCQUErQixDQUFDLEVBQzFDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMscUJBQXFCLEVBQ3hELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsd0JBQXdCO0FBQ2xELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFNBQUssNkJBQTZCLFdBQVc7QUFFN0MsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFLHdCQUF3QixFQUFFLENBQUM7QUFDaEUsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSw2QkFBNkIsQ0FBQyxFQUN4QyxRQUFRLEVBQUUsa0NBQWtDLENBQUMsRUFDN0M7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsRUFDbkQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxtQkFBbUI7QUFDN0MsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSwrQkFBK0IsQ0FBQyxFQUMxQztBQUFBLE1BQVksQ0FBQyxhQUNWLFNBQ0ssV0FBVztBQUFBLFFBQ1Isb0JBQW9CLEVBQUUsd0NBQXdDO0FBQUEsUUFDOUQsb0JBQW9CLEVBQUUsd0NBQXdDO0FBQUEsUUFDOUQsZ0JBQWdCLEVBQUUsb0NBQW9DO0FBQUEsUUFDdEQsZ0JBQWdCLEVBQUUsb0NBQW9DO0FBQUEsUUFDdEQsNEJBQTRCLEVBQUUsd0NBQXdDO0FBQUEsTUFDMUUsQ0FBQyxFQUNBLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxrQkFBa0IsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxxQkFBcUI7QUFDL0MsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVDtBQUVKLFVBQU0sbUJBQ0YsS0FBSyxPQUFPLEtBQUssU0FBUyxzQkFBc0I7QUFDcEQsUUFBSSx5QkFBUSxXQUFXLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixDQUFDLEVBQUU7QUFBQSxNQUFZLENBQUMsYUFDbEUsU0FDSztBQUFBLFFBQ0csbUJBQ007QUFBQTtBQUFBLFVBRUksNkJBQTZCO0FBQUEsWUFDekI7QUFBQSxVQUNKO0FBQUE7QUFBQSxVQUVBLHlCQUF5QjtBQUFBLFlBQ3JCO0FBQUEsVUFDSjtBQUFBLFFBQ0osSUFDQTtBQUFBLFVBQ0ksNEJBQTRCO0FBQUEsWUFDeEI7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLE1BQ1YsRUFDQztBQUFBLFFBQ0csbUJBQ00sS0FBSyxPQUFPLEtBQUssU0FBUyxxQkFDMUI7QUFBQSxNQUNWLEVBQ0MsWUFBWSxDQUFDLGdCQUFnQixFQUM3QixTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLHFCQUFxQjtBQUMvQyxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFQSxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQztBQUNwRSxVQUFNLDhCQUE4QixJQUFJLHlCQUFRLFdBQVcsRUFBRTtBQUFBLE1BQ3pELEVBQUUsOEJBQThCO0FBQUEsSUFDcEM7QUFDQSxnQ0FBNEIsT0FBTztBQUFBLE1BQy9CO0FBQUEsTUFDQSxFQUFFLHFDQUFxQyxFQUFFLGdCQUFnQiw0QkFBNEIsQ0FBQztBQUFBLElBQzFGO0FBQ0EsZ0NBQTRCO0FBQUEsTUFBVSxDQUFDLFdBQ25DLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHlCQUF5QixFQUM1RCxTQUFTLE9BQU8sVUFBVTtBQUN2QixjQUFNLDJCQUEyQjtBQUNqQyxjQUFNLGtCQUFrQixJQUFJLElBQUksS0FBSyxPQUFPLEtBQUssU0FBUyxhQUFhO0FBRXZFLFlBQUksT0FBTztBQUNQLDBCQUFnQixJQUFJLHdCQUF3QjtBQUFBLFFBQ2hELE9BQU87QUFDSCwwQkFBZ0IsT0FBTyx3QkFBd0I7QUFBQSxRQUNuRDtBQUVBLGFBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxlQUFlO0FBQzdELGFBQUssT0FBTyxLQUFLLFNBQVMsNEJBQTRCO0FBQ3RELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1Q7QUFFQSxVQUFNLDRCQUE0QixJQUFJLHlCQUFRLFdBQVcsRUFBRTtBQUFBLE1BQ3ZELEVBQUUsNkJBQTZCO0FBQUEsSUFDbkM7QUFDQSw4QkFBMEIsT0FBTztBQUFBLE1BQzdCO0FBQUEsTUFDQSxFQUFFLG9DQUFvQyxFQUFFLGdCQUFnQiw0QkFBNEIsQ0FBQztBQUFBLElBQ3pGO0FBQ0EsOEJBQTBCO0FBQUEsTUFBVSxDQUFDLFdBQ2pDLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixFQUMxRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixjQUFNLHFCQUFxQjtBQUMzQixjQUFNLGtCQUFrQixJQUFJLElBQUksS0FBSyxPQUFPLEtBQUssU0FBUyxhQUFhO0FBRXZFLFlBQUksT0FBTztBQUNQLDBCQUFnQixJQUFJLGtCQUFrQjtBQUFBLFFBQzFDLE9BQU87QUFDSCwwQkFBZ0IsT0FBTyxrQkFBa0I7QUFBQSxRQUM3QztBQUVBLGFBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxlQUFlO0FBQzdELGFBQUssT0FBTyxLQUFLLFNBQVMsMEJBQTBCO0FBQ3BELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1Q7QUFFQSxVQUFNLGlDQUFpQyxJQUFJLHlCQUFRLFdBQVcsRUFBRTtBQUFBLE1BQzVELEVBQUUsa0NBQWtDO0FBQUEsSUFDeEM7QUFDQSxtQ0FBK0IsT0FBTztBQUFBLE1BQ2xDO0FBQUEsTUFDQSxFQUFFLHlDQUF5QztBQUFBLFFBQ3ZDLGdCQUFnQjtBQUFBLE1BQ3BCLENBQUM7QUFBQSxJQUNMO0FBQ0EsbUNBQStCO0FBQUEsTUFBVSxDQUFDLFdBQ3RDLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLDRCQUE0QixFQUMvRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixjQUFNLDhCQUE4QjtBQUNwQyxjQUFNLGtCQUFrQixJQUFJLElBQUksS0FBSyxPQUFPLEtBQUssU0FBUyxhQUFhO0FBRXZFLFlBQUksT0FBTztBQUNQLDBCQUFnQixJQUFJLDJCQUEyQjtBQUFBLFFBQ25ELE9BQU87QUFDSCwwQkFBZ0IsT0FBTywyQkFBMkI7QUFBQSxRQUN0RDtBQUVBLGFBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxlQUFlO0FBQzdELGFBQUssT0FBTyxLQUFLLFNBQVMsK0JBQStCO0FBQ3pELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1Q7QUFFQSxVQUFNLGtCQUFrQixJQUFJLHlCQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLENBQUM7QUFDNUUsb0JBQWdCLE9BQU87QUFBQSxNQUNuQjtBQUFBLE1BQ0EsRUFBRSx1QkFBdUI7QUFBQSxRQUNyQixTQUNJO0FBQUEsTUFDUixDQUFDO0FBQUEsSUFDTDtBQUNBLG9CQUFnQjtBQUFBLE1BQVksQ0FBQyxTQUN6QixLQUNLO0FBQUEsUUFDRztBQUFBLE1BQ0osRUFDQyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsY0FBYyxLQUFLLElBQUksQ0FBQyxFQUMzRCxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixnQkFBTSwyQkFBMkI7QUFDakMsZ0JBQU0scUJBQXFCO0FBQzNCLGdCQUFNLDhCQUE4QjtBQUVwQyxnQkFBTSxrQkFBa0IsSUFBSTtBQUFBLFlBQ3hCLE1BQ0ssTUFBTSxLQUFLLEVBQ1gsSUFBSSxDQUFDQyxPQUFNQSxHQUFFLEtBQUssQ0FBQyxFQUNuQixPQUFPLENBQUNBLE9BQU1BLEVBQUM7QUFBQSxVQUN4QjtBQUVBLGNBQUksZ0JBQWdCLElBQUksd0JBQXdCLEdBQUc7QUFDL0MsaUJBQUssT0FBTyxLQUFLLFNBQVMsNEJBQTRCO0FBQUEsVUFDMUQsT0FBTztBQUNILGlCQUFLLE9BQU8sS0FBSyxTQUFTLDRCQUE0QjtBQUFBLFVBQzFEO0FBRUEsY0FBSSxnQkFBZ0IsSUFBSSxrQkFBa0IsR0FBRztBQUN6QyxpQkFBSyxPQUFPLEtBQUssU0FBUywwQkFBMEI7QUFBQSxVQUN4RCxPQUFPO0FBQ0gsaUJBQUssT0FBTyxLQUFLLFNBQVMsMEJBQTBCO0FBQUEsVUFDeEQ7QUFFQSxjQUFJLGdCQUFnQixJQUFJLDJCQUEyQixHQUFHO0FBQ2xELGlCQUFLLE9BQU8sS0FBSyxTQUFTLCtCQUErQjtBQUFBLFVBQzdELE9BQU87QUFDSCxpQkFBSyxPQUFPLEtBQUssU0FBUywrQkFBK0I7QUFBQSxVQUM3RDtBQUVBLGVBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxlQUFlO0FBQzdELGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1Q7QUFFQSxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHdCQUF3QixDQUFDLEVBQ25DLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixFQUMxRCxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLDBCQUEwQjtBQUNwRCxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLDBCQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QyxRQUFRLEVBQUUsaUNBQWlDLENBQUMsRUFDNUM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUywrQkFBK0IsRUFDbEUsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyxrQ0FBa0M7QUFDNUQsZ0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUNyQyxDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyxrQ0FDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsMkJBQTJCLENBQUMsRUFDdEMsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLEVBQzVDO0FBQUEsTUFBUSxDQUFDLFNBQ04sS0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsc0JBQXNCLEVBQ3pELFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMseUJBQXlCO0FBQ25ELGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMseUJBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBRWpDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLG9DQUFvQyxDQUFDLEVBQy9DLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QztBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLDhCQUE4QixFQUNqRSxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLGlDQUFpQztBQUMzRCxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLGlDQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSw0QkFBNEIsQ0FBQyxFQUN2QyxRQUFRLEVBQUUsaUNBQWlDLENBQUMsRUFDNUM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxzQkFBc0IsRUFDekQsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyx5QkFBeUI7QUFDbkQsZ0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUNyQyxDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyx5QkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQWMsU0FBUyxhQUF5QztBQUM1RCxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQztBQUM1RCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLEVBQzNCLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQztBQUFBLE1BQVksQ0FBQyxTQUNWLEtBQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGFBQWEsS0FBSyxHQUFHLENBQUMsRUFDekQsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZUFBSyxPQUFPLEtBQUssU0FBUyxlQUFlLE1BQU0sTUFBTSxLQUFLO0FBQzFELGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1Q7QUFFSixTQUFLLDZCQUE2QixXQUFXO0FBRTdDLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxDQUFDO0FBQzVELFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQzdELE9BQU8sU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVksRUFBRSxTQUFTLE9BQU8sVUFBVTtBQUM5RSxhQUFLLE9BQU8sS0FBSyxTQUFTLGVBQWU7QUFDekMsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNMO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxFQUM3QixRQUFRLEVBQUUsdUJBQXVCLENBQUMsRUFDbEM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxjQUFjLEVBQ2pELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsaUJBQWlCO0FBQzNDLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSx3QkFBd0IsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQ3JFLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLDZCQUE2QixFQUNoRSxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLGdDQUFnQztBQUMxRCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFQSxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHlCQUF5QixDQUFDLEVBQ3BDO0FBQUEsTUFBUSxDQUFDLFNBQ04sS0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMseUJBQXlCLFNBQVMsQ0FBQyxFQUN0RSxTQUFTLENBQUMsVUFBVTtBQUNqQiw0QkFBb0IsWUFBWTtBQUM1QixnQkFBTSxXQUFtQixPQUFPLFNBQVMsS0FBSztBQUM5QyxjQUFJLENBQUMsTUFBTSxRQUFRLEdBQUc7QUFDbEIsZ0JBQUksV0FBVyxHQUFHO0FBQ2Qsa0JBQUksd0JBQU8sRUFBRSxhQUFhLENBQUM7QUFDM0IsbUJBQUs7QUFBQSxnQkFDRCxLQUFLLE9BQU8sS0FBSyxTQUFTLHlCQUF5QixTQUFTO0FBQUEsY0FDaEU7QUFDQTtBQUFBLFlBQ0o7QUFFQSxpQkFBSyxPQUFPLEtBQUssU0FBUywyQkFBMkI7QUFDckQsa0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxVQUNyQyxPQUFPO0FBQ0gsZ0JBQUksd0JBQU8sRUFBRSxzQkFBc0IsQ0FBQztBQUFBLFVBQ3hDO0FBQUEsUUFDSixDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUywyQkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQWMsNkJBQTZCLGFBQXlDO0FBQ2hGLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsbUJBQW1CLENBQUMsRUFDOUIsUUFBUSxFQUFFLHdCQUF3QixDQUFDLEVBQ25DO0FBQUEsTUFBWSxDQUFDLFNBQ1YsS0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsb0JBQW9CLEtBQUssSUFBSSxDQUFDLEVBQ2pFLFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGVBQUssT0FBTyxLQUFLLFNBQVMsc0JBQXNCLE1BQzNDLE1BQU0sS0FBSyxFQUNYLElBQUksQ0FBQ0EsT0FBTUEsR0FBRSxLQUFLLENBQUMsRUFDbkIsT0FBTyxDQUFDQSxPQUFNQSxFQUFDO0FBQ3BCLGdCQUFNLEtBQUssT0FBTyxlQUFlO0FBRWpDLGVBQUssUUFBUTtBQUFBLFFBQ2pCLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNUO0FBQUEsRUFDUjtBQUFBLEVBRUEsTUFBYyxpQkFBaUIsYUFBeUM7QUFDcEUsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFLHNCQUFzQixFQUFFLENBQUM7QUFDOUQsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxhQUFhLENBQUMsRUFDeEIsUUFBUSxFQUFFLGtCQUFrQixDQUFDLEVBQzdCO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLEVBQ25ELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFlBQUksT0FBTztBQUNQLGVBQUssT0FBTyx3QkFBd0I7QUFBQSxRQUN4QyxPQUFPO0FBQ0gsZUFBSyxPQUFPLGVBQWUsaUJBQWlCO0FBRzVDLGVBQUssT0FBTyxzQkFBc0I7QUFBQSxRQUN0QztBQUNBLGFBQUssT0FBTyxLQUFLLFNBQVMsbUJBQW1CO0FBQzdDLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsa0JBQWtCLENBQUMsRUFDN0IsUUFBUSxFQUFFLHVCQUF1QixDQUFDLEVBQ2xDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FDSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsY0FBYyxFQUNqRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLGlCQUFpQjtBQUMzQyxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQ2pDLGFBQUssT0FBTyxlQUFlLEtBQUs7QUFBQSxNQUNwQyxDQUFDO0FBQUEsSUFDVDtBQUVKLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsaUJBQWlCLENBQUMsRUFDNUIsUUFBUSxFQUFFLHNCQUFzQixDQUFDLEVBQ2pDO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FBTyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsYUFBYSxFQUFFLFNBQVMsT0FBTyxVQUFVO0FBQy9FLGFBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCO0FBQzFDLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxPQUFPLGNBQWMsS0FBSztBQUFBLE1BQ25DLENBQUM7QUFBQSxJQUNMO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QyxRQUFRLEVBQUUsc0NBQXNDLENBQUMsRUFDakQ7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsQ0FBQyxLQUFLLE9BQU8sS0FBSyxTQUFTLDRCQUE0QixFQUNoRSxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLCtCQUErQixDQUFDO0FBQzFELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFDakMsYUFBSyxPQUFPLGtCQUFrQixLQUFLO0FBQUEsTUFDdkMsQ0FBQztBQUFBLElBQ1Q7QUFFSixnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLENBQUM7QUFDcEQsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxtQ0FBbUMsQ0FBQyxFQUM5QyxRQUFRLEVBQUUsd0NBQXdDLENBQUMsRUFDbkQ7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxnQ0FBZ0MsRUFDbkUsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxtQ0FBbUM7QUFDN0QsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxtQkFBbUIsQ0FBQyxFQUM5QixRQUFRLEVBQUUsd0JBQXdCLENBQUMsRUFDbkM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxrQkFBa0IsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxxQkFBcUI7QUFDL0MsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QyxRQUFRLEVBQUUsc0NBQXNDLENBQUMsRUFDakQ7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUywyQkFBMkIsRUFDOUQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyw4QkFBOEI7QUFDeEQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUosUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxFQUN0QyxRQUFRLEVBQUUsOEJBQThCLENBQUMsRUFDekM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFVBQVUsSUFBSSxLQUFLLENBQUMsRUFDcEIsU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHlCQUF5QixFQUM1RCxrQkFBa0IsRUFDbEIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyw0QkFBNEI7QUFDdEQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLDRCQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSwwQkFBMEIsQ0FBQyxFQUNyQyxRQUFRLEVBQUUsOEJBQThCLENBQUMsRUFDekM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFVBQVUsSUFBSSxLQUFLLENBQUMsRUFDcEIsU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHdCQUF3QixFQUMzRCxrQkFBa0IsRUFDbEIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUywyQkFBMkI7QUFDckQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLDJCQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFLHdCQUF3QixFQUFFLENBQUM7QUFDaEUsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxzQkFBc0IsQ0FBQyxFQUNqQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsRUFDaEM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUFLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxpQkFBaUIsRUFBRSxTQUFTLENBQUMsVUFBVTtBQUMzRSw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUFvQjtBQUM5QyxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNMLEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxzQkFBc0IsQ0FBQyxFQUNqQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsRUFDaEM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUFLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxpQkFBaUIsRUFBRSxTQUFTLENBQUMsVUFBVTtBQUMzRSw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUFvQjtBQUM5QyxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNMLEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxzQkFBc0IsQ0FBQyxFQUNqQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsRUFDaEM7QUFBQSxNQUFRLENBQUMsU0FDTixLQUFLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxpQkFBaUIsRUFBRSxTQUFTLENBQUMsVUFBVTtBQUMzRSw0QkFBb0IsWUFBWTtBQUM1QixlQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUFvQjtBQUM5QyxnQkFBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLFFBQ3JDLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNMLEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUNoQyxRQUFRLEVBQUUsMEJBQTBCLENBQUMsRUFDckM7QUFBQSxNQUFVLENBQUMsV0FDUixPQUNLLFVBQVUsR0FBRyxLQUFNLEdBQUcsRUFDdEIsU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLGlCQUFpQixFQUNwRCxrQkFBa0IsRUFDbEIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUyxvQkFBb0I7QUFDOUMsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNULEVBQ0MsZUFBZSxDQUFDLFdBQVc7QUFDeEIsYUFDSyxRQUFRLE9BQU8sRUFDZixXQUFXLEVBQUUsZUFBZSxDQUFDLEVBQzdCLFFBQVEsWUFBWTtBQUNqQixhQUFLLE9BQU8sS0FBSyxTQUFTLG9CQUN0QixpQkFBaUI7QUFDckIsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBYyxjQUFjLGFBQXlDO0FBQ2pFLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsQ0FBQztBQUNuRCxVQUFNLGdCQUFnQixJQUFJLHlCQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDO0FBQ3JFLGtCQUFjLE9BQU87QUFBQSxNQUNqQjtBQUFBLE1BQ0EsRUFBRSx3QkFBd0I7QUFBQSxRQUN0QixTQUFTO0FBQUEsTUFDYixDQUFDO0FBQUEsSUFDTDtBQUNBLGtCQUFjO0FBQUEsTUFBWSxDQUFDLGFBQ3ZCLFNBQ0ssV0FBVztBQUFBLFFBQ1IsWUFBWSxFQUFFLGlCQUFpQjtBQUFBLE1BQ25DLENBQUMsRUFDQSxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsU0FBUyxFQUM1QyxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVk7QUFDdEMsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxXQUFXLENBQUMsRUFDdEIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLEVBQzNCO0FBQUEsTUFBUSxDQUFDLFNBQ04sS0FBSyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsU0FBUyxTQUFTLENBQUMsRUFBRSxTQUFTLENBQUMsVUFBVTtBQUM3RSw0QkFBb0IsWUFBWTtBQUM1QixnQkFBTSxXQUFtQixPQUFPLFNBQVMsS0FBSztBQUM5QyxjQUFJLENBQUMsTUFBTSxRQUFRLEdBQUc7QUFDbEIsZ0JBQUksV0FBVyxLQUFLO0FBQ2hCLGtCQUFJLHdCQUFPLEVBQUUsdUJBQXVCLENBQUM7QUFDckMsbUJBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLFNBQVMsU0FBUyxDQUFDO0FBQzNEO0FBQUEsWUFDSjtBQUVBLGlCQUFLLE9BQU8sS0FBSyxTQUFTLFdBQVc7QUFDckMsa0JBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxVQUNyQyxPQUFPO0FBQ0gsZ0JBQUksd0JBQU8sRUFBRSxzQkFBc0IsQ0FBQztBQUFBLFVBQ3hDO0FBQUEsUUFDSixDQUFDO0FBQUEsTUFDTCxDQUFDO0FBQUEsSUFDTCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyxXQUFXLGlCQUFpQjtBQUN0RCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBRWpDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLHVCQUF1QixDQUFDLEVBQ2xDLFFBQVEsRUFBRSw0QkFBNEIsQ0FBQyxFQUN2QztBQUFBLE1BQVUsQ0FBQyxXQUNSLE9BQ0ssVUFBVSxHQUFHLElBQUksQ0FBQyxFQUNsQixTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsdUJBQXVCLEdBQUcsRUFDN0Qsa0JBQWtCLEVBQ2xCLFNBQVMsT0FBTyxVQUFrQjtBQUMvQixhQUFLLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixRQUFRO0FBQ3pELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyx1QkFDdEIsaUJBQWlCO0FBQ3JCLGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsWUFBWSxDQUFDLEVBQ3ZCLFFBQVEsRUFBRSxpQkFBaUIsQ0FBQyxFQUM1QjtBQUFBLE1BQVEsQ0FBQyxTQUNOLEtBQ0ssVUFBVSxLQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVksS0FBSyxTQUFTLENBQUMsRUFDL0QsU0FBUyxDQUFDLFVBQVU7QUFDakIsNEJBQW9CLFlBQVk7QUFDNUIsZ0JBQU0sV0FBbUIsT0FBTyxTQUFTLEtBQUssSUFBSTtBQUNsRCxjQUFJLENBQUMsTUFBTSxRQUFRLEdBQUc7QUFDbEIsZ0JBQUksV0FBVyxHQUFLO0FBQ2hCLGtCQUFJLHdCQUFPLEVBQUUsd0JBQXdCLENBQUM7QUFDdEMsbUJBQUs7QUFBQSxpQkFDQSxLQUFLLE9BQU8sS0FBSyxTQUFTLFlBQVksS0FBSyxTQUFTO0FBQUEsY0FDekQ7QUFDQTtBQUFBLFlBQ0o7QUFFQSxpQkFBSyxPQUFPLEtBQUssU0FBUyxZQUFZO0FBQ3RDLGtCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsVUFDckMsT0FBTztBQUNILGdCQUFJLHdCQUFPLEVBQUUsc0JBQXNCLENBQUM7QUFBQSxVQUN4QztBQUFBLFFBQ0osQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsWUFBWSxpQkFBaUI7QUFDdkQsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUVqQyxhQUFLLFFBQVE7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDVCxDQUFDO0FBRUwsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsRUFBRSxjQUFjLENBQUMsRUFDekIsUUFBUSxFQUFFLG1CQUFtQixDQUFDLEVBQzlCO0FBQUEsTUFBVSxDQUFDLFdBQ1IsT0FBTyxTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsV0FBVyxFQUFFLFNBQVMsT0FBTyxVQUFVO0FBQzdFLGFBQUssT0FBTyxLQUFLLFNBQVMsY0FBYztBQUN4QyxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ0w7QUFFSixRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGNBQWMsQ0FBQyxFQUN6QixRQUFRLEVBQUUsbUJBQW1CLENBQUMsRUFDOUI7QUFBQSxNQUFRLENBQUMsU0FDTixLQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsU0FBUyxDQUFDLEVBQzdELFNBQVMsQ0FBQyxVQUFVO0FBQ2pCLDRCQUFvQixZQUFZO0FBQzVCLGdCQUFNLFdBQW1CLE9BQU8sU0FBUyxLQUFLO0FBQzlDLGNBQUksQ0FBQyxNQUFNLFFBQVEsR0FBRztBQUNsQixnQkFBSSxXQUFXLEdBQUc7QUFDZCxrQkFBSSx3QkFBTyxFQUFFLDBCQUEwQixDQUFDO0FBQ3hDLG1CQUFLO0FBQUEsZ0JBQ0QsS0FBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsU0FBUztBQUFBLGNBQ3ZEO0FBQ0E7QUFBQSxZQUNKO0FBRUEsaUJBQUssT0FBTyxLQUFLLFNBQVMsa0JBQWtCO0FBQzVDLGtCQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsVUFDckMsT0FBTztBQUNILGdCQUFJLHdCQUFPLEVBQUUsc0JBQXNCLENBQUM7QUFBQSxVQUN4QztBQUFBLFFBQ0osQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ1QsRUFDQyxlQUFlLENBQUMsV0FBVztBQUN4QixhQUNLLFFBQVEsT0FBTyxFQUNmLFdBQVcsRUFBRSxlQUFlLENBQUMsRUFDN0IsUUFBUSxZQUFZO0FBQ2pCLGFBQUssT0FBTyxLQUFLLFNBQVMsa0JBQ3RCLGlCQUFpQjtBQUNyQixjQUFNLEtBQUssT0FBTyxlQUFlO0FBRWpDLGFBQUssUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNULENBQUM7QUFFTCxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLGtCQUFrQixDQUFDLEVBQzdCLFFBQVEsRUFBRSx1QkFBdUIsQ0FBQyxFQUNsQztBQUFBLE1BQVUsQ0FBQyxXQUNSLE9BQ0ssVUFBVSxHQUFHLEtBQUssQ0FBQyxFQUNuQixTQUFTLEtBQUssT0FBTyxLQUFLLFNBQVMsZ0JBQWdCLEdBQUcsRUFDdEQsa0JBQWtCLEVBQ2xCLFNBQVMsT0FBTyxVQUFrQjtBQUMvQixhQUFLLE9BQU8sS0FBSyxTQUFTLGdCQUFnQixRQUFRO0FBQ2xELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFBQSxNQUNyQyxDQUFDO0FBQUEsSUFDVCxFQUNDLGVBQWUsQ0FBQyxXQUFXO0FBQ3hCLGFBQ0ssUUFBUSxPQUFPLEVBQ2YsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUM3QixRQUFRLFlBQVk7QUFDakIsYUFBSyxPQUFPLEtBQUssU0FBUyxnQkFBZ0IsaUJBQWlCO0FBQzNELGNBQU0sS0FBSyxPQUFPLGVBQWU7QUFFakMsYUFBSyxRQUFRO0FBQUEsTUFDakIsQ0FBQztBQUFBLElBQ1QsQ0FBQztBQUVMLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxDQUFDO0FBQzVELFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLEVBQUUsb0JBQW9CLENBQUMsRUFDL0IsUUFBUSxFQUFFLHlCQUF5QixDQUFDLEVBQ3BDO0FBQUEsTUFBWSxDQUFDLGFBQ1YsU0FDSyxXQUFXO0FBQUEsUUFDUixPQUFPLEVBQUUsZ0JBQWdCO0FBQUEsTUFDN0IsQ0FBQyxFQUNBLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyxTQUFTLEVBQzVDLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxLQUFLLFNBQVMsWUFBWTtBQUN0QyxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFSixRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxFQUFFLDRCQUE0QixDQUFDLEVBQ3ZDLFFBQVEsRUFBRSxpQ0FBaUMsQ0FBQyxFQUM1QztBQUFBLE1BQVUsQ0FBQyxXQUNSLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLHFCQUFxQixFQUN4RCxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLHdCQUF3QjtBQUNsRCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFBQSxFQUNSO0FBQUEsRUFFQSxNQUFjLFFBQVEsYUFBeUM7QUFDM0QsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUNuRCxnQkFBWSxTQUFTLEdBQUcsRUFBRTtBQUFBLE1BQ3RCO0FBQUEsTUFDQSxFQUFFLGNBQWM7QUFBQSxRQUNaLFNBQVM7QUFBQSxNQUNiLENBQUM7QUFBQSxJQUNMO0FBRUEsZ0JBQVksU0FBUyxHQUFHLEVBQUU7QUFBQSxNQUN0QjtBQUFBLE1BQ0EsRUFBRSxzQkFBc0I7QUFBQSxRQUNwQixnQkFDSTtBQUFBLE1BQ1IsQ0FBQztBQUFBLElBQ0w7QUFFQSxnQkFBWSxTQUFTLEdBQUcsRUFBRTtBQUFBLE1BQ3RCO0FBQUEsTUFDQSxFQUFFLGlCQUFpQjtBQUFBLFFBQ2YsV0FBVztBQUFBLE1BQ2YsQ0FBQztBQUFBLElBQ0w7QUFFQSxnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDO0FBQ3RELFFBQUkseUJBQVEsV0FBVyxFQUFFLFFBQVEsRUFBRSwrQkFBK0IsQ0FBQyxFQUFFO0FBQUEsTUFBVSxDQUFDLFdBQzVFLE9BQ0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxTQUFTLDJCQUEyQixFQUM5RCxTQUFTLE9BQU8sVUFBVTtBQUN2QixhQUFLLE9BQU8sS0FBSyxTQUFTLDhCQUE4QjtBQUN4RCxjQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDckMsQ0FBQztBQUFBLElBQ1Q7QUFFQSxRQUFJLHlCQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsMkJBQTJCLENBQUMsRUFBRTtBQUFBLE1BQVUsQ0FBQyxXQUN4RSxPQUNLLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBUyx1QkFBdUIsRUFDMUQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsYUFBSyxPQUFPLEtBQUssU0FBUywwQkFBMEI7QUFDcEQsdUJBQWUsS0FBSyxPQUFPLEtBQUssU0FBUyx1QkFBdUI7QUFDaEUsY0FBTSxLQUFLLE9BQU8sZUFBZTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNUO0FBRUEsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFLG9CQUFvQixFQUFFLENBQUM7QUFDNUQsZ0JBQVksU0FBUyxHQUFHLEVBQUU7QUFBQSxNQUN0QjtBQUFBLE1BQ0EsRUFBRSxzQkFBc0I7QUFBQSxRQUNwQixrQkFBa0I7QUFBQSxNQUN0QixDQUFDO0FBQUEsSUFDTDtBQUVBLGdCQUFZLFNBQVMsR0FBRyxFQUFFO0FBQUEsTUFDdEI7QUFBQSxNQUNBLEVBQUUsMEJBQTBCO0FBQUEsUUFDeEIscUJBQ0k7QUFBQSxNQUNSLENBQUM7QUFBQSxJQUNMO0FBRUEsZ0JBQVksU0FBUyxHQUFHLEVBQUU7QUFBQSxNQUN0QjtBQUFBLE1BQ0EsRUFBRSxpQ0FBaUM7QUFBQSxRQUMvQiw0QkFDSTtBQUFBLE1BQ1IsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFTUSxxQkFBcUIsa0JBQStCO0FBQ3hELFVBQU0sZUFBZSxLQUFLO0FBRzFCLFNBQUssYUFBYSxRQUFRLGFBQWEsT0FBTyxFQUFFLE1BQU07QUFHdEQscUJBQWlCLFNBQVM7QUFBQSxNQUN0QixLQUFLLEtBQUssYUFBYTtBQUFBLE1BQ3ZCLFVBQVU7QUFBQSxJQUNkLENBQUM7QUFHRCxxQkFBaUIsaUJBQWlCLFVBQVUsQ0FBQ0MsT0FBTTtBQUMvQyxXQUFLLGFBQWEsaUJBQWlCLGlCQUFpQjtBQUFBLElBQ3hELENBQUM7QUFDRCxlQUFXLFdBQVcsS0FBSyxhQUFhLFNBQVM7QUFDN0MsWUFBTSxTQUFTLEtBQUssYUFBYSxRQUFRLE9BQU87QUFDaEQsYUFBTyxhQUFhLENBQUNBLE9BQWtCO0FBQ25DLHFCQUFhLFVBQVU7QUFBQSxNQUMzQixDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSjs7O0FnSmpuQ08sSUFBTSxhQUFOLE1BQWlCO0FBQUEsRUFNcEIsSUFBWSxNQUFXO0FBQ25CLFdBQU8sS0FBSyxPQUFPO0FBQUEsRUFDdkI7QUFBQSxFQUVBLFlBQ0ksUUFDQSxVQUNBLHVCQUNGO0FBQ0UsU0FBSyxTQUFTO0FBQ2QsU0FBSyxXQUFXO0FBQ2hCLFNBQUssd0JBQXdCO0FBQUEsRUFDakM7QUFBQSxFQUVBLFNBQWU7QUFDWCxTQUFLLG9CQUFvQixPQUFPO0FBQUEsRUFDcEM7QUFBQSxFQUVRLGNBQWMsTUFBb0M7QUFDdEQsVUFBTSxTQUFTLEtBQUssSUFBSSxVQUFVLGdCQUFnQixJQUFJO0FBQ3RELFFBQUksT0FBTyxVQUFVLEdBQUc7QUFDcEIsYUFBTyxLQUFLLElBQUksVUFBVSxhQUFhLEtBQUs7QUFBQSxJQUNoRDtBQUVBLFdBQU8sT0FBTyxDQUFDO0FBQUEsRUFDbkI7QUFBQSxFQUVBLE9BQWE7QUFDVCxTQUFLLE9BQU8sYUFBYSx3QkFBd0IsQ0FBQyxTQUFTO0FBQ3ZELGFBQVEsS0FBSyxzQkFBc0IsSUFBSTtBQUFBLFFBQ25DO0FBQUEsUUFDQSxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsTUFDVDtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLE1BQU0sK0JBQThDO0FBQ2hELFFBQUksS0FBSyxTQUFTLCtCQUErQjtBQUM3QyxZQUFNLEtBQUssY0FBYyxzQkFBc0IsRUFBRSxhQUFhO0FBQUEsUUFDMUQsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLE1BQ1osQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLHNCQUFxQztBQUN2QyxVQUFNLGtCQUFrQixLQUFLLGNBQWMsc0JBQXNCO0FBQ2pFLFNBQUssSUFBSSxVQUFVLFdBQVcsZUFBZTtBQUFBLEVBQ2pEO0FBQ0o7OztBQzlEQSxJQUFBQyxvQkFBb0M7OztBQ0FwQyxJQUFBQyxpQkFBb0I7QUFDcEIsSUFBQUMsbUJBQStDOzs7QUNEL0MsSUFBQUMsbUJBQTZDO0FBTXRDLElBQU0sd0JBQU4sTUFBNEI7QUFBQSxFQUsvQixZQUFZLEtBQVUsUUFBa0IsVUFBa0I7QUFDdEQsU0FBSyxNQUFNO0FBQ1gsU0FBSyxXQUFXO0FBQ2hCLFNBQUssU0FBUztBQUFBLEVBQ2xCO0FBQUE7QUFBQTtBQUFBLEVBSUEsTUFBTSxzQkFDRixnQkFDQSxhQUNBLGVBQ0EsaUJBQWlCLEdBQ0o7QUFDYixRQUFJLGlCQUFpQixFQUFHO0FBRXhCLFFBQUk7QUFDSixRQUFJLDhCQUFvQztBQUNwQyxXQUFLLFlBQVksVUFBVTtBQUMzQixTQUFHLGFBQWEsT0FBTyxLQUFLO0FBQUEsSUFDaEMsTUFBTyxNQUFLO0FBQ1osc0NBQWlCLE9BQU8sS0FBSyxLQUFLLGdCQUFnQixJQUFJLEtBQUssVUFBVSxLQUFLLE1BQU07QUFFaEYsT0FBRyxRQUFRLGlCQUFpQixFQUFFLFFBQVEsQ0FBQ0MsUUFBTztBQUMxQyxZQUFNQyxRQUFPLEtBQUssVUFBVUQsSUFBRyxhQUFhLEtBQUssQ0FBQztBQUdsRCxVQUFJLENBQUNDLE1BQUssUUFBUTtBQUNkLFFBQUFELElBQUcsWUFBWUMsTUFBSztBQUFBLE1BQ3hCLFdBQVdBLE1BQUssa0JBQWtCLHdCQUFPO0FBQ3JDLFlBQUlBLE1BQUssT0FBTyxjQUFjLE1BQU07QUFDaEMsZUFBSyxlQUFlRCxLQUFJQyxNQUFLLE1BQU07QUFBQSxRQUN2QyxPQUFPO0FBQUEsUUFLUDtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFUSxVQUFVLEtBQWE7QUFDM0IsVUFBTSxzQkFDRjtBQUNKLFVBQU0sVUFBVSxPQUFPLFFBQVEsWUFBWSxJQUFJLE1BQU0sbUJBQW1CO0FBQ3hFLFVBQU0sT0FBTyxRQUFRLE9BQU8sUUFBUSxLQUFLO0FBQ3pDLFVBQU0sU0FBUyxLQUFLLE9BQU8sSUFBSSxjQUFjLHFCQUFxQixNQUFNLEtBQUssUUFBUTtBQUNyRixXQUFPO0FBQUEsTUFDSCxNQUFNLFFBQVEsQ0FBQztBQUFBLE1BQ2YsTUFBTSxRQUFRLE9BQU87QUFBQSxNQUNyQixTQUFTLFFBQVEsT0FBTztBQUFBLE1BQ3hCLFNBQVMsUUFBUSxPQUFPO0FBQUEsTUFDeEI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRVEsZUFBZSxJQUFpQixRQUFlO0FBQ25ELE9BQUcsWUFBWTtBQUNmLFFBQUksY0FBYyxTQUFTLE9BQU8sU0FBUyxHQUFHO0FBQzFDLFNBQUc7QUFBQSxRQUNDO0FBQUEsUUFDQTtBQUFBLFVBQ0ksTUFBTTtBQUFBLFlBQ0YsS0FBSyxLQUFLLE9BQU8sSUFBSSxNQUFNLGdCQUFnQixNQUFNO0FBQUEsVUFDckQ7QUFBQSxRQUNKO0FBQUEsUUFDQSxDQUFDLFFBQVE7QUFDTCxjQUFJLEdBQUcsYUFBYSxPQUFPO0FBQ3ZCLGdCQUFJLGFBQWEsU0FBUyxHQUFHLGFBQWEsT0FBTyxDQUFDO0FBQUEsY0FDakQsS0FBSSxhQUFhLFNBQVMsTUFBTTtBQUNyQyxjQUFJLEdBQUcsYUFBYSxLQUFLLEVBQUcsS0FBSSxhQUFhLE9BQU8sR0FBRyxhQUFhLEtBQUssQ0FBQztBQUMxRSxhQUFHO0FBQUEsWUFDQztBQUFBLFlBQ0EsQ0FBQyxPQUNLLEdBQUcsT0FBdUIsTUFBTSxXQUM3QixHQUFHLE9BQXVCLE1BQU0sYUFBYSxTQUN4QyxPQUNBO0FBQUEsVUFDbEI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNBLFNBQUcsV0FBVyxDQUFDLGVBQWUsV0FBVyxDQUFDO0FBQUEsSUFDOUMsV0FDSSxjQUFjLFNBQVMsT0FBTyxTQUFTLEtBQ3ZDLGNBQWMsU0FBUyxPQUFPLFNBQVMsR0FDekM7QUFDRSxTQUFHO0FBQUEsUUFDQyxjQUFjLFNBQVMsT0FBTyxTQUFTLElBQUksVUFBVTtBQUFBLFFBQ3JEO0FBQUEsVUFDSSxNQUFNO0FBQUEsWUFDRixVQUFVO0FBQUEsWUFDVixLQUFLLEtBQUssT0FBTyxJQUFJLE1BQU0sZ0JBQWdCLE1BQU07QUFBQSxVQUNyRDtBQUFBLFFBQ0o7QUFBQSxRQUNBLENBQUMsVUFBVTtBQUNQLGNBQUksR0FBRyxhQUFhLEtBQUssRUFBRyxPQUFNLGFBQWEsT0FBTyxHQUFHLGFBQWEsS0FBSyxDQUFDO0FBQUEsUUFDaEY7QUFBQSxNQUNKO0FBQ0EsU0FBRyxXQUFXLENBQUMsZUFBZSxXQUFXLENBQUM7QUFBQSxJQUM5QyxPQUFPO0FBQ0gsU0FBRyxZQUFZLE9BQU87QUFBQSxJQUMxQjtBQUFBLEVBQ0o7QUFDSjs7O0FEL0ZPLElBQU0sU0FBTixNQUFhO0FBQUEsRUFrRWhCLFlBQ0ksS0FDQSxRQUNBLFVBQ0EsaUJBQ0EsWUFDQSxNQUNBLFlBQ0Esa0JBQ0Y7QUF0QkYsU0FBUSxzQkFBOEI7QUFDdEMsU0FBUSxzQkFBOEI7QUFJdEMsU0FBUSwrQkFBdUM7QUEraEIvQyxTQUFRLGtCQUFrQixDQUFDQyxPQUFxQjtBQUU1QyxVQUNJLFNBQVMsY0FBYyxhQUFhLGNBQ3BDLEtBQUssMkJBQ0wsQ0FBQyxLQUFLLE9BQU8sa0JBQWtCLEdBQ2pDO0FBQ0U7QUFBQSxNQUNKO0FBRUEsWUFBTSxrQkFBa0IsTUFBTTtBQUMxQixRQUFBQSxHQUFFLGVBQWU7QUFDakIsUUFBQUEsR0FBRSxnQkFBZ0I7QUFBQSxNQUN0QjtBQUVBLGNBQVFBLEdBQUUsTUFBTTtBQUFBLFFBQ1osS0FBSztBQUNELGVBQUssaUJBQWlCO0FBQ3RCLDBCQUFnQjtBQUNoQjtBQUFBLFFBQ0osS0FBSztBQUNELGNBQUksS0FBSyx3QkFBOEI7QUFDbkMsaUJBQUssWUFBWTtBQUNqQiw0QkFBZ0I7QUFBQSxVQUNwQixXQUFXLEtBQUssdUJBQTZCO0FBQ3pDLGlCQUFLLDJCQUFrQztBQUN2Qyw0QkFBZ0I7QUFBQSxVQUNwQjtBQUNBO0FBQUEsUUFDSixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0QsY0FBSSxLQUFLLHdCQUE4QjtBQUNuQztBQUFBLFVBQ0o7QUFDQSxlQUFLLFlBQVk7QUFDakIsMEJBQWdCO0FBQ2hCO0FBQUEsUUFDSixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0QsY0FBSSxLQUFLLHVCQUE2QjtBQUNsQztBQUFBLFVBQ0o7QUFDQSxlQUFLLDJCQUFrQztBQUN2QywwQkFBZ0I7QUFDaEI7QUFBQSxRQUNKLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDRCxjQUFJLEtBQUssdUJBQTZCO0FBQ2xDO0FBQUEsVUFDSjtBQUNBLGVBQUssMkJBQWtDO0FBQ3ZDLDBCQUFnQjtBQUNoQjtBQUFBLFFBQ0osS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNELGNBQUksS0FBSyx1QkFBNkI7QUFDbEM7QUFBQSxVQUNKO0FBQ0EsZUFBSywyQkFBa0M7QUFDdkMsMEJBQWdCO0FBQ2hCO0FBQUEsUUFDSixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0QsY0FBSSxLQUFLLHVCQUE2QjtBQUNsQztBQUFBLFVBQ0o7QUFDQSxlQUFLLDRCQUFtQztBQUN4QywwQkFBZ0I7QUFDaEI7QUFBQSxRQUNKO0FBQ0k7QUFBQSxNQUNSO0FBQUEsSUFDSjtBQXBsQkksU0FBSyxNQUFNO0FBQ1gsU0FBSyxTQUFTO0FBQ2QsU0FBSyxXQUFXO0FBQ2hCLFNBQUssa0JBQWtCO0FBQ3ZCLFNBQUssYUFBYTtBQUNsQixTQUFLLGFBQWE7QUFDbEIsU0FBSyxtQkFBbUI7QUFDeEIsU0FBSyxPQUFPO0FBQ1osU0FBSyxhQUFhO0FBR2xCLFNBQUssS0FBSztBQUFBLEVBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsT0FBTztBQUNILFNBQUssS0FBSyxXQUFXLENBQUMsZ0JBQWdCLGNBQWMsQ0FBQztBQUVyRCxTQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVU7QUFDcEMsU0FBSyxTQUFTLFNBQVMsYUFBYTtBQUVwQyxTQUFLLG9CQUFvQjtBQUV6QixTQUFLLG1CQUFtQjtBQUV4QixTQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVU7QUFDbkMsU0FBSyxRQUFRLFNBQVMsWUFBWTtBQUVsQyxTQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVU7QUFDcEMsU0FBSyxTQUFTLFNBQVMsYUFBYTtBQUVwQyxTQUFLLHVCQUF1QjtBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLEtBQUssWUFBa0I7QUFFekIsUUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLGNBQWMsR0FBRztBQUNyQztBQUFBLElBQ0o7QUFFQSxTQUFLLGFBQWE7QUFDbEIsVUFBTSxZQUFZLEtBQUssZ0JBQWdCLGFBQWEsV0FBVyxhQUFhLENBQUM7QUFDN0UsU0FBSyxzQkFBc0IsVUFBVTtBQUNyQyxTQUFLLHNCQUFzQixVQUFVO0FBRXJDLFVBQU0sS0FBSyxhQUFhO0FBRXhCLFNBQUssS0FBSyxZQUFZLGNBQWM7QUFDcEMsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGVBQWU7QUFBQSxFQUM3RDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxVQUFVO0FBQ1osVUFBTSxLQUFLLGFBQWE7QUFBQSxFQUM1QjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsT0FBTztBQUVILFFBQUksS0FBSyxLQUFLLFNBQVMsY0FBYyxHQUFHO0FBQ3BDO0FBQUEsSUFDSjtBQUVBLGFBQVMsb0JBQW9CLFdBQVcsS0FBSyxlQUFlO0FBQzVELFNBQUssS0FBSyxTQUFTLGNBQWM7QUFBQSxFQUNyQztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsUUFBUTtBQUNKLFNBQUssS0FBSztBQUNWLGFBQVMsb0JBQW9CLFdBQVcsS0FBSyxlQUFlO0FBQUEsRUFDaEU7QUFBQTtBQUFBLEVBSUEsTUFBYyxlQUFlO0FBQ3pCLFNBQUssWUFBWSxXQUFXO0FBRzVCLFNBQUs7QUFDTCxTQUFLLGVBQWUsS0FBSztBQUN6QixTQUFLLGNBQWMsS0FBSyxnQkFBZ0I7QUFDeEMsUUFBSSxLQUFLLGlCQUFpQixLQUFLLGFBQWE7QUFDeEMsWUFBTSxtQkFBbUIsS0FBSyxnQkFBZ0I7QUFBQSxRQUMxQyxLQUFLLFlBQVksYUFBYTtBQUFBLE1BQ2xDO0FBQ0EsV0FBSywrQkFBK0IsaUJBQWlCO0FBQUEsSUFDekQ7QUFFQSxTQUFLLGVBQWUsS0FBSyxZQUFZLEtBQUssV0FBVztBQUdyRCxTQUFLLFFBQVEsTUFBTTtBQUNuQixVQUFNLFVBQWlDLElBQUk7QUFBQSxNQUN2QyxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLLGFBQWE7QUFBQSxJQUN0QjtBQUVBLFVBQU0sUUFBUTtBQUFBLE1BQ1YsS0FBSyxhQUFhLE1BQU0sVUFBVTtBQUFBLE1BQ2xDLEtBQUs7QUFBQSxNQUNMLEtBQUssaUJBQWlCLGFBQWE7QUFBQSxJQUN2QztBQUVBLFNBQUssUUFBUSxZQUFZO0FBR3pCLFNBQUssc0JBQXNCO0FBQUEsRUFDL0I7QUFBQSxFQUVBLElBQVksZUFBcUI7QUFDN0IsV0FBTyxLQUFLLGdCQUFnQjtBQUFBLEVBQ2hDO0FBQUEsRUFFQSxJQUFZLG1CQUE2QjtBQUNyQyxXQUFPLEtBQUssZ0JBQWdCO0FBQUEsRUFDaEM7QUFBQSxFQUVBLElBQVksZUFBcUI7QUFDN0IsV0FBTyxLQUFLLGdCQUFnQjtBQUFBLEVBQ2hDO0FBQUEsRUFFQSxNQUFjLGVBQWUsVUFBeUM7QUFDbEUsVUFBTSxjQUFVLG9CQUFJO0FBQ3BCLFFBQ0ksS0FBSyxlQUNMLFVBQVUsS0FBSyxjQUFjLEtBQUssT0FBTyxLQUFLLFNBQVMsbUJBQ3pEO0FBQ0U7QUFBQSxJQUNKO0FBQ0EsU0FBSyxjQUFjO0FBRW5CLFVBQU0sS0FBSyxnQkFBZ0IsY0FBYyxRQUFRO0FBQ2pELFVBQU0sS0FBSyxjQUFjO0FBQUEsRUFDN0I7QUFBQSxFQUVBLE1BQWMsZ0JBQStCO0FBQ3pDLFFBQUksS0FBSyxnQkFBZ0IsS0FBTSxPQUFNLEtBQUssUUFBUTtBQUFBLFFBQzdDLE1BQUssV0FBVztBQUFBLEVBQ3pCO0FBQUE7QUFBQSxFQUlRLHNCQUFzQjtBQUMxQixTQUFLLGtCQUFrQjtBQUN2QixTQUFLLG1CQUFtQjtBQUN4QixTQUFLLHNCQUFzQjtBQUMzQixTQUFLLGtCQUFrQjtBQUFBLEVBQzNCO0FBQUEsRUFFUSxvQkFBb0I7QUFDeEIsU0FBSyxhQUFhLEtBQUssU0FBUyxTQUFTLFFBQVE7QUFDakQsU0FBSyxXQUFXLFdBQVcsQ0FBQyxhQUFhLGdCQUFnQixDQUFDO0FBQzFELGtDQUFRLEtBQUssWUFBWSxNQUFNO0FBQy9CLFNBQUssV0FBVyxhQUFhLGNBQWMsRUFBRSxXQUFXLENBQUM7QUFDekQsU0FBSyxXQUFXLGlCQUFpQixTQUFTLFlBQVk7QUFDbEQsV0FBSyxpQkFBaUI7QUFBQSxJQUMxQixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRVEscUJBQXFCO0FBQ3pCLFNBQUssY0FBYyxLQUFLLFNBQVMsU0FBUyxRQUFRO0FBQ2xELFNBQUssWUFBWSxXQUFXLENBQUMsYUFBYSxpQkFBaUIsQ0FBQztBQUM1RCxrQ0FBUSxLQUFLLGFBQWEsWUFBWTtBQUN0QyxTQUFLLFlBQVksYUFBYSxjQUFjLEVBQUUscUJBQXFCLENBQUM7QUFDcEUsU0FBSyxZQUFZLGlCQUFpQixTQUFTLE1BQU07QUFDN0MsV0FBSyw0QkFBbUM7QUFBQSxJQUM1QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRVEsd0JBQXdCO0FBQzVCLFNBQUssYUFBYSxLQUFLLFNBQVMsU0FBUyxRQUFRO0FBQ2pELFNBQUssV0FBVyxXQUFXLENBQUMsYUFBYSxnQkFBZ0IsQ0FBQztBQUMxRCxrQ0FBUSxLQUFLLFlBQVksTUFBTTtBQUMvQixTQUFLLFdBQVcsYUFBYSxjQUFjLGdCQUFnQjtBQUMzRCxTQUFLLFdBQVcsaUJBQWlCLFNBQVMsWUFBWTtBQUNsRCxXQUFLLDhCQUE4QjtBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFUSxvQkFBb0I7QUFDeEIsU0FBSyxhQUFhLEtBQUssU0FBUyxTQUFTLFFBQVE7QUFDakQsU0FBSyxXQUFXLFdBQVcsQ0FBQyxhQUFhLGdCQUFnQixDQUFDO0FBQzFELGtDQUFRLEtBQUssWUFBWSxnQkFBZ0I7QUFDekMsU0FBSyxXQUFXLGFBQWEsY0FBYyxFQUFFLE1BQU0sQ0FBQztBQUNwRCxTQUFLLFdBQVcsaUJBQWlCLFNBQVMsTUFBTTtBQUM1QyxXQUFLLGlCQUFpQjtBQUFBLElBQzFCLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxNQUFjLG1CQUFrQztBQUM1QyxTQUFLLGdCQUFnQixnQkFBZ0I7QUFDckMsVUFBTSxLQUFLLGNBQWM7QUFBQSxFQUM3QjtBQUFBLEVBRVEsZ0NBQWdDO0FBbFQ1QztBQW1UUSxVQUFNLFdBQVcsS0FBSyxhQUFhO0FBRW5DLFVBQU0saUJBQWlCLEVBQUUsd0JBQXdCLE1BQUssMENBQVUsZUFBVixZQUF3QixFQUFFLEtBQUs7QUFDckYsVUFBTSxxQkFDRixFQUFFLDRCQUE0QixJQUFJLGFBQWEscUNBQVUsVUFBVSxLQUFLO0FBQzVFLFVBQU0sbUJBQW1CLEVBQUUsdUJBQXVCO0FBQUEsTUFDOUMsVUFBVSxLQUFLLGlCQUFpQixLQUFLO0FBQUEsSUFDekMsQ0FBQztBQUVELFFBQUksd0JBQU8saUJBQWlCLE9BQU8scUJBQXFCLE9BQU8sZ0JBQWdCO0FBQUEsRUFDbkY7QUFBQTtBQUFBLEVBSVEscUJBQXFCO0FBQ3pCLFNBQUssY0FBYyxLQUFLLEtBQUssVUFBVTtBQUN2QyxTQUFLLFlBQVksU0FBUyxpQkFBaUI7QUFFM0MsU0FBSyxtQkFBbUIsS0FBSyxZQUFZLFVBQVU7QUFDbkQsU0FBSyxpQkFBaUIsU0FBUyx1QkFBdUI7QUFFdEQsU0FBSyxpQkFBaUIsS0FBSyxpQkFBaUIsVUFBVTtBQUN0RCxTQUFLLGVBQWUsU0FBUyxxQkFBcUI7QUFDbEQsU0FBSyxpQkFBaUIsS0FBSyxlQUFlLFVBQVU7QUFDcEQsU0FBSyxlQUFlLFNBQVMscUJBQXFCO0FBRWxELFNBQUssMkJBQTJCLEtBQUssZUFBZSxVQUFVO0FBQzlELFNBQUsseUJBQXlCLFNBQVMsZ0NBQWdDO0FBRXZFLFNBQUssMkJBQTJCLEtBQUsseUJBQXlCLFVBQVU7QUFDeEUsU0FBSyx5QkFBeUIsU0FBUyxnQ0FBZ0M7QUFFdkUsU0FBSywrQkFBK0IsS0FBSyx5QkFBeUIsVUFBVTtBQUM1RSxTQUFLLDZCQUE2QixTQUFTLHFDQUFxQztBQUVoRixTQUFLLHdCQUF3QixLQUFLLDZCQUE2QixVQUFVO0FBQ3pFLFNBQUssc0JBQXNCLFNBQVMsNkJBQTZCO0FBRWpFLFNBQUssNEJBQTRCLEtBQUssNkJBQTZCLFVBQVU7QUFDN0UsU0FBSywwQkFBMEIsU0FBUyxrQ0FBa0M7QUFDMUUsa0NBQVEsS0FBSywyQkFBMkIsYUFBYTtBQUVyRCxTQUFLLGtDQUFrQyxLQUFLLHlCQUF5QixVQUFVO0FBQy9FLFNBQUssZ0NBQWdDLFNBQVMsY0FBYztBQUM1RCxTQUFLLGdDQUFnQyxTQUFTLHdDQUF3QztBQUV0RixTQUFLLDJCQUEyQixLQUFLLGdDQUFnQyxVQUFVO0FBQy9FLFNBQUsseUJBQXlCLFNBQVMsZ0NBQWdDO0FBRXZFLFNBQUssK0JBQStCLEtBQUssZ0NBQWdDLFVBQVU7QUFDbkYsU0FBSyw2QkFBNkIsU0FBUyxxQ0FBcUM7QUFDaEYsa0NBQVEsS0FBSyw4QkFBOEIsUUFBUTtBQUVuRCxTQUFLLGtCQUFrQixLQUFLLGlCQUFpQixVQUFVO0FBQ3ZELFNBQUssZ0JBQWdCLFNBQVMsY0FBYztBQUM1QyxTQUFLLGdCQUFnQixTQUFTLHNCQUFzQjtBQUVwRCxTQUFLLGtCQUFrQixLQUFLLGdCQUFnQixVQUFVO0FBQ3RELFNBQUssZ0JBQWdCLFNBQVMsc0JBQXNCO0FBRXBELFNBQUssNEJBQTRCLEtBQUssZ0JBQWdCLFVBQVU7QUFDaEUsU0FBSywwQkFBMEIsU0FBUyxpQ0FBaUM7QUFFekUsU0FBSyw0QkFBNEIsS0FBSywwQkFBMEIsVUFBVTtBQUMxRSxTQUFLLDBCQUEwQixTQUFTLGlDQUFpQztBQUV6RSxTQUFLLGdDQUFnQyxLQUFLLDBCQUEwQixVQUFVO0FBQzlFLFNBQUssOEJBQThCLFNBQVMsc0NBQXNDO0FBRWxGLFNBQUsseUJBQXlCLEtBQUssOEJBQThCLFVBQVU7QUFDM0UsU0FBSyx1QkFBdUIsU0FBUyw4QkFBOEI7QUFDbkUsU0FBSyw2QkFBNkIsS0FBSyw4QkFBOEIsVUFBVTtBQUMvRSxTQUFLLDJCQUEyQixTQUFTLG1DQUFtQztBQUM1RSxrQ0FBUSxLQUFLLDRCQUE0QixhQUFhO0FBRXRELFFBQUksS0FBSyxTQUFTLG9CQUFvQjtBQUNsQyxXQUFLLGNBQWMsS0FBSyxZQUFZLFVBQVU7QUFDOUMsV0FBSyxZQUFZLFNBQVMsWUFBWTtBQUFBLElBQzFDO0FBQUEsRUFDSjtBQUFBLEVBRVEsZUFBZSxZQUFrQixhQUFtQjtBQUN4RCxTQUFLLHNCQUFzQixVQUFVO0FBQ3JDLFNBQUssdUJBQXVCLFlBQVksV0FBVztBQUNuRCxTQUFLLG1CQUFtQjtBQUFBLEVBQzVCO0FBQUEsRUFFUSxzQkFBc0IsWUFBa0I7QUFDNUMsVUFBTSxrQkFBa0IsS0FBSyxnQkFBZ0IsYUFBYSxXQUFXLGFBQWEsQ0FBQztBQUVuRixTQUFLLGVBQWUsUUFBUSxHQUFHLFdBQVcsUUFBUSxFQUFFO0FBQ3BELFNBQUssc0JBQXNCO0FBQUEsTUFDdkIsR0FBRyxLQUFLLHNCQUFzQixnQkFBZ0IsaUJBQWlCLElBQUksS0FBSyxtQkFBbUI7QUFBQSxJQUMvRjtBQUVBLFFBQUksV0FBVyxTQUFTLFdBQVcsR0FBRztBQUNsQyxVQUFJLENBQUMsS0FBSyxnQ0FBZ0MsU0FBUyxjQUFjLEdBQUc7QUFDaEUsYUFBSyxnQ0FBZ0MsU0FBUyxjQUFjO0FBQUEsTUFDaEU7QUFDQTtBQUFBLElBQ0o7QUFFQSxRQUFJLEtBQUssZ0NBQWdDLFNBQVMsY0FBYyxHQUFHO0FBQy9ELFdBQUssZ0NBQWdDLFlBQVksY0FBYztBQUFBLElBQ25FO0FBRUEsU0FBSyx5QkFBeUI7QUFBQSxNQUMxQixHQUFHLEtBQUssc0JBQXNCLGdCQUFnQiwyQkFBMkIsSUFBSSxLQUFLLG1CQUFtQjtBQUFBLElBQ3pHO0FBQUEsRUFDSjtBQUFBLEVBRVEsdUJBQXVCLFlBQWtCLGFBQW1CO0FBQ2hFLFFBQUksV0FBVyxTQUFTLFdBQVcsR0FBRztBQUNsQyxVQUFJLENBQUMsS0FBSyxnQkFBZ0IsU0FBUyxjQUFjLEdBQUc7QUFDaEQsYUFBSyxnQkFBZ0IsU0FBUyxjQUFjO0FBQUEsTUFDaEQ7QUFDQTtBQUFBLElBQ0o7QUFFQSxRQUFJLEtBQUssZ0JBQWdCLFNBQVMsY0FBYyxHQUFHO0FBQy9DLFdBQUssZ0JBQWdCLFlBQVksY0FBYztBQUFBLElBQ25EO0FBRUEsU0FBSyxnQkFBZ0IsUUFBUSxHQUFHLFlBQVksUUFBUSxFQUFFO0FBRXRELFVBQU0sZUFBZSxLQUFLLFNBQVMsdUJBQXVCO0FBQzFELFFBQUksQ0FBQyxjQUFjO0FBQ2YsWUFBTSxtQkFBbUIsS0FBSyxnQkFBZ0IsYUFBYSxZQUFZLGFBQWEsQ0FBQztBQUNyRixXQUFLLHVCQUF1QjtBQUFBLFFBQ3hCLEdBQUcsS0FBSywrQkFBK0IsaUJBQWlCLDJCQUEyQixJQUFJLEtBQUssNEJBQTRCO0FBQUEsTUFDNUg7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRVEscUJBQXFCO0FBQ3pCLFFBQUksQ0FBQyxLQUFLLFlBQWE7QUFDdkIsUUFBSSxDQUFDLEtBQUssU0FBUyxvQkFBb0I7QUFDbkMsV0FBSyxZQUFZLFFBQVEsRUFBRTtBQUMzQjtBQUFBLElBQ0o7QUFDQSxTQUFLLFlBQVk7QUFBQSxNQUNiLElBQUksS0FBSywyQkFBMkIsS0FBSyxpQkFBaUIsZUFBZSxDQUFDO0FBQUEsSUFDOUU7QUFBQSxFQUNKO0FBQUEsRUFFUSwyQkFBMkIsaUJBQW1DO0FBQ2xFLFVBQU0sWUFBb0I7QUFDMUIsUUFBSSxTQUFTLEtBQUssYUFBYSxLQUFLO0FBQ3BDLG9CQUFnQixRQUFRLENBQUMsWUFBWTtBQUVqQyxVQUFJLFFBQVEsV0FBVyxJQUFJLEtBQUssUUFBUSxTQUFTLElBQUksR0FBRztBQUNwRCxrQkFBVSxRQUFRLFFBQVEsTUFBTSxFQUFFLEVBQUUsUUFBUSxNQUFNLEVBQUU7QUFFcEQsWUFBSSxRQUFRLFNBQVMsR0FBRyxHQUFHO0FBQ3ZCLG9CQUFVLFFBQVEsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUFBLFFBQ2xDO0FBQUEsTUFDSjtBQUNBLGdCQUFVLFlBQVk7QUFBQSxJQUMxQixDQUFDO0FBQ0QsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBLEVBSVEseUJBQXlCO0FBQzdCLFNBQUssd0JBQXdCO0FBQzdCLFNBQUssa0JBQWtCO0FBQ3ZCLFNBQUssa0JBQWtCO0FBQ3ZCLFNBQUssa0JBQWtCO0FBQUEsRUFDM0I7QUFBQSxFQUVRLHdCQUF3QjtBQUU1QixTQUFLLGFBQWEsWUFBWSxjQUFjO0FBQzVDLFNBQUssV0FBVyxTQUFTLGNBQWM7QUFDdkMsU0FBSyxXQUFXLFNBQVMsY0FBYztBQUN2QyxTQUFLLFdBQVcsU0FBUyxjQUFjO0FBQUEsRUFDM0M7QUFBQSxFQUVRLDBCQUEwQjtBQUM5QixTQUFLLGVBQWUsS0FBSyxTQUFTLFNBQVMsUUFBUTtBQUNuRCxTQUFLLGFBQWEsV0FBVyxDQUFDLHNCQUFzQix5QkFBeUIsWUFBWSxDQUFDO0FBQzFGLFNBQUssYUFBYSxRQUFRLEVBQUUsYUFBYSxDQUFDO0FBQzFDLFNBQUssYUFBYSxpQkFBaUIsU0FBUyxNQUFNO0FBQzlDLFdBQUssWUFBWTtBQUFBLElBQ3JCLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFUSxvQkFBb0I7QUFDeEIsU0FBSyxhQUFhLEtBQUssU0FBUyxTQUFTLFFBQVE7QUFDakQsU0FBSyxXQUFXLFdBQVc7QUFBQSxNQUN2QjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0osQ0FBQztBQUNELFNBQUssV0FBVyxRQUFRLEtBQUssU0FBUyxpQkFBaUI7QUFDdkQsU0FBSyxXQUFXLGlCQUFpQixTQUFTLE1BQU07QUFDNUMsV0FBSywyQkFBa0M7QUFBQSxJQUMzQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRVEsb0JBQW9CO0FBQ3hCLFNBQUssYUFBYSxLQUFLLFNBQVMsU0FBUyxRQUFRO0FBQ2pELFNBQUssV0FBVyxXQUFXO0FBQUEsTUFDdkI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNKLENBQUM7QUFDRCxTQUFLLFdBQVcsUUFBUSxLQUFLLFNBQVMsaUJBQWlCO0FBQ3ZELFNBQUssV0FBVyxpQkFBaUIsU0FBUyxNQUFNO0FBQzVDLFdBQUssMkJBQWtDO0FBQUEsSUFDM0MsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVRLG9CQUFvQjtBQUN4QixTQUFLLGFBQWEsS0FBSyxTQUFTLFNBQVMsUUFBUTtBQUNqRCxTQUFLLFdBQVcsV0FBVztBQUFBLE1BQ3ZCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDO0FBQ0QsU0FBSyxXQUFXLFFBQVEsS0FBSyxTQUFTLGlCQUFpQjtBQUN2RCxTQUFLLFdBQVcsaUJBQWlCLFNBQVMsTUFBTTtBQUM1QyxXQUFLLDJCQUFrQztBQUFBLElBQzNDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFUSxpQkFDSixRQUNBLFlBQ0EsZ0JBQ0Y7QUFDRSxVQUFNLFdBQWdDLEtBQUssZ0JBQWdCO0FBQUEsTUFDdkQ7QUFBQSxNQUNBLEtBQUs7QUFBQSxJQUNUO0FBQ0EsVUFBTSxXQUFtQixTQUFTO0FBRWxDLFFBQUksS0FBSyxTQUFTLDZCQUE2QjtBQUMzQyxVQUFJLDBCQUFTLFVBQVU7QUFDbkIsZUFBTyxRQUFRLGFBQWEsVUFBVSxJQUFJLENBQUM7QUFBQSxNQUMvQyxPQUFPO0FBQ0gsZUFBTyxRQUFRLEdBQUcsVUFBVSxNQUFNLGFBQWEsVUFBVSxLQUFLLENBQUMsRUFBRTtBQUFBLE1BQ3JFO0FBQUEsSUFDSixPQUFPO0FBQ0gsYUFBTyxRQUFRLFVBQVU7QUFBQSxJQUM3QjtBQUFBLEVBQ0o7QUFBQSxFQUVRLGNBQW9CO0FBQ3hCLFVBQU0sY0FBVSxvQkFBSTtBQUNwQixRQUNJLEtBQUssZUFDTCxVQUFVLEtBQUssY0FBYyxLQUFLLE9BQU8sS0FBSyxTQUFTLG1CQUN6RDtBQUNFO0FBQUEsSUFDSjtBQUNBLFNBQUssY0FBYztBQUVuQixTQUFLO0FBRUwsU0FBSyxZQUFZLFdBQVc7QUFHNUIsUUFBSSxLQUFLLGlCQUFpQixnQ0FBaUM7QUFDdkQsWUFBTSxLQUFrQixTQUFTLGNBQWMsSUFBSTtBQUNuRCxXQUFLLFFBQVEsWUFBWSxFQUFFO0FBQUEsSUFDL0IsT0FBTztBQUNILFdBQUssUUFBUSxNQUFNO0FBQUEsSUFDdkI7QUFFQSxVQUFNLFVBQWlDLElBQUk7QUFBQSxNQUN2QyxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLLGFBQWE7QUFBQSxJQUN0QjtBQUNBLFlBQVE7QUFBQSxNQUNKLEtBQUssYUFBYTtBQUFBLE1BQ2xCLEtBQUs7QUFBQSxNQUNMLEtBQUssaUJBQWlCLGFBQWE7QUFBQSxJQUN2QztBQUdBLFNBQUssYUFBYSxTQUFTLGNBQWM7QUFDekMsU0FBSyxXQUFXLFlBQVksY0FBYztBQUMxQyxTQUFLLFdBQVcsWUFBWSxjQUFjO0FBRTFDLFFBQUksS0FBSyw2QkFBeUM7QUFDOUMsV0FBSyxTQUFTLFNBQVMsU0FBUztBQUNoQyxXQUFLLFdBQVcsUUFBUSxHQUFHLEtBQUssU0FBUyxpQkFBaUIsRUFBRTtBQUM1RCxXQUFLLFdBQVcsUUFBUSxHQUFHLEtBQUssU0FBUyxpQkFBaUIsRUFBRTtBQUFBLElBQ2hFLE9BQU87QUFDSCxXQUFLLFdBQVcsWUFBWSxjQUFjO0FBQzFDLFdBQUs7QUFBQSxRQUNELEtBQUs7QUFBQSxRQUNMLEtBQUssU0FBUztBQUFBO0FBQUEsTUFFbEI7QUFDQSxXQUFLO0FBQUEsUUFDRCxLQUFLO0FBQUEsUUFDTCxLQUFLLFNBQVM7QUFBQTtBQUFBLE1BRWxCO0FBQ0EsV0FBSztBQUFBLFFBQ0QsS0FBSztBQUFBLFFBQ0wsS0FBSyxTQUFTO0FBQUE7QUFBQSxNQUVsQjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBMkVKOzs7QUVyckJBLElBQUFDLGdCQUFjO0FBY1AsSUFBTSxTQUFOLE1BQWE7QUFBQSxFQWdCaEIsWUFDSSxRQUNBLFVBQ0EsaUJBQ0EsTUFDQSxtQkFDRjtBQUVFLFNBQUssU0FBUztBQUNkLFNBQUssV0FBVztBQUNoQixTQUFLLGtCQUFrQjtBQUN2QixTQUFLLE9BQU87QUFDWixTQUFLLG9CQUFvQjtBQUd6QixTQUFLLEtBQUs7QUFBQSxFQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFhO0FBQ1QsU0FBSyxLQUFLLFdBQVcsQ0FBQyxnQkFBZ0IsY0FBYyxDQUFDO0FBRXJELFNBQUssU0FBUyxLQUFLLEtBQUssVUFBVTtBQUNsQyxTQUFLLE9BQU8sU0FBUyxXQUFXO0FBRWhDLFNBQUssUUFBUSxLQUFLLE9BQU8sVUFBVTtBQUNuQyxTQUFLLE1BQU0sU0FBUyxVQUFVO0FBQzlCLFNBQUssTUFBTSxRQUFRLEVBQUUsT0FBTyxDQUFDO0FBRTdCLFNBQUssUUFBUSxLQUFLLE9BQU8sVUFBVTtBQUNuQyxTQUFLLE1BQU0sU0FBUywyQkFBMkI7QUFDL0MsU0FBSyxtQkFBbUI7QUFFeEIsU0FBSyxnQkFBZ0IsS0FBSyxLQUFLLFNBQVMsSUFBSTtBQUU1QyxTQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVU7QUFDbkMsU0FBSyxRQUFRLFNBQVMsWUFBWTtBQUFBLEVBQ3RDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFhO0FBQ1QsU0FBSztBQUdMLFNBQUssbUJBQW1CO0FBRXhCLFNBQUssUUFBUSxNQUFNO0FBQ25CLGVBQVcsUUFBUSxLQUFLLGdCQUFnQixpQkFBaUIsVUFBVTtBQUMvRCxXQUFLLFlBQVksTUFBTSxLQUFLLE9BQU87QUFBQSxJQUN2QztBQUVBLFFBQUksS0FBSyxLQUFLLFNBQVMsY0FBYyxHQUFHO0FBQ3BDLFdBQUssS0FBSyxZQUFZLGNBQWM7QUFBQSxJQUN4QztBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE9BQU87QUFDSCxRQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsY0FBYyxHQUFHO0FBQ3JDLFdBQUssS0FBSyxTQUFTLGNBQWM7QUFBQSxJQUNyQztBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFFBQVE7QUFDSixTQUFLLEtBQUs7QUFBQSxFQUNkO0FBQUE7QUFBQSxFQUlRLHFCQUFxQjtBQUN6QixVQUFNLGFBQXdCLEtBQUssZ0JBQWdCLGFBQWEsVUFBVSxTQUFTO0FBQ25GLFNBQUssTUFBTSxNQUFNO0FBRWpCLFNBQUssNEJBQTRCLEVBQUUsV0FBVyxHQUFHLFdBQVcsVUFBVSxhQUFhO0FBQ25GLFNBQUssNEJBQTRCLEVBQUUsV0FBVyxHQUFHLFdBQVcsVUFBVSxZQUFZO0FBQ2xGLFNBQUssNEJBQTRCLEVBQUUsYUFBYSxHQUFHLFdBQVcsWUFBWSxXQUFXO0FBQUEsRUFDekY7QUFBQSxFQUVRLDRCQUNKLFlBQ0EsYUFDQSxZQUNJO0FBQ0osVUFBTSxpQkFBaUIsS0FBSyxNQUFNLFVBQVU7QUFDNUMsbUJBQWUsWUFBWTtBQUMzQixtQkFBZSxXQUFXO0FBQUEsTUFDdEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNKLENBQUM7QUFFRCxVQUFNLFFBQVEsZUFBZSxVQUFVO0FBQ3ZDLFVBQU0sUUFBUSxhQUFhLEdBQUc7QUFFOUIsVUFBTSxTQUFTLGVBQWUsVUFBVTtBQUN4QyxXQUFPLFFBQVEsWUFBWSxTQUFTLENBQUM7QUFBQSxFQUN6QztBQUFBO0FBQUEsRUFJUSxZQUFZLE1BQVksV0FBOEI7QUFDMUQsVUFBTSxXQUF3QixVQUFVLFVBQVUsa0NBQWtDO0FBQ3BGLFVBQU0sZUFBNEIsU0FBUztBQUFBLE1BQ3ZDO0FBQUEsSUFDSjtBQUVBLFVBQU0sNEJBQXFDLEtBQUssU0FBUztBQUN6RCxRQUFJLFlBQVksQ0FBQztBQUNqQixRQUFJLGlCQUFxQztBQUN6QyxRQUFJLEtBQUssU0FBUyxTQUFTLEdBQUc7QUFDMUIsdUJBQWlCLGFBQWEsVUFBVSw4QkFBOEI7QUFDdEUscUJBQWUsWUFBWTtBQUMzQixNQUFDLGVBQWUsV0FBVyxDQUFDLEVBQWtCLE1BQU0sWUFBWSxZQUMxRCxtQkFDQTtBQUFBLElBQ1Y7QUFFQSxVQUFNLGdCQUE2QixhQUFhLFVBQVUsaUJBQWlCO0FBQzNFLFVBQU0sb0JBQWlDLGNBQWMsVUFBVSxtQkFBbUI7QUFDbEYsc0JBQWtCLGFBQWEsa0NBQUFDLFNBQUMsVUFBSyxPQUFNLHVCQUFxQixLQUFLLFFBQVM7QUFFOUUsVUFBTSxnQkFBZ0MsYUFBYSxVQUFVO0FBQzdELGtCQUFjLFdBQVcsQ0FBQyx5QkFBeUIseUJBQXlCLENBQUM7QUFFN0UsVUFBTSxZQUFZLEtBQUssZ0JBQWdCLGFBQWEsS0FBSyxhQUFhLENBQUM7QUFDdkUsU0FBSyxhQUFhLFdBQVcsYUFBYTtBQUUxQyxVQUFNLG1CQUFnQyxTQUFTLFVBQVUsb0JBQW9CO0FBQzdFLHFCQUFpQixNQUFNLFVBQVUsWUFBWSxTQUFTO0FBQ3RELFFBQUksS0FBSyxTQUFTLFNBQVMsR0FBRztBQUMxQixxQkFBZSxpQkFBaUIsU0FBUyxDQUFDQyxPQUFNO0FBQzVDLFlBQUksV0FBVztBQUNYLFVBQUMsZUFBZSxXQUFXLENBQUMsRUFBa0IsTUFBTSxZQUFZO0FBQ2hFLDJCQUFpQixNQUFNLFVBQVU7QUFBQSxRQUNyQyxPQUFPO0FBQ0gsVUFBQyxlQUFlLFdBQVcsQ0FBQyxFQUFrQixNQUFNLFlBQ2hEO0FBQ0osMkJBQWlCLE1BQU0sVUFBVTtBQUFBLFFBQ3JDO0FBSUEsUUFBQUEsR0FBRSxnQkFBZ0I7QUFDbEIsb0JBQVksQ0FBQztBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNMO0FBS0EsaUJBQWEsaUJBQWlCLFNBQVMsTUFBTTtBQUN6QyxXQUFLLGtCQUFrQixJQUFJO0FBQUEsSUFDL0IsQ0FBQztBQUVELGVBQVcsV0FBVyxLQUFLLFVBQVU7QUFDakMsV0FBSyxZQUFZLFNBQVMsZ0JBQWdCO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQUEsRUFFUSxhQUFhLFlBQXVCLGNBQThCO0FBQ3RFLGlCQUFhLE1BQU07QUFFbkIsU0FBSztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsTUFDYixXQUFXO0FBQUEsTUFDWDtBQUFBLE1BQ0E7QUFBQSxJQUNKO0FBQ0EsU0FBSyxzQkFBc0IsRUFBRSxXQUFXLEdBQUcsV0FBVyxVQUFVLGNBQWMsWUFBWTtBQUMxRixTQUFLO0FBQUEsTUFDRCxFQUFFLGFBQWE7QUFBQSxNQUNmLFdBQVc7QUFBQSxNQUNYO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFUSxzQkFDSixZQUNBLGFBQ0EsWUFDQSxjQUNJO0FBQ0osVUFBTSxpQkFBaUIsYUFBYSxVQUFVO0FBRTlDLG1CQUFlLFlBQVk7QUFFM0IsbUJBQWUsV0FBVztBQUFBLE1BQ3RCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDO0FBRUQsbUJBQWUsUUFBUSxZQUFZLFNBQVMsQ0FBQztBQUFBLEVBQ2pEO0FBQ0o7OztBQzdPQSxJQUFBQyxtQkFBMkI7QUFNcEIsSUFBTSxxQkFBTixNQUFNLDRCQUEyQix1QkFBTTtBQUFBLEVBMEIxQyxZQUFZLEtBQVUsY0FBc0IsZUFBOEI7QUFDdEUsVUFBTSxHQUFHO0FBZGIsU0FBUSxpQkFBaUI7QUEwRXpCO0FBQUEsU0FBUSxvQkFBb0IsQ0FBQ0MsT0FBa0IsS0FBSyxLQUFLO0FBRXpELFNBQVEsc0JBQXNCLENBQUNBLE9BQWtCLEtBQUssT0FBTztBQUU3RCxTQUFRLHNCQUFzQixDQUFDLFFBQXVCO0FBQ2xELFdBQUssSUFBSSxXQUFXLElBQUksWUFBWSxJQUFJLFFBQVEsU0FBUztBQUNyRCxZQUFJLGVBQWU7QUFDbkIsYUFBSyxLQUFLO0FBQUEsTUFDZDtBQUFBLElBQ0o7QUFuRUksU0FBSyxZQUFZO0FBQ2pCLFNBQUssY0FBYztBQUNuQixTQUFLLGdCQUFnQjtBQUVyQixTQUFLLGVBQWUsSUFBSSxRQUFnQixDQUFDQyxVQUFTLFdBQVc7QUFDekQsV0FBSyxpQkFBaUJBO0FBQ3RCLFdBQUssZ0JBQWdCO0FBQUEsSUFDekIsQ0FBQztBQUdELFNBQUssUUFBUSxXQUFXLENBQUMsWUFBWSxlQUFlLENBQUM7QUFDckQsU0FBSyxLQUFLO0FBRVYsU0FBSyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBMUJBLE9BQWMsT0FDVixLQUNBLGFBQ0EsZUFDZTtBQUNmLFVBQU0saUJBQWlCLElBQUksb0JBQW1CLEtBQUssYUFBYSxhQUFhO0FBQzdFLFdBQU8sZUFBZTtBQUFBLEVBQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUF3QkEsT0FBTztBQXREWDtBQXVEUSxTQUFLLFVBQVUsTUFBTTtBQUNyQixTQUFLLFVBQVUsU0FBUyxjQUFjO0FBRXRDLFNBQUssUUFBUSxLQUFLLFVBQVUsVUFBVTtBQUN0QyxTQUFLLE1BQU0sUUFBUSxFQUFFLFdBQVcsQ0FBQztBQUNqQyxTQUFLLE1BQU0sU0FBUyxVQUFVO0FBRTlCLFNBQUssV0FBVyxLQUFLLFVBQVUsU0FBUyxVQUFVO0FBQ2xELFNBQUssU0FBUyxTQUFTLFVBQVU7QUFDakMsU0FBSyxTQUFTLFNBQVEsVUFBSyxjQUFMLFlBQWtCLEVBQUU7QUFDMUMsU0FBSyxTQUFTLGlCQUFpQixXQUFXLEtBQUssbUJBQW1CO0FBQ2xFLFFBQUksS0FBSyw4QkFBb0M7QUFDekMsV0FBSyxTQUFTLGFBQWEsT0FBTyxLQUFLO0FBQUEsSUFDM0M7QUFFQSxTQUFLLGdCQUFnQixLQUFLLFNBQVM7QUFBQSxFQUN2QztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsU0FBUztBQUNMLFVBQU0sT0FBTztBQUViLFNBQUssU0FBUyxNQUFNO0FBQUEsRUFDeEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFVBQVU7QUFDTixVQUFNLFFBQVE7QUFDZCxTQUFLLGFBQWE7QUFDbEIsU0FBSyxvQkFBb0I7QUFBQSxFQUM3QjtBQUFBLEVBZVEsT0FBTztBQUNYLFNBQUssaUJBQWlCO0FBQ3RCLFNBQUssY0FBYyxLQUFLLFNBQVM7QUFDakMsU0FBSyxNQUFNO0FBQUEsRUFDZjtBQUFBLEVBRVEsU0FBUztBQUNiLFNBQUssTUFBTTtBQUFBLEVBQ2Y7QUFBQSxFQUVRLGVBQWU7QUFDbkIsUUFBSSxDQUFDLEtBQUssZUFBZ0IsTUFBSyxjQUFjLEVBQUUsVUFBVSxDQUFDO0FBQUEsUUFDckQsTUFBSyxlQUFlLEtBQUssV0FBVztBQUFBLEVBQzdDO0FBQUEsRUFFUSxzQkFBc0I7QUFDMUIsU0FBSyxTQUFTLG9CQUFvQixXQUFXLEtBQUssbUJBQW1CO0FBQUEsRUFDekU7QUFBQTtBQUFBLEVBSVEsc0JBQ0osV0FDQSxNQUNBLFlBQ0FDLFdBQ0Y7QUFDRSxVQUFNLFNBQVMsVUFBVSxTQUFTLFFBQVE7QUFDMUMsV0FBTyxXQUFXLENBQUMsc0JBQXNCLFVBQVUsQ0FBQztBQUNwRCxXQUFPLFFBQVEsSUFBSTtBQUNuQixXQUFPLGlCQUFpQixTQUFTQSxTQUFRO0FBQUEsRUFDN0M7QUFBQSxFQUVRLGdCQUFnQixzQkFBbUM7QUFDdkQsVUFBTSxXQUEyQixxQkFBcUIsVUFBVTtBQUNoRSxhQUFTLFNBQVMsYUFBYTtBQUMvQixTQUFLLHNCQUFzQixVQUFVLEVBQUUsUUFBUSxHQUFHLGFBQWEsS0FBSyxtQkFBbUI7QUFDdkYsU0FBSyxzQkFBc0IsVUFBVSxJQUFJLGFBQWEsTUFBTTtBQUFBLElBQUMsQ0FBQztBQUM5RCxTQUFLLHNCQUFzQixVQUFVLEVBQUUsTUFBTSxHQUFHLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxFQUN6RjtBQUNKOzs7QUoxSE8sSUFBTSxpQkFBTixjQUE2Qix3QkFBTTtBQUFBLEVBVXRDLFlBQ0ksS0FDQSxRQUNBLFVBQ0EsaUJBQ0EsWUFDRjtBQUNFLFVBQU0sR0FBRztBQUdULFNBQUssU0FBUztBQUNkLFNBQUssV0FBVztBQUNoQixTQUFLLGtCQUFrQjtBQUN2QixTQUFLLGFBQWE7QUFHbEIsU0FBSyxRQUFRLE1BQU0sU0FBUyxLQUFLLFNBQVMsNEJBQTRCO0FBQ3RFLFNBQUssUUFBUSxNQUFNLFlBQVksS0FBSyxTQUFTLDRCQUE0QjtBQUN6RSxTQUFLLFFBQVEsTUFBTSxRQUFRLEtBQUssU0FBUywyQkFBMkI7QUFDcEUsU0FBSyxRQUFRLE1BQU0sV0FBVyxLQUFLLFNBQVMsMkJBQTJCO0FBQ3ZFLFNBQUssUUFBUSxhQUFhLE1BQU0sVUFBVTtBQUUxQyxRQUNJLEtBQUssU0FBUyw2QkFBNkIsT0FDM0MsS0FBSyxTQUFTLDRCQUE0QixLQUM1QztBQUNFLFdBQUssUUFBUSxNQUFNLGVBQWU7QUFBQSxJQUN0QztBQUVBLFNBQUssVUFBVSxTQUFTLGtCQUFrQjtBQUcxQyxTQUFLLFdBQVcsSUFBSTtBQUFBLE1BQ2hCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUssVUFBVSxVQUFVO0FBQUEsTUFDekIsS0FBSyxtQkFBbUIsS0FBSyxJQUFJO0FBQUEsSUFDckM7QUFFQSxTQUFLLGdCQUFnQixJQUFJO0FBQUEsTUFDckIsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSyxVQUFVLFVBQVU7QUFBQSxNQUN6QixLQUFLLGVBQWUsS0FBSyxJQUFJO0FBQUEsTUFDN0IsS0FBSyxvQkFBb0IsS0FBSyxJQUFJO0FBQUEsSUFDdEM7QUFBQSxFQUNKO0FBQUEsRUFFQSxTQUFlO0FBQ1gsU0FBSyxrQkFBa0I7QUFDdkIsU0FBSyxlQUFlO0FBQUEsRUFDeEI7QUFBQSxFQUVBLFVBQWdCO0FBQ1osU0FBSyxPQUFPLGlCQUFpQixLQUFLO0FBQ2xDLFNBQUssT0FBTztBQUNaLFNBQUssU0FBUyxNQUFNO0FBQ3BCLFNBQUssY0FBYyxNQUFNO0FBQUEsRUFDN0I7QUFBQSxFQUVRLGlCQUF1QjtBQUMzQixTQUFLLGVBQWU7QUFDcEIsU0FBSyxTQUFTLEtBQUs7QUFBQSxFQUN2QjtBQUFBLEVBRVEsaUJBQXVCO0FBQzNCLFNBQUssU0FBUyxLQUFLO0FBQUEsRUFDdkI7QUFBQSxFQUVRLGVBQWUsTUFBa0I7QUFDckMsU0FBSyxlQUFlO0FBQ3BCLFNBQUssY0FBYyxLQUFLLElBQUk7QUFBQSxFQUNoQztBQUFBLEVBRVEsaUJBQXVCO0FBQzNCLFNBQUssY0FBYyxLQUFLO0FBQUEsRUFDNUI7QUFBQSxFQUVRLG1CQUFtQixNQUFZO0FBQ25DLFNBQUssZ0JBQWdCLGVBQWUsS0FBSyxhQUFhLENBQUM7QUFDdkQsUUFBSSxLQUFLLGdCQUFnQixnQkFBZ0I7QUFDckMsV0FBSyxlQUFlLElBQUk7QUFDeEIsV0FBSyxXQUFXLFlBQVksY0FBYztBQUFBLElBQzlDLE9BQU87QUFDSCxXQUFLLGVBQWU7QUFBQSxJQUN4QjtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQWMsc0JBQXFDO0FBQy9DLFVBQU0sV0FBcUIsS0FBSyxnQkFBZ0I7QUFHaEQsVUFBTSxhQUFhLFNBQVMsYUFBYTtBQUV6QyxVQUFNLFlBQVksbUJBQW1CO0FBQUEsTUFDakMsS0FBSztBQUFBLE1BQ0w7QUFBQSxNQUNBLFNBQVMsYUFBYTtBQUFBLElBQzFCO0FBQ0EsY0FDSyxLQUFLLE9BQU8scUJBQXFCO0FBQzlCLFdBQUssZ0JBQWdCLDBCQUEwQixnQkFBZ0I7QUFBQSxJQUNuRSxDQUFDLEVBQ0EsTUFBTSxDQUFDLFdBQVcsUUFBUSxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQzlDO0FBQUEsRUFFUSxvQkFBb0I7QUFDeEIsU0FBSyxhQUFhLEtBQUssUUFBUSxVQUFVO0FBQ3pDLFNBQUssV0FBVyxXQUFXLENBQUMsa0JBQWtCLGNBQWMsQ0FBQztBQUM3RCxtQ0FBUSxLQUFLLFlBQVksWUFBWTtBQUNyQyxTQUFLLFdBQVcsYUFBYSxjQUFjLEVBQUUsTUFBTSxDQUFDO0FBQ3BELFNBQUssV0FBVyxpQkFBaUIsU0FBUyxNQUFNO0FBQzVDLFdBQUssV0FBVyxTQUFTLGNBQWM7QUFDdkMsV0FBSyxlQUFlO0FBQUEsSUFDeEIsQ0FBQztBQUFBLEVBQ0w7QUFDSjs7O0FLeEpBLElBQUFDLG9CQUFpRDtBQTRCMUMsSUFBTSxZQUFOLGNBQXdCLDJCQUFTO0FBQUEsRUFpQnBDLFlBQ0ksTUFDQSxRQUNBLHlCQUlGO0FBQ0UsVUFBTSxJQUFJO0FBWGQsU0FBUSxpQkFBeUI7QUFZN0IsU0FBSyxTQUFTO0FBQ2QsU0FBSyxXQUFXLE9BQU8sS0FBSztBQUM1QixTQUFLLDBCQUEwQjtBQUUvQixVQUFNLGNBQWMsS0FBSyxZQUFZLHVCQUF1QixjQUFjO0FBQzFFLFFBQUksWUFBWSxTQUFTLEdBQUc7QUFDeEIsV0FBSyxrQkFBa0IsWUFBWSxDQUFDO0FBQ3BDLFdBQUssZ0JBQWdCLFNBQVMsYUFBYTtBQUUzQyxXQUFLLGdCQUFnQixLQUFLLGdCQUFnQixVQUFVLHFCQUFxQjtBQUV6RSxXQUFLLGNBQWMsTUFBTSxTQUFTLEtBQUssU0FBUyw0QkFBNEI7QUFDNUUsV0FBSyxjQUFjLE1BQU0sWUFBWSxLQUFLLFNBQVMsNEJBQTRCO0FBQy9FLFdBQUssY0FBYyxNQUFNLFFBQVEsS0FBSyxTQUFTLDJCQUEyQjtBQUMxRSxXQUFLLGNBQWMsTUFBTSxXQUFXLEtBQUssU0FBUywyQkFBMkI7QUFFN0UsV0FBSyxnQkFBZ0IsWUFBWSxLQUFLLGFBQWE7QUFBQSxJQUN2RDtBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxjQUFjO0FBQ1YsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxVQUFVO0FBQ04sV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxpQkFBaUI7QUFDYixXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE1BQU0sU0FBUztBQUNYLFFBQUk7QUFDQSxXQUFLLGtCQUFrQjtBQUN2QixZQUFNLGFBQWEsTUFBTSxLQUFLLHdCQUF3QjtBQUV0RCxXQUFLLGtCQUFrQixXQUFXO0FBQ2xDLFdBQUssYUFBYSxXQUFXO0FBRTdCLFVBQUksS0FBSyxhQUFhLFFBQVc7QUFFN0IsYUFBSyxXQUFXLElBQUk7QUFBQSxVQUNoQixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxLQUFLLGNBQWMsVUFBVTtBQUFBLFVBQzdCLEtBQUssbUJBQW1CLEtBQUssSUFBSTtBQUFBLFFBQ3JDO0FBQUEsTUFDSjtBQUVBLFVBQUksS0FBSyxrQkFBa0IsUUFBVztBQUNsQyxhQUFLLGdCQUFnQixJQUFJO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSyxjQUFjLFVBQVU7QUFBQSxVQUM3QixLQUFLLGVBQWUsS0FBSyxJQUFJO0FBQUEsVUFDN0IsS0FBSyxvQkFBb0IsS0FBSyxJQUFJO0FBQUEsUUFDdEM7QUFBQSxNQUNKO0FBRUEsV0FBSyxlQUFlO0FBQUEsSUFDeEIsU0FBU0MsSUFBRztBQVNSLFVBQUksS0FBSyxpQkFBaUIsR0FBRztBQUN6QixnQkFBUSxNQUFNQSxFQUFDO0FBQUEsTUFDbkI7QUFDQSxXQUFLO0FBQUEsSUFDVDtBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsTUFBTSxVQUFVO0FBQ1osUUFBSSxLQUFLLFNBQVUsTUFBSyxTQUFTLE1BQU07QUFDdkMsUUFBSSxLQUFLLGNBQWUsTUFBSyxjQUFjLE1BQU07QUFBQSxFQUNyRDtBQUFBLEVBRVEsaUJBQXVCO0FBQzNCLFNBQUssZUFBZTtBQUNwQixTQUFLLFNBQVMsS0FBSztBQUFBLEVBQ3ZCO0FBQUEsRUFFUSxpQkFBdUI7QUFDM0IsU0FBSyxTQUFTLEtBQUs7QUFBQSxFQUN2QjtBQUFBLEVBRVEsZUFBZSxNQUFrQjtBQUNyQyxTQUFLLGVBQWU7QUFDcEIsU0FBSyxjQUFjLEtBQUssSUFBSTtBQUFBLEVBQ2hDO0FBQUEsRUFFUSxpQkFBdUI7QUFDM0IsU0FBSyxjQUFjLEtBQUs7QUFBQSxFQUM1QjtBQUFBLEVBRVEsbUJBQW1CLE1BQVk7QUFDbkMsU0FBSyxnQkFBZ0IsZUFBZSxLQUFLLGFBQWEsQ0FBQztBQUN2RCxRQUFJLEtBQUssZ0JBQWdCLGdCQUFnQjtBQUNyQyxXQUFLLFdBQVcsWUFBWSxjQUFjO0FBQzFDLFdBQUssZUFBZSxJQUFJO0FBQUEsSUFDNUIsT0FBTztBQUNILFdBQUssZUFBZTtBQUFBLElBQ3hCO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBYyxzQkFBcUM7QUFDL0MsVUFBTSxXQUFxQixLQUFLLGdCQUFnQjtBQUdoRCxVQUFNLGFBQWEsU0FBUyxhQUFhO0FBRXpDLFVBQU0sWUFBWSxtQkFBbUI7QUFBQSxNQUNqQyxLQUFLO0FBQUEsTUFDTDtBQUFBLE1BQ0EsU0FBUyxhQUFhO0FBQUEsSUFDMUI7QUFDQSxjQUNLLEtBQUssT0FBTyxxQkFBcUI7QUFDOUIsV0FBSyxnQkFBZ0IsMEJBQTBCLGdCQUFnQjtBQUFBLElBQ25FLENBQUMsRUFDQSxNQUFNLENBQUMsV0FBVyxRQUFRLElBQUksTUFBTSxDQUFDO0FBQUEsRUFDOUM7QUFBQSxFQUVRLG9CQUFvQjtBQUN4QixTQUFLLGFBQWEsS0FBSyxjQUFjLFVBQVU7QUFDL0MsU0FBSyxXQUFXLFdBQVcsQ0FBQyxrQkFBa0IsY0FBYyxDQUFDO0FBQzdELG1DQUFRLEtBQUssWUFBWSxZQUFZO0FBQ3JDLFNBQUssV0FBVyxhQUFhLGNBQWMsRUFBRSxNQUFNLENBQUM7QUFDcEQsU0FBSyxXQUFXLGlCQUFpQixTQUFTLE1BQU07QUFDNUMsV0FBSyxXQUFXLFNBQVMsY0FBYztBQUN2QyxXQUFLLGVBQWU7QUFBQSxJQUN4QixDQUFDO0FBQUEsRUFDTDtBQUNKOzs7QUN2TUEsSUFBcUIsaUJBQXJCLE1BQW9DO0FBQUE7QUFBQSxFQTZDaEMsWUFBWSxRQUFrQjtBQXJDOUI7QUFBQSxTQUFRLGVBQThCO0FBQUEsTUFDbEM7QUFBQSxRQUNJLE1BQU07QUFBQSxRQUNOLGFBQWEsQ0FBQyxTQUNWLElBQUksVUFBVSxNQUFNLEtBQUssUUFBUSxZQUFZO0FBR3pDLGNBQUksS0FBSyw0QkFBNEI7QUFDakMsa0JBQU0scUJBQ0YsTUFBTSxLQUFLLE9BQU87QUFBQSxjQUNkLEtBQUs7QUFBQSxjQUNMLEtBQUs7QUFBQSxZQUNUO0FBRUosbUJBQU8sS0FBSyxPQUFPO0FBQUEsY0FDZixtQkFBbUI7QUFBQSxjQUNuQixtQkFBbUI7QUFBQSxjQUNuQixtQkFBbUI7QUFBQSxZQUN2QjtBQUFBLFVBQ0o7QUFFQSxnQkFBTSxlQUFxQixLQUFLLFdBQVc7QUFDM0MsZ0JBQU0sb0JBQ0YsS0FBSyxpREFDQyxLQUFLLFdBQVcscUJBQ2hCLEtBQUssV0FBVztBQUUxQixpQkFBTyxLQUFLLE9BQU87QUFBQSxZQUNmO0FBQUEsWUFDQTtBQUFBLFlBQ0EsS0FBSztBQUFBLFVBQ1Q7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNUO0FBQUEsSUFDSjtBQUlJLFNBQUssU0FBUztBQUNkLFNBQUssNkJBQTZCO0FBRWxDLFNBQUssb0JBQW9CO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBZUEsTUFBYSxjQUNULFlBQ0EsWUFDQSxZQUNGO0FBQ0UsU0FBSyxhQUFhO0FBQ2xCLFNBQUssZ0NBQWdDO0FBQ3JDLFNBQUssNkJBQTZCLGVBQWU7QUFDakQsUUFBSSxXQUFZLE1BQUssZ0NBQWdDO0FBRXJELFVBQU0sS0FBSyxZQUFZLGFBQWEsSUFBSTtBQUFBLEVBQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRTyxtQkFBbUI7QUFDdEIsU0FBSyxtQkFBbUIsQ0FBQyxhQUFhO0FBQ2xDLFdBQUssT0FBTyxJQUFJLFVBQVUsbUJBQW1CLFNBQVMsSUFBSTtBQUFBLElBQzlELENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFTyxtQkFBbUJDLFdBQXVDO0FBQzdELFNBQUssYUFBYSxRQUFRLENBQUMsU0FBU0EsVUFBUyxJQUFJLENBQUM7QUFBQSxFQUN0RDtBQUFBLEVBRU8sc0JBQXNCO0FBQ3pCLFNBQUs7QUFBQSxNQUFtQixDQUFDLGFBQ3JCLEtBQUssT0FBTyxhQUFhLFNBQVMsTUFBTSxTQUFTLFdBQVc7QUFBQSxJQUNoRTtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQWEsWUFBWSxNQUFjLFNBQThCO0FBQ2pFLFVBQU0sRUFBRSxVQUFVLElBQUksS0FBSyxPQUFPO0FBRWxDLFFBQUksT0FBNkI7QUFDakMsVUFBTSxTQUFTLFVBQVUsZ0JBQWdCLElBQUk7QUFFN0MsUUFBSSxPQUFPLFNBQVMsR0FBRztBQUVuQixhQUFPLE9BQU8sQ0FBQztBQUFBLElBQ25CLE9BQU87QUFFSCxhQUFPLFVBQVUsUUFBUSxPQUFPO0FBQ2hDLFVBQUksU0FBUyxNQUFNO0FBQ2YsY0FBTSxLQUFLLGFBQWEsRUFBRSxNQUFZLFFBQVEsS0FBSyxDQUFDO0FBQUEsTUFDeEQ7QUFBQSxJQUNKO0FBR0EsUUFBSSxTQUFTLE1BQU07QUFDZixnQkFBVSxXQUFXLElBQUk7QUFBQSxJQUM3QjtBQUFBLEVBQ0o7QUFDSjs7O0FDL0lBLElBQUFDLG9CQUF3QjtBQUVqQixTQUFTLFVBQVU7QUFDdEI7QUFBQSxJQUNJO0FBQUEsSUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUo7QUFDSjs7O0FDVkEsSUFBQUMsb0JBQW1DOzs7QUNBbkMsSUFBQUMsb0JBQXVDO0FBRWhDLElBQU0sMkJBQU4sY0FBdUMsb0NBQTBCO0FBQUEsRUFJcEUsWUFBWSxLQUFVLFVBQW9CO0FBQ3RDLFVBQU0sR0FBRztBQUpiLFNBQU8sV0FBcUIsQ0FBQztBQUt6QixTQUFLLFdBQVc7QUFBQSxFQUNwQjtBQUFBLEVBRUEsV0FBcUI7QUFDakIsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFlBQVksTUFBc0I7QUFDOUIsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVBLGFBQWEsU0FBaUJDLElBQXFDO0FBQy9ELFNBQUssTUFBTTtBQUNYLFNBQUssZUFBZSxPQUFPO0FBQUEsRUFDL0I7QUFDSjs7O0FEaEJPLElBQU0sd0JBQU4sTUFBNEI7QUFBQSxFQU0vQixJQUFJLHlCQUFpQztBQUNqQyxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsSUFBSSxrQkFBbUM7QUFDbkMsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFlBQVksS0FBVSxVQUFzQixpQkFBa0M7QUFDMUUsU0FBSyxNQUFNO0FBQ1gsU0FBSyxXQUFXO0FBQ2hCLFNBQUssbUJBQW1CO0FBQUEsRUFDNUI7QUFBQSxFQUVBLE1BQU0scUJBQW9DO0FBQ3RDLFFBQUksS0FBSyxTQUFTLGNBQWM7QUFDNUIsVUFBSSxDQUFDLEtBQUsseUJBQXlCO0FBQy9CLGNBQU0saUJBQTJCLEtBQUssaUJBQWlCO0FBQ3ZELFlBQUksZUFBZSxTQUFTLEVBQUcsTUFBSywwQkFBMEIsZUFBZSxDQUFDO0FBQUEsYUFDekU7QUFFRCxjQUFJLHlCQUFPLEVBQUUsZUFBZSxDQUFDO0FBQzdCO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFDQSxXQUFLLGVBQWUsS0FBSyx1QkFBdUI7QUFBQSxJQUNwRDtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sc0JBQXFDO0FBQ3ZDLFVBQU0sa0JBQTRCLEtBQUssaUJBQWlCO0FBRXhELFFBQUksZ0JBQWdCLFdBQVcsR0FBRztBQUU5QixXQUFLLGVBQWUsZ0JBQWdCLENBQUMsQ0FBQztBQUFBLElBQzFDLE9BQU87QUFDSCxZQUFNLHFCQUFxQixJQUFJLHlCQUF5QixLQUFLLEtBQUssZUFBZTtBQUNqRix5QkFBbUIsaUJBQWlCLENBQUMsWUFBb0IsS0FBSyxlQUFlLE9BQU87QUFDcEYseUJBQW1CLEtBQUs7QUFBQSxJQUM1QjtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sZUFBZSxTQUFnQztBQUNqRCxRQUFJLENBQUMsS0FBSyxpQkFBaUIsbUJBQW1CLFNBQVMsT0FBTyxHQUFHO0FBQzdELFVBQUkseUJBQU8sRUFBRSxrQkFBa0IsRUFBRSxVQUFVLFFBQVEsQ0FBQyxDQUFDO0FBQ3JEO0FBQUEsSUFDSjtBQUVBLFNBQUssMEJBQTBCO0FBQy9CLFVBQU0sT0FBTyxLQUFLLGlCQUFpQixZQUFZLElBQUksT0FBTztBQUMxRCxVQUFNLFdBQVcsS0FBSyxrQkFBa0IsS0FBSyxTQUFTLGNBQWM7QUFFcEUsUUFBSSxVQUFVO0FBQ1YsWUFBTSxLQUFLLFNBQVMsU0FBUyxTQUFTLEtBQUs7QUFBQSxJQUMvQyxPQUFPO0FBQ0gsVUFBSSx5QkFBTyxFQUFFLGVBQWUsQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSxTQUFTLFVBQWtCLE1BQTRCO0FBQ3pELFNBQUssMEJBQTBCO0FBQy9CLFVBQU0sS0FBSyxJQUFJLFVBQVUsUUFBUSxFQUFFLFNBQVMsSUFBSTtBQUFBLEVBQ3BEO0FBQ0o7OztBRXZFTyxJQUFNLFlBQU4sTUFBZ0I7QUFBQSxFQUluQixZQUFZLE1BQWUsU0FBaUI7QUFDeEMsU0FBSyxPQUFPO0FBQ1osU0FBSyxVQUFVO0FBQUEsRUFDbkI7QUFBQSxFQUVBLE1BQU0sV0FBNEI7QUFDOUIsV0FBTyxLQUFLLFdBQVc7QUFBQSxFQUMzQjtBQUNKO0FBRU8sSUFBTSxpQkFBTixNQUFxQjtBQUFBLEVBZ0N4QixZQUFZLE1BQWM7QUE1QjFCLFNBQVEsWUFBdUIsQ0FBQztBQUNoQyxTQUFRLGtCQUErQixDQUFDO0FBQ3hDLFNBQVEsaUJBQWlCO0FBMkJyQixTQUFLLFlBQVk7QUFDakIsU0FBSyxpQkFBaUIsb0JBQUksSUFBSSxDQUFDLEtBQUssV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQUEsRUFDOUQ7QUFBQSxFQXZCQSxJQUFJLFdBQW1CO0FBQ25CLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxJQUFJLFdBQXNCO0FBQ3RCLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxJQUFJLGlCQUE4QjtBQUM5QixXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsSUFBSSxnQkFBd0I7QUFDeEIsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUVBLElBQUksZ0JBQTZCO0FBQzdCLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFPTyxrQkFBa0IsV0FBeUI7QUFDOUMsU0FBSyxpQkFBaUI7QUFDdEIsU0FBSyxlQUFlLFFBQVEsQ0FBQyxrQkFBNkI7QUFDdEQsVUFBSSxjQUFjLE1BQU0sU0FBUyxHQUFHO0FBQ2hDLGFBQUs7QUFBQSxNQUNUO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRU8sNkJBQTZCLFdBQXlDO0FBRXpFLFNBQUssWUFBWSxLQUFLLFNBQVM7QUFBQSxNQUMzQixDQUFDQyxJQUFZQyxRQUFnQixVQUFVQSxHQUFFLElBQUksS0FBSyxNQUFNLFVBQVVELEdBQUUsSUFBSSxLQUFLO0FBQUEsSUFDakY7QUFHQSxTQUFLLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxDQUFDQSxJQUFjQyxPQUFpQjtBQUM1RSxZQUFNLFNBQVNELEdBQUUsVUFBVUMsR0FBRTtBQUM3QixVQUFJLFVBQVUsR0FBRztBQUNiLGVBQU87QUFBQSxNQUNYO0FBQ0EsY0FBUSxVQUFVQSxHQUFFLEtBQUssSUFBSSxLQUFLLE1BQU0sVUFBVUQsR0FBRSxLQUFLLElBQUksS0FBSztBQUFBLElBQ3RFLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxrQkFBa0IsZ0JBQWtDO0FBRWhELFVBQU0sWUFBb0IsbUJBQW1CLE1BQU0sUUFBUTtBQUMzRCxVQUFNLFdBQVcsS0FBSyxlQUFlLE9BQU8sQ0FBQyxTQUFTLEtBQUssTUFBTSxTQUFTLENBQUM7QUFDM0UsUUFBSSxTQUFTLFNBQVMsR0FBRztBQUNyQixZQUFNLFFBQVEsaUJBQ1IsMkJBQTJCLFdBQVcsR0FBRyxTQUFTLFNBQVMsQ0FBQyxJQUM1RDtBQUNOLGFBQU8sU0FBUyxLQUFLLEVBQUU7QUFBQSxJQUMzQjtBQUVBLFFBQUksS0FBSyxTQUFTLFNBQVMsR0FBRztBQUMxQixZQUFNLFFBQVEsaUJBQ1IsMkJBQTJCLFdBQVcsR0FBRyxLQUFLLFNBQVMsU0FBUyxDQUFDLElBQ2pFO0FBQ04sYUFBTyxLQUFLLFNBQVMsS0FBSztBQUFBLElBQzlCO0FBRUEsV0FBTztBQUFBLEVBQ1g7QUFDSjs7O0FDakdPLElBQU0sa0JBQU4sTUFBc0I7QUFBQSxFQUl6QixJQUFJLGNBQTJDO0FBQzNDLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxJQUFJLGdCQUF3QjtBQUN4QixXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsSUFBSSxxQkFBK0I7QUFDL0IsV0FBTyxDQUFDLEdBQUcsS0FBSyxhQUFhLEtBQUssQ0FBQztBQUFBLEVBQ3ZDO0FBQUEsRUFFQSxPQUFhO0FBQ1QsU0FBSyxlQUFlLG9CQUFJLElBQTRCO0FBQUEsRUFDeEQ7QUFBQSxFQUVPLGtCQUFrQixXQUF5QjtBQUM5QyxTQUFLLGlCQUFpQjtBQUN0QixTQUFLLGFBQWEsUUFBUSxDQUFDLGVBQStCO0FBQ3RELGlCQUFXLGtCQUFrQixTQUFTO0FBQ3RDLFdBQUssa0JBQWtCLFdBQVc7QUFBQSxJQUN0QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUEsZUFDSSxVQUNBLGNBQ0EsaUJBQ0k7QUFDSixlQUFXLGtCQUFrQixpQkFBaUI7QUFDMUMsVUFBSSxDQUFDLEtBQUssWUFBWSxJQUFJLGNBQWMsR0FBRztBQUN2QyxhQUFLLFlBQVksSUFBSSxnQkFBZ0IsSUFBSSxlQUFlLGNBQWMsQ0FBQztBQUFBLE1BQzNFO0FBQUEsSUFDSjtBQUNBLFFBQUksZ0JBQWdCLE1BQU07QUFDdEIsaUJBQVcsa0JBQWtCLGlCQUFpQjtBQUMxQyxhQUFLLFlBQVksSUFBSSxjQUFjLEVBQUUsU0FBUyxLQUFLLFFBQVE7QUFBQSxNQUMvRDtBQUFBLElBQ0osT0FBTztBQUVILGlCQUFXLGtCQUFrQixpQkFBaUI7QUFDMUMsYUFBSyxZQUNBLElBQUksY0FBYyxFQUNsQixlQUFlLEtBQUssSUFBSSxVQUFVLFVBQVUsYUFBYSxhQUFhLENBQUM7QUFBQSxNQUNoRjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFQSxtQkFBbUIsTUFBZSxjQUF5QztBQUN2RSxTQUFLLFlBQVksUUFBUSxDQUFDLGVBQStCO0FBQ3JELFVBQUksZUFBZTtBQUNuQixpQkFBVyxpQkFBaUIsV0FBVyxnQkFBZ0I7QUFDbkQsWUFBSSxjQUFjLEtBQUssU0FBUyxLQUFLLE1BQU07QUFDdkMsd0JBQWMsVUFBVSxhQUFhLFFBQVEsUUFBUTtBQUNyRCx5QkFBZTtBQUNmO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFHQSxVQUFJLENBQUMsY0FBYztBQUNmLG1CQUFXLFNBQVM7QUFBQSxVQUNoQixXQUFXLFNBQVMsVUFBVSxDQUFDLFlBQXFCLFFBQVEsU0FBUyxLQUFLLElBQUk7QUFBQSxVQUM5RTtBQUFBLFFBQ0o7QUFDQSxtQkFBVyxlQUFlLEtBQUssSUFBSSxVQUFVLE1BQU0sYUFBYSxRQUFRLFFBQVEsQ0FBQyxDQUFDO0FBQUEsTUFDdEY7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQ0o7OztBQ2pFTyxJQUFNLGVBQTJCO0FBQUEsRUFDcEMsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVSxDQUFDO0FBQUEsRUFDWCxhQUFhO0FBQ2pCOzs7QUNMTyxJQUFNLDJCQUFOLE1BQW9FO0FBQUEsRUFLdkUsWUFBWSxRQUFrQixVQUFzQixNQUFnQjtBQUNoRSxTQUFLLFNBQVM7QUFDZCxTQUFLLFdBQVc7QUFDaEIsU0FBSyxPQUFPO0FBQUEsRUFDaEI7QUFBQSxFQUVBLE1BQU0sY0FBYyxNQUFpQztBQUNqRCxVQUFNRSxPQUFNLE9BQU8sT0FBTyxLQUFLLElBQUksQ0FBQztBQUNwQyxVQUFNLFlBQW9CQSxLQUFJLE9BQU8sWUFBWTtBQUdqRCxVQUFNLFdBQW9CLGNBQWMsS0FBSztBQUM3QyxRQUFJLFVBQVU7QUFDVixXQUFLLFdBQVc7QUFDaEIsV0FBSyxNQUFNO0FBQ1gsWUFBTSxLQUFLLE1BQU07QUFBQSxJQUNyQjtBQUFBLEVBQ0o7QUFBQSxFQUVBLFFBQWM7QUFDVixTQUFLLEtBQUssT0FBTyxDQUFDO0FBQUEsRUFDdEI7QUFBQSxFQUVBLElBQUksVUFBMEI7QUFDMUIsUUFBSSxDQUFDLEtBQUssU0FBUyxRQUFRLEVBQUcsTUFBSyxLQUFLLEtBQUssU0FBUyxhQUFhLFFBQVE7QUFBQSxFQUMvRTtBQUFBLEVBRUEsU0FBUyxVQUE2QjtBQUNsQyxXQUFPLEtBQUssS0FBSyxTQUFTLFNBQVMsYUFBYSxRQUFRO0FBQUEsRUFDNUQ7QUFBQSxFQUVBLE1BQU0sUUFBdUI7QUFFekIsUUFBSSxLQUFLLFVBQVUsS0FBTTtBQUV6QixVQUFNLEtBQUssT0FBTyxlQUFlO0FBQUEsRUFDckM7QUFDSjs7O0E5T1ZBLElBQXFCLFdBQXJCLE1BQXFCLGtCQUFpQix5QkFBTztBQUFBLEVBQTdDO0FBQUE7QUFPSSxTQUFRLGFBQWlDO0FBQ3pDLFNBQVEsWUFBZ0M7QUFDeEMsU0FBUSxjQUF1QjtBQUFBO0FBQUEsRUFRL0IsTUFBTSxTQUF3QjtBQUUxQixTQUFLLGlCQUFpQixJQUFJLGVBQWUsSUFBSTtBQUM3QyxTQUFLLElBQUksVUFBVSxjQUFjLFlBQVk7QUFDekMsV0FBSyxlQUFlLGlCQUFpQjtBQUFBLElBQ3pDLENBQUM7QUFFRCxVQUFNLEtBQUssZUFBZTtBQUUxQixVQUFNLGtCQUFrQixJQUFJLGdCQUFnQjtBQUM1QyxTQUFLLHdCQUF3QixJQUFJO0FBQUEsTUFDN0IsS0FBSztBQUFBLE1BQ0wsS0FBSyxLQUFLO0FBQUEsTUFDVjtBQUFBLElBQ0o7QUFFQSxTQUFLLGFBQWEsSUFBSSxXQUFXLE1BQU0sS0FBSyxLQUFLLFVBQVUsS0FBSyxxQkFBcUI7QUFDckYsU0FBSyxXQUFXLEtBQUs7QUFDckIsU0FBSyxJQUFJLFVBQVUsY0FBYyxZQUFZO0FBQ3pDLFlBQU0sS0FBSyxXQUFXLDZCQUE2QjtBQUNuRCxpQkFBVyxZQUFZO0FBQ25CLFlBQUksQ0FBQyxLQUFLLFdBQVcsVUFBVTtBQUMzQixnQkFBTSxLQUFLLEtBQUs7QUFBQSxRQUNwQjtBQUFBLE1BQ0osR0FBRyxHQUFJO0FBQUEsSUFDWCxDQUFDO0FBRUQsVUFBTSwyQkFBcUQsSUFBSTtBQUFBLE1BQzNEO0FBQUEsTUFDQSxLQUFLLEtBQUs7QUFBQSxNQUNWLEtBQUssS0FBSztBQUFBLElBQ2Q7QUFFQSxVQUFNLHdCQUNGLElBQUksZ0NBQWdDLEtBQUssSUFBSSxhQUFhO0FBRTlELFNBQUssYUFBYSxJQUFJLFdBQVcsS0FBSyxHQUFHO0FBQ3pDLFNBQUssV0FBVztBQUFBLE1BQ1o7QUFBQSxNQUNBO0FBQUEsTUFDQSxLQUFLLEtBQUs7QUFBQSxNQUNWLEtBQUssc0JBQXNCLEtBQUssSUFBSTtBQUFBLE1BQ3BDO0FBQUEsSUFDSjtBQUVBLFlBQVE7QUFFUixTQUFLLGNBQWMsS0FBSyxLQUFLLFNBQVMsYUFBYTtBQUVuRCxTQUFLLGVBQWUsS0FBSyxLQUFLLFNBQVMsY0FBYztBQUVyRCxTQUFLLGtCQUFrQixDQUFDLEtBQUssS0FBSyxTQUFTLDRCQUE0QjtBQUV2RSxTQUFLLGtCQUFrQjtBQUV2QixTQUFLLGNBQWMsSUFBSSxhQUFhLEtBQUssS0FBSyxJQUFJLENBQUM7QUFFbkQsU0FBSyx3QkFBd0I7QUFBQSxFQUNqQztBQUFBLEVBRUEsa0JBQWtCLFFBQWlCO0FBRS9CLFFBQUksS0FBSyxvQkFBb0IsUUFBVztBQUNwQyxXQUFLLGtCQUFrQixDQUFDLE1BQU0sWUFBMkI7QUFDckQsWUFBSSxtQkFBbUIsMkJBQVMsUUFBUSxjQUFjLE1BQU07QUFDeEQsZUFBSyxRQUFRLENBQUMsU0FBUztBQUNuQixpQkFBSztBQUFBLGNBQ0QsRUFBRSwrQkFBK0I7QUFBQSxnQkFDN0IsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLGNBQ25DLENBQUM7QUFBQSxZQUNMLEVBQ0ssUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsTUFBTTtBQUNYLG1CQUFLLHVCQUF1QixxQkFBNEI7QUFBQSxZQUM1RCxDQUFDO0FBQUEsVUFDVCxDQUFDO0FBRUQsZUFBSyxRQUFRLENBQUMsU0FBUztBQUNuQixpQkFBSztBQUFBLGNBQ0QsRUFBRSwrQkFBK0I7QUFBQSxnQkFDN0IsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLGNBQ25DLENBQUM7QUFBQSxZQUNMLEVBQ0ssUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsTUFBTTtBQUNYLG1CQUFLLHVCQUF1QixxQkFBNEI7QUFBQSxZQUM1RCxDQUFDO0FBQUEsVUFDVCxDQUFDO0FBRUQsZUFBSyxRQUFRLENBQUMsU0FBUztBQUNuQixpQkFBSztBQUFBLGNBQ0QsRUFBRSwrQkFBK0I7QUFBQSxnQkFDN0IsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLGNBQ25DLENBQUM7QUFBQSxZQUNMLEVBQ0ssUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsTUFBTTtBQUNYLG1CQUFLLHVCQUF1QixxQkFBNEI7QUFBQSxZQUM1RCxDQUFDO0FBQUEsVUFDVCxDQUFDO0FBQUEsUUFDTDtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsUUFBSSxRQUFRO0FBQ1IsV0FBSyxjQUFjLEtBQUssSUFBSSxVQUFVLEdBQUcsYUFBYSxLQUFLLGVBQWUsQ0FBQztBQUFBLElBQy9FLE9BQU87QUFDSCxXQUFLLElBQUksVUFBVSxJQUFJLGFBQWEsS0FBSyxlQUFlO0FBQUEsSUFDNUQ7QUFBQSxFQUNKO0FBQUEsRUFFUSxvQkFBb0I7QUFDeEIsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsc0JBQXNCO0FBQUEsTUFDOUIsVUFBVSxZQUFZO0FBQ2xCLFlBQUksQ0FBQyxLQUFLLFdBQVcsVUFBVTtBQUMzQixnQkFBTSxLQUFLLEtBQUs7QUFDaEIsZUFBSyxzQkFBc0Isb0JBQW9CO0FBQUEsUUFDbkQ7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsOEJBQThCO0FBQUEsUUFDbEMsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLE1BQ25DLENBQUM7QUFBQSxNQUNELFVBQVUsTUFBTTtBQUNaLGNBQU0sV0FBeUIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNoRSxZQUFJLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDekMsZUFBSyx1QkFBdUIsc0JBQTZCO0FBQUEsUUFDN0Q7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsOEJBQThCO0FBQUEsUUFDbEMsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLE1BQ25DLENBQUM7QUFBQSxNQUNELFVBQVUsTUFBTTtBQUNaLGNBQU0sV0FBeUIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNoRSxZQUFJLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDekMsZUFBSyx1QkFBdUIsc0JBQTZCO0FBQUEsUUFDN0Q7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsOEJBQThCO0FBQUEsUUFDbEMsWUFBWSxLQUFLLEtBQUssU0FBUztBQUFBLE1BQ25DLENBQUM7QUFBQSxNQUNELFVBQVUsTUFBTTtBQUNaLGNBQU0sV0FBeUIsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNoRSxZQUFJLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDekMsZUFBSyx1QkFBdUIsc0JBQTZCO0FBQUEsUUFDN0Q7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsa0JBQWtCO0FBQUEsTUFDMUIsVUFBVSxZQUFZO0FBQ2xCLFlBQUksS0FBSyxXQUFXLFVBQVU7QUFDMUI7QUFBQSxRQUNKO0FBQ0EsY0FBTSxLQUFLLEtBQUs7QUFFaEIsWUFBSSxLQUFLLEtBQUssU0FBUyxrQkFBa0I7QUFDckMsZUFBSyxlQUFlLGNBQWMsS0FBSywwQkFBc0M7QUFBQSxRQUNqRixPQUFPO0FBQ0gsZUFBSztBQUFBLFlBQ0QsS0FBSyxXQUFXO0FBQUEsWUFDaEIsS0FBSyxXQUFXO0FBQUE7QUFBQSxVQUVwQjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsZ0JBQWdCO0FBQUEsTUFDeEIsVUFBVSxZQUFZO0FBQ2xCLGNBQU0sS0FBSyxLQUFLO0FBQ2hCLFlBQUksS0FBSyxLQUFLLFNBQVMsa0JBQWtCO0FBQ3JDLGVBQUssZUFBZSxjQUFjLEtBQUssd0JBQW9DO0FBQUEsUUFDL0UsT0FBTztBQUNILGVBQUs7QUFBQSxZQUNELEtBQUssV0FBVztBQUFBLFlBQ2hCLEtBQUssV0FBVztBQUFBO0FBQUEsVUFFcEI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTSxFQUFFLHNCQUFzQjtBQUFBLE1BQzlCLFVBQVUsWUFBWTtBQUNsQixjQUFNLFdBQXlCLEtBQUssSUFBSSxVQUFVLGNBQWM7QUFDaEUsWUFBSSxDQUFDLFlBQVksU0FBUyxjQUFjLE1BQU07QUFDMUM7QUFBQSxRQUNKO0FBRUEsWUFBSSxLQUFLLEtBQUssU0FBUyxrQkFBa0I7QUFDckMsZUFBSyxlQUFlO0FBQUEsWUFDaEIsS0FBSztBQUFBO0FBQUEsWUFFTDtBQUFBLFVBQ0o7QUFBQSxRQUNKLE9BQU87QUFDSCxlQUFLLGdDQUFnQyx3QkFBb0M7QUFBQSxRQUM3RTtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU0sRUFBRSxvQkFBb0I7QUFBQSxNQUM1QixVQUFVLFlBQVk7QUFDbEIsY0FBTSxXQUF5QixLQUFLLElBQUksVUFBVSxjQUFjO0FBQ2hFLFlBQUksQ0FBQyxZQUFZLFNBQVMsY0FBYyxNQUFNO0FBQzFDO0FBQUEsUUFDSjtBQUVBLFlBQUksS0FBSyxLQUFLLFNBQVMsa0JBQWtCO0FBQ3JDLGVBQUssZUFBZTtBQUFBLFlBQ2hCLEtBQUs7QUFBQTtBQUFBLFlBRUw7QUFBQSxVQUNKO0FBQUEsUUFDSixPQUFPO0FBQ0gsZUFBSyxnQ0FBZ0Msc0JBQWtDO0FBQUEsUUFDM0U7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNLEVBQUUsd0JBQXdCO0FBQUEsTUFDaEMsVUFBVSxZQUFZO0FBQ2xCLGNBQU0sS0FBSyxXQUFXLG9CQUFvQjtBQUFBLE1BQzlDO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUEsV0FBaUI7QUFDYixTQUFLLElBQUksVUFBVSxnQkFBZ0Isc0JBQXNCLEVBQUUsUUFBUSxDQUFDLFNBQVMsS0FBSyxPQUFPLENBQUM7QUFDMUYsU0FBSyxlQUFlLGlCQUFpQjtBQUFBLEVBQ3pDO0FBQUEsRUFFTywyQkFDSCxjQUNBLG1CQUNBLFlBQ3lFO0FBQ3pFLFVBQU0sZUFBa0MsVUFBUyx1QkFBdUIsS0FBSyxLQUFLLFFBQVE7QUFFMUYsVUFBTSxrQkFBNkMsSUFBSTtBQUFBLE1BQ25EO0FBQUEsTUFDQTtBQUFBLE1BQ0EsS0FBSyxLQUFLO0FBQUEsTUFDVixhQUFhLFlBQVk7QUFBQSxNQUN6QixLQUFLLFdBQVc7QUFBQSxNQUNoQixLQUFLLFdBQVc7QUFBQSxJQUNwQjtBQUVBLG9CQUFnQixZQUFZLGNBQWMsaUJBQWlCO0FBQzNELFdBQU8sRUFBRSxpQkFBaUIsTUFBTSxXQUFXO0FBQUEsRUFDL0M7QUFBQSxFQUVBLE1BQWEsb0NBQ1QsTUFDQSxNQUMrRTtBQUMvRSxVQUFNLE9BQWEsTUFBTSxLQUFLLFNBQVMsSUFBSTtBQUUzQyxVQUFNLFdBQVcsSUFBSUMsTUFBSyxRQUFRLElBQUk7QUFDdEMsU0FBSyxrQkFBa0IsUUFBUTtBQUMvQixVQUFNLG9CQUFvQixlQUFlO0FBQUEsTUFDckMsS0FBSyxXQUFXO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUVBLFdBQU8sRUFBRSxVQUFVLG1CQUFtQixLQUFLO0FBQUEsRUFDL0M7QUFBQSxFQUVPLDBCQUEwQjtBQUM3QixTQUFLO0FBQUEsTUFDRCxLQUFLLElBQUksVUFBVSxHQUFHLHNCQUFzQixLQUFLLGtCQUFrQixLQUFLLElBQUksQ0FBQztBQUFBLElBQ2pGO0FBQUEsRUFDSjtBQUFBLEVBRU8sd0JBQXdCO0FBQzNCLFNBQUssaUJBQWlCLEtBQUs7QUFDM0IsU0FBSyxJQUFJLFVBQVUsSUFBSSxzQkFBc0IsS0FBSyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7QUFBQSxFQUNsRjtBQUFBLEVBRU8sa0JBQWtCLE1BQTRCO0FBQ2pELFNBQUssaUJBQWlCLFNBQVMsUUFBUSxLQUFLLGdCQUFnQixTQUFTO0FBQUEsRUFDekU7QUFBQSxFQUVPLGlCQUFpQixPQUFnQjtBQUNwQyxTQUFLLGNBQWM7QUFBQSxFQUN2QjtBQUFBLEVBRU8sb0JBQTZCO0FBQ2hDLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxNQUFjLGdDQUNWLFVBQ0EsWUFDYTtBQUNiLFVBQU0scUJBQXFCLE1BQU0sS0FBSztBQUFBLE1BQ2xDO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFDQSxTQUFLO0FBQUEsTUFDRCxtQkFBbUI7QUFBQSxNQUNuQixtQkFBbUI7QUFBQSxNQUNuQjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFDUSxtQkFDSixjQUNBLG1CQUNBLFlBQ0k7QUFDSixVQUFNLHNCQUFzQixLQUFLO0FBQUEsTUFDN0I7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFFQSxTQUFLLGlCQUFpQixJQUFJO0FBQzFCLFFBQUk7QUFBQSxNQUNBLEtBQUs7QUFBQSxNQUNMO0FBQUEsTUFDQSxLQUFLLEtBQUs7QUFBQSxNQUNWLG9CQUFvQjtBQUFBLE1BQ3BCLG9CQUFvQjtBQUFBLElBQ3hCLEVBQUUsS0FBSztBQUFBLEVBQ1g7QUFBQSxFQUVBLE9BQWUsdUJBQXVCLFVBQXlDO0FBQzNFLFFBQUksWUFBdUIsVUFBVSxTQUFTLGtCQUE0QztBQUMxRixRQUFJLGNBQWMsT0FBVztBQUM3QixRQUFJLFlBQXVCLFVBQVUsU0FBUyxrQkFBNEM7QUFDMUYsUUFBSSxjQUFjLE9BQVc7QUFFN0IsVUFBTSxnQkFBZ0M7QUFBQSxNQUNsQztBQUFBLE1BQ0E7QUFBQSxJQUNKO0FBQ0EsV0FBTyxJQUFJLGlCQUFpQixlQUFlLElBQUk7QUFBQSxFQUNuRDtBQUFBLEVBRUEsTUFBTSxPQUFzQjtBQUN4QixRQUFJLEtBQUssV0FBVyxVQUFVO0FBQzFCO0FBQUEsSUFDSjtBQUVBLFVBQU1DLE9BQU0sT0FBTyxPQUFPLEtBQUssSUFBSSxDQUFDO0FBQ3BDLFNBQUssV0FBVyx1QkFBdUIsS0FBSyxzQkFBc0I7QUFFbEUsVUFBTSxLQUFLLFdBQVcsVUFBVTtBQUVoQyxRQUFJLEtBQUssS0FBSyxTQUFTLDZCQUE2QjtBQUNoRCxjQUFRLElBQUksT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEtBQUssV0FBVyxrQkFBa0I7QUFDbkUsY0FBUTtBQUFBLFFBQ0osU0FDSSxFQUFFLG1CQUFtQjtBQUFBLFVBQ2pCLEdBQUcsS0FBSyxJQUFJLElBQUlBLEtBQUksUUFBUTtBQUFBLFFBQ2hDLENBQUM7QUFBQSxNQUNUO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUVRLHdCQUF3QjtBQUM1QixTQUFLLFVBQVU7QUFBQSxNQUNYLEVBQUUsY0FBYztBQUFBLFFBQ1osZUFBZSxLQUFLLFdBQVcsZ0JBQWdCO0FBQUEsUUFDL0Msb0JBQW9CLEtBQUssV0FBVyxrQkFBa0I7QUFBQTtBQUFBLFVBRWxEO0FBQUEsUUFDSjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFFQSxRQUFJLEtBQUssS0FBSyxTQUFTLDhCQUErQixNQUFLLFdBQVcsT0FBTztBQUFBLEVBQ2pGO0FBQUEsRUFFQSxNQUFNLFNBQVMsVUFBZ0M7QUFDM0MsVUFBTSxTQUF5QixJQUFJLGVBQWUsS0FBSyxLQUFLLFFBQVE7QUFDcEUsVUFBTSxTQUFrQixLQUFLLGNBQWMsUUFBUTtBQUNuRCxVQUFNLGtCQUE2QixVQUFVO0FBQUEsTUFDekM7QUFBQSxNQUNBLEtBQUssS0FBSztBQUFBLElBQ2Q7QUFFQSxVQUFNLE9BQWEsTUFBTSxPQUFPO0FBQUEsTUFDNUIsS0FBSyxjQUFjLFFBQVE7QUFBQSxNQUMzQixLQUFLLHNCQUFzQjtBQUFBLE1BQzNCO0FBQUEsSUFDSjtBQUNBLFFBQUksS0FBSyxZQUFZO0FBQ2pCLFdBQUssY0FBYyxLQUFLLEtBQUssUUFBUTtBQUFBLElBQ3pDO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVRLHdCQUF1QztBQUczQyxVQUFNQyxLQUFVLEtBQUssSUFBSSxNQUFjLFVBQVUsYUFBYTtBQUM5RCxXQUFPLHVCQUF1QkEsRUFBQyxLQUFLO0FBQUEsRUFDeEM7QUFBQSxFQUVBLE1BQU0sdUJBQXVCLE1BQWEsVUFBeUM7QUFDL0UsVUFBTSxjQUF1QixLQUFLLGNBQWMsSUFBSTtBQUVwRCxRQUFJLGFBQWEseUJBQXlCLEtBQUssS0FBSyxVQUFVLEtBQUssSUFBSSxHQUFHO0FBQ3RFLFVBQUkseUJBQU8sRUFBRSx3QkFBd0IsQ0FBQztBQUN0QztBQUFBLElBQ0o7QUFFQSxVQUFNLE9BQU8sWUFBWSxvQkFBb0I7QUFDN0MsUUFBSSxDQUFDLGFBQWEsdUJBQXVCLEtBQUssS0FBSyxVQUFVLElBQUksR0FBRztBQUNoRSxVQUFJLHlCQUFPLEVBQUUsaUJBQWlCLENBQUM7QUFDL0I7QUFBQSxJQUNKO0FBR0EsVUFBTSxLQUFLLFdBQVcsdUJBQXVCLGFBQWEsVUFBVSxLQUFLLEtBQUssUUFBUTtBQUV0RixRQUFJLHlCQUFPLEVBQUUsbUJBQW1CLENBQUM7QUFFakMsUUFBSSxLQUFLLEtBQUssU0FBUyxjQUFjO0FBQ2pDLFdBQUssc0JBQXNCLG1CQUFtQjtBQUFBLElBQ2xEO0FBQUEsRUFDSjtBQUFBLEVBRUEsY0FBYyxNQUFzQjtBQUNoQyxXQUFPLElBQUksUUFBUSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUksZUFBZSxJQUFJO0FBQUEsRUFDbkU7QUFBQSxFQUVBLE1BQU0saUJBQWdDO0FBQ2xDLFVBQU0sYUFBeUIsTUFBTSxLQUFLLFNBQVM7QUFDbkQsUUFBSSx5Q0FBWSxTQUFVLGlCQUFnQixXQUFXLFFBQVE7QUFDN0QsU0FBSyxPQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsY0FBYyxVQUFVO0FBQ3RELFNBQUssS0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLEtBQUssS0FBSyxRQUFRO0FBQzNFLG1CQUFlLEtBQUssS0FBSyxTQUFTLHVCQUF1QjtBQUV6RCxTQUFLLG9DQUFvQyxLQUFLLEtBQUssUUFBUTtBQUFBLEVBQy9EO0FBQUEsRUFFQSxvQ0FBb0MsVUFBc0I7QUFFdEQsY0FBVSxXQUFXLElBQUksYUFBYSxRQUFRO0FBQzlDLGlCQUFhLFdBQVcsSUFBSSxnQkFBZ0IsUUFBUTtBQUNwRCx1QkFBbUIsV0FBVyxJQUFJLDRCQUE0QixRQUFRO0FBQUEsRUFDMUU7QUFBQSxFQUNBLE1BQU0saUJBQWdDO0FBQ2xDLFVBQU0sS0FBSyxTQUFTLEtBQUssSUFBSTtBQUFBLEVBQ2pDO0FBQUEsRUFFQSxlQUFlLFFBQWlCO0FBRTVCLFFBQUksQ0FBQyxLQUFLLFlBQVk7QUFDbEIsV0FBSyxhQUFhLEtBQUssY0FBYyxpQkFBaUIsRUFBRSxjQUFjLEdBQUcsWUFBWTtBQUNqRixZQUFJLENBQUMsS0FBSyxXQUFXLFVBQVU7QUFDM0IsZ0JBQU0sS0FBSyxLQUFLO0FBQ2hCLGVBQUs7QUFBQSxZQUNELEtBQUssV0FBVztBQUFBLFlBQ2hCLEtBQUssV0FBVztBQUFBO0FBQUEsVUFFcEI7QUFBQSxRQUNKO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUNBLFFBQUksUUFBUTtBQUNSLFdBQUssV0FBVyxNQUFNLFVBQVU7QUFBQSxJQUNwQyxPQUFPO0FBQ0gsV0FBSyxXQUFXLE1BQU0sVUFBVTtBQUFBLElBQ3BDO0FBQUEsRUFDSjtBQUFBLEVBRUEsY0FBYyxRQUFpQjtBQUUzQixRQUFJLENBQUMsS0FBSyxXQUFXO0FBQ2pCLFdBQUssWUFBWSxLQUFLLGlCQUFpQjtBQUN2QyxXQUFLLFVBQVUsVUFBVSxJQUFJLGVBQWU7QUFDNUMsV0FBSyxVQUFVLGFBQWEsY0FBYyxFQUFFLHNCQUFzQixDQUFDO0FBQ25FLFdBQUssVUFBVSxhQUFhLHVCQUF1QixLQUFLO0FBQ3hELFdBQUssVUFBVSxpQkFBaUIsU0FBUyxZQUFZO0FBQ2pELFlBQUksQ0FBQyxLQUFLLFdBQVcsVUFBVTtBQUMzQixnQkFBTSxLQUFLLEtBQUs7QUFDaEIsZUFBSyxzQkFBc0Isb0JBQW9CO0FBQUEsUUFDbkQ7QUFBQSxNQUNKLENBQUM7QUFBQSxJQUNMO0FBRUEsUUFBSSxRQUFRO0FBQ1IsV0FBSyxVQUFVLE1BQU0sVUFBVTtBQUFBLElBQ25DLE9BQU87QUFDSCxXQUFLLFVBQVUsTUFBTSxVQUFVO0FBQUEsSUFDbkM7QUFBQSxFQUNKO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJjYWxsYmFjayIsICJpc0FycmF5IiwgImlzT2JqZWN0IiwgImEiLCAiYiIsICJpc051bWJlciIsICJtYXAiLCAiZm4iLCAiaSIsICJmb3JtYXQiLCAibG9jYWxlIiwgIm0iLCAidCIsICJ0byIsICJmcm9tIiwgIk1vbWVudCIsICJpc0Z1bmN0aW9uIiwgInNldCIsICJub3ciLCAic2lnbiIsICJ0b2tlbiIsICJvcmRpbmFsIiwgImRpZmYiLCAidSIsICJsb2NhbGVEYXRhIiwgInMiLCAieSIsICJkIiwgIm4iLCAieCIsICJvIiwgImgiLCAiTSIsICJob3VycyIsICJtaW51dGVzIiwgIm5hbWVzIiwgImoiLCAiZSIsICJsIiwgIm1hdGNoIiwgImRlZmF1bHRzIiwgImMiLCAidyIsICJ0b2tlbnMiLCAibWVyaWRpZW0iLCAieWVhcnMiLCAibW9udGhzIiwgIndlZWtzIiwgImRheXMiLCAic2Vjb25kcyIsICJtaWxsaXNlY29uZHMiLCAib2Zmc2V0IiwgImNsb25lIiwgInJvdW5kIiwgInRocmVzaG9sZHMiLCAibW9kdWxlIiwgImNhbGxiYWNrIiwgImFscGhhIiwgIkNsb3plRmllbGRFbnVtIiwgIm1hdGNoIiwgIm1hdGNoIiwgIm1hdGNoIiwgIm1hdGNoIiwgIkNsb3plVHlwZUVudW0iLCAicG9zaXRpb25zIiwgImEiLCAiYiIsICJ4IiwgIkNsb3plQ3JhZnRlciIsICJlc2MiLCAiU3RyaW5nIiwgInN0ciIsICJyZXBsYWNlIiwgInMiLCAibWFwIiwgInNldElubmVySFRNTEF0dHIiLCAiRE9NQXR0cmlidXRlTmFtZXMiLCAic2FuaXRpemVkIiwgImgiLCAibmFtZSIsICJhdHRycyIsICJzdGFjayIsICJpIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAicHVzaCIsICJjaGlsZHJlbiIsICJyZXZlcnNlIiwgImVtcHR5VGFncyIsICJpbmRleE9mIiwgIl9faHRtbCIsICJjaGlsZCIsICJwb3AiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiaW1wb3J0X21vbWVudCIsICJuYW1lcyIsICJtIiwgInkiLCAibW9tZW50IiwgIm1vbWVudCIsICJwYXRoIiwgIm1vbWVudCIsICJwYXRoIiwgImEiLCAiYiIsICJyIiwgIm0iLCAiaSIsICJtIiwgInAiLCAiaSIsICJ5IiwgIm4iLCAiTiIsICJ4IiwgImMiLCAieiIsICJqIiwgInMiLCAiaSIsICJjIiwgInUiLCAiciIsICJzIiwgImMiLCAicyIsICJwIiwgImkiLCAiX2EiLCAiXyIsICJzdGFydCIsICJmaW5hbCIsICJuIiwgImFjYyIsICJleHQiLCAiX2hhc01hZ2ljIiwgInMiLCAicCIsICJleHQiLCAiZiIsICJxbWFyayIsICJzdGFyIiwgImEiLCAiYiIsICJtIiwgInMiLCAicmVnRXhwRXNjYXBlIiwgIl8iLCAic2V0IiwgImkiLCAiaiIsICJwMiIsICJwYXRoIiwgInBhdGgiLCAicmFuayIsICJwYXRoIiwgImkiLCAic2VwIiwgInEiLCAiRGVjayIsICJpIiwgInQiLCAiYSIsICJiIiwgInMiLCAidiIsICJhIiwgImIiLCAicmFuZ2UiLCAiaSIsICJ4IiwgIl8iLCAiQ2FyZE9yZGVyIiwgIkRlY2tPcmRlciIsICJEZWNrIiwgImkiLCAiXyIsICJpIiwgImltcG9ydF9vYnNpZGlhbiIsICJoMSIsICJoMiIsICJpIiwgInYiLCAidiIsICJPYnNpZGlhbkdldEFsbFRhZ3MiLCAiaSIsICJxIiwgIm1hdGNoIiwgInNlcCIsICJtYXRjaCIsICJhIiwgImIiLCAiaSIsICJpbXBvcnRfY2xvemVjcmFmdCIsICJpIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgInEiLCAiaSIsICJhIiwgImIiLCAiRGVjayIsICJpbXBvcnRfbW9tZW50IiwgIm1vbWVudCIsICJpIiwgIl8iLCAiaSIsICJtYXRjaCIsICJpbXBvcnRfb2JzaWRpYW4iLCAibm93IiwgImltcG9ydF9vYnNpZGlhbiIsICJ2IiwgImwiLCAiaCIsICJ2IiwgImIiLCAiYSIsICJmIiwgImgiLCAicyIsICJsIiwgIm4iLCAidyIsICJpIiwgInIiLCAiZyIsICJkIiwgInJhbmdlIiwgImMiLCAibSIsICJqIiwgImludGVycG9sYXRlIiwgInQiLCAiY29sb3IiLCAicCIsICJub29wIiwgInVpZCIsICJpZCIsICJpc051bGxPclVuZGVmIiwgInZhbHVlIiwgInVuZGVmaW5lZCIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOb25QcmltaXRpdmUiLCAibiIsICJTeW1ib2wiLCAidG9QcmltaXRpdmUiLCAiaXNOdW1iZXIiLCAiaXNOYU4iLCAicGFyc2VGbG9hdCIsICJpc0Zpbml0ZSIsICJhbG1vc3RXaG9sZSIsICJyb3VuZGVkIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJhcnJheSIsICJ0YXJnZXQiLCAicHJvcGVydHkiLCAiaWxlbiIsICJsZW5ndGgiLCAibWluIiwgIm1heCIsICJ0b1JhZGlhbnMiLCAiZGVncmVlcyIsICJ0b0RlZ3JlZXMiLCAicmFkaWFucyIsICJfZGVjaW1hbFBsYWNlcyIsICJpc0Zpbml0ZU51bWJlciIsICJwIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImNlbnRyZVBvaW50IiwgImFuZ2xlUG9pbnQiLCAiZGlzdGFuY2VGcm9tWENlbnRlciIsICJkaXN0YW5jZUZyb21ZQ2VudGVyIiwgInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsICJhbmdsZSIsICJhdGFuMiIsICJkaXN0YW5jZSIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAicHQxIiwgInB0MiIsICJfbm9ybWFsaXplQW5nbGUiLCAiYSIsICJUQVUiLCAiX2FuZ2xlQmV0d2VlbiIsICJhbmdsZSIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiZSIsICJhbmdsZVRvU3RhcnQiLCAiYW5nbGVUb0VuZCIsICJzdGFydFRvQW5nbGUiLCAiZW5kVG9BbmdsZSIsICJfbGltaXRWYWx1ZSIsICJ2YWx1ZSIsICJtaW4iLCAibWF4IiwgIk1hdGgiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJlcHNpbG9uIiwgIl9sb29rdXAiLCAidGFibGUiLCAiY21wIiwgImluZGV4IiwgImhpIiwgImxlbmd0aCIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgInNsaWNlIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImFycmF5IiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJwdXNoIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAic2l6ZSIsICJBcnJheSIsICJmcm9tIiwgInJlcXVlc3RBbmltRnJhbWUiLCAid2luZG93IiwgImNhbGxiYWNrIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJ0aHJvdHRsZWQiLCAiZm4iLCAidGhpc0FyZyIsICJhcmdzVG9Vc2UiLCAidGlja2luZyIsICJhcmdzIiwgImNhbGwiLCAiYXBwbHkiLCAiZGVib3VuY2UiLCAiZGVsYXkiLCAidGltZW91dCIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgIl90ZXh0WCIsICJsZWZ0IiwgInJpZ2h0IiwgInJ0bCIsICJjaGVjayIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgIk1hdGgiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAiZGVsYXkiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmbiIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCIsICJpbnRsQ2FjaGUiLCAiTWFwIiwgImdldE51bWJlckZvcm1hdCIsICJsb2NhbGUiLCAib3B0aW9ucyIsICJjYWNoZUtleSIsICJKU09OIiwgInN0cmluZ2lmeSIsICJmb3JtYXR0ZXIiLCAiZ2V0IiwgIkludGwiLCAiTnVtYmVyRm9ybWF0IiwgImZvcm1hdE51bWJlciIsICJudW0iLCAiZm9ybWF0IiwgImZvcm1hdHRlcnMiLCAidmFsdWVzIiwgImlzQXJyYXkiLCAibnVtZXJpYyIsICJ0aWNrVmFsdWUiLCAiaW5kZXgiLCAidGlja3MiLCAiY2hhcnQiLCAibm90YXRpb24iLCAiZGVsdGEiLCAibGVuZ3RoIiwgIm1heFRpY2siLCAibWF4IiwgImFicyIsICJjYWxjdWxhdGVEZWx0YSIsICJsb2dEZWx0YSIsICJsb2cxMCIsICJudW1EZWNpbWFsIiwgImlzTmFOIiwgIm1pbiIsICJmbG9vciIsICJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAibG9nYXJpdGhtaWMiLCAicmVtYWluIiwgInNpZ25pZmljYW5kIiwgImluY2x1ZGVzIiwgImNhbGwiLCAiYXBwbHlTY2FsZURlZmF1bHRzIiwgImRpc3BsYXkiLCAib2Zmc2V0IiwgInJldmVyc2UiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgImNhbGxiYWNrIiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImFsaWduIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJhcHBseSIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJzZXRSZW5kZXJPcHRzIiwgImN0eCIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgInRyYW5zbGF0ZSIsICJpc051bGxPclVuZGVmIiwgInJvdGF0aW9uIiwgInJvdGF0ZSIsICJjb2xvciIsICJmaWxsU3R5bGUiLCAidGV4dEFsaWduIiwgInRleHRCYXNlbGluZSIsICJkZWNvcmF0ZVRleHQiLCAieCIsICJ5IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJtZWFzdXJlVGV4dCIsICJsZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsICJyaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwgInRvcCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJib3R0b20iLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImJlZ2luUGF0aCIsICJsaW5lV2lkdGgiLCAiZGVjb3JhdGlvbldpZHRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJ3aWR0aCIsICJoZWlnaHQiLCAicmVuZGVyVGV4dCIsICJ0ZXh0IiwgImZvbnQiLCAibGluZXMiLCAiaXNBcnJheSIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJpIiwgInNhdmUiLCAic3RyaW5nIiwgImxlbmd0aCIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJsaW5lSGVpZ2h0IiwgInJlc3RvcmUiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInJlY3QiLCAidyIsICJoIiwgInJhZGl1cyIsICJhcmMiLCAidG9wTGVmdCIsICJQSSIsICJib3R0b21MZWZ0IiwgIkhBTEZfUEkiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAidmFsdWUiLCAic2l6ZSIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJ2IiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInByb3BzIiwgInJldCIsICJvYmpQcm9wcyIsICJpc09iamVjdCIsICJrZXlzIiwgIk9iamVjdCIsICJyZWFkIiwgInByb3AiLCAidmFsdWVPckRlZmF1bHQiLCAidG9UUkJMIiwgInRvVFJCTENvcm5lcnMiLCAidG9QYWRkaW5nIiwgIm9iaiIsICJ0b0ZvbnQiLCAib3B0aW9ucyIsICJmYWxsYmFjayIsICJkZWZhdWx0cyIsICJwYXJzZUludCIsICJzdHlsZSIsICJjb25zb2xlIiwgIndhcm4iLCAidW5kZWZpbmVkIiwgImZhbWlseSIsICJ3ZWlnaHQiLCAidG9Gb250U3RyaW5nIiwgInJlc29sdmUiLCAiaW5wdXRzIiwgImNvbnRleHQiLCAiaW5kZXgiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiaWxlbiIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImdyYWNlIiwgImJlZ2luQXRaZXJvIiwgIm1pbiIsICJtYXgiLCAiY2hhbmdlIiwgInRvRGltZW5zaW9uIiwgImtlZXBaZXJvIiwgImFkZCIsICJNYXRoIiwgImFicyIsICJjcmVhdGVDb250ZXh0IiwgInBhcmVudENvbnRleHQiLCAiYXNzaWduIiwgImNyZWF0ZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJjYWNoZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9mYWxsYmFjayIsICJfZ2V0VGFyZ2V0IiwgIm92ZXJyaWRlIiwgInNjb3BlIiwgIlByb3h5IiwgImRlbGV0ZVByb3BlcnR5IiwgInRhcmdldCIsICJfa2V5cyIsICJnZXQiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAiaW5jbHVkZXMiLCAib3duS2V5cyIsICJzZXQiLCAic3RvcmFnZSIsICJfc3RvcmFnZSIsICJfYXR0YWNoQ29udGV4dCIsICJwcm94eSIsICJzdWJQcm94eSIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAiX3Byb3h5IiwgIl9jb250ZXh0IiwgIl9zdWJQcm94eSIsICJfc3RhY2siLCAiU2V0IiwgIl9kZXNjcmlwdG9ycyIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJlbnVtZXJhYmxlIiwgImNvbmZpZ3VyYWJsZSIsICJzY3JpcHRhYmxlIiwgImluZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIm5hbWUiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJjb25zdHJ1Y3RvciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiY2FsbCIsICJkZXNjcmlwdG9ycyIsICJfcmVzb2x2ZVNjcmlwdGFibGUiLCAiX3Jlc29sdmVBcnJheSIsICJnZXRWYWx1ZSIsICJFcnJvciIsICJBcnJheSIsICJmcm9tIiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAicyIsICJpdGVtIiwgInJlc29sdmVyIiwgInB1c2giLCAicmVzb2x2ZUZhbGxiYWNrIiwgImdldFNjb3BlIiwgImtleSIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiayIsICJzdGFydHNXaXRoIiwgIkVQU0lMT04iLCAiTnVtYmVyIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJ3aW5kb3ciLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnQiLCAicGFyZW50Tm9kZSIsICJ0b1N0cmluZyIsICJob3N0IiwgInBhcnNlTWF4U3R5bGUiLCAic3R5bGVWYWx1ZSIsICJub2RlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAicGFyc2VJbnQiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN0eWxlIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAiaSIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ3aWR0aCIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgInVzZU9mZnNldFBvcyIsICJ4IiwgInkiLCAidGFyZ2V0IiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJjYW52YXMiLCAidG91Y2hlcyIsICJzb3VyY2UiLCAibGVuZ3RoIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAicmVjdCIsICJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCAiY2xpZW50WCIsICJjbGllbnRZIiwgImdldFJlbGF0aXZlUG9zaXRpb24iLCAiZXZlbnQiLCAiY2hhcnQiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAiYm9yZGVyQm94IiwgImJveFNpemluZyIsICJwYWRkaW5ncyIsICJib3JkZXJzIiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJNYXRoIiwgInJvdW5kIiwgImdldENvbnRhaW5lclNpemUiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgInVuZGVmaW5lZCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJ2IiwgImdldE1heGltdW1TaXplIiwgImJiV2lkdGgiLCAiYmJIZWlnaHQiLCAiYXNwZWN0UmF0aW8iLCAibWFyZ2lucyIsICJjb250YWluZXJTaXplIiwgIm1heCIsICJtaW4iLCAibWFpbnRhaW5IZWlnaHQiLCAiZmxvb3IiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgImN0eCIsICJzZXRUcmFuc2Zvcm0iLCAic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsICJwYXNzaXZlU3VwcG9ydGVkIiwgIm9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgInZhbHVlIiwgIm1hdGNoZXMiLCAibWF0Y2giLCAiZ2V0UmlnaHRUb0xlZnRBZGFwdGVyIiwgInJlY3RYIiwgIndpZHRoIiwgIngiLCAic2V0V2lkdGgiLCAidyIsICJ0ZXh0QWxpZ24iLCAiYWxpZ24iLCAieFBsdXMiLCAidmFsdWUiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJydGwiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgImN0eCIsICJkaXJlY3Rpb24iLCAic3R5bGUiLCAib3JpZ2luYWwiLCAiY2FudmFzIiwgImdldFByb3BlcnR5VmFsdWUiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ1bmRlZmluZWQiLCAiZ2V0U2l6ZUZvckFyZWEiLCAic2NhbGUiLCAiY2hhcnRBcmVhIiwgImZpZWxkIiwgIm9wdGlvbnMiLCAiY2xpcCIsICJnZXREYXRhc2V0QXJlYSIsICJtZXRhIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImdldERhdGFzZXRDbGlwQXJlYSIsICJjaGFydCIsICJfY2xpcCIsICJkaXNhYmxlZCIsICJhcmVhIiwgIndpZHRoIiwgImhlaWdodCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiZm91bmQiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRBeGlzQ291bnQiLCAiX2dldEF4aXMiLCAiZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzIiwgImluZGV4U2NhbGVJZCIsICJmaXJzdFNjYWxlQXhpc0lkIiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAiYXhpc0NvdW50IiwgImF4aXNJRCIsICJheGlzTnVtYmVyIiwgInN0YWNrSW5kZXgiLCAicmVjdHMiLCAibnVtYmVycyIsICJvdmVycmlkZXMiLCAiX2luZGV4XyIsICJvZmZzZXQiLCAiZ3JpZCIsICJfdmFsdWVfIiwgImJlZ2luQXRaZXJvIiwgImdldFJhdGlvQW5kT2Zmc2V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAiY3V0b3V0IiwgInJhdGlvWCIsICJyYXRpb1kiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgIlRBVSIsICJzdGFydEFuZ2xlIiwgImVuZEFuZ2xlIiwgInN0YXJ0WCIsICJNYXRoIiwgImNvcyIsICJzdGFydFkiLCAic2luIiwgImVuZFgiLCAiZW5kWSIsICJjYWxjTWF4IiwgImFuZ2xlIiwgImEiLCAiYiIsICJfYW5nbGVCZXR3ZWVuIiwgIm1heCIsICJjYWxjTWluIiwgIm1pbiIsICJtYXhYIiwgIm1heFkiLCAiSEFMRl9QSSIsICJtaW5YIiwgIlBJIiwgIm1pblkiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgImNvbnN0cnVjdG9yIiwgImNoYXJ0IiwgImRhdGFzZXRJbmRleCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgImlubmVyUmFkaXVzIiwgInVuZGVmaW5lZCIsICJvdXRlclJhZGl1cyIsICJsaW5rU2NhbGVzIiwgInBhcnNlIiwgInN0YXJ0IiwgImNvdW50IiwgImRhdGEiLCAiZ2V0RGF0YXNldCIsICJtZXRhIiwgIl9jYWNoZWRNZXRhIiwgIl9wYXJzaW5nIiwgIl9wYXJzZWQiLCAiZ2V0dGVyIiwgImkiLCAiaXNPYmplY3QiLCAia2V5IiwgInJlc29sdmVPYmplY3RLZXkiLCAiaWxlbiIsICJfZ2V0Um90YXRpb24iLCAidG9SYWRpYW5zIiwgIm9wdGlvbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJkYXRhc2V0cyIsICJsZW5ndGgiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJnZXREYXRhc2V0TWV0YSIsICJ0eXBlIiwgIl90eXBlIiwgImNvbnRyb2xsZXIiLCAidXBkYXRlIiwgIm1vZGUiLCAiY2hhcnRBcmVhIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAidG9QZXJjZW50YWdlIiwgImNoYXJ0V2VpZ2h0IiwgIl9nZXRSaW5nV2VpZ2h0IiwgImluZGV4IiwgIm1heFdpZHRoIiwgIm1heEhlaWdodCIsICJtYXhSYWRpdXMiLCAidG9EaW1lbnNpb24iLCAicmFkaXVzIiwgInJhZGl1c0xlbmd0aCIsICJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsICJ0b3RhbCIsICJjYWxjdWxhdGVUb3RhbCIsICJfZ2V0UmluZ1dlaWdodE9mZnNldCIsICJ1cGRhdGVFbGVtZW50cyIsICJfY2lyY3VtZmVyZW5jZSIsICJyZXNldCIsICJvcHRzIiwgImFuaW1hdGlvbiIsICJhbmltYXRlUm90YXRlIiwgImdldERhdGFWaXNpYmlsaXR5IiwgImhpZGRlbiIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJsZWZ0IiwgInJpZ2h0IiwgImNlbnRlclkiLCAidG9wIiwgImJvdHRvbSIsICJhbmltYXRlU2NhbGUiLCAic2hhcmVkT3B0aW9ucyIsICJpbmNsdWRlT3B0aW9ucyIsICJfZ2V0U2hhcmVkT3B0aW9ucyIsICJhcmMiLCAicHJvcGVydGllcyIsICJ4IiwgInkiLCAicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsICJhY3RpdmUiLCAidXBkYXRlRWxlbWVudCIsICJtZXRhRGF0YSIsICJ2YWx1ZSIsICJpc05hTiIsICJhYnMiLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbHMiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJsYWJlbCIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgIm9mZnNldCIsICJob3Zlck9mZnNldCIsICJyaW5nV2VpZ2h0T2Zmc2V0IiwgInZhbHVlT3JEZWZhdWx0IiwgIndlaWdodCIsICJpZCIsICJkZWZhdWx0cyIsICJkYXRhc2V0RWxlbWVudFR5cGUiLCAiZGF0YUVsZW1lbnRUeXBlIiwgImFuaW1hdGlvbnMiLCAibnVtYmVycyIsICJpbmRleEF4aXMiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJfaW5kZXhhYmxlIiwgInN0YXJ0c1dpdGgiLCAib3ZlcnJpZGVzIiwgImFzcGVjdFJhdGlvIiwgInBsdWdpbnMiLCAibGVnZW5kIiwgImdlbmVyYXRlTGFiZWxzIiwgInBvaW50U3R5bGUiLCAidGV4dEFsaWduIiwgImNvbG9yIiwgInVzZUJvcmRlclJhZGl1cyIsICJib3JkZXJSYWRpdXMiLCAibWFwIiwgInN0eWxlIiwgImdldFN0eWxlIiwgInRleHQiLCAiZmlsbFN0eWxlIiwgImJhY2tncm91bmRDb2xvciIsICJmb250Q29sb3IiLCAibGluZURhc2giLCAiYm9yZGVyRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImxpbmVKb2luIiwgImJvcmRlckpvaW5TdHlsZSIsICJsaW5lV2lkdGgiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAib25DbGljayIsICJlIiwgImxlZ2VuZEl0ZW0iLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiUGllQ29udHJvbGxlciIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaWQiLCAiZGVmYXVsdHMiLCAiY3V0b3V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAicmFkaXVzIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJjb25zdHJ1Y3RvciIsICJvcHRpb25zIiwgIm92ZXJyaWRlIiwgIm1lbWJlcnMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJwcm90b3R5cGUiLCAiaW5pdCIsICJmb3JtYXRzIiwgInBhcnNlIiwgImZvcm1hdCIsICJhZGQiLCAiZGlmZiIsICJzdGFydE9mIiwgImVuZE9mIiwgIl9kYXRlIiwgImJpbmFyeVNlYXJjaCIsICJtZXRhc2V0IiwgImF4aXMiLCAidmFsdWUiLCAiaW50ZXJzZWN0IiwgImNvbnRyb2xsZXIiLCAiZGF0YSIsICJfc29ydGVkIiwgImlTY2FsZSIsICJfY2FjaGVkTWV0YSIsICJzcGFuR2FwcyIsICJkYXRhc2V0IiwgImxlbmd0aCIsICJsb29rdXBNZXRob2QiLCAiX3JldmVyc2VQaXhlbHMiLCAiX3Jsb29rdXBCeUtleSIsICJfbG9va3VwQnlLZXkiLCAicmVzdWx0IiwgInZTY2FsZSIsICJfcGFyc2VkIiwgImRpc3RhbmNlVG9EZWZpbmVkTG8iLCAic2xpY2UiLCAibG8iLCAicmV2ZXJzZSIsICJmaW5kSW5kZXgiLCAicG9pbnQiLCAiaXNOdWxsT3JVbmRlZiIsICJNYXRoIiwgIm1heCIsICJkaXN0YW5jZVRvRGVmaW5lZEhpIiwgImhpIiwgIl9zaGFyZWRPcHRpb25zIiwgImVsIiwgInJhbmdlIiwgImdldFJhbmdlIiwgInN0YXJ0IiwgImVuZCIsICJldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMiLCAiY2hhcnQiLCAicG9zaXRpb24iLCAiaGFuZGxlciIsICJtZXRhc2V0cyIsICJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwgImkiLCAiaWxlbiIsICJpbmRleCIsICJqIiwgImVsZW1lbnQiLCAic2tpcCIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJpbmRleE9mIiwgInVzZVkiLCAicHQxIiwgInB0MiIsICJkZWx0YVgiLCAiYWJzIiwgIngiLCAiZGVsdGFZIiwgInkiLCAic3FydCIsICJwb3ciLCAiZ2V0SW50ZXJzZWN0SXRlbXMiLCAidXNlRmluYWxQb3NpdGlvbiIsICJpbmNsdWRlSW52aXNpYmxlIiwgIml0ZW1zIiwgImlzUG9pbnRJbkFyZWEiLCAiZXZhbHVhdGlvbkZ1bmMiLCAiZGF0YXNldEluZGV4IiwgIl9pc1BvaW50SW5BcmVhIiwgImNoYXJ0QXJlYSIsICJpblJhbmdlIiwgInB1c2giLCAiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAiZ2V0UHJvcHMiLCAiYW5nbGUiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiX2FuZ2xlQmV0d2VlbiIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJwb2ludEluQXJlYSIsICJkaXN0YW5jZSIsICJnZXROZWFyZXN0SXRlbXMiLCAiZ2V0QXhpc0l0ZW1zIiwgInJhbmdlTWV0aG9kIiwgImludGVyc2VjdHNJdGVtIiwgIm1vZGVzIiwgImUiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJlbGVtZW50cyIsICJmb3JFYWNoIiwgIm1ldGEiLCAiZ2V0RGF0YXNldE1ldGEiLCAibmVhcmVzdCIsICJTVEFUSUNfUE9TSVRJT05TIiwgImZpbHRlckJ5UG9zaXRpb24iLCAiYXJyYXkiLCAiZmlsdGVyIiwgInYiLCAicG9zIiwgImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsICJib3giLCAic29ydEJ5V2VpZ2h0IiwgInNvcnQiLCAiYSIsICJiIiwgInYwIiwgInYxIiwgIndlaWdodCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2siLCAic3RhY2tXZWlnaHQiLCAiaG9yaXpvbnRhbCIsICJpc0hvcml6b250YWwiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJzdGFja3MiLCAid3JhcCIsICJpbmNsdWRlcyIsICJfc3RhY2siLCAiY291bnQiLCAicGxhY2VkIiwgInNpemUiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImZhY3RvciIsICJ3aWR0aCIsICJhdmFpbGFibGVXaWR0aCIsICJoZWlnaHQiLCAiYXZhaWxhYmxlSGVpZ2h0IiwgImJ1aWxkTGF5b3V0Qm94ZXMiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJjb25jYXQiLCAicmlnaHRBbmRCb3R0b20iLCAidmVydGljYWwiLCAiZ2V0Q29tYmluZWRNYXgiLCAibWF4UGFkZGluZyIsICJ1cGRhdGVNYXhQYWRkaW5nIiwgImJveFBhZGRpbmciLCAidXBkYXRlRGltcyIsICJpc09iamVjdCIsICJnZXRQYWRkaW5nIiwgIm5ld1dpZHRoIiwgIm91dGVyV2lkdGgiLCAibmV3SGVpZ2h0IiwgIm91dGVySGVpZ2h0IiwgIndpZHRoQ2hhbmdlZCIsICJ3IiwgImhlaWdodENoYW5nZWQiLCAiaCIsICJzYW1lIiwgIm90aGVyIiwgImhhbmRsZU1heFBhZGRpbmciLCAidXBkYXRlUG9zIiwgImNoYW5nZSIsICJnZXRNYXJnaW5zIiwgIm1hcmdpbkZvclBvc2l0aW9ucyIsICJwb3NpdGlvbnMiLCAibWFyZ2luIiwgImZpdEJveGVzIiwgInJlZml0Qm94ZXMiLCAicmVmaXQiLCAiY2hhbmdlZCIsICJ1cGRhdGUiLCAic2V0Qm94RGltcyIsICJwbGFjZUJveGVzIiwgInVzZXJQYWRkaW5nIiwgInBhZGRpbmciLCAiZGVmaW5lZCIsICJhZGRCb3giLCAiaXRlbSIsICJfbGF5ZXJzIiwgInoiLCAiZHJhdyIsICJyZW1vdmVCb3giLCAibGF5b3V0SXRlbSIsICJzcGxpY2UiLCAiY29uZmlndXJlIiwgIm1pblBhZGRpbmciLCAidG9QYWRkaW5nIiwgInZlcnRpY2FsQm94ZXMiLCAiaG9yaXpvbnRhbEJveGVzIiwgImVhY2giLCAiYmVmb3JlTGF5b3V0IiwgInZpc2libGVWZXJ0aWNhbEJveENvdW50IiwgInJlZHVjZSIsICJ0b3RhbCIsICJkaXNwbGF5IiwgImZyZWV6ZSIsICJCYXNlUGxhdGZvcm0iLCAiYWNxdWlyZUNvbnRleHQiLCAiY2FudmFzIiwgImFzcGVjdFJhdGlvIiwgInJlbGVhc2VDb250ZXh0IiwgImNvbnRleHQiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJ0eXBlIiwgImxpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJnZXRNYXhpbXVtU2l6ZSIsICJmbG9vciIsICJpc0F0dGFjaGVkIiwgInVwZGF0ZUNvbmZpZyIsICJjb25maWciLCAiQmFzaWNQbGF0Zm9ybSIsICJnZXRDb250ZXh0IiwgImFuaW1hdGlvbiIsICJFWFBBTkRPX0tFWSIsICJFVkVOVF9UWVBFUyIsICJ0b3VjaHN0YXJ0IiwgInRvdWNobW92ZSIsICJ0b3VjaGVuZCIsICJwb2ludGVyZW50ZXIiLCAicG9pbnRlcmRvd24iLCAicG9pbnRlcm1vdmUiLCAicG9pbnRlcnVwIiwgInBvaW50ZXJsZWF2ZSIsICJwb2ludGVyb3V0IiwgImlzTnVsbE9yRW1wdHkiLCAiaW5pdENhbnZhcyIsICJzdHlsZSIsICJyZW5kZXJIZWlnaHQiLCAiZ2V0QXR0cmlidXRlIiwgInJlbmRlcldpZHRoIiwgImluaXRpYWwiLCAiYm94U2l6aW5nIiwgImRpc3BsYXlXaWR0aCIsICJyZWFkVXNlZFNpemUiLCAidW5kZWZpbmVkIiwgImRpc3BsYXlIZWlnaHQiLCAiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZExpc3RlbmVyIiwgIm5vZGUiLCAicmVtb3ZlTGlzdGVuZXIiLCAiZnJvbU5hdGl2ZUV2ZW50IiwgImV2ZW50IiwgIm5hdGl2ZSIsICJub2RlTGlzdENvbnRhaW5zIiwgIm5vZGVMaXN0IiwgImNvbnRhaW5zIiwgImNyZWF0ZUF0dGFjaE9ic2VydmVyIiwgIm9ic2VydmVyIiwgIk11dGF0aW9uT2JzZXJ2ZXIiLCAiZW50cmllcyIsICJ0cmlnZ2VyIiwgImVudHJ5IiwgImFkZGVkTm9kZXMiLCAicmVtb3ZlZE5vZGVzIiwgIm9ic2VydmUiLCAiZG9jdW1lbnQiLCAiY2hpbGRMaXN0IiwgInN1YnRyZWUiLCAiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCAiZHJwTGlzdGVuaW5nQ2hhcnRzIiwgIk1hcCIsICJvbGREZXZpY2VQaXhlbFJhdGlvIiwgIm9uV2luZG93UmVzaXplIiwgImRwciIsICJ3aW5kb3ciLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJyZXNpemUiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAic2V0IiwgInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAiZGVsZXRlIiwgImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwgImNvbnRhaW5lciIsICJfZ2V0UGFyZW50Tm9kZSIsICJ0aHJvdHRsZWQiLCAiY2xpZW50V2lkdGgiLCAiUmVzaXplT2JzZXJ2ZXIiLCAiY29udGVudFJlY3QiLCAicmVsZWFzZU9ic2VydmVyIiwgImRpc2Nvbm5lY3QiLCAiY3JlYXRlUHJveHlBbmRMaXN0ZW4iLCAicHJveHkiLCAiY3R4IiwgIkRvbVBsYXRmb3JtIiwgInByb3AiLCAicmVtb3ZlQXR0cmlidXRlIiwgInNldEF0dHJpYnV0ZSIsICJrZXlzIiwgImtleSIsICJwcm94aWVzIiwgIiRwcm94aWVzIiwgImhhbmRsZXJzIiwgImF0dGFjaCIsICJkZXRhY2giLCAiaXNDb25uZWN0ZWQiLCAiX2RldGVjdFBsYXRmb3JtIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJPZmZzY3JlZW5DYW52YXMiLCAiRWxlbWVudCIsICJhY3RpdmUiLCAiJGFuaW1hdGlvbnMiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImlzTnVtYmVyIiwgInByb3BzIiwgImZpbmFsIiwgImFuaW1zIiwgInJldCIsICJfdG8iLCAiZGVmYXVsdHMiLCAiZGVmYXVsdFJvdXRlcyIsICJhdXRvU2tpcCIsICJzY2FsZSIsICJ0aWNrcyIsICJ0aWNrT3B0cyIsICJkZXRlcm1pbmVkTWF4VGlja3MiLCAiZGV0ZXJtaW5lTWF4VGlja3MiLCAidGlja3NMaW1pdCIsICJtaW4iLCAibWF4VGlja3NMaW1pdCIsICJtYWpvckluZGljZXMiLCAibWFqb3IiLCAiZW5hYmxlZCIsICJnZXRNYWpvckluZGljZXMiLCAibnVtTWFqb3JJbmRpY2VzIiwgImZpcnN0IiwgImxhc3QiLCAibmV3VGlja3MiLCAic2tpcE1ham9ycyIsICJzcGFjaW5nIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgIm9mZnNldCIsICJ0aWNrTGVuZ3RoIiwgIl90aWNrU2l6ZSIsICJtYXhTY2FsZSIsICJfbGVuZ3RoIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAibmV4dCIsICJjZWlsIiwgIm1ham9yU3RhcnQiLCAibWFqb3JFbmQiLCAidmFsdWVPckRlZmF1bHQiLCAiYXJyIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZWRnZSIsICJnZXRUaWNrc0xpbWl0IiwgInRpY2tzTGVuZ3RoIiwgInNhbXBsZSIsICJudW1JdGVtcyIsICJpbmNyZW1lbnQiLCAiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsICJvZmZzZXRHcmlkTGluZXMiLCAidmFsaWRJbmRleCIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImdhcmJhZ2VDb2xsZWN0IiwgImNhY2hlcyIsICJjYWNoZSIsICJnYyIsICJnY0xlbiIsICJnZXRUaWNrTWFya0xlbmd0aCIsICJkcmF3VGlja3MiLCAiZ2V0VGl0bGVIZWlnaHQiLCAiZmFsbGJhY2siLCAiZm9udCIsICJ0b0ZvbnQiLCAibGluZXMiLCAiaXNBcnJheSIsICJ0ZXh0IiwgImxpbmVIZWlnaHQiLCAiY3JlYXRlU2NhbGVDb250ZXh0IiwgInBhcmVudCIsICJjcmVhdGVDb250ZXh0IiwgImNyZWF0ZVRpY2tDb250ZXh0IiwgInRpY2siLCAidGl0bGVBbGlnbiIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAidGl0bGVBcmdzIiwgInNjYWxlcyIsICJyb3RhdGlvbiIsICJtYXhXaWR0aCIsICJ0aXRsZVgiLCAidGl0bGVZIiwgIl9hbGlnblN0YXJ0RW5kIiwgInBvc2l0aW9uQXhpc0lEIiwgImdldFBpeGVsRm9yVmFsdWUiLCAiSEFMRl9QSSIsICJTY2FsZSIsICJjZmciLCAiaWQiLCAiX21hcmdpbnMiLCAibWF4SGVpZ2h0IiwgInBhZGRpbmdUb3AiLCAicGFkZGluZ0JvdHRvbSIsICJwYWRkaW5nTGVmdCIsICJwYWRkaW5nUmlnaHQiLCAibGFiZWxSb3RhdGlvbiIsICJfcmFuZ2UiLCAiX2dyaWRMaW5lSXRlbXMiLCAiX2xhYmVsSXRlbXMiLCAiX2xhYmVsU2l6ZXMiLCAiX2xvbmdlc3RUZXh0Q2FjaGUiLCAiX3VzZXJNYXgiLCAiX3VzZXJNaW4iLCAiX3N1Z2dlc3RlZE1heCIsICJfc3VnZ2VzdGVkTWluIiwgIl90aWNrc0xlbmd0aCIsICJfYm9yZGVyVmFsdWUiLCAiX2NhY2hlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgIiRjb250ZXh0IiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJyYXciLCAiZ2V0VXNlckJvdW5kcyIsICJmaW5pdGVPckRlZmF1bHQiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAibWluRGVmaW5lZCIsICJpc0Zpbml0ZSIsICJtYXhEZWZpbmVkIiwgImdldE1pbk1heCIsICJjYW5TdGFjayIsICJtZXRhcyIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJnZXRUaWNrcyIsICJnZXRMYWJlbHMiLCAibGFiZWxzIiwgInhMYWJlbHMiLCAieUxhYmVscyIsICJnZXRMYWJlbEl0ZW1zIiwgIl9jb21wdXRlTGFiZWxJdGVtcyIsICJiZWZvcmVVcGRhdGUiLCAiY2FsbCIsICJtYXJnaW5zIiwgImJlZ2luQXRaZXJvIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAic3RhcnRQaXhlbCIsICJlbmRQaXhlbCIsICJfYWxpZ25Ub1BpeGVscyIsICJhbGlnblRvUGl4ZWxzIiwgIl9jYWxsSG9va3MiLCAibmFtZSIsICJub3RpZnlQbHVnaW5zIiwgImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJnZW5lcmF0ZVRpY2tMYWJlbHMiLCAibGFiZWwiLCAiY2FsbGJhY2siLCAiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAibnVtVGlja3MiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAidGlja1dpZHRoIiwgIm1heExhYmVsRGlhZ29uYWwiLCAiX2lzVmlzaWJsZSIsICJsYWJlbFNpemVzIiwgIl9nZXRMYWJlbFNpemVzIiwgIm1heExhYmVsV2lkdGgiLCAid2lkZXN0IiwgIm1heExhYmVsSGVpZ2h0IiwgImhpZ2hlc3QiLCAiX2xpbWl0VmFsdWUiLCAiZ3JpZCIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJtaW5TaXplIiwgInRpdGxlT3B0cyIsICJncmlkT3B0cyIsICJ0aXRsZUhlaWdodCIsICJ0aWNrUGFkZGluZyIsICJhbmdsZVJhZGlhbnMiLCAidG9SYWRpYW5zIiwgImNvcyIsICJzaW4iLCAibGFiZWxIZWlnaHQiLCAibWlycm9yIiwgImxhYmVsV2lkdGgiLCAiX2NhbGN1bGF0ZVBhZGRpbmciLCAiX2hhbmRsZU1hcmdpbnMiLCAiaXNSb3RhdGVkIiwgImxhYmVsc0JlbG93VGlja3MiLCAib2Zmc2V0TGVmdCIsICJvZmZzZXRSaWdodCIsICJpc0Z1bGxTaXplIiwgIl9jb21wdXRlTGFiZWxTaXplcyIsICJ3aWR0aHMiLCAiaGVpZ2h0cyIsICJ3aWRlc3RMYWJlbFNpemUiLCAiaGlnaGVzdExhYmVsU2l6ZSIsICJqbGVuIiwgInRpY2tGb250IiwgImZvbnRTdHJpbmciLCAibmVzdGVkTGFiZWwiLCAiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCAic3RyaW5nIiwgIl9tZWFzdXJlVGV4dCIsICJ2YWx1ZUF0IiwgImlkeCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIk5hTiIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJkZWNpbWFsIiwgIl9pbnQxNlJhbmdlIiwgIl9hbGlnblBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgImJvcmRlciIsICJ0bCIsICJib3JkZXJPcHRzIiwgImF4aXNXaWR0aCIsICJheGlzSGFsZldpZHRoIiwgImFsaWduQm9yZGVyVmFsdWUiLCAiYm9yZGVyVmFsdWUiLCAiYWxpZ25lZExpbmVWYWx1ZSIsICJ0eDEiLCAidHkxIiwgInR4MiIsICJ0eTIiLCAieDEiLCAieTEiLCAieDIiLCAieTIiLCAibGltaXQiLCAic3RlcCIsICJvcHRzQXRJbmRleCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJsaW5lV2lkdGgiLCAibGluZUNvbG9yIiwgImNvbG9yIiwgImJvcmRlckRhc2giLCAiZGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAidGlja0NvbG9yIiwgInRpY2tCb3JkZXJEYXNoIiwgInRpY2tCb3JkZXJEYXNoT2Zmc2V0IiwgImNyb3NzQWxpZ24iLCAidGlja0FuZFBhZGRpbmciLCAiaFRpY2tBbmRQYWRkaW5nIiwgInRleHRBbGlnbiIsICJsaW5lQ291bnQiLCAidGV4dE9mZnNldCIsICJ0ZXh0QmFzZWxpbmUiLCAiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCAiX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQiLCAibGFiZWxPZmZzZXQiLCAiaGFsZkNvdW50IiwgInN0cm9rZUNvbG9yIiwgInRleHRTdHJva2VDb2xvciIsICJzdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlV2lkdGgiLCAidGlja1RleHRBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcCIsICJsYWJlbFBhZGRpbmciLCAiYmFja2Ryb3BQYWRkaW5nIiwgImJhY2tkcm9wQ29sb3IiLCAidHJhbnNsYXRpb24iLCAiX2NvbXB1dGVMYWJlbEFyZWEiLCAiZHJhd0JhY2tncm91bmQiLCAiYmFja2dyb3VuZENvbG9yIiwgInNhdmUiLCAiZmlsbFN0eWxlIiwgImZpbGxSZWN0IiwgInJlc3RvcmUiLCAiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCAidCIsICJvcHRzIiwgImRyYXdHcmlkIiwgImRyYXdMaW5lIiwgInAxIiwgInAyIiwgInN0cm9rZVN0eWxlIiwgInNldExpbmVEYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImJlZ2luUGF0aCIsICJtb3ZlVG8iLCAibGluZVRvIiwgInN0cm9rZSIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd0JvcmRlciIsICJsYXN0TGluZVdpZHRoIiwgImRyYXdMYWJlbHMiLCAiYXJlYSIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgImF4aXNJRCIsICJfbWF4RGlnaXRzIiwgImZvbnRTaXplIiwgIlR5cGVkUmVnaXN0cnkiLCAic2NvcGUiLCAiY3JlYXRlIiwgImlzRm9yVHlwZSIsICJpc1Byb3RvdHlwZU9mIiwgInJlZ2lzdGVyIiwgInByb3RvIiwgImdldFByb3RvdHlwZU9mIiwgInBhcmVudFNjb3BlIiwgImlzSUNoYXJ0Q29tcG9uZW50IiwgInJlZ2lzdGVyRGVmYXVsdHMiLCAib3ZlcnJpZGVzIiwgImdldCIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaXB0b3JzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAicG9wIiwgInNvdXJjZVNjb3BlIiwgImpvaW4iLCAicGFydHMiLCAidGFyZ2V0TmFtZSIsICJ0YXJnZXRTY29wZSIsICJyb3V0ZSIsICJSZWdpc3RyeSIsICJjb250cm9sbGVycyIsICJEYXRhc2V0Q29udHJvbGxlciIsICJwbHVnaW5zIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiYXJncyIsICJfZWFjaCIsICJyZW1vdmUiLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkRWxlbWVudHMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldEVsZW1lbnQiLCAiZ2V0UGx1Z2luIiwgImdldFNjYWxlIiwgInJlbW92ZUNvbnRyb2xsZXJzIiwgInJlbW92ZUVsZW1lbnRzIiwgInJlbW92ZVBsdWdpbnMiLCAicmVtb3ZlU2NhbGVzIiwgIm1ldGhvZCIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgInJlZ2lzdHJ5IiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfbm90aWZ5IiwgIl9kZXNjcmlwdG9ycyIsICJkZXNjcmlwdG9yIiwgInBsdWdpbiIsICJjYWxsQ2FsbGJhY2siLCAiY2FuY2VsYWJsZSIsICJpbnZhbGlkYXRlIiwgIl9vbGRDYWNoZSIsICJfbm90aWZ5U3RhdGVDaGFuZ2VzIiwgImFsbCIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjb3BlcyIsICJnZXRPcHRpb25TY29wZXMiLCAiY3JlYXRlUmVzb2x2ZXIiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiYWxsS2V5cyIsICJnZXRJbmRleEF4aXMiLCAiZGF0YXNldERlZmF1bHRzIiwgImRhdGFzZXRzIiwgImRhdGFzZXRPcHRpb25zIiwgImluZGV4QXhpcyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgInhBeGlzSUQiLCAieUF4aXNJRCIsICJtZXJnZVNjYWxlQ29uZmlnIiwgImNoYXJ0RGVmYXVsdHMiLCAiY29uZmlnU2NhbGVzIiwgImNoYXJ0SW5kZXhBeGlzIiwgInNjYWxlQ29uZiIsICJjb25zb2xlIiwgImVycm9yIiwgIl9wcm94eSIsICJ3YXJuIiwgImRlZmF1bHRJZCIsICJkZWZhdWx0U2NhbGVPcHRpb25zIiwgIm1lcmdlSWYiLCAiZGVmYXVsdElEIiwgImluaXRPcHRpb25zIiwgImluaXREYXRhIiwgImluaXRDb25maWciLCAia2V5Q2FjaGUiLCAia2V5c0NhY2hlZCIsICJTZXQiLCAiY2FjaGVkS2V5cyIsICJjYWNoZUtleSIsICJnZW5lcmF0ZSIsICJhZGRJZkZvdW5kIiwgIm9iaiIsICJyZXNvbHZlT2JqZWN0S2V5IiwgIkNvbmZpZyIsICJfY29uZmlnIiwgIl9zY29wZUNhY2hlIiwgIl9yZXNvbHZlckNhY2hlIiwgInBsYXRmb3JtIiwgImNsZWFyQ2FjaGUiLCAiY2xlYXIiLCAiZGF0YXNldFNjb3BlS2V5cyIsICJkYXRhc2V0VHlwZSIsICJkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAiZWxlbWVudFR5cGUiLCAiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsICJfY2FjaGVkU2NvcGVzIiwgIm1haW5TY29wZSIsICJyZXNldENhY2hlIiwgImtleUxpc3RzIiwgImNhY2hlZCIsICJBcnJheSIsICJmcm9tIiwgImhhcyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlTmFtZWRPcHRpb25zIiwgIm5hbWVzIiwgInByZWZpeGVzIiwgIiRzaGFyZWQiLCAicmVzb2x2ZXIiLCAic3ViUHJlZml4ZXMiLCAiZ2V0UmVzb2x2ZXIiLCAibmVlZENvbnRleHQiLCAiaXNGdW5jdGlvbiIsICJzdWJSZXNvbHZlciIsICJfYXR0YWNoQ29udGV4dCIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAicmVzb2x2ZXJDYWNoZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAicCIsICJoYXNGdW5jdGlvbiIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJhbmltYXRpb25PcHRpb25zIiwgIm9uQ29tcGxldGUiLCAib25BbmltYXRpb25Qcm9ncmVzcyIsICJvblByb2dyZXNzIiwgImdldENhbnZhcyIsICJnZXRFbGVtZW50QnlJZCIsICJpbnN0YW5jZXMiLCAiZ2V0Q2hhcnQiLCAidmFsdWVzIiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgIm1vdmUiLCAiaW50S2V5IiwgImRldGVybWluZUxhc3RFdmVudCIsICJsYXN0RXZlbnQiLCAiaW5DaGFydEFyZWEiLCAiaXNDbGljayIsICJDaGFydCIsICJpbnZhbGlkYXRlUGx1Z2lucyIsICJ1c2VyQ29uZmlnIiwgImluaXRpYWxDYW52YXMiLCAiZXhpc3RpbmdDaGFydCIsICJ1aWQiLCAiX29wdGlvbnMiLCAiX2FzcGVjdFJhdGlvIiwgIl9tZXRhc2V0cyIsICJfc3RhY2tzIiwgIl9hY3RpdmUiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9kb1Jlc2l6ZSIsICJkZWJvdW5jZSIsICJtb2RlIiwgInJlc2l6ZURlbGF5IiwgIl9kYXRhQ2hhbmdlcyIsICJhbmltYXRvciIsICJsaXN0ZW4iLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAic3RvcCIsICJydW5uaW5nIiwgIl9yZXNpemUiLCAiX3Jlc2l6ZUJlZm9yZURyYXciLCAibmV3U2l6ZSIsICJuZXdSYXRpbyIsICJvblJlc2l6ZSIsICJyZW5kZXIiLCAiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsICJzY2FsZXNPcHRpb25zIiwgImF4aXNPcHRpb25zIiwgImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCAic2NhbGVPcHRzIiwgInVwZGF0ZWQiLCAibWFwIiwgImlzUmFkaWFsIiwgImRwb3NpdGlvbiIsICJkdHlwZSIsICJzY2FsZVR5cGUiLCAic2NhbGVDbGFzcyIsICJoYXNVcGRhdGVkIiwgIl91cGRhdGVNZXRhc2V0cyIsICJudW1EYXRhIiwgIm51bU1ldGEiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiX2RhdGFzZXQiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJ1cGRhdGVJbmRleCIsICJsaW5rU2NhbGVzIiwgIkNvbnRyb2xsZXJDbGFzcyIsICJkYXRhc2V0RWxlbWVudFR5cGUiLCAiZGF0YUVsZW1lbnRUeXBlIiwgIl9yZXNldEVsZW1lbnRzIiwgInJlc2V0IiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsICJnZXRNYXhPdmVyZmxvdyIsICJfbWluUGFkZGluZyIsICJhdXRvUGFkZGluZyIsICJfdXBkYXRlTGF5b3V0IiwgIl91cGRhdGVEYXRhc2V0cyIsICJfZXZlbnRIYW5kbGVyIiwgIl91cGRhdGVIb3ZlclN0eWxlcyIsICJleGlzdGluZ0V2ZW50cyIsICJuZXdFdmVudHMiLCAiZXZlbnRzIiwgInNldHNFcXVhbCIsICJ1bmJpbmRFdmVudHMiLCAiY2hhbmdlcyIsICJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwgImRhdGFzZXRDb3VudCIsICJtYWtlU2V0IiwgImNoYW5nZVNldCIsICJub0FyZWEiLCAiX2lkeCIsICJfdXBkYXRlRGF0YXNldCIsICJfdXBkYXRlIiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCAiZmlsdGVyVmlzaWJsZSIsICJfZHJhd0RhdGFzZXQiLCAiY2xpcCIsICJnZXREYXRhc2V0Q2xpcEFyZWEiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJoaWRkZW4iLCAiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJkYXRhSW5kZXgiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgImhpZGUiLCAic2hvdyIsICJfZGVzdHJveSIsICJfc3RvcCIsICJkZXN0cm95IiwgInRvQmFzZTY0SW1hZ2UiLCAidG9EYXRhVVJMIiwgImJpbmRVc2VyRXZlbnRzIiwgImJpbmRSZXNwb25zaXZlRXZlbnRzIiwgImxpc3RlbmVycyIsICJfYWRkIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJfcmVtb3ZlIiwgImRldGFjaGVkIiwgInVwZGF0ZUhvdmVyU3R5bGUiLCAicHJlZml4IiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiX2VsZW1lbnRzRXF1YWwiLCAiaXNQbHVnaW5FbmFibGVkIiwgInBsdWdpbklkIiwgInJlcGxheSIsICJob3Zlck9wdGlvbnMiLCAiaG92ZXIiLCAiZGVhY3RpdmF0ZWQiLCAiYWN0aXZhdGVkIiwgImV2ZW50RmlsdGVyIiwgIl9oYW5kbGVFdmVudCIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiX2lzQ2xpY2tFdmVudCIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAidmVyc2lvbiIsICJjbGlwU2VsZiIsICJvdXRlclJhZGl1cyIsICJpbm5lclJhZGl1cyIsICJib3JkZXJXaWR0aCIsICJib3JkZXJKb2luU3R5bGUiLCAib3V0ZXJBbmdsZUNsaXAiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgImFyYyIsICJpbm5lckFuZ2xlQ2xpcCIsICJjbGlwV2lkdGgiLCAiUEkiLCAiciIsICJlbmRYIiwgImVuZFkiLCAic3RhcnRYIiwgInN0YXJ0WSIsICJjbG9zZVBhdGgiLCAicmVjdCIsICJjbGlwQXJjIiwgInBpeGVsTWFyZ2luIiwgImFuZ2xlTWFyZ2luIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJ2YWwiLCAib3V0ZXJBcmNMaW1pdCIsICJvdXRlclN0YXJ0IiwgIm91dGVyRW5kIiwgImlubmVyU3RhcnQiLCAiaW5uZXJFbmQiLCAiclRoZXRhVG9YWSIsICJ0aGV0YSIsICJwYXRoQXJjIiwgImNpcmN1bGFyIiwgImlubmVyUiIsICJzcGFjaW5nT2Zmc2V0IiwgImFscGhhIiwgIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwgIm5vU3BhY2luZ091dGVyUmFkaXVzIiwgImF2Tm9nU3BhY2luZ1JhZGl1cyIsICJhZGp1c3RlZEFuZ2xlIiwgImJldGEiLCAiYW5nbGVPZmZzZXQiLCAib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCAib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwgImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwgImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsICJvdXRlck1pZEFkanVzdGVkQW5nbGUiLCAicENlbnRlciIsICJwNCIsICJpbm5lck1pZEFkanVzdGVkQW5nbGUiLCAicDgiLCAib3V0ZXJTdGFydFgiLCAib3V0ZXJTdGFydFkiLCAib3V0ZXJFbmRYIiwgIm91dGVyRW5kWSIsICJkcmF3QXJjIiwgImZ1bGxDaXJjbGVzIiwgImNpcmN1bWZlcmVuY2UiLCAiZmlsbCIsICJpc05hTiIsICJUQVUiLCAiaW5uZXIiLCAiYm9yZGVyQWxpZ24iLCAibGluZUpvaW4iLCAic2VsZkpvaW4iLCAiQXJjRWxlbWVudCIsICJjaGFydFgiLCAiY2hhcnRZIiwgInJBZGp1c3QiLCAiX2NpcmN1bWZlcmVuY2UiLCAibm9uWmVyb0JldHdlZW4iLCAiYmV0d2VlbkFuZ2xlcyIsICJ3aXRoaW5SYWRpdXMiLCAiX2lzQmV0d2VlbiIsICJoYWxmQW5nbGUiLCAiaGFsZlJhZGl1cyIsICJ0cmFuc2xhdGUiLCAiZml4IiwgInJhZGl1c09mZnNldCIsICJib3JkZXJDb2xvciIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgImdldEJhckJvdW5kcyIsICJiYXIiLCAidXNlRmluYWxQb3NpdGlvbiIsICJ4IiwgInkiLCAiYmFzZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAiZ2V0UHJvcHMiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImhhbGYiLCAiaG9yaXpvbnRhbCIsICJNYXRoIiwgIm1pbiIsICJtYXgiLCAic2tpcE9yTGltaXQiLCAic2tpcCIsICJ2YWx1ZSIsICJfbGltaXRWYWx1ZSIsICJwYXJzZUJvcmRlcldpZHRoIiwgIm1heFciLCAibWF4SCIsICJvcHRpb25zIiwgImJvcmRlcldpZHRoIiwgImJvcmRlclNraXBwZWQiLCAibyIsICJ0b1RSQkwiLCAidCIsICJyIiwgImIiLCAibCIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJlbmFibGVCb3JkZXJSYWRpdXMiLCAiYm9yZGVyUmFkaXVzIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAiaXNPYmplY3QiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgImJvcmRlciIsICJyYWRpdXMiLCAib3V0ZXIiLCAidyIsICJoIiwgImlubmVyIiwgImluUmFuZ2UiLCAic2tpcFgiLCAic2tpcFkiLCAic2tpcEJvdGgiLCAiX2lzQmV0d2VlbiIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAiY3R4IiwgInJlY3QiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNmZyIsICJ1bmRlZmluZWQiLCAiaW5mbGF0ZUFtb3VudCIsICJPYmplY3QiLCAiYXNzaWduIiwgImRyYXciLCAiYm9yZGVyQ29sb3IiLCAiYmFja2dyb3VuZENvbG9yIiwgImFkZFJlY3RQYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJzYXZlIiwgImJlZ2luUGF0aCIsICJjbGlwIiwgImZpbGxTdHlsZSIsICJmaWxsIiwgInJlc3RvcmUiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJnZXRDZW50ZXJQb2ludCIsICJnZXRSYW5nZSIsICJheGlzIiwgImlkIiwgImRlZmF1bHRzIiwgInBvaW50U3R5bGUiLCAiZGVmYXVsdFJvdXRlcyIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJmb250U2l6ZSIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJNYXRoIiwgIm1pbiIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJtYXgiLCAiaXRlbXNFcXVhbCIsICJhIiwgImIiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgIkxlZ2VuZCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbmZpZyIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJjaGFydCIsICJvcHRpb25zIiwgImN0eCIsICJsZWdlbmRJdGVtcyIsICJ1bmRlZmluZWQiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJtYXhIZWlnaHQiLCAibWF4V2lkdGgiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ3aWR0aCIsICJfbWFyZ2lucyIsICJwb3NpdGlvbiIsICJ3ZWlnaHQiLCAiZnVsbFNpemUiLCAidXBkYXRlIiwgIm1hcmdpbnMiLCAic2V0RGltZW5zaW9ucyIsICJidWlsZExhYmVscyIsICJmaXQiLCAiaXNIb3Jpem9udGFsIiwgImxhYmVscyIsICJjYWxsIiwgImdlbmVyYXRlTGFiZWxzIiwgImZpbHRlciIsICJpdGVtIiwgImRhdGEiLCAic29ydCIsICJyZXZlcnNlIiwgImRpc3BsYXkiLCAibGFiZWxGb250IiwgInRvRm9udCIsICJmb250IiwgInNpemUiLCAidGl0bGVIZWlnaHQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJzdHJpbmciLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAicGFkZGluZyIsICJoaXRib3hlcyIsICJsaW5lSGVpZ2h0IiwgInRvdGFsSGVpZ2h0IiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAicm93IiwgImZvckVhY2giLCAibGVnZW5kSXRlbSIsICJpIiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJ0ZXh0IiwgImxlbmd0aCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJwdXNoIiwgImFkanVzdEhpdEJveGVzIiwgImFsaWduIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJfYWxpZ25TdGFydEVuZCIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJ4IiwgImRyYXciLCAiY2xpcEFyZWEiLCAiX2RyYXciLCAidW5jbGlwQXJlYSIsICJvcHRzIiwgImRlZmF1bHRDb2xvciIsICJkZWZhdWx0cyIsICJjb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdUaXRsZSIsICJsaW5lV2lkdGgiLCAiZHJhd0xlZ2VuZEJveCIsICJ5IiwgImlzTmFOIiwgInNhdmUiLCAidmFsdWVPckRlZmF1bHQiLCAiZmlsbFN0eWxlIiwgImxpbmVDYXAiLCAibGluZURhc2hPZmZzZXQiLCAibGluZUpvaW4iLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAicmFkaXVzIiwgIlNRUlQyIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAiYm9yZGVyV2lkdGgiLCAiY2VudGVyWCIsICJ4UGx1cyIsICJjZW50ZXJZIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImJlZ2luUGF0aCIsICJPYmplY3QiLCAidmFsdWVzIiwgInNvbWUiLCAidiIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAidyIsICJoIiwgInJlY3QiLCAiZmlsbCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJmaWxsVGV4dCIsICJyZW5kZXJUZXh0IiwgInN0cmlrZXRocm91Z2giLCAiaGlkZGVuIiwgImxpbmUiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAiZm9udENvbG9yIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZU9wdHMiLCAidGl0bGUiLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAicmVkdWNlIiwgImFjYyIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiX2lzQmV0d2VlbiIsICJoYW5kbGVFdmVudCIsICJlIiwgImlzTGlzdGVuZWQiLCAidHlwZSIsICJob3ZlcmVkSXRlbSIsICJwcmV2aW91cyIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgIm9uSG92ZXIiLCAib25DbGljayIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJsYWJlbEhlaWdodCIsICJpZCIsICJfZWxlbWVudCIsICJzdGFydCIsICJfYXJncyIsICJsZWdlbmQiLCAibGF5b3V0cyIsICJjb25maWd1cmUiLCAiYWRkQm94IiwgInN0b3AiLCAicmVtb3ZlQm94IiwgImJlZm9yZVVwZGF0ZSIsICJhZnRlclVwZGF0ZSIsICJhZnRlckV2ZW50IiwgImFyZ3MiLCAicmVwbGF5IiwgImV2ZW50IiwgImNpIiwgImlzRGF0YXNldFZpc2libGUiLCAiaGlkZSIsICJzaG93IiwgImRhdGFzZXRzIiwgInVzZUJvcmRlclJhZGl1cyIsICJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwgIm1hcCIsICJtZXRhIiwgInN0eWxlIiwgImNvbnRyb2xsZXIiLCAiZ2V0U3R5bGUiLCAibGFiZWwiLCAiYmFja2dyb3VuZENvbG9yIiwgInZpc2libGUiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJib3JkZXJDb2xvciIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInN0YXJ0c1dpdGgiLCAiaW5jbHVkZXMiLCAiVGl0bGUiLCAiX3BhZGRpbmciLCAibGluZUNvdW50IiwgImlzQXJyYXkiLCAidGV4dFNpemUiLCAicG9zIiwgIl9kcmF3QXJncyIsICJvZmZzZXQiLCAidGl0bGVYIiwgInRpdGxlWSIsICJQSSIsICJmb250T3B0cyIsICJ0cmFuc2xhdGlvbiIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgImRlZmF1bHRSb3V0ZXMiLCAiX2luZGV4YWJsZSIsICJXZWFrTWFwIiwgInNldCIsICJnZXQiLCAiZGVsZXRlIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAiaXRlbXMiLCAibGVuIiwgInhTZXQiLCAiU2V0IiwgImNvdW50IiwgImVsIiwgImVsZW1lbnQiLCAiaGFzVmFsdWUiLCAidG9vbHRpcFBvc2l0aW9uIiwgImFkZCIsICJ4QXZlcmFnZSIsICJuZWFyZXN0IiwgImV2ZW50UG9zaXRpb24iLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgIm5lYXJlc3RFbGVtZW50IiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJkIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAiYmFzZSIsICJ0b1B1c2giLCAiQXJyYXkiLCAicHJvdG90eXBlIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJpbmRleE9mIiwgInNwbGl0IiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImdldERhdGFzZXRNZXRhIiwgInZhbHVlIiwgImdldExhYmVsQW5kVmFsdWUiLCAicGFyc2VkIiwgImdldFBhcnNlZCIsICJyYXciLCAiZm9ybWF0dGVkVmFsdWUiLCAiZGF0YXNldCIsICJnZXREYXRhc2V0IiwgImRhdGFJbmRleCIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAibGluZXMiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJlYWNoIiwgImNvbmNhdCIsICJib3hQYWRkaW5nIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJjaGFydEFyZWEiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgIl9saW1pdFZhbHVlIiwgImdldEFsaWduZWRYIiwgImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwgImNhbGxiYWNrIiwgImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwgInBhcmVudCIsICJ0b29sdGlwSXRlbXMiLCAiY3JlYXRlQ29udGV4dCIsICJvdmVycmlkZUNhbGxiYWNrcyIsICJjYWxsYmFja3MiLCAiY29udGV4dCIsICJvdmVycmlkZSIsICJkZWZhdWx0Q2FsbGJhY2tzIiwgImJlZm9yZVRpdGxlIiwgIm5vb3AiLCAibGFiZWxDb3VudCIsICJtb2RlIiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAiaXNOdWxsT3JVbmRlZiIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiYXJnIiwgInJlc3VsdCIsICJUb29sdGlwIiwgIm9wYWNpdHkiLCAiX2FjdGl2ZSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgIiRhbmltYXRpb25zIiwgIiRjb250ZXh0IiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJpbml0aWFsaXplIiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJjYWNoZWQiLCAic2V0Q29udGV4dCIsICJnZXRDb250ZXh0IiwgImVuYWJsZWQiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGlvbnMiLCAiQW5pbWF0aW9ucyIsICJfY2FjaGVhYmxlIiwgImZyZWV6ZSIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJhY3RpdmUiLCAiYXJyYXkiLCAiaXRlbVNvcnQiLCAiY2hhbmdlZCIsICJwcm9wZXJ0aWVzIiwgInBvc2l0aW9uQW5kU2l6ZSIsICJhc3NpZ24iLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgImxpbmVUbyIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJ4MyIsICJ5MyIsICJwdFgiLCAicHRZIiwgInB0IiwgInRpdGxlQWxpZ24iLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgImRyYXdQb2ludCIsICJpc09iamVjdCIsICJvdXRlclgiLCAiaW5uZXJYIiwgImZpbGxSZWN0IiwgInN0cm9rZVJlY3QiLCAiZHJhd0JvZHkiLCAiYm9keUFsaWduIiwgInhMaW5lUGFkZGluZyIsICJmaWxsTGluZU9mVGV4dCIsICJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsICJ0ZXh0Q29sb3IiLCAiaiIsICJpbGVuIiwgImpsZW4iLCAiZHJhd0Zvb3RlciIsICJmb290ZXJBbGlnbiIsICJmb290ZXJDb2xvciIsICJkcmF3QmFja2dyb3VuZCIsICJ0b29sdGlwU2l6ZSIsICJtb3ZlVG8iLCAicXVhZHJhdGljQ3VydmVUbyIsICJjbG9zZVBhdGgiLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltcyIsICJhbmltWCIsICJhbmltWSIsICJwb2ludCIsICJfdG8iLCAiX3dpbGxSZW5kZXIiLCAiYWJzIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiRXJyb3IiLCAiX2VsZW1lbnRzRXF1YWwiLCAicG9zaXRpb25DaGFuZ2VkIiwgIl9wb3NpdGlvbkNoYW5nZWQiLCAiX2lnbm9yZVJlcGxheUV2ZW50cyIsICJpbkNoYXJ0QXJlYSIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJhZnRlckluaXQiLCAicmVzZXQiLCAiYWZ0ZXJEcmF3IiwgIm5vdGlmeVBsdWdpbnMiLCAiY2FuY2VsYWJsZSIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJudW1iZXJzIiwgIl9mYWxsYmFjayIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgImFkZElmU3RyaW5nIiwgImxhYmVscyIsICJyYXciLCAiaW5kZXgiLCAiYWRkZWRMYWJlbHMiLCAicHVzaCIsICJ1bnNoaWZ0IiwgImxhYmVsIiwgImlzTmFOIiwgImZpbmRPckFkZExhYmVsIiwgImZpcnN0IiwgImluZGV4T2YiLCAibGFzdCIsICJsYXN0SW5kZXhPZiIsICJ2YWxpZEluZGV4IiwgIm1heCIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgInJvdW5kIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgInZhbHVlIiwgImdldExhYmVscyIsICJsZW5ndGgiLCAiQ2F0ZWdvcnlTY2FsZSIsICJTY2FsZSIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAiX3N0YXJ0VmFsdWUiLCAidW5kZWZpbmVkIiwgIl92YWx1ZVJhbmdlIiwgIl9hZGRlZExhYmVscyIsICJpbml0IiwgInNjYWxlT3B0aW9ucyIsICJhZGRlZCIsICJzcGxpY2UiLCAicGFyc2UiLCAiaXNOdWxsT3JVbmRlZiIsICJpc0Zpbml0ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbiIsICJnZXRNaW5NYXgiLCAib3B0aW9ucyIsICJib3VuZHMiLCAiYnVpbGRUaWNrcyIsICJvZmZzZXQiLCAidGlja3MiLCAic2xpY2UiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJjYWxsIiwgImNvbmZpZ3VyZSIsICJpc0hvcml6b250YWwiLCAiX3JldmVyc2VQaXhlbHMiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJOYU4iLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImdldFBpeGVsRm9yVGljayIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlUGl4ZWwiLCAiYm90dG9tIiwgImlkIiwgImRlZmF1bHRzIiwgImNhbGxiYWNrIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInN0ZXAiLCAicHJlY2lzaW9uIiwgImNvdW50IiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJzcGFjaW5nIiwgIm5pY2VOdW0iLCAiZmFjdG9yIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiY2VpbCIsICJmbG9vciIsICJwb3ciLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaiIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJ0aWNrVmFsdWUiLCAiaG9yaXpvbnRhbCIsICJtaW5Sb3RhdGlvbiIsICJyYWQiLCAidG9SYWRpYW5zIiwgInJhdGlvIiwgInNpbiIsICJjb3MiLCAiTGluZWFyU2NhbGVCYXNlIiwgInN0YXJ0IiwgImVuZCIsICJfZW5kVmFsdWUiLCAiTnVtYmVyIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAiYmVnaW5BdFplcm8iLCAic2V0TWluIiwgInYiLCAic2V0TWF4IiwgIm1pblNpZ24iLCAic2lnbiIsICJtYXhTaWduIiwgImFicyIsICJnZXRUaWNrTGltaXQiLCAidGlja09wdHMiLCAibWF4VGlja3NMaW1pdCIsICJzdGVwU2l6ZSIsICJjb25zb2xlIiwgIndhcm4iLCAiY29tcHV0ZVRpY2tMaW1pdCIsICJQT1NJVElWRV9JTkZJTklUWSIsICJvcHRzIiwgIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwgIl9tYXhEaWdpdHMiLCAiX3JhbmdlIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJyZXZlcnNlIiwgImZvcm1hdE51bWJlciIsICJjaGFydCIsICJsb2NhbGUiLCAiZm9ybWF0IiwgIkxpbmVhclNjYWxlIiwgIndpZHRoIiwgImhlaWdodCIsICJ0aWNrRm9udCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJsaW5lSGVpZ2h0IiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInJlbWFpbiIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAicmFuZ2UiLCAiZmluaXRlT3JEZWZhdWx0IiwgIm1pbkV4cCIsICJleHAiLCAiYmFzZSIsICJzaWduaWZpY2FuZCIsICJtYWpvciIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgInByb3RvdHlwZSIsICJhcHBseSIsICJfemVybyIsICJfc3VnZ2VzdGVkTWluIiwgIl91c2VyTWluIiwgIl91c2VyTWF4IiwgImRlY2ltYWwiLCAibG9nYXJpdGhtaWMiLCAiZW5hYmxlZCIsICJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCAiZGlzcGxheSIsICJwYWRkaW5nIiwgInRvUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiZm9udCIsICJzaXplIiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiY3R4IiwgImlzQXJyYXkiLCAidyIsICJfbG9uZ2VzdFRleHQiLCAic3RyaW5nIiwgImgiLCAiZGV0ZXJtaW5lTGltaXRzIiwgImFuZ2xlIiwgInBvcyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAic2NhbGUiLCAib3JpZyIsICJsIiwgImxlZnQiLCAiX3BhZGRpbmciLCAiciIsICJyaWdodCIsICJ0IiwgInRvcCIsICJiIiwgImxpbWl0cyIsICJPYmplY3QiLCAiYXNzaWduIiwgImxhYmVsU2l6ZXMiLCAidmFsdWVDb3VudCIsICJfcG9pbnRMYWJlbHMiLCAicG9pbnRMYWJlbE9wdHMiLCAicG9pbnRMYWJlbHMiLCAiYWRkaXRpb25hbEFuZ2xlIiwgImNlbnRlclBvaW50TGFiZWxzIiwgIlBJIiwgImkiLCAic2V0Q29udGV4dCIsICJnZXRQb2ludExhYmVsQ29udGV4dCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb24iLCAiZHJhd2luZ0FyZWEiLCAicGxGb250IiwgInRvRm9udCIsICJ0ZXh0U2l6ZSIsICJhbmdsZVJhZGlhbnMiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAidG9EZWdyZWVzIiwgImhMaW1pdHMiLCAieCIsICJ2TGltaXRzIiwgInkiLCAidXBkYXRlTGltaXRzIiwgInNldENlbnRlclBvaW50IiwgIl9wb2ludExhYmVsSXRlbXMiLCAiYnVpbGRQb2ludExhYmVsSXRlbXMiLCAiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCAiaXRlbU9wdHMiLCAib3V0ZXJEaXN0YW5jZSIsICJleHRyYSIsICJwb2ludExhYmVsUG9zaXRpb24iLCAiSEFMRl9QSSIsICJ5Rm9yQW5nbGUiLCAidGV4dEFsaWduIiwgImdldFRleHRBbGlnbkZvckFuZ2xlIiwgImxlZnRGb3JUZXh0QWxpZ24iLCAidmlzaWJsZSIsICJpc05vdE92ZXJsYXBwZWQiLCAiaXRlbSIsICJhcmVhIiwgImFwZXhlc0luQXJlYSIsICJfaXNQb2ludEluQXJlYSIsICJpdGVtcyIsICJhbGlnbiIsICJkcmF3UG9pbnRMYWJlbEJveCIsICJiYWNrZHJvcENvbG9yIiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImZpbGxTdHlsZSIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJ2YWx1ZXMiLCAic29tZSIsICJiZWdpblBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInJhZGl1cyIsICJmaWxsIiwgImZpbGxSZWN0IiwgImRyYXdQb2ludExhYmVscyIsICJsYWJlbENvdW50IiwgIm9wdHNBdEluZGV4IiwgInJlbmRlclRleHQiLCAiY29sb3IiLCAidGV4dEJhc2VsaW5lIiwgInBhdGhSYWRpdXNMaW5lIiwgImNpcmN1bGFyIiwgImFyYyIsICJ4Q2VudGVyIiwgInlDZW50ZXIiLCAiVEFVIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImJvcmRlck9wdHMiLCAibGluZVdpZHRoIiwgInNhdmUiLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAiZGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgImNsb3NlUGF0aCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJ0eXBlIiwgIlJhZGlhbExpbmVhclNjYWxlIiwgInNldERpbWVuc2lvbnMiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJtYXAiLCAiY2FsbENhbGxiYWNrIiwgImZpbHRlciIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJmaXQiLCAibGVmdE1vdmVtZW50IiwgInJpZ2h0TW92ZW1lbnQiLCAidG9wTW92ZW1lbnQiLCAiYm90dG9tTW92ZW1lbnQiLCAiYW5nbGVNdWx0aXBsaWVyIiwgInN0YXJ0QW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJkaXN0YW5jZSIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImdldENvbnRleHQiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0QmFzZVZhbHVlIiwgImdldFBvaW50TGFiZWxQb3NpdGlvbiIsICJkcmF3QmFja2dyb3VuZCIsICJiYWNrZ3JvdW5kQ29sb3IiLCAiZ3JpZCIsICJkcmF3R3JpZCIsICJhbmdsZUxpbmVzIiwgImJvcmRlciIsICJwb3NpdGlvbiIsICJmb3JFYWNoIiwgInRpY2siLCAiY29udGV4dCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJib3JkZXJEYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZHJhd0JvcmRlciIsICJkcmF3TGFiZWxzIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAibWVhc3VyZVRleHQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJkcmF3VGl0bGUiLCAiYW5pbWF0ZSIsICJkZWZhdWx0Um91dGVzIiwgImRlc2NyaXB0b3JzIiwgIl9mYWxsYmFjayIsICJJTlRFUlZBTFMiLCAibWlsbGlzZWNvbmQiLCAiY29tbW9uIiwgInNlY29uZCIsICJtaW51dGUiLCAiaG91ciIsICJkYXkiLCAid2VlayIsICJtb250aCIsICJxdWFydGVyIiwgInllYXIiLCAiVU5JVFMiLCAia2V5cyIsICJzb3J0ZXIiLCAiYSIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiaXNOdW1iZXIiLCAic3RhcnRPZiIsICJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwgIm1pblVuaXQiLCAiY2FwYWNpdHkiLCAiaWxlbiIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgIm51bVRpY2tzIiwgImRpZmYiLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgImxvIiwgImhpIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgImFkZCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJwcm9wcyIsICJfY2FjaGUiLCAiZGF0YSIsICJhbGwiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJzY2FsZU9wdHMiLCAiYWRhcHRlcnMiLCAiX2RhdGUiLCAiZGF0ZSIsICJtZXJnZUlmIiwgImRpc3BsYXlGb3JtYXRzIiwgImZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJiZWZvcmVMYXlvdXQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJzb3VyY2UiLCAiRGF0ZSIsICJub3ciLCAiZW5kT2YiLCAiYXJyIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJORUdBVElWRV9JTkZJTklUWSIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiYXV0b1NraXAiLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAiYWZ0ZXJBdXRvU2tpcCIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJsaW1pdCIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiRXJyb3IiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAic29ydCIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgIm1heFJvdGF0aW9uIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibWV0YXMiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAiY29udHJvbGxlciIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiY29uY2F0IiwgIm5vcm1hbGl6ZSIsICJfYXJyYXlVbmlxdWUiLCAiaW50ZXJwb2xhdGUiLCAidGFibGUiLCAidmFsIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAiX2xvb2t1cEJ5S2V5IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJwcmV2IiwgImN1cnIiLCAibmV4dCIsICJpbmNsdWRlcyIsICJTdGF0dXMiLCAibiIsICJsIiwgInUiLCAiaSIsICJ0IiwgIm8iLCAiciIsICJmIiwgImUiLCAiYyIsICJzIiwgImEiLCAicGFyZW50Tm9kZSIsICJyZW1vdmVDaGlsZCIsICJoIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAiY2hpbGRyZW4iLCAiY2FsbCIsICJkZWZhdWx0UHJvcHMiLCAidiIsICJ0eXBlIiwgInByb3BzIiwgImtleSIsICJyZWYiLCAiX19rIiwgIl9fIiwgIl9fYiIsICJfX2UiLCAiX19kIiwgIl9fYyIsICJfX2giLCAiY29uc3RydWN0b3IiLCAiX192IiwgInZub2RlIiwgInAiLCAibiIsICJjaGlsZHJlbiIsICJkIiwgImwiLCAidGhpcyIsICJwcm9wcyIsICJjb250ZXh0IiwgIl8iLCAiX18iLCAiX19rIiwgImluZGV4T2YiLCAidSIsICJsZW5ndGgiLCAiX19lIiwgInR5cGUiLCAiayIsICJfX2MiLCAiYmFzZSIsICJiIiwgIl9fZCIsICJ0IiwgInB1c2giLCAiZyIsICJfX3IiLCAibyIsICJkZWJvdW5jZVJlbmRlcmluZyIsICJzZXRUaW1lb3V0IiwgInNvcnQiLCAiX192IiwgIl9fYiIsICJzb21lIiwgImkiLCAiciIsICJfX1AiLCAicyIsICJqIiwgIl9fbiIsICJvd25lclNWR0VsZW1lbnQiLCAiX19oIiwgInoiLCAidyIsICJjIiwgImEiLCAiaCIsICJ5IiwgIngiLCAiZSIsICJDIiwgInYiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJrZXkiLCAicmVmIiwgImYiLCAibSIsICJBIiwgInBhcmVudE5vZGUiLCAiTiIsICJNIiwgImFwcGVuZENoaWxkIiwgIm5leHRTaWJsaW5nIiwgImluc2VydEJlZm9yZSIsICIkIiwgInNldFByb3BlcnR5IiwgInRlc3QiLCAiSCIsICJzdHlsZSIsICJjc3NUZXh0IiwgInJlcGxhY2UiLCAidG9Mb3dlckNhc2UiLCAic2xpY2UiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJUIiwgIkkiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgImV2ZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbnRleHRUeXBlIiwgInZhbHVlIiwgIl9fRSIsICJwcm90b3R5cGUiLCAicmVuZGVyIiwgIk8iLCAic3ViIiwgInN0YXRlIiwgIl9zYiIsICJfX3MiLCAiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwgImNvbXBvbmVudFdpbGxNb3VudCIsICJjb21wb25lbnREaWRNb3VudCIsICJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJmb3JFYWNoIiwgImNvbXBvbmVudFdpbGxVcGRhdGUiLCAiY29tcG9uZW50RGlkVXBkYXRlIiwgImdldENoaWxkQ29udGV4dCIsICJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsICJMIiwgImRpZmZlZCIsICJjYWxsIiwgImxvY2FsTmFtZSIsICJub2RlVHlwZSIsICJkb2N1bWVudCIsICJjcmVhdGVUZXh0Tm9kZSIsICJjcmVhdGVFbGVtZW50TlMiLCAiY3JlYXRlRWxlbWVudCIsICJpcyIsICJkYXRhIiwgImNoaWxkTm9kZXMiLCAiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCAiYXR0cmlidXRlcyIsICJuYW1lIiwgIl9faHRtbCIsICJpbm5lckhUTUwiLCAiY2hlY2tlZCIsICJjdXJyZW50IiwgInVubW91bnQiLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAiUCIsICJmaXJzdENoaWxkIiwgIk1hdGgiLCAicmFuZG9tIiwgInRvU3RyaW5nIiwgImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsICJzZXRTdGF0ZSIsICJjb21wb25lbnREaWRDYXRjaCIsICJmb3JjZVVwZGF0ZSIsICJCYXNlIiwgImlkIiwgIl9pZCIsICJnZW5lcmF0ZVVVSUQiLCAiX2NyZWF0ZUNsYXNzIiwgIkhUTUxFbGVtZW50IiwgInBhcmVudEVsZW1lbnQiLCAiY29udGVudCIsICJodG1sIiwgIkNlbGwiLCAiUHJvY2Vzc29yVHlwZSIsICJfQmFzZSIsICJfdGhpcyIsICJ1cGRhdGUiLCAiX2luaGVyaXRzTG9vc2UiLCAiX3Byb3RvIiwgImNhc3QiLCAib3V0ZXJIVE1MIiwgIlJvdyIsICJjZWxscyIsICJfY2VsbHMiLCAiY2VsbCIsICJpbmRleCIsICJ0b0FycmF5IiwgIm1hcCIsICJmcm9tQ2VsbHMiLCAiZ2V0IiwgInNldCIsICJUYWJ1bGFyIiwgInJvd3MiLCAiX3Jvd3MiLCAiX2xlbmd0aCIsICJyb3ciLCAiZnJvbVJvd3MiLCAiZnJvbUFycmF5IiwgImxlbiIsICJFdmVudEVtaXR0ZXIiLCAiY2FsbGJhY2tzIiwgImluaXQiLCAibGlzdGVuZXJzIiwgIm9uIiwgImxpc3RlbmVyIiwgIm9mZiIsICJldmVudE5hbWUiLCAiZmlsdGVyIiwgImVtaXQiLCAiX2FyZ3VtZW50cyIsICJhcmd1bWVudHMiLCAiYXBwbHkiLCAiZGVlcEVxdWFsIiwgIm9iajEiLCAib2JqMiIsICJoYXNPd25Qcm9wZXJ0eSIsICJrZXlzMSIsICJPYmplY3QiLCAia2V5cyIsICJrZXlzMiIsICJfaSIsICJfa2V5cyIsICJQaXBlbGluZVByb2Nlc3NvciIsICJfRXZlbnRFbWl0dGVyIiwgIl9wcm9wcyIsICJzZXRQcm9wcyIsICJwcm9jZXNzIiwgImFyZ3MiLCAidmFsaWRhdGVQcm9wcyIsICJfcHJvY2VzcyIsICJjb25jYXQiLCAidXBkYXRlZFByb3BzIiwgIl9leHRlbmRzIiwgIkdsb2JhbFNlYXJjaEZpbHRlciIsICJrZXl3b3JkIiwgIlN0cmluZyIsICJ0cmltIiwgImNvbHVtbnMiLCAiaWdub3JlSGlkZGVuQ29sdW1ucyIsICJ0YWJ1bGFyIiwgInNlbGVjdG9yIiwgInJvd0luZGV4IiwgImNlbGxJbmRleCIsICJoaWRkZW4iLCAiZWxlbWVudCIsICJGaWx0ZXIiLCAiY2xhc3NOYW1lIiwgInByZWZpeCIsICJyZWR1Y2UiLCAicHJldiIsICJjdXIiLCAiU2VydmVyR2xvYmFsU2VhcmNoRmlsdGVyIiwgIm9wdGlvbnMiLCAidXBkYXRlcyIsICJ1cmwiLCAiYm9keSIsICJTZXJ2ZXJGaWx0ZXIiLCAiX19IIiwgIl9fViIsICJCIiwgIl9fTiIsICJldmVyeSIsICJGIiwgInNoaWZ0IiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJjbGVhclRpbWVvdXQiLCAiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCAiQ29uZmlnQ29udGV4dCIsICJlblVTIiwgInNlYXJjaCIsICJwbGFjZWhvbGRlciIsICJzb3J0QXNjIiwgInNvcnREZXNjIiwgInBhZ2luYXRpb24iLCAicHJldmlvdXMiLCAibmV4dCIsICJuYXZpZ2F0ZSIsICJwYWdlIiwgInBhZ2VzIiwgInNob3dpbmciLCAib2YiLCAidG8iLCAicmVzdWx0cyIsICJsb2FkaW5nIiwgIm5vUmVjb3Jkc0ZvdW5kIiwgImVycm9yIiwgIlRyYW5zbGF0b3IiLCAibGFuZ3VhZ2UiLCAiX2xhbmd1YWdlIiwgIl9kZWZhdWx0TGFuZ3VhZ2UiLCAiZ2V0U3RyaW5nIiwgIm1lc3NhZ2UiLCAibGFuZyIsICJzcGxpdHRlZCIsICJzcGxpdCIsICJ2YWwiLCAiam9pbiIsICJ0cmFuc2xhdGUiLCAibWVzc2FnZUZvcm1hdCIsICJ0cmFuc2xhdGVkIiwgInVzZVRyYW5zbGF0b3IiLCAiY29uZmlnIiwgInVzZUNvbmZpZyIsICJfY29uZmlnJHRyYW5zbGF0b3IiLCAidHJhbnNsYXRvciIsICJwYXlsb2FkIiwgInN0b3JlIiwgInVzZVNlbGVjdG9yIiwgInVzZVN0b3JlIiwgIl91c2VTdGF0ZSIsICJ1c2VTdGF0ZSIsICJnZXRTdGF0ZSIsICJzZXRDdXJyZW50IiwgInVzZUVmZmVjdCIsICJzdWJzY3JpYmUiLCAidXBkYXRlZCIsICJTZWFyY2giLCAiX2NvbmZpZyRjbGFzc05hbWUiLCAidW5kZWZpbmVkIiwgInByb2Nlc3NvciIsICJzZXRQcm9jZXNzb3IiLCAiZGlzcGF0Y2giLCAic2VydmVyIiwgImhlYWRlciIsICJhY3Rpb25zIiwgInBpcGVsaW5lIiwgInJlZ2lzdGVyIiwgInVucmVnaXN0ZXIiLCAiZnVuYyIsICJ3YWl0Rm9yIiwgInRpbWVvdXQiLCAiZGVib3VuY2VkT25JbnB1dCIsICJ0YXJnZXQiLCAiSFRNTElucHV0RWxlbWVudCIsICJkZWJvdW5jZVRpbWVvdXQiLCAicmVzb2x2ZSIsICJjbGFzc0pvaW4iLCAib25JbnB1dCIsICJkZWZhdWx0VmFsdWUiLCAiUGFnaW5hdGlvbkxpbWl0IiwgImlzTmFOIiwgIk51bWJlciIsICJsaW1pdCIsICJFcnJvciIsICJMaW1pdCIsICJTZXJ2ZXJQYWdpbmF0aW9uTGltaXQiLCAiU2VydmVyTGltaXQiLCAiUGFnaW5hdGlvbiIsICJfY29uZmlnJHBhZ2luYXRpb24iLCAic3VtbWFyeSIsICJfY29uZmlnJHBhZ2luYXRpb24kc3UiLCAiX2NvbmZpZyRwYWdpbmF0aW9uJG5lIiwgIm5leHRCdXR0b24iLCAiX2NvbmZpZyRwYWdpbmF0aW9uJHByIiwgInByZXZCdXR0b24iLCAiX2NvbmZpZyRwYWdpbmF0aW9uJGJ1IiwgImJ1dHRvbnNDb3VudCIsICJfY29uZmlnJHBhZ2luYXRpb24kbGkiLCAiX2NvbmZpZyRwYWdpbmF0aW9uJHBhIiwgIl9jb25maWckcGFnaW5hdGlvbiRyZSIsICJyZXNldFBhZ2VPblVwZGF0ZSIsICJ1c2VSZWYiLCAiY3VycmVudFBhZ2UiLCAic2V0Q3VycmVudFBhZ2UiLCAidG90YWwiLCAic2V0VG90YWwiLCAiX3VzZVN0YXRlMiIsICJvblVwZGF0ZSIsICJ1cGRhdGVkUHJvY2Vzc29yIiwgImNlaWwiLCAic2V0UGFnZSIsICJGcmFnbWVudCIsICJyb2xlIiwgInBhZ2luYXRpb25TdW1tYXJ5IiwgInRpdGxlIiwgIm1pbiIsICJ0YWJJbmRleCIsICJkaXNhYmxlZCIsICJvbkNsaWNrIiwgInBhZ2luYXRpb25CdXR0b24iLCAicGFnaW5hdGlvbkJ1dHRvblByZXYiLCAibWF4Q291bnQiLCAicGFnZVBpdm90IiwgImZsb29yIiwgImZyb20iLCAicGFnaW5hdGlvbkJ1dHRvbkN1cnJlbnQiLCAicmVuZGVyUGFnZXMiLCAicGFnaW5hdGlvbkJ1dHRvbk5leHQiLCAid2lkdGgiLCAiY29udGFpbmVyV2lkdGgiLCAicGFyc2VJbnQiLCAicHgiLCAiU2hhZG93VGFibGUiLCAic2hhZG93VGFibGUiLCAidGFibGVSZWYiLCAiY2xvbmVOb2RlIiwgInBvc2l0aW9uIiwgInpJbmRleCIsICJ2aXNpYmlsaXR5IiwgIm5vZGVFbGVtZW50IiwgImNhbWVsQ2FzZSIsICJzdHIiLCAid29yZHMiLCAid29yZCIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiUGx1Z2luUG9zaXRpb24iLCAibG9nIiwgIkxvZ2dlciIsICJmb3JtYXQiLCAidGhyb3dFeGNlcHRpb24iLCAibXNnIiwgImNvbnNvbGUiLCAid2FybiIsICJpbmZvIiwgIlBsdWdpbk1hbmFnZXIiLCAicGx1Z2lucyIsICJmaW5kIiwgImFkZCIsICJwbHVnaW4iLCAicmVtb3ZlIiwgInNwbGljZSIsICJsaXN0IiwgIm9yZGVyIiwgIlBsdWdpblJlbmRlcmVyIiwgInBsdWdpbklkIiwgImNvbXBvbmVudCIsICJIZWFkZXIiLCAiX2NvbHVtbnMiLCAiYWRqdXN0V2lkdGgiLCAidGVtcFJlZiIsICJjb250YWluZXIiLCAiYXV0b1dpZHRoIiwgImNsaWVudFdpZHRoIiwgIndpZHRocyIsICJnZXRTaGFkb3dUYWJsZVdpZHRocyIsICJxdWVyeVNlbGVjdG9yIiwgInRhYmxlRWxlbWVudCIsICJ0YWJsZUNsYXNzTmFtZSIsICJ0YWJsZVN0eWxlIiwgInRhYmxlTGF5b3V0IiwgInBhZGRpbmciLCAibWFyZ2luIiwgImJvcmRlciIsICJvdXRsaW5lIiwgInF1ZXJ5U2VsZWN0b3JBbGwiLCAiZ2V0QXR0cmlidXRlIiwgIm1pbldpZHRoIiwgIm9iaiIsICJfc3RlcCIsICJfaXRlcmF0b3IiLCAiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsICJ0YWJ1bGFyRm9ybWF0IiwgImRvbmUiLCAiY29sdW1uIiwgInNldFNvcnQiLCAic29ydENvbmZpZyIsICJjb2xzIiwgIl9zdGVwMiIsICJzZXRSZXNpemFibGUiLCAicmVzaXphYmxlIiwgIl9zdGVwMyIsICJfaXRlcmF0b3IzIiwgInNldElEIiwgIl9zdGVwNCIsICJfaXRlcmF0b3I0IiwgImxvZ2dlciIsICJwb3B1bGF0ZVBsdWdpbnMiLCAicGx1Z2luTWFuYWdlciIsICJfc3RlcDUiLCAiX2l0ZXJhdG9yNSIsICJmcm9tQ29sdW1ucyIsICJfc3RlcDYiLCAiX2l0ZXJhdG9yNiIsICJpc1ZhbGlkRWxlbWVudCIsICJ0eXBlZENvbHVtbiIsICJjcmVhdGVGcm9tQ29uZmlnIiwgImZyb21IVE1MVGFibGUiLCAiX3N0ZXA3IiwgIl9pdGVyYXRvcjciLCAidGgiLCAicmVzdWx0IiwgIl9zdGVwOCIsICJfaXRlcmF0b3I4IiwgImNvbCIsICJuZXh0Um93IiwgImxlYWZDb2x1bW5zIiwgIl9zdGVwOSIsICJfaXRlcmF0b3I5IiwgIm1heGltdW1EZXB0aCIsICJTdG9yYWdlIiwgIk1lbW9yeVN0b3JhZ2UiLCAiX1N0b3JhZ2UiLCAiUHJvbWlzZSIsICJyZWplY3QiLCAiU2VydmVyU3RvcmFnZSIsICJoYW5kbGVyIiwgInJlc3BvbnNlIiwgImhhbmRsZSIsICJvayIsICJqc29uIiwgInN0YXR1cyIsICJzdGF0dXNUZXh0IiwgIm9wdHMiLCAiZmV0Y2giLCAidGhlbiIsICJiaW5kIiwgInJlcyIsICJTdG9yYWdlVXRpbHMiLCAic3RvcmFnZSIsICJ0YWJsZUVsZW1lbnRUb0FycmF5IiwgImRpc3BsYXkiLCAiYXJyIiwgInBhcnNlZFJvdyIsICJfaXRlcmF0b3IyIiwgIk5vZGUiLCAiVEVYVF9OT0RFIiwgIkRPTVBhcnNlciIsICJwYXJzZUZyb21TdHJpbmciLCAiZG9jdW1lbnRFbGVtZW50IiwgInRleHRDb250ZW50IiwgInBhY3QiLCAiX3NldHRsZSIsICJvYnNlcnZlciIsICJfUGFjdCIsICJvbkZ1bGZpbGxlZCIsICJvblJlamVjdGVkIiwgImNhbGxiYWNrIiwgIl9pc1NldHRsZWRQYWN0IiwgInRoZW5hYmxlIiwgIlBpcGVsaW5lIiwgInN0ZXBzIiwgIl9zdGVwcyIsICJjYWNoZSIsICJNYXAiLCAibGFzdFByb2Nlc3NvckluZGV4VXBkYXRlZCIsICJzdGVwIiwgImNsZWFyQ2FjaGUiLCAicHJpb3JpdHkiLCAiZmluZFByb2Nlc3NvckluZGV4QnlJRCIsICJwcm9jZXNzb3JQcm9wc1VwZGF0ZWQiLCAiYWRkUHJvY2Vzc29yQnlQcmlvcml0eSIsICJhZnRlclJlZ2lzdGVyZWQiLCAidHJ5UmVnaXN0ZXIiLCAic3ViU3RlcHMiLCAicHJvYyIsICJuZXdTdWJTdGVwIiwgInNlY29uZCIsICJmaXJzdCIsICJnZXRTdGVwc0J5VHlwZSIsICJnZXRTb3J0ZWRQcm9jZXNzb3JUeXBlcyIsICJfdGVtcDMiLCAiX3Jlc3VsdCIsICJfdGhpczIiLCAiX3RlbXAyIiwgImFycmF5IiwgImNoZWNrIiwgIl9jeWNsZSIsICJwcm9jZXNzb3JJbmRleCIsICJfcHJvY2Vzc29yJHByb2Nlc3MiLCAicHJvY2Vzc29ySUQiLCAiZmluZEluZGV4IiwgInNldExhc3RQcm9jZXNzb3JJbmRleCIsICJTdG9yYWdlRXh0cmFjdG9yIiwgIkV4dHJhY3RvciIsICJhcnJheVJlc3BvbnNlIiwgIkFycmF5VG9UYWJ1bGFyVHJhbnNmb3JtZXIiLCAiVHJhbnNmb3JtZXIiLCAiU2VydmVySW5pdGlhdG9yIiwgIl9QaXBlbGluZVByb2Nlc3NvciIsICJlbnRyaWVzIiwgInNlcnZlclN0b3JhZ2VPcHRpb25zIiwgIl9yZWYiLCAiYWNjIiwgIl9leHRlbmRzMiIsICJJbml0aWF0b3IiLCAiU3RvcmFnZVJlc3BvbnNlVG9BcnJheVRyYW5zZm9ybWVyIiwgImNhc3REYXRhIiwgInBhZCIsICJzdG9yYWdlUmVzcG9uc2UiLCAiUGlwZWxpbmVVdGlscyIsICJpbml0aWFsU3RhdGUiLCAiaXNEaXNwYXRjaGluZyIsICJnZXRMaXN0ZW5lcnMiLCAicmVkdWNlciIsICJwcmV2U3RhdGUiLCAibGlzIiwgIkNvbnN1bWVyIiwgIlByb3ZpZGVyIiwgImNyZWF0ZUNvbnRleHQiLCAiQ29uZmlnIiwgImFzc2lnbiIsICJkZWZhdWx0Q29uZmlnIiwgInBhcnRpYWxDb25maWciLCAiZnJvbVBhcnRpYWxDb25maWciLCAiU3RvcmUiLCAiU3RhdHVzIiwgIkluaXQiLCAiaGVpZ2h0IiwgInByb2Nlc3NpbmdUaHJvdHRsZU1zIiwgIm11bHRpQ29sdW1uIiwgIkZvb3RlciIsICJURCIsICJjb2xTcGFuIiwgInRkIiwgIm1lc3NhZ2VDZWxsIiwgImV2ZW50RW1pdHRlciIsICJmb3JtYXR0ZXIiLCAiVFIiLCAidHIiLCAibWVzc2FnZVJvdyIsICJNZXNzYWdlUm93IiwgIlRCb2R5IiwgImhlYWRlckxlbmd0aCIsICJ2aXNpYmxlQ29sdW1ucyIsICJ0Ym9keSIsICJMb2FkaW5nIiwgIlJlbmRlcmVkIiwgIm5vdGZvdW5kIiwgIk5hdGl2ZVNvcnQiLCAiY29uZGl0aW9uIiwgImRpcmVjdGlvbiIsICJjb21wYXJlIiwgImNlbGxBIiwgImNlbGxCIiwgImNvbXBhcmVXcmFwcGVyIiwgImNtcCIsICJzb3J0ZWRSb3dzIiwgInNvcnRlZCIsICJTb3J0IiwgIm11bHRpIiwgIl9zdGF0ZSRzb3J0IiwgInJlc2V0IiwgImNvdW50IiwgIl9pbmRleDIiLCAiU29ydFRvZ2dsZSIsICJTb3J0Q29sdW1uIiwgIlNlcnZlclNvcnQiLCAic2V0RGlyZWN0aW9uIiwgInByb2Nlc3NvclR5cGUiLCAiZ2V0U29ydFByb2Nlc3NvciIsICJwcm9jZXNzb3JzIiwgImN1cnJlbnRDb2x1bW4iLCAiX3Byb3BzJGRpcmVjdGlvbiIsICJwcmV2ZW50RGVmYXVsdCIsICJzdG9wUHJvcGFnYXRpb24iLCAic2hpZnRLZXkiLCAidGhyb3R0bGUiLCAiZm4iLCAid2FpdCIsICJ0aW1lb3V0SWQiLCAibGFzdFRpbWUiLCAiRGF0ZSIsICJub3ciLCAiZXhlY3V0ZSIsICJjdXJyZW50VGltZSIsICJlbGFwc2VkIiwgIlJlc2l6ZSIsICJnZXRQYWdlWCIsICJNb3VzZUV2ZW50IiwgInBhZ2VYIiwgImNoYW5nZWRUb3VjaGVzIiwgInN0YXJ0IiwgIm9mZnNldFN0YXJ0IiwgInRoUmVmIiwgIm1vdmVGbiIsICJtb3ZlIiwgImVuZCIsICJ0aEVsZW1lbnQiLCAib25Nb3VzZURvd24iLCAib25Ub3VjaFN0YXJ0IiwgIlRIIiwgInNldFN0eWxlIiwgImZpeGVkSGVhZGVyIiwgIm9mZnNldFRvcCIsICJ0b3AiLCAiaXNTb3J0YWJsZSIsICJTb3J0QWN0aW9ucyIsICJvbktleURvd24iLCAid2hpY2giLCAicm93U3BhbiIsICJUSGVhZCIsICJ0aGVhZCIsICJyZW5kZXJSb3ciLCAidG90YWxSb3dzIiwgImNvbHVtbkluZGV4IiwgImNhbGN1bGF0ZVJvd0NvbFNwYW5zIiwgImRlcHRoIiwgInJlbWFpbmluZ1Jvd3MiLCAiX2NhbGN1bGF0ZVJvd0NvbFNwYW5zIiwgIlNldEhlYWRlciIsICJUYWJsZSIsICJ0YWJsZSIsICJIZWFkZXJDb250YWluZXIiLCAiaXNBY3RpdmUiLCAic2V0SXNBY3RpdmUiLCAiaGVhZGVyUmVmIiwgIkZvb3RlckNvbnRhaW5lciIsICJmb290ZXJSZWYiLCAiZm9vdGVyIiwgIkNvbnRhaW5lciIsICJwcm9jZXNzUGlwZWxpbmUiLCAiTG9hZGVkIiwgIl90ZW1wIiwgIkdyaWQiLCAiaW5zdGFuY2UiLCAiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsICJ1cGRhdGVDb25maWciLCAiZm9yY2VSZW5kZXIiLCAiZGVzdHJveSIsICJoIiwgInBhdGgiLCAiYSIsICJiIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmh0bWwiLCAidGFiSGVhZGVyIiwgImNvbnRhaW5lckVsZW1lbnQiLCAidGFiQ29udGVudCIsICJ0YWJCdXR0b24iLCAiYWN0aXZhdGVUYWJJZCIsICJoIiwgImNhbGxiYWNrIiwgInYiLCAiXyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X21vbWVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsIiwgImxpbmsiLCAiZSIsICJpbXBvcnRfdmh0bWwiLCAiaCIsICJlIiwgImltcG9ydF9vYnNpZGlhbiIsICJfIiwgInJlc29sdmUiLCAiY2FsbGJhY2siLCAiaW1wb3J0X29ic2lkaWFuIiwgImUiLCAiY2FsbGJhY2siLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiXyIsICJhIiwgImIiLCAibm93IiwgIkRlY2siLCAibm93IiwgInYiXQp9Cg==
